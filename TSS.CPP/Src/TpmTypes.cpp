/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

/*
 * NOTE: this file is partially auto generated!
 *
 * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
 * is autogenerated from the TPM 2.0 Specification docs.
 *
 * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
 */

#include "stdafx.h"
#include "MarshalInternal.h"

_TPMCPP_USING

// Windows SDK headers may define this symbol
#ifdef _C2
#undef _C2
#endif

using namespace std;

// <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

void Tpm2::Startup(TPM_SU startupType)
{
    TPM2_Startup_REQUEST _req(startupType);
    Dispatch(TPM_CC::Startup, &_req, NULL);
}

void Tpm2::Shutdown(TPM_SU shutdownType)
{
    TPM2_Shutdown_REQUEST _req(shutdownType);
    Dispatch(TPM_CC::Shutdown, &_req, NULL);
}

void Tpm2::SelfTest(BYTE fullTest)
{
    TPM2_SelfTest_REQUEST _req(fullTest);
    Dispatch(TPM_CC::SelfTest, &_req, NULL);
}

vector<TPM_ALG_ID> Tpm2::IncrementalSelfTest(const vector<TPM_ALG_ID>& toTest)
{
    TPM2_IncrementalSelfTest_REQUEST _req(toTest);
    IncrementalSelfTestResponse _resp;
    Dispatch(TPM_CC::IncrementalSelfTest, &_req, &_resp);
    return _resp.toDoList;
}

GetTestResultResponse Tpm2::GetTestResult()
{
    GetTestResultResponse _resp;
    Dispatch(TPM_CC::GetTestResult, NULL, &_resp);
    return _resp;
}

StartAuthSessionResponse Tpm2::StartAuthSession
(
    const TPM_HANDLE& tpmKey, 
    const TPM_HANDLE& bind, 
    const ByteVec& nonceCaller, 
    const ByteVec& encryptedSalt, 
    TPM_SE sessionType, 
    const TPMT_SYM_DEF& symmetric, 
    TPM_ALG_ID authHash
)
{
    TPM2_StartAuthSession_REQUEST _req(tpmKey,bind,nonceCaller,encryptedSalt,sessionType,symmetric,authHash);
    StartAuthSessionResponse _resp;
    Dispatch(TPM_CC::StartAuthSession, &_req, &_resp);
    return _resp;
}

void Tpm2::PolicyRestart(const TPM_HANDLE& sessionHandle)
{
    TPM2_PolicyRestart_REQUEST _req(sessionHandle);
    Dispatch(TPM_CC::PolicyRestart, &_req, NULL);
}

CreateResponse Tpm2::Create
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_Create_REQUEST _req(parentHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    CreateResponse _resp;
    Dispatch(TPM_CC::Create, &_req, &_resp);
    return _resp;
}

TPM_HANDLE Tpm2::Load
(
    const TPM_HANDLE& parentHandle, 
    const TPM2B_PRIVATE& inPrivate, 
    const TPMT_PUBLIC& inPublic
)
{
    TPM2_Load_REQUEST _req(parentHandle,inPrivate,inPublic);
    LoadResponse _resp;
    Dispatch(TPM_CC::Load, &_req, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::LoadExternal
(
    const TPMT_SENSITIVE& inPrivate, 
    const TPMT_PUBLIC& inPublic, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_LoadExternal_REQUEST _req(inPrivate,inPublic,hierarchy);
    LoadExternalResponse _resp;
    Dispatch(TPM_CC::LoadExternal, &_req, &_resp);
    return _resp.handle;
}

ReadPublicResponse Tpm2::ReadPublic(const TPM_HANDLE& objectHandle)
{
    TPM2_ReadPublic_REQUEST _req(objectHandle);
    ReadPublicResponse _resp;
    Dispatch(TPM_CC::ReadPublic, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::ActivateCredential
(
    const TPM_HANDLE& activateHandle, 
    const TPM_HANDLE& keyHandle, 
    const TPMS_ID_OBJECT& credentialBlob, 
    const ByteVec& secret
)
{
    TPM2_ActivateCredential_REQUEST _req(activateHandle,keyHandle,credentialBlob,secret);
    ActivateCredentialResponse _resp;
    Dispatch(TPM_CC::ActivateCredential, &_req, &_resp);
    return _resp.certInfo;
}

MakeCredentialResponse Tpm2::MakeCredential
(
    const TPM_HANDLE& handle, 
    const ByteVec& credential, 
    const ByteVec& objectName
)
{
    TPM2_MakeCredential_REQUEST _req(handle,credential,objectName);
    MakeCredentialResponse _resp;
    Dispatch(TPM_CC::MakeCredential, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::Unseal(const TPM_HANDLE& itemHandle)
{
    TPM2_Unseal_REQUEST _req(itemHandle);
    UnsealResponse _resp;
    Dispatch(TPM_CC::Unseal, &_req, &_resp);
    return _resp.outData;
}

TPM2B_PRIVATE Tpm2::ObjectChangeAuth
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& parentHandle, 
    const ByteVec& newAuth
)
{
    TPM2_ObjectChangeAuth_REQUEST _req(objectHandle,parentHandle,newAuth);
    ObjectChangeAuthResponse _resp;
    Dispatch(TPM_CC::ObjectChangeAuth, &_req, &_resp);
    return _resp.outPrivate;
}

CreateLoadedResponse Tpm2::CreateLoaded
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const ByteVec& inPublic
)
{
    TPM2_CreateLoaded_REQUEST _req(parentHandle,inSensitive,inPublic);
    CreateLoadedResponse _resp;
    Dispatch(TPM_CC::CreateLoaded, &_req, &_resp);
    return _resp;
}

DuplicateResponse Tpm2::Duplicate
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& newParentHandle, 
    const ByteVec& encryptionKeyIn, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Duplicate_REQUEST _req(objectHandle,newParentHandle,encryptionKeyIn,symmetricAlg);
    DuplicateResponse _resp;
    Dispatch(TPM_CC::Duplicate, &_req, &_resp);
    return _resp;
}

RewrapResponse Tpm2::Rewrap
(
    const TPM_HANDLE& oldParent, 
    const TPM_HANDLE& newParent, 
    const TPM2B_PRIVATE& inDuplicate, 
    const ByteVec& name, 
    const ByteVec& inSymSeed
)
{
    TPM2_Rewrap_REQUEST _req(oldParent,newParent,inDuplicate,name,inSymSeed);
    RewrapResponse _resp;
    Dispatch(TPM_CC::Rewrap, &_req, &_resp);
    return _resp;
}

TPM2B_PRIVATE Tpm2::Import
(
    const TPM_HANDLE& parentHandle, 
    const ByteVec& encryptionKey, 
    const TPMT_PUBLIC& objectPublic, 
    const TPM2B_PRIVATE& duplicate, 
    const ByteVec& inSymSeed, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Import_REQUEST _req(parentHandle,encryptionKey,objectPublic,duplicate,inSymSeed,symmetricAlg);
    ImportResponse _resp;
    Dispatch(TPM_CC::Import, &_req, &_resp);
    return _resp.outPrivate;
}

ByteVec Tpm2::RSA_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& message, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Encrypt_REQUEST _req(keyHandle,message,inScheme,label);
    RSA_EncryptResponse _resp;
    Dispatch(TPM_CC::RSA_Encrypt, &_req, &_resp);
    return _resp.outData;
}

ByteVec Tpm2::RSA_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& cipherText, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Decrypt_REQUEST _req(keyHandle,cipherText,inScheme,label);
    RSA_DecryptResponse _resp;
    Dispatch(TPM_CC::RSA_Decrypt, &_req, &_resp);
    return _resp.message;
}

ECDH_KeyGenResponse Tpm2::ECDH_KeyGen(const TPM_HANDLE& keyHandle)
{
    TPM2_ECDH_KeyGen_REQUEST _req(keyHandle);
    ECDH_KeyGenResponse _resp;
    Dispatch(TPM_CC::ECDH_KeyGen, &_req, &_resp);
    return _resp;
}

TPMS_ECC_POINT Tpm2::ECDH_ZGen
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& inPoint
)
{
    TPM2_ECDH_ZGen_REQUEST _req(keyHandle,inPoint);
    ECDH_ZGenResponse _resp;
    Dispatch(TPM_CC::ECDH_ZGen, &_req, &_resp);
    return _resp.outPoint;
}

TPMS_ALGORITHM_DETAIL_ECC Tpm2::ECC_Parameters(TPM_ECC_CURVE curveID)
{
    TPM2_ECC_Parameters_REQUEST _req(curveID);
    ECC_ParametersResponse _resp;
    Dispatch(TPM_CC::ECC_Parameters, &_req, &_resp);
    return _resp.parameters;
}

ZGen_2PhaseResponse Tpm2::ZGen_2Phase
(
    const TPM_HANDLE& keyA, 
    const TPMS_ECC_POINT& inQsB, 
    const TPMS_ECC_POINT& inQeB, 
    TPM_ALG_ID inScheme, 
    UINT16 counter
)
{
    TPM2_ZGen_2Phase_REQUEST _req(keyA,inQsB,inQeB,inScheme,counter);
    ZGen_2PhaseResponse _resp;
    Dispatch(TPM_CC::ZGen_2Phase, &_req, &_resp);
    return _resp;
}

ECC_EncryptResponse Tpm2::ECC_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& plainText, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Encrypt_REQUEST _req(keyHandle,plainText,inScheme);
    ECC_EncryptResponse _resp;
    Dispatch(TPM_CC::ECC_Encrypt, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::ECC_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& C1, 
    const ByteVec& C2, 
    const ByteVec& C3, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Decrypt_REQUEST _req(keyHandle,C1,C2,C3,inScheme);
    ECC_DecryptResponse _resp;
    Dispatch(TPM_CC::ECC_Decrypt, &_req, &_resp);
    return _resp.plainText;
}

EncryptDecryptResponse Tpm2::EncryptDecrypt
(
    const TPM_HANDLE& keyHandle, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn, 
    const ByteVec& inData
)
{
    TPM2_EncryptDecrypt_REQUEST _req(keyHandle,decrypt,mode,ivIn,inData);
    EncryptDecryptResponse _resp;
    Dispatch(TPM_CC::EncryptDecrypt, &_req, &_resp);
    return _resp;
}

EncryptDecrypt2Response Tpm2::EncryptDecrypt2
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& inData, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn
)
{
    TPM2_EncryptDecrypt2_REQUEST _req(keyHandle,inData,decrypt,mode,ivIn);
    EncryptDecrypt2Response _resp;
    Dispatch(TPM_CC::EncryptDecrypt2, &_req, &_resp);
    return _resp;
}

HashResponse Tpm2::Hash
(
    const ByteVec& data, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_Hash_REQUEST _req(data,hashAlg,hierarchy);
    HashResponse _resp;
    Dispatch(TPM_CC::Hash, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::HMAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_REQUEST _req(handle,buffer,hashAlg);
    HMACResponse _resp;
    Dispatch(TPM_CC::HMAC, &_req, &_resp);
    return _resp.outHMAC;
}

ByteVec Tpm2::MAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_REQUEST _req(handle,buffer,inScheme);
    MACResponse _resp;
    Dispatch(TPM_CC::MAC, &_req, &_resp);
    return _resp.outMAC;
}

ByteVec Tpm2::GetRandom(UINT16 bytesRequested)
{
    TPM2_GetRandom_REQUEST _req(bytesRequested);
    GetRandomResponse _resp;
    Dispatch(TPM_CC::GetRandom, &_req, &_resp);
    return _resp.randomBytes;
}

void Tpm2::StirRandom(const ByteVec& inData)
{
    TPM2_StirRandom_REQUEST _req(inData);
    Dispatch(TPM_CC::StirRandom, &_req, NULL);
}

TPM_HANDLE Tpm2::HMAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_Start_REQUEST _req(handle,auth,hashAlg);
    HMAC_StartResponse _resp;
    Dispatch(TPM_CC::HMAC_Start, &_req, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::MAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_Start_REQUEST _req(handle,auth,inScheme);
    MAC_StartResponse _resp;
    Dispatch(TPM_CC::MAC_Start, &_req, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::HashSequenceStart
(
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HashSequenceStart_REQUEST _req(auth,hashAlg);
    HashSequenceStartResponse _resp;
    Dispatch(TPM_CC::HashSequenceStart, &_req, &_resp);
    return _resp.handle;
}

void Tpm2::SequenceUpdate
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_SequenceUpdate_REQUEST _req(sequenceHandle,buffer);
    Dispatch(TPM_CC::SequenceUpdate, &_req, NULL);
}

SequenceCompleteResponse Tpm2::SequenceComplete
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_SequenceComplete_REQUEST _req(sequenceHandle,buffer,hierarchy);
    SequenceCompleteResponse _resp;
    Dispatch(TPM_CC::SequenceComplete, &_req, &_resp);
    return _resp;
}

vector<TPMT_HA> Tpm2::EventSequenceComplete
(
    const TPM_HANDLE& pcrHandle, 
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_EventSequenceComplete_REQUEST _req(pcrHandle,sequenceHandle,buffer);
    EventSequenceCompleteResponse _resp;
    Dispatch(TPM_CC::EventSequenceComplete, &_req, &_resp);
    return _resp.results;
}

CertifyResponse Tpm2::Certify
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_Certify_REQUEST _req(objectHandle,signHandle,qualifyingData,inScheme);
    CertifyResponse _resp;
    Dispatch(TPM_CC::Certify, &_req, &_resp);
    return _resp;
}

CertifyCreationResponse Tpm2::CertifyCreation
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& objectHandle, 
    const ByteVec& qualifyingData, 
    const ByteVec& creationHash, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_CREATION& creationTicket
)
{
    TPM2_CertifyCreation_REQUEST _req(signHandle,objectHandle,qualifyingData,creationHash,inScheme,creationTicket);
    CertifyCreationResponse _resp;
    Dispatch(TPM_CC::CertifyCreation, &_req, &_resp);
    return _resp;
}

QuoteResponse Tpm2::Quote
(
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    const vector<TPMS_PCR_SELECTION>& PCRselect
)
{
    TPM2_Quote_REQUEST _req(signHandle,qualifyingData,inScheme,PCRselect);
    QuoteResponse _resp;
    Dispatch(TPM_CC::Quote, &_req, &_resp);
    return _resp;
}

GetSessionAuditDigestResponse Tpm2::GetSessionAuditDigest
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& sessionHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetSessionAuditDigest_REQUEST _req(privacyAdminHandle,signHandle,sessionHandle,qualifyingData,inScheme);
    GetSessionAuditDigestResponse _resp;
    Dispatch(TPM_CC::GetSessionAuditDigest, &_req, &_resp);
    return _resp;
}

GetCommandAuditDigestResponse Tpm2::GetCommandAuditDigest
(
    const TPM_HANDLE& privacyHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetCommandAuditDigest_REQUEST _req(privacyHandle,signHandle,qualifyingData,inScheme);
    GetCommandAuditDigestResponse _resp;
    Dispatch(TPM_CC::GetCommandAuditDigest, &_req, &_resp);
    return _resp;
}

GetTimeResponse Tpm2::GetTime
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetTime_REQUEST _req(privacyAdminHandle,signHandle,qualifyingData,inScheme);
    GetTimeResponse _resp;
    Dispatch(TPM_CC::GetTime, &_req, &_resp);
    return _resp;
}

CertifyX509Response Tpm2::CertifyX509
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& reserved, 
    const TPMU_SIG_SCHEME& inScheme, 
    const ByteVec& partialCertificate
)
{
    TPM2_CertifyX509_REQUEST _req(objectHandle,signHandle,reserved,inScheme,partialCertificate);
    CertifyX509Response _resp;
    Dispatch(TPM_CC::CertifyX509, &_req, &_resp);
    return _resp;
}

CommitResponse Tpm2::Commit
(
    const TPM_HANDLE& signHandle, 
    const TPMS_ECC_POINT& P1, 
    const ByteVec& s2, 
    const ByteVec& y2
)
{
    TPM2_Commit_REQUEST _req(signHandle,P1,s2,y2);
    CommitResponse _resp;
    Dispatch(TPM_CC::Commit, &_req, &_resp);
    return _resp;
}

EC_EphemeralResponse Tpm2::EC_Ephemeral(TPM_ECC_CURVE curveID)
{
    TPM2_EC_Ephemeral_REQUEST _req(curveID);
    EC_EphemeralResponse _resp;
    Dispatch(TPM_CC::EC_Ephemeral, &_req, &_resp);
    return _resp;
}

TPMT_TK_VERIFIED Tpm2::VerifySignature
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIGNATURE& signature
)
{
    TPM2_VerifySignature_REQUEST _req(keyHandle,digest,signature);
    VerifySignatureResponse _resp;
    Dispatch(TPM_CC::VerifySignature, &_req, &_resp);
    return _resp.validation;
}

std::shared_ptr<TPMU_SIGNATURE> Tpm2::Sign
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_HASHCHECK& validation
)
{
    TPM2_Sign_REQUEST _req(keyHandle,digest,inScheme,validation);
    SignResponse _resp;
    Dispatch(TPM_CC::Sign, &_req, &_resp);
    return _resp.signature;
}

void Tpm2::SetCommandCodeAuditStatus
(
    const TPM_HANDLE& auth, 
    TPM_ALG_ID auditAlg, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_SetCommandCodeAuditStatus_REQUEST _req(auth,auditAlg,setList,clearList);
    Dispatch(TPM_CC::SetCommandCodeAuditStatus, &_req, NULL);
}

void Tpm2::PCR_Extend
(
    const TPM_HANDLE& pcrHandle, 
    const vector<TPMT_HA>& digests
)
{
    TPM2_PCR_Extend_REQUEST _req(pcrHandle,digests);
    Dispatch(TPM_CC::PCR_Extend, &_req, NULL);
}

vector<TPMT_HA> Tpm2::PCR_Event
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& eventData
)
{
    TPM2_PCR_Event_REQUEST _req(pcrHandle,eventData);
    PCR_EventResponse _resp;
    Dispatch(TPM_CC::PCR_Event, &_req, &_resp);
    return _resp.digests;
}

PCR_ReadResponse Tpm2::PCR_Read(const vector<TPMS_PCR_SELECTION>& pcrSelectionIn)
{
    TPM2_PCR_Read_REQUEST _req(pcrSelectionIn);
    PCR_ReadResponse _resp;
    Dispatch(TPM_CC::PCR_Read, &_req, &_resp);
    return _resp;
}

PCR_AllocateResponse Tpm2::PCR_Allocate
(
    const TPM_HANDLE& authHandle, 
    const vector<TPMS_PCR_SELECTION>& pcrAllocation
)
{
    TPM2_PCR_Allocate_REQUEST _req(authHandle,pcrAllocation);
    PCR_AllocateResponse _resp;
    Dispatch(TPM_CC::PCR_Allocate, &_req, &_resp);
    return _resp;
}

void Tpm2::PCR_SetAuthPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& pcrNum
)
{
    TPM2_PCR_SetAuthPolicy_REQUEST _req(authHandle,authPolicy,hashAlg,pcrNum);
    Dispatch(TPM_CC::PCR_SetAuthPolicy, &_req, NULL);
}

void Tpm2::PCR_SetAuthValue
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& auth
)
{
    TPM2_PCR_SetAuthValue_REQUEST _req(pcrHandle,auth);
    Dispatch(TPM_CC::PCR_SetAuthValue, &_req, NULL);
}

void Tpm2::PCR_Reset(const TPM_HANDLE& pcrHandle)
{
    TPM2_PCR_Reset_REQUEST _req(pcrHandle);
    Dispatch(TPM_CC::PCR_Reset, &_req, NULL);
}

PolicySignedResponse Tpm2::PolicySigned
(
    const TPM_HANDLE& authObject, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration, 
    const TPMU_SIGNATURE& auth
)
{
    TPM2_PolicySigned_REQUEST _req(authObject,policySession,nonceTPM,cpHashA,policyRef,expiration,auth);
    PolicySignedResponse _resp;
    Dispatch(TPM_CC::PolicySigned, &_req, &_resp);
    return _resp;
}

PolicySecretResponse Tpm2::PolicySecret
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration
)
{
    TPM2_PolicySecret_REQUEST _req(authHandle,policySession,nonceTPM,cpHashA,policyRef,expiration);
    PolicySecretResponse _resp;
    Dispatch(TPM_CC::PolicySecret, &_req, &_resp);
    return _resp;
}

void Tpm2::PolicyTicket
(
    const TPM_HANDLE& policySession, 
    const ByteVec& timeout, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    const ByteVec& authName, 
    const TPMT_TK_AUTH& ticket
)
{
    TPM2_PolicyTicket_REQUEST _req(policySession,timeout,cpHashA,policyRef,authName,ticket);
    Dispatch(TPM_CC::PolicyTicket, &_req, NULL);
}

void Tpm2::PolicyOR
(
    const TPM_HANDLE& policySession, 
    const vector<TPM2B_DIGEST>& pHashList
)
{
    TPM2_PolicyOR_REQUEST _req(policySession,pHashList);
    Dispatch(TPM_CC::PolicyOR, &_req, NULL);
}

void Tpm2::PolicyPCR
(
    const TPM_HANDLE& policySession, 
    const ByteVec& pcrDigest, 
    const vector<TPMS_PCR_SELECTION>& pcrs
)
{
    TPM2_PolicyPCR_REQUEST _req(policySession,pcrDigest,pcrs);
    Dispatch(TPM_CC::PolicyPCR, &_req, NULL);
}

void Tpm2::PolicyLocality
(
    const TPM_HANDLE& policySession, 
    TPMA_LOCALITY locality
)
{
    TPM2_PolicyLocality_REQUEST _req(policySession,locality);
    Dispatch(TPM_CC::PolicyLocality, &_req, NULL);
}

void Tpm2::PolicyNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyNV_REQUEST _req(authHandle,nvIndex,policySession,operandB,offset,operation);
    Dispatch(TPM_CC::PolicyNV, &_req, NULL);
}

void Tpm2::PolicyCounterTimer
(
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyCounterTimer_REQUEST _req(policySession,operandB,offset,operation);
    Dispatch(TPM_CC::PolicyCounterTimer, &_req, NULL);
}

void Tpm2::PolicyCommandCode
(
    const TPM_HANDLE& policySession, 
    TPM_CC code
)
{
    TPM2_PolicyCommandCode_REQUEST _req(policySession,code);
    Dispatch(TPM_CC::PolicyCommandCode, &_req, NULL);
}

void Tpm2::PolicyPhysicalPresence(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPhysicalPresence_REQUEST _req(policySession);
    Dispatch(TPM_CC::PolicyPhysicalPresence, &_req, NULL);
}

void Tpm2::PolicyCpHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& cpHashA
)
{
    TPM2_PolicyCpHash_REQUEST _req(policySession,cpHashA);
    Dispatch(TPM_CC::PolicyCpHash, &_req, NULL);
}

void Tpm2::PolicyNameHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& nameHash
)
{
    TPM2_PolicyNameHash_REQUEST _req(policySession,nameHash);
    Dispatch(TPM_CC::PolicyNameHash, &_req, NULL);
}

void Tpm2::PolicyDuplicationSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& newParentName, 
    BYTE includeObject
)
{
    TPM2_PolicyDuplicationSelect_REQUEST _req(policySession,objectName,newParentName,includeObject);
    Dispatch(TPM_CC::PolicyDuplicationSelect, &_req, NULL);
}

void Tpm2::PolicyAuthorize
(
    const TPM_HANDLE& policySession, 
    const ByteVec& approvedPolicy, 
    const ByteVec& policyRef, 
    const ByteVec& keySign, 
    const TPMT_TK_VERIFIED& checkTicket
)
{
    TPM2_PolicyAuthorize_REQUEST _req(policySession,approvedPolicy,policyRef,keySign,checkTicket);
    Dispatch(TPM_CC::PolicyAuthorize, &_req, NULL);
}

void Tpm2::PolicyAuthValue(const TPM_HANDLE& policySession)
{
    TPM2_PolicyAuthValue_REQUEST _req(policySession);
    Dispatch(TPM_CC::PolicyAuthValue, &_req, NULL);
}

void Tpm2::PolicyPassword(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPassword_REQUEST _req(policySession);
    Dispatch(TPM_CC::PolicyPassword, &_req, NULL);
}

ByteVec Tpm2::PolicyGetDigest(const TPM_HANDLE& policySession)
{
    TPM2_PolicyGetDigest_REQUEST _req(policySession);
    PolicyGetDigestResponse _resp;
    Dispatch(TPM_CC::PolicyGetDigest, &_req, &_resp);
    return _resp.policyDigest;
}

void Tpm2::PolicyNvWritten
(
    const TPM_HANDLE& policySession, 
    BYTE writtenSet
)
{
    TPM2_PolicyNvWritten_REQUEST _req(policySession,writtenSet);
    Dispatch(TPM_CC::PolicyNvWritten, &_req, NULL);
}

void Tpm2::PolicyTemplate
(
    const TPM_HANDLE& policySession, 
    const ByteVec& templateHash
)
{
    TPM2_PolicyTemplate_REQUEST _req(policySession,templateHash);
    Dispatch(TPM_CC::PolicyTemplate, &_req, NULL);
}

void Tpm2::PolicyAuthorizeNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthorizeNV_REQUEST _req(authHandle,nvIndex,policySession);
    Dispatch(TPM_CC::PolicyAuthorizeNV, &_req, NULL);
}

CreatePrimaryResponse Tpm2::CreatePrimary
(
    const TPM_HANDLE& primaryHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_CreatePrimary_REQUEST _req(primaryHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    CreatePrimaryResponse _resp;
    Dispatch(TPM_CC::CreatePrimary, &_req, &_resp);
    return _resp;
}

void Tpm2::HierarchyControl
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& enable, 
    BYTE state
)
{
    TPM2_HierarchyControl_REQUEST _req(authHandle,enable,state);
    Dispatch(TPM_CC::HierarchyControl, &_req, NULL);
}

void Tpm2::SetPrimaryPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_SetPrimaryPolicy_REQUEST _req(authHandle,authPolicy,hashAlg);
    Dispatch(TPM_CC::SetPrimaryPolicy, &_req, NULL);
}

void Tpm2::ChangePPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangePPS_REQUEST _req(authHandle);
    Dispatch(TPM_CC::ChangePPS, &_req, NULL);
}

void Tpm2::ChangeEPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangeEPS_REQUEST _req(authHandle);
    Dispatch(TPM_CC::ChangeEPS, &_req, NULL);
}

void Tpm2::Clear(const TPM_HANDLE& authHandle)
{
    TPM2_Clear_REQUEST _req(authHandle);
    Dispatch(TPM_CC::Clear, &_req, NULL);
}

void Tpm2::ClearControl
(
    const TPM_HANDLE& auth, 
    BYTE disable
)
{
    TPM2_ClearControl_REQUEST _req(auth,disable);
    Dispatch(TPM_CC::ClearControl, &_req, NULL);
}

void Tpm2::HierarchyChangeAuth
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& newAuth
)
{
    TPM2_HierarchyChangeAuth_REQUEST _req(authHandle,newAuth);
    Dispatch(TPM_CC::HierarchyChangeAuth, &_req, NULL);
}

void Tpm2::DictionaryAttackLockReset(const TPM_HANDLE& lockHandle)
{
    TPM2_DictionaryAttackLockReset_REQUEST _req(lockHandle);
    Dispatch(TPM_CC::DictionaryAttackLockReset, &_req, NULL);
}

void Tpm2::DictionaryAttackParameters
(
    const TPM_HANDLE& lockHandle, 
    UINT32 newMaxTries, 
    UINT32 newRecoveryTime, 
    UINT32 lockoutRecovery
)
{
    TPM2_DictionaryAttackParameters_REQUEST _req(lockHandle,newMaxTries,newRecoveryTime,lockoutRecovery);
    Dispatch(TPM_CC::DictionaryAttackParameters, &_req, NULL);
}

void Tpm2::PP_Commands
(
    const TPM_HANDLE& auth, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_PP_Commands_REQUEST _req(auth,setList,clearList);
    Dispatch(TPM_CC::PP_Commands, &_req, NULL);
}

void Tpm2::SetAlgorithmSet
(
    const TPM_HANDLE& authHandle, 
    UINT32 algorithmSet
)
{
    TPM2_SetAlgorithmSet_REQUEST _req(authHandle,algorithmSet);
    Dispatch(TPM_CC::SetAlgorithmSet, &_req, NULL);
}

void Tpm2::FieldUpgradeStart
(
    const TPM_HANDLE& authorization, 
    const TPM_HANDLE& keyHandle, 
    const ByteVec& fuDigest, 
    const TPMU_SIGNATURE& manifestSignature
)
{
    TPM2_FieldUpgradeStart_REQUEST _req(authorization,keyHandle,fuDigest,manifestSignature);
    Dispatch(TPM_CC::FieldUpgradeStart, &_req, NULL);
}

FieldUpgradeDataResponse Tpm2::FieldUpgradeData(const ByteVec& fuData)
{
    TPM2_FieldUpgradeData_REQUEST _req(fuData);
    FieldUpgradeDataResponse _resp;
    Dispatch(TPM_CC::FieldUpgradeData, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::FirmwareRead(UINT32 sequenceNumber)
{
    TPM2_FirmwareRead_REQUEST _req(sequenceNumber);
    FirmwareReadResponse _resp;
    Dispatch(TPM_CC::FirmwareRead, &_req, &_resp);
    return _resp.fuData;
}

TPMS_CONTEXT Tpm2::ContextSave(const TPM_HANDLE& saveHandle)
{
    TPM2_ContextSave_REQUEST _req(saveHandle);
    ContextSaveResponse _resp;
    Dispatch(TPM_CC::ContextSave, &_req, &_resp);
    return _resp.context;
}

TPM_HANDLE Tpm2::ContextLoad(const TPMS_CONTEXT& context)
{
    TPM2_ContextLoad_REQUEST _req(context);
    ContextLoadResponse _resp;
    Dispatch(TPM_CC::ContextLoad, &_req, &_resp);
    return _resp.handle;
}

void Tpm2::FlushContext(const TPM_HANDLE& flushHandle)
{
    TPM2_FlushContext_REQUEST _req(flushHandle);
    Dispatch(TPM_CC::FlushContext, &_req, NULL);
}

void Tpm2::EvictControl
(
    const TPM_HANDLE& auth, 
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& persistentHandle
)
{
    TPM2_EvictControl_REQUEST _req(auth,objectHandle,persistentHandle);
    Dispatch(TPM_CC::EvictControl, &_req, NULL);
}

TPMS_TIME_INFO Tpm2::ReadClock()
{
    ReadClockResponse _resp;
    Dispatch(TPM_CC::ReadClock, NULL, &_resp);
    return _resp.currentTime;
}

void Tpm2::ClockSet
(
    const TPM_HANDLE& auth, 
    UINT64 newTime
)
{
    TPM2_ClockSet_REQUEST _req(auth,newTime);
    Dispatch(TPM_CC::ClockSet, &_req, NULL);
}

void Tpm2::ClockRateAdjust
(
    const TPM_HANDLE& auth, 
    TPM_CLOCK_ADJUST rateAdjust
)
{
    TPM2_ClockRateAdjust_REQUEST _req(auth,rateAdjust);
    Dispatch(TPM_CC::ClockRateAdjust, &_req, NULL);
}

GetCapabilityResponse Tpm2::GetCapability
(
    TPM_CAP capability, 
    UINT32 property, 
    UINT32 propertyCount
)
{
    TPM2_GetCapability_REQUEST _req(capability,property,propertyCount);
    GetCapabilityResponse _resp;
    Dispatch(TPM_CC::GetCapability, &_req, &_resp);
    return _resp;
}

void Tpm2::TestParms(const TPMU_PUBLIC_PARMS& parameters)
{
    TPM2_TestParms_REQUEST _req(parameters);
    Dispatch(TPM_CC::TestParms, &_req, NULL);
}

void Tpm2::NV_DefineSpace
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& auth, 
    const TPMS_NV_PUBLIC& publicInfo
)
{
    TPM2_NV_DefineSpace_REQUEST _req(authHandle,auth,publicInfo);
    Dispatch(TPM_CC::NV_DefineSpace, &_req, NULL);
}

void Tpm2::NV_UndefineSpace
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_UndefineSpace_REQUEST _req(authHandle,nvIndex);
    Dispatch(TPM_CC::NV_UndefineSpace, &_req, NULL);
}

void Tpm2::NV_UndefineSpaceSpecial
(
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& platform
)
{
    TPM2_NV_UndefineSpaceSpecial_REQUEST _req(nvIndex,platform);
    Dispatch(TPM_CC::NV_UndefineSpaceSpecial, &_req, NULL);
}

NV_ReadPublicResponse Tpm2::NV_ReadPublic(const TPM_HANDLE& nvIndex)
{
    TPM2_NV_ReadPublic_REQUEST _req(nvIndex);
    NV_ReadPublicResponse _resp;
    Dispatch(TPM_CC::NV_ReadPublic, &_req, &_resp);
    return _resp;
}

void Tpm2::NV_Write
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data, 
    UINT16 offset
)
{
    TPM2_NV_Write_REQUEST _req(authHandle,nvIndex,data,offset);
    Dispatch(TPM_CC::NV_Write, &_req, NULL);
}

void Tpm2::NV_Increment
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_Increment_REQUEST _req(authHandle,nvIndex);
    Dispatch(TPM_CC::NV_Increment, &_req, NULL);
}

void Tpm2::NV_Extend
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data
)
{
    TPM2_NV_Extend_REQUEST _req(authHandle,nvIndex,data);
    Dispatch(TPM_CC::NV_Extend, &_req, NULL);
}

void Tpm2::NV_SetBits
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT64 bits
)
{
    TPM2_NV_SetBits_REQUEST _req(authHandle,nvIndex,bits);
    Dispatch(TPM_CC::NV_SetBits, &_req, NULL);
}

void Tpm2::NV_WriteLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_WriteLock_REQUEST _req(authHandle,nvIndex);
    Dispatch(TPM_CC::NV_WriteLock, &_req, NULL);
}

void Tpm2::NV_GlobalWriteLock(const TPM_HANDLE& authHandle)
{
    TPM2_NV_GlobalWriteLock_REQUEST _req(authHandle);
    Dispatch(TPM_CC::NV_GlobalWriteLock, &_req, NULL);
}

ByteVec Tpm2::NV_Read
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Read_REQUEST _req(authHandle,nvIndex,size,offset);
    NV_ReadResponse _resp;
    Dispatch(TPM_CC::NV_Read, &_req, &_resp);
    return _resp.data;
}

void Tpm2::NV_ReadLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadLock_REQUEST _req(authHandle,nvIndex);
    Dispatch(TPM_CC::NV_ReadLock, &_req, NULL);
}

void Tpm2::NV_ChangeAuth
(
    const TPM_HANDLE& nvIndex, 
    const ByteVec& newAuth
)
{
    TPM2_NV_ChangeAuth_REQUEST _req(nvIndex,newAuth);
    Dispatch(TPM_CC::NV_ChangeAuth, &_req, NULL);
}

NV_CertifyResponse Tpm2::NV_Certify
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Certify_REQUEST _req(signHandle,authHandle,nvIndex,qualifyingData,inScheme,size,offset);
    NV_CertifyResponse _resp;
    Dispatch(TPM_CC::NV_Certify, &_req, &_resp);
    return _resp;
}

AC_GetCapabilityResponse Tpm2::AC_GetCapability
(
    const TPM_HANDLE& ac, 
    TPM_AT capability, 
    UINT32 count
)
{
    TPM2_AC_GetCapability_REQUEST _req(ac,capability,count);
    AC_GetCapabilityResponse _resp;
    Dispatch(TPM_CC::AC_GetCapability, &_req, &_resp);
    return _resp;
}

TPMS_AC_OUTPUT Tpm2::AC_Send
(
    const TPM_HANDLE& sendObject, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& ac, 
    const ByteVec& acDataIn
)
{
    TPM2_AC_Send_REQUEST _req(sendObject,authHandle,ac,acDataIn);
    AC_SendResponse _resp;
    Dispatch(TPM_CC::AC_Send, &_req, &_resp);
    return _resp.acDataOut;
}

void Tpm2::Policy_AC_SendSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& authHandleName, 
    const ByteVec& acName, 
    BYTE includeObject
)
{
    TPM2_Policy_AC_SendSelect_REQUEST _req(policySession,objectName,authHandleName,acName,includeObject);
    Dispatch(TPM_CC::Policy_AC_SendSelect, &_req, NULL);
}

void Tpm2::ACT_SetTimeout
(
    const TPM_HANDLE& actHandle, 
    UINT32 startTimeout
)
{
    TPM2_ACT_SetTimeout_REQUEST _req(actHandle,startTimeout);
    Dispatch(TPM_CC::ACT_SetTimeout, &_req, NULL);
}

ByteVec Tpm2::Vendor_TCG_Test(const ByteVec& inputData)
{
    TPM2_Vendor_TCG_Test_REQUEST _req(inputData);
    Vendor_TCG_TestResponse _resp;
    Dispatch(TPM_CC::Vendor_TCG_Test, &_req, &_resp);
    return _resp.outputData;
}

void Tpm2::AsyncMethods::Startup(TPM_SU startupType)
{
    TPM2_Startup_REQUEST _req(startupType);
    theTpm.DispatchOut(TPM_CC::Startup, &_req);
}

void Tpm2::AsyncMethods::Shutdown(TPM_SU shutdownType)
{
    TPM2_Shutdown_REQUEST _req(shutdownType);
    theTpm.DispatchOut(TPM_CC::Shutdown, &_req);
}

void Tpm2::AsyncMethods::SelfTest(BYTE fullTest)
{
    TPM2_SelfTest_REQUEST _req(fullTest);
    theTpm.DispatchOut(TPM_CC::SelfTest, &_req);
}

void Tpm2::AsyncMethods::IncrementalSelfTest(const vector<TPM_ALG_ID>& toTest)
{
    TPM2_IncrementalSelfTest_REQUEST _req(toTest);
    theTpm.DispatchOut(TPM_CC::IncrementalSelfTest, &_req);
}

void Tpm2::AsyncMethods::GetTestResult()
{
    theTpm.DispatchOut(TPM_CC::GetTestResult, NULL);
}

void Tpm2::AsyncMethods::StartAuthSession
(
    const TPM_HANDLE& tpmKey, 
    const TPM_HANDLE& bind, 
    const ByteVec& nonceCaller, 
    const ByteVec& encryptedSalt, 
    TPM_SE sessionType, 
    const TPMT_SYM_DEF& symmetric, 
    TPM_ALG_ID authHash
)
{
    TPM2_StartAuthSession_REQUEST _req(tpmKey,bind,nonceCaller,encryptedSalt,sessionType,symmetric,authHash);
    theTpm.DispatchOut(TPM_CC::StartAuthSession, &_req);
}

void Tpm2::AsyncMethods::PolicyRestart(const TPM_HANDLE& sessionHandle)
{
    TPM2_PolicyRestart_REQUEST _req(sessionHandle);
    theTpm.DispatchOut(TPM_CC::PolicyRestart, &_req);
}

void Tpm2::AsyncMethods::Create
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_Create_REQUEST _req(parentHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    theTpm.DispatchOut(TPM_CC::Create, &_req);
}

void Tpm2::AsyncMethods::Load
(
    const TPM_HANDLE& parentHandle, 
    const TPM2B_PRIVATE& inPrivate, 
    const TPMT_PUBLIC& inPublic
)
{
    TPM2_Load_REQUEST _req(parentHandle,inPrivate,inPublic);
    theTpm.DispatchOut(TPM_CC::Load, &_req);
}

void Tpm2::AsyncMethods::LoadExternal
(
    const TPMT_SENSITIVE& inPrivate, 
    const TPMT_PUBLIC& inPublic, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_LoadExternal_REQUEST _req(inPrivate,inPublic,hierarchy);
    theTpm.DispatchOut(TPM_CC::LoadExternal, &_req);
}

void Tpm2::AsyncMethods::ReadPublic(const TPM_HANDLE& objectHandle)
{
    TPM2_ReadPublic_REQUEST _req(objectHandle);
    theTpm.DispatchOut(TPM_CC::ReadPublic, &_req);
}

void Tpm2::AsyncMethods::ActivateCredential
(
    const TPM_HANDLE& activateHandle, 
    const TPM_HANDLE& keyHandle, 
    const TPMS_ID_OBJECT& credentialBlob, 
    const ByteVec& secret
)
{
    TPM2_ActivateCredential_REQUEST _req(activateHandle,keyHandle,credentialBlob,secret);
    theTpm.DispatchOut(TPM_CC::ActivateCredential, &_req);
}

void Tpm2::AsyncMethods::MakeCredential
(
    const TPM_HANDLE& handle, 
    const ByteVec& credential, 
    const ByteVec& objectName
)
{
    TPM2_MakeCredential_REQUEST _req(handle,credential,objectName);
    theTpm.DispatchOut(TPM_CC::MakeCredential, &_req);
}

void Tpm2::AsyncMethods::Unseal(const TPM_HANDLE& itemHandle)
{
    TPM2_Unseal_REQUEST _req(itemHandle);
    theTpm.DispatchOut(TPM_CC::Unseal, &_req);
}

void Tpm2::AsyncMethods::ObjectChangeAuth
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& parentHandle, 
    const ByteVec& newAuth
)
{
    TPM2_ObjectChangeAuth_REQUEST _req(objectHandle,parentHandle,newAuth);
    theTpm.DispatchOut(TPM_CC::ObjectChangeAuth, &_req);
}

void Tpm2::AsyncMethods::CreateLoaded
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const ByteVec& inPublic
)
{
    TPM2_CreateLoaded_REQUEST _req(parentHandle,inSensitive,inPublic);
    theTpm.DispatchOut(TPM_CC::CreateLoaded, &_req);
}

void Tpm2::AsyncMethods::Duplicate
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& newParentHandle, 
    const ByteVec& encryptionKeyIn, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Duplicate_REQUEST _req(objectHandle,newParentHandle,encryptionKeyIn,symmetricAlg);
    theTpm.DispatchOut(TPM_CC::Duplicate, &_req);
}

void Tpm2::AsyncMethods::Rewrap
(
    const TPM_HANDLE& oldParent, 
    const TPM_HANDLE& newParent, 
    const TPM2B_PRIVATE& inDuplicate, 
    const ByteVec& name, 
    const ByteVec& inSymSeed
)
{
    TPM2_Rewrap_REQUEST _req(oldParent,newParent,inDuplicate,name,inSymSeed);
    theTpm.DispatchOut(TPM_CC::Rewrap, &_req);
}

void Tpm2::AsyncMethods::Import
(
    const TPM_HANDLE& parentHandle, 
    const ByteVec& encryptionKey, 
    const TPMT_PUBLIC& objectPublic, 
    const TPM2B_PRIVATE& duplicate, 
    const ByteVec& inSymSeed, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Import_REQUEST _req(parentHandle,encryptionKey,objectPublic,duplicate,inSymSeed,symmetricAlg);
    theTpm.DispatchOut(TPM_CC::Import, &_req);
}

void Tpm2::AsyncMethods::RSA_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& message, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Encrypt_REQUEST _req(keyHandle,message,inScheme,label);
    theTpm.DispatchOut(TPM_CC::RSA_Encrypt, &_req);
}

void Tpm2::AsyncMethods::RSA_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& cipherText, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Decrypt_REQUEST _req(keyHandle,cipherText,inScheme,label);
    theTpm.DispatchOut(TPM_CC::RSA_Decrypt, &_req);
}

void Tpm2::AsyncMethods::ECDH_KeyGen(const TPM_HANDLE& keyHandle)
{
    TPM2_ECDH_KeyGen_REQUEST _req(keyHandle);
    theTpm.DispatchOut(TPM_CC::ECDH_KeyGen, &_req);
}

void Tpm2::AsyncMethods::ECDH_ZGen
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& inPoint
)
{
    TPM2_ECDH_ZGen_REQUEST _req(keyHandle,inPoint);
    theTpm.DispatchOut(TPM_CC::ECDH_ZGen, &_req);
}

void Tpm2::AsyncMethods::ECC_Parameters(TPM_ECC_CURVE curveID)
{
    TPM2_ECC_Parameters_REQUEST _req(curveID);
    theTpm.DispatchOut(TPM_CC::ECC_Parameters, &_req);
}

void Tpm2::AsyncMethods::ZGen_2Phase
(
    const TPM_HANDLE& keyA, 
    const TPMS_ECC_POINT& inQsB, 
    const TPMS_ECC_POINT& inQeB, 
    TPM_ALG_ID inScheme, 
    UINT16 counter
)
{
    TPM2_ZGen_2Phase_REQUEST _req(keyA,inQsB,inQeB,inScheme,counter);
    theTpm.DispatchOut(TPM_CC::ZGen_2Phase, &_req);
}

void Tpm2::AsyncMethods::ECC_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& plainText, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Encrypt_REQUEST _req(keyHandle,plainText,inScheme);
    theTpm.DispatchOut(TPM_CC::ECC_Encrypt, &_req);
}

void Tpm2::AsyncMethods::ECC_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& C1, 
    const ByteVec& C2, 
    const ByteVec& C3, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Decrypt_REQUEST _req(keyHandle,C1,C2,C3,inScheme);
    theTpm.DispatchOut(TPM_CC::ECC_Decrypt, &_req);
}

void Tpm2::AsyncMethods::EncryptDecrypt
(
    const TPM_HANDLE& keyHandle, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn, 
    const ByteVec& inData
)
{
    TPM2_EncryptDecrypt_REQUEST _req(keyHandle,decrypt,mode,ivIn,inData);
    theTpm.DispatchOut(TPM_CC::EncryptDecrypt, &_req);
}

void Tpm2::AsyncMethods::EncryptDecrypt2
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& inData, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn
)
{
    TPM2_EncryptDecrypt2_REQUEST _req(keyHandle,inData,decrypt,mode,ivIn);
    theTpm.DispatchOut(TPM_CC::EncryptDecrypt2, &_req);
}

void Tpm2::AsyncMethods::Hash
(
    const ByteVec& data, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_Hash_REQUEST _req(data,hashAlg,hierarchy);
    theTpm.DispatchOut(TPM_CC::Hash, &_req);
}

void Tpm2::AsyncMethods::HMAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_REQUEST _req(handle,buffer,hashAlg);
    theTpm.DispatchOut(TPM_CC::HMAC, &_req);
}

void Tpm2::AsyncMethods::MAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_REQUEST _req(handle,buffer,inScheme);
    theTpm.DispatchOut(TPM_CC::MAC, &_req);
}

void Tpm2::AsyncMethods::GetRandom(UINT16 bytesRequested)
{
    TPM2_GetRandom_REQUEST _req(bytesRequested);
    theTpm.DispatchOut(TPM_CC::GetRandom, &_req);
}

void Tpm2::AsyncMethods::StirRandom(const ByteVec& inData)
{
    TPM2_StirRandom_REQUEST _req(inData);
    theTpm.DispatchOut(TPM_CC::StirRandom, &_req);
}

void Tpm2::AsyncMethods::HMAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_Start_REQUEST _req(handle,auth,hashAlg);
    theTpm.DispatchOut(TPM_CC::HMAC_Start, &_req);
}

void Tpm2::AsyncMethods::MAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_Start_REQUEST _req(handle,auth,inScheme);
    theTpm.DispatchOut(TPM_CC::MAC_Start, &_req);
}

void Tpm2::AsyncMethods::HashSequenceStart
(
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HashSequenceStart_REQUEST _req(auth,hashAlg);
    theTpm.DispatchOut(TPM_CC::HashSequenceStart, &_req);
}

void Tpm2::AsyncMethods::SequenceUpdate
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_SequenceUpdate_REQUEST _req(sequenceHandle,buffer);
    theTpm.DispatchOut(TPM_CC::SequenceUpdate, &_req);
}

void Tpm2::AsyncMethods::SequenceComplete
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_SequenceComplete_REQUEST _req(sequenceHandle,buffer,hierarchy);
    theTpm.DispatchOut(TPM_CC::SequenceComplete, &_req);
}

void Tpm2::AsyncMethods::EventSequenceComplete
(
    const TPM_HANDLE& pcrHandle, 
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_EventSequenceComplete_REQUEST _req(pcrHandle,sequenceHandle,buffer);
    theTpm.DispatchOut(TPM_CC::EventSequenceComplete, &_req);
}

void Tpm2::AsyncMethods::Certify
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_Certify_REQUEST _req(objectHandle,signHandle,qualifyingData,inScheme);
    theTpm.DispatchOut(TPM_CC::Certify, &_req);
}

void Tpm2::AsyncMethods::CertifyCreation
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& objectHandle, 
    const ByteVec& qualifyingData, 
    const ByteVec& creationHash, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_CREATION& creationTicket
)
{
    TPM2_CertifyCreation_REQUEST _req(signHandle,objectHandle,qualifyingData,creationHash,inScheme,creationTicket);
    theTpm.DispatchOut(TPM_CC::CertifyCreation, &_req);
}

void Tpm2::AsyncMethods::Quote
(
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    const vector<TPMS_PCR_SELECTION>& PCRselect
)
{
    TPM2_Quote_REQUEST _req(signHandle,qualifyingData,inScheme,PCRselect);
    theTpm.DispatchOut(TPM_CC::Quote, &_req);
}

void Tpm2::AsyncMethods::GetSessionAuditDigest
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& sessionHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetSessionAuditDigest_REQUEST _req(privacyAdminHandle,signHandle,sessionHandle,qualifyingData,inScheme);
    theTpm.DispatchOut(TPM_CC::GetSessionAuditDigest, &_req);
}

void Tpm2::AsyncMethods::GetCommandAuditDigest
(
    const TPM_HANDLE& privacyHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetCommandAuditDigest_REQUEST _req(privacyHandle,signHandle,qualifyingData,inScheme);
    theTpm.DispatchOut(TPM_CC::GetCommandAuditDigest, &_req);
}

void Tpm2::AsyncMethods::GetTime
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetTime_REQUEST _req(privacyAdminHandle,signHandle,qualifyingData,inScheme);
    theTpm.DispatchOut(TPM_CC::GetTime, &_req);
}

void Tpm2::AsyncMethods::CertifyX509
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& reserved, 
    const TPMU_SIG_SCHEME& inScheme, 
    const ByteVec& partialCertificate
)
{
    TPM2_CertifyX509_REQUEST _req(objectHandle,signHandle,reserved,inScheme,partialCertificate);
    theTpm.DispatchOut(TPM_CC::CertifyX509, &_req);
}

void Tpm2::AsyncMethods::Commit
(
    const TPM_HANDLE& signHandle, 
    const TPMS_ECC_POINT& P1, 
    const ByteVec& s2, 
    const ByteVec& y2
)
{
    TPM2_Commit_REQUEST _req(signHandle,P1,s2,y2);
    theTpm.DispatchOut(TPM_CC::Commit, &_req);
}

void Tpm2::AsyncMethods::EC_Ephemeral(TPM_ECC_CURVE curveID)
{
    TPM2_EC_Ephemeral_REQUEST _req(curveID);
    theTpm.DispatchOut(TPM_CC::EC_Ephemeral, &_req);
}

void Tpm2::AsyncMethods::VerifySignature
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIGNATURE& signature
)
{
    TPM2_VerifySignature_REQUEST _req(keyHandle,digest,signature);
    theTpm.DispatchOut(TPM_CC::VerifySignature, &_req);
}

void Tpm2::AsyncMethods::Sign
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_HASHCHECK& validation
)
{
    TPM2_Sign_REQUEST _req(keyHandle,digest,inScheme,validation);
    theTpm.DispatchOut(TPM_CC::Sign, &_req);
}

void Tpm2::AsyncMethods::SetCommandCodeAuditStatus
(
    const TPM_HANDLE& auth, 
    TPM_ALG_ID auditAlg, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_SetCommandCodeAuditStatus_REQUEST _req(auth,auditAlg,setList,clearList);
    theTpm.DispatchOut(TPM_CC::SetCommandCodeAuditStatus, &_req);
}

void Tpm2::AsyncMethods::PCR_Extend
(
    const TPM_HANDLE& pcrHandle, 
    const vector<TPMT_HA>& digests
)
{
    TPM2_PCR_Extend_REQUEST _req(pcrHandle,digests);
    theTpm.DispatchOut(TPM_CC::PCR_Extend, &_req);
}

void Tpm2::AsyncMethods::PCR_Event
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& eventData
)
{
    TPM2_PCR_Event_REQUEST _req(pcrHandle,eventData);
    theTpm.DispatchOut(TPM_CC::PCR_Event, &_req);
}

void Tpm2::AsyncMethods::PCR_Read(const vector<TPMS_PCR_SELECTION>& pcrSelectionIn)
{
    TPM2_PCR_Read_REQUEST _req(pcrSelectionIn);
    theTpm.DispatchOut(TPM_CC::PCR_Read, &_req);
}

void Tpm2::AsyncMethods::PCR_Allocate
(
    const TPM_HANDLE& authHandle, 
    const vector<TPMS_PCR_SELECTION>& pcrAllocation
)
{
    TPM2_PCR_Allocate_REQUEST _req(authHandle,pcrAllocation);
    theTpm.DispatchOut(TPM_CC::PCR_Allocate, &_req);
}

void Tpm2::AsyncMethods::PCR_SetAuthPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& pcrNum
)
{
    TPM2_PCR_SetAuthPolicy_REQUEST _req(authHandle,authPolicy,hashAlg,pcrNum);
    theTpm.DispatchOut(TPM_CC::PCR_SetAuthPolicy, &_req);
}

void Tpm2::AsyncMethods::PCR_SetAuthValue
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& auth
)
{
    TPM2_PCR_SetAuthValue_REQUEST _req(pcrHandle,auth);
    theTpm.DispatchOut(TPM_CC::PCR_SetAuthValue, &_req);
}

void Tpm2::AsyncMethods::PCR_Reset(const TPM_HANDLE& pcrHandle)
{
    TPM2_PCR_Reset_REQUEST _req(pcrHandle);
    theTpm.DispatchOut(TPM_CC::PCR_Reset, &_req);
}

void Tpm2::AsyncMethods::PolicySigned
(
    const TPM_HANDLE& authObject, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration, 
    const TPMU_SIGNATURE& auth
)
{
    TPM2_PolicySigned_REQUEST _req(authObject,policySession,nonceTPM,cpHashA,policyRef,expiration,auth);
    theTpm.DispatchOut(TPM_CC::PolicySigned, &_req);
}

void Tpm2::AsyncMethods::PolicySecret
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration
)
{
    TPM2_PolicySecret_REQUEST _req(authHandle,policySession,nonceTPM,cpHashA,policyRef,expiration);
    theTpm.DispatchOut(TPM_CC::PolicySecret, &_req);
}

void Tpm2::AsyncMethods::PolicyTicket
(
    const TPM_HANDLE& policySession, 
    const ByteVec& timeout, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    const ByteVec& authName, 
    const TPMT_TK_AUTH& ticket
)
{
    TPM2_PolicyTicket_REQUEST _req(policySession,timeout,cpHashA,policyRef,authName,ticket);
    theTpm.DispatchOut(TPM_CC::PolicyTicket, &_req);
}

void Tpm2::AsyncMethods::PolicyOR
(
    const TPM_HANDLE& policySession, 
    const vector<TPM2B_DIGEST>& pHashList
)
{
    TPM2_PolicyOR_REQUEST _req(policySession,pHashList);
    theTpm.DispatchOut(TPM_CC::PolicyOR, &_req);
}

void Tpm2::AsyncMethods::PolicyPCR
(
    const TPM_HANDLE& policySession, 
    const ByteVec& pcrDigest, 
    const vector<TPMS_PCR_SELECTION>& pcrs
)
{
    TPM2_PolicyPCR_REQUEST _req(policySession,pcrDigest,pcrs);
    theTpm.DispatchOut(TPM_CC::PolicyPCR, &_req);
}

void Tpm2::AsyncMethods::PolicyLocality
(
    const TPM_HANDLE& policySession, 
    TPMA_LOCALITY locality
)
{
    TPM2_PolicyLocality_REQUEST _req(policySession,locality);
    theTpm.DispatchOut(TPM_CC::PolicyLocality, &_req);
}

void Tpm2::AsyncMethods::PolicyNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyNV_REQUEST _req(authHandle,nvIndex,policySession,operandB,offset,operation);
    theTpm.DispatchOut(TPM_CC::PolicyNV, &_req);
}

void Tpm2::AsyncMethods::PolicyCounterTimer
(
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyCounterTimer_REQUEST _req(policySession,operandB,offset,operation);
    theTpm.DispatchOut(TPM_CC::PolicyCounterTimer, &_req);
}

void Tpm2::AsyncMethods::PolicyCommandCode
(
    const TPM_HANDLE& policySession, 
    TPM_CC code
)
{
    TPM2_PolicyCommandCode_REQUEST _req(policySession,code);
    theTpm.DispatchOut(TPM_CC::PolicyCommandCode, &_req);
}

void Tpm2::AsyncMethods::PolicyPhysicalPresence(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPhysicalPresence_REQUEST _req(policySession);
    theTpm.DispatchOut(TPM_CC::PolicyPhysicalPresence, &_req);
}

void Tpm2::AsyncMethods::PolicyCpHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& cpHashA
)
{
    TPM2_PolicyCpHash_REQUEST _req(policySession,cpHashA);
    theTpm.DispatchOut(TPM_CC::PolicyCpHash, &_req);
}

void Tpm2::AsyncMethods::PolicyNameHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& nameHash
)
{
    TPM2_PolicyNameHash_REQUEST _req(policySession,nameHash);
    theTpm.DispatchOut(TPM_CC::PolicyNameHash, &_req);
}

void Tpm2::AsyncMethods::PolicyDuplicationSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& newParentName, 
    BYTE includeObject
)
{
    TPM2_PolicyDuplicationSelect_REQUEST _req(policySession,objectName,newParentName,includeObject);
    theTpm.DispatchOut(TPM_CC::PolicyDuplicationSelect, &_req);
}

void Tpm2::AsyncMethods::PolicyAuthorize
(
    const TPM_HANDLE& policySession, 
    const ByteVec& approvedPolicy, 
    const ByteVec& policyRef, 
    const ByteVec& keySign, 
    const TPMT_TK_VERIFIED& checkTicket
)
{
    TPM2_PolicyAuthorize_REQUEST _req(policySession,approvedPolicy,policyRef,keySign,checkTicket);
    theTpm.DispatchOut(TPM_CC::PolicyAuthorize, &_req);
}

void Tpm2::AsyncMethods::PolicyAuthValue(const TPM_HANDLE& policySession)
{
    TPM2_PolicyAuthValue_REQUEST _req(policySession);
    theTpm.DispatchOut(TPM_CC::PolicyAuthValue, &_req);
}

void Tpm2::AsyncMethods::PolicyPassword(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPassword_REQUEST _req(policySession);
    theTpm.DispatchOut(TPM_CC::PolicyPassword, &_req);
}

void Tpm2::AsyncMethods::PolicyGetDigest(const TPM_HANDLE& policySession)
{
    TPM2_PolicyGetDigest_REQUEST _req(policySession);
    theTpm.DispatchOut(TPM_CC::PolicyGetDigest, &_req);
}

void Tpm2::AsyncMethods::PolicyNvWritten
(
    const TPM_HANDLE& policySession, 
    BYTE writtenSet
)
{
    TPM2_PolicyNvWritten_REQUEST _req(policySession,writtenSet);
    theTpm.DispatchOut(TPM_CC::PolicyNvWritten, &_req);
}

void Tpm2::AsyncMethods::PolicyTemplate
(
    const TPM_HANDLE& policySession, 
    const ByteVec& templateHash
)
{
    TPM2_PolicyTemplate_REQUEST _req(policySession,templateHash);
    theTpm.DispatchOut(TPM_CC::PolicyTemplate, &_req);
}

void Tpm2::AsyncMethods::PolicyAuthorizeNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthorizeNV_REQUEST _req(authHandle,nvIndex,policySession);
    theTpm.DispatchOut(TPM_CC::PolicyAuthorizeNV, &_req);
}

void Tpm2::AsyncMethods::CreatePrimary
(
    const TPM_HANDLE& primaryHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_CreatePrimary_REQUEST _req(primaryHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    theTpm.DispatchOut(TPM_CC::CreatePrimary, &_req);
}

void Tpm2::AsyncMethods::HierarchyControl
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& enable, 
    BYTE state
)
{
    TPM2_HierarchyControl_REQUEST _req(authHandle,enable,state);
    theTpm.DispatchOut(TPM_CC::HierarchyControl, &_req);
}

void Tpm2::AsyncMethods::SetPrimaryPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_SetPrimaryPolicy_REQUEST _req(authHandle,authPolicy,hashAlg);
    theTpm.DispatchOut(TPM_CC::SetPrimaryPolicy, &_req);
}

void Tpm2::AsyncMethods::ChangePPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangePPS_REQUEST _req(authHandle);
    theTpm.DispatchOut(TPM_CC::ChangePPS, &_req);
}

void Tpm2::AsyncMethods::ChangeEPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangeEPS_REQUEST _req(authHandle);
    theTpm.DispatchOut(TPM_CC::ChangeEPS, &_req);
}

void Tpm2::AsyncMethods::Clear(const TPM_HANDLE& authHandle)
{
    TPM2_Clear_REQUEST _req(authHandle);
    theTpm.DispatchOut(TPM_CC::Clear, &_req);
}

void Tpm2::AsyncMethods::ClearControl
(
    const TPM_HANDLE& auth, 
    BYTE disable
)
{
    TPM2_ClearControl_REQUEST _req(auth,disable);
    theTpm.DispatchOut(TPM_CC::ClearControl, &_req);
}

void Tpm2::AsyncMethods::HierarchyChangeAuth
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& newAuth
)
{
    TPM2_HierarchyChangeAuth_REQUEST _req(authHandle,newAuth);
    theTpm.DispatchOut(TPM_CC::HierarchyChangeAuth, &_req);
}

void Tpm2::AsyncMethods::DictionaryAttackLockReset(const TPM_HANDLE& lockHandle)
{
    TPM2_DictionaryAttackLockReset_REQUEST _req(lockHandle);
    theTpm.DispatchOut(TPM_CC::DictionaryAttackLockReset, &_req);
}

void Tpm2::AsyncMethods::DictionaryAttackParameters
(
    const TPM_HANDLE& lockHandle, 
    UINT32 newMaxTries, 
    UINT32 newRecoveryTime, 
    UINT32 lockoutRecovery
)
{
    TPM2_DictionaryAttackParameters_REQUEST _req(lockHandle,newMaxTries,newRecoveryTime,lockoutRecovery);
    theTpm.DispatchOut(TPM_CC::DictionaryAttackParameters, &_req);
}

void Tpm2::AsyncMethods::PP_Commands
(
    const TPM_HANDLE& auth, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_PP_Commands_REQUEST _req(auth,setList,clearList);
    theTpm.DispatchOut(TPM_CC::PP_Commands, &_req);
}

void Tpm2::AsyncMethods::SetAlgorithmSet
(
    const TPM_HANDLE& authHandle, 
    UINT32 algorithmSet
)
{
    TPM2_SetAlgorithmSet_REQUEST _req(authHandle,algorithmSet);
    theTpm.DispatchOut(TPM_CC::SetAlgorithmSet, &_req);
}

void Tpm2::AsyncMethods::FieldUpgradeStart
(
    const TPM_HANDLE& authorization, 
    const TPM_HANDLE& keyHandle, 
    const ByteVec& fuDigest, 
    const TPMU_SIGNATURE& manifestSignature
)
{
    TPM2_FieldUpgradeStart_REQUEST _req(authorization,keyHandle,fuDigest,manifestSignature);
    theTpm.DispatchOut(TPM_CC::FieldUpgradeStart, &_req);
}

void Tpm2::AsyncMethods::FieldUpgradeData(const ByteVec& fuData)
{
    TPM2_FieldUpgradeData_REQUEST _req(fuData);
    theTpm.DispatchOut(TPM_CC::FieldUpgradeData, &_req);
}

void Tpm2::AsyncMethods::FirmwareRead(UINT32 sequenceNumber)
{
    TPM2_FirmwareRead_REQUEST _req(sequenceNumber);
    theTpm.DispatchOut(TPM_CC::FirmwareRead, &_req);
}

void Tpm2::AsyncMethods::ContextSave(const TPM_HANDLE& saveHandle)
{
    TPM2_ContextSave_REQUEST _req(saveHandle);
    theTpm.DispatchOut(TPM_CC::ContextSave, &_req);
}

void Tpm2::AsyncMethods::ContextLoad(const TPMS_CONTEXT& context)
{
    TPM2_ContextLoad_REQUEST _req(context);
    theTpm.DispatchOut(TPM_CC::ContextLoad, &_req);
}

void Tpm2::AsyncMethods::FlushContext(const TPM_HANDLE& flushHandle)
{
    TPM2_FlushContext_REQUEST _req(flushHandle);
    theTpm.DispatchOut(TPM_CC::FlushContext, &_req);
}

void Tpm2::AsyncMethods::EvictControl
(
    const TPM_HANDLE& auth, 
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& persistentHandle
)
{
    TPM2_EvictControl_REQUEST _req(auth,objectHandle,persistentHandle);
    theTpm.DispatchOut(TPM_CC::EvictControl, &_req);
}

void Tpm2::AsyncMethods::ReadClock()
{
    theTpm.DispatchOut(TPM_CC::ReadClock, NULL);
}

void Tpm2::AsyncMethods::ClockSet
(
    const TPM_HANDLE& auth, 
    UINT64 newTime
)
{
    TPM2_ClockSet_REQUEST _req(auth,newTime);
    theTpm.DispatchOut(TPM_CC::ClockSet, &_req);
}

void Tpm2::AsyncMethods::ClockRateAdjust
(
    const TPM_HANDLE& auth, 
    TPM_CLOCK_ADJUST rateAdjust
)
{
    TPM2_ClockRateAdjust_REQUEST _req(auth,rateAdjust);
    theTpm.DispatchOut(TPM_CC::ClockRateAdjust, &_req);
}

void Tpm2::AsyncMethods::GetCapability
(
    TPM_CAP capability, 
    UINT32 property, 
    UINT32 propertyCount
)
{
    TPM2_GetCapability_REQUEST _req(capability,property,propertyCount);
    theTpm.DispatchOut(TPM_CC::GetCapability, &_req);
}

void Tpm2::AsyncMethods::TestParms(const TPMU_PUBLIC_PARMS& parameters)
{
    TPM2_TestParms_REQUEST _req(parameters);
    theTpm.DispatchOut(TPM_CC::TestParms, &_req);
}

void Tpm2::AsyncMethods::NV_DefineSpace
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& auth, 
    const TPMS_NV_PUBLIC& publicInfo
)
{
    TPM2_NV_DefineSpace_REQUEST _req(authHandle,auth,publicInfo);
    theTpm.DispatchOut(TPM_CC::NV_DefineSpace, &_req);
}

void Tpm2::AsyncMethods::NV_UndefineSpace
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_UndefineSpace_REQUEST _req(authHandle,nvIndex);
    theTpm.DispatchOut(TPM_CC::NV_UndefineSpace, &_req);
}

void Tpm2::AsyncMethods::NV_UndefineSpaceSpecial
(
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& platform
)
{
    TPM2_NV_UndefineSpaceSpecial_REQUEST _req(nvIndex,platform);
    theTpm.DispatchOut(TPM_CC::NV_UndefineSpaceSpecial, &_req);
}

void Tpm2::AsyncMethods::NV_ReadPublic(const TPM_HANDLE& nvIndex)
{
    TPM2_NV_ReadPublic_REQUEST _req(nvIndex);
    theTpm.DispatchOut(TPM_CC::NV_ReadPublic, &_req);
}

void Tpm2::AsyncMethods::NV_Write
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data, 
    UINT16 offset
)
{
    TPM2_NV_Write_REQUEST _req(authHandle,nvIndex,data,offset);
    theTpm.DispatchOut(TPM_CC::NV_Write, &_req);
}

void Tpm2::AsyncMethods::NV_Increment
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_Increment_REQUEST _req(authHandle,nvIndex);
    theTpm.DispatchOut(TPM_CC::NV_Increment, &_req);
}

void Tpm2::AsyncMethods::NV_Extend
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data
)
{
    TPM2_NV_Extend_REQUEST _req(authHandle,nvIndex,data);
    theTpm.DispatchOut(TPM_CC::NV_Extend, &_req);
}

void Tpm2::AsyncMethods::NV_SetBits
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT64 bits
)
{
    TPM2_NV_SetBits_REQUEST _req(authHandle,nvIndex,bits);
    theTpm.DispatchOut(TPM_CC::NV_SetBits, &_req);
}

void Tpm2::AsyncMethods::NV_WriteLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_WriteLock_REQUEST _req(authHandle,nvIndex);
    theTpm.DispatchOut(TPM_CC::NV_WriteLock, &_req);
}

void Tpm2::AsyncMethods::NV_GlobalWriteLock(const TPM_HANDLE& authHandle)
{
    TPM2_NV_GlobalWriteLock_REQUEST _req(authHandle);
    theTpm.DispatchOut(TPM_CC::NV_GlobalWriteLock, &_req);
}

void Tpm2::AsyncMethods::NV_Read
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Read_REQUEST _req(authHandle,nvIndex,size,offset);
    theTpm.DispatchOut(TPM_CC::NV_Read, &_req);
}

void Tpm2::AsyncMethods::NV_ReadLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadLock_REQUEST _req(authHandle,nvIndex);
    theTpm.DispatchOut(TPM_CC::NV_ReadLock, &_req);
}

void Tpm2::AsyncMethods::NV_ChangeAuth
(
    const TPM_HANDLE& nvIndex, 
    const ByteVec& newAuth
)
{
    TPM2_NV_ChangeAuth_REQUEST _req(nvIndex,newAuth);
    theTpm.DispatchOut(TPM_CC::NV_ChangeAuth, &_req);
}

void Tpm2::AsyncMethods::NV_Certify
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Certify_REQUEST _req(signHandle,authHandle,nvIndex,qualifyingData,inScheme,size,offset);
    theTpm.DispatchOut(TPM_CC::NV_Certify, &_req);
}

void Tpm2::AsyncMethods::AC_GetCapability
(
    const TPM_HANDLE& ac, 
    TPM_AT capability, 
    UINT32 count
)
{
    TPM2_AC_GetCapability_REQUEST _req(ac,capability,count);
    theTpm.DispatchOut(TPM_CC::AC_GetCapability, &_req);
}

void Tpm2::AsyncMethods::AC_Send
(
    const TPM_HANDLE& sendObject, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& ac, 
    const ByteVec& acDataIn
)
{
    TPM2_AC_Send_REQUEST _req(sendObject,authHandle,ac,acDataIn);
    theTpm.DispatchOut(TPM_CC::AC_Send, &_req);
}

void Tpm2::AsyncMethods::Policy_AC_SendSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& authHandleName, 
    const ByteVec& acName, 
    BYTE includeObject
)
{
    TPM2_Policy_AC_SendSelect_REQUEST _req(policySession,objectName,authHandleName,acName,includeObject);
    theTpm.DispatchOut(TPM_CC::Policy_AC_SendSelect, &_req);
}

void Tpm2::AsyncMethods::ACT_SetTimeout
(
    const TPM_HANDLE& actHandle, 
    UINT32 startTimeout
)
{
    TPM2_ACT_SetTimeout_REQUEST _req(actHandle,startTimeout);
    theTpm.DispatchOut(TPM_CC::ACT_SetTimeout, &_req);
}

void Tpm2::AsyncMethods::Vendor_TCG_Test(const ByteVec& inputData)
{
    TPM2_Vendor_TCG_Test_REQUEST _req(inputData);
    theTpm.DispatchOut(TPM_CC::Vendor_TCG_Test, &_req);
}

void Tpm2::AsyncMethods::StartupComplete()
{
    theTpm.DispatchIn(TPM_CC::Startup, NULL);
}

void Tpm2::AsyncMethods::ShutdownComplete()
{
    theTpm.DispatchIn(TPM_CC::Shutdown, NULL);
}

void Tpm2::AsyncMethods::SelfTestComplete()
{
    theTpm.DispatchIn(TPM_CC::SelfTest, NULL);
}

vector<TPM_ALG_ID> Tpm2::AsyncMethods::IncrementalSelfTestComplete()
{
    IncrementalSelfTestResponse _resp;
    theTpm.DispatchIn(TPM_CC::IncrementalSelfTest, &_resp);
    return _resp.toDoList;
}

GetTestResultResponse Tpm2::AsyncMethods::GetTestResultComplete()
{
    GetTestResultResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetTestResult, &_resp);
    return _resp;
}

StartAuthSessionResponse Tpm2::AsyncMethods::StartAuthSessionComplete()
{
    StartAuthSessionResponse _resp;
    theTpm.DispatchIn(TPM_CC::StartAuthSession, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::PolicyRestartComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyRestart, NULL);
}

CreateResponse Tpm2::AsyncMethods::CreateComplete()
{
    CreateResponse _resp;
    theTpm.DispatchIn(TPM_CC::Create, &_resp);
    return _resp;
}

LoadResponse Tpm2::AsyncMethods::LoadComplete()
{
    LoadResponse _resp;
    theTpm.DispatchIn(TPM_CC::Load, &_resp);
    return _resp;
}

LoadExternalResponse Tpm2::AsyncMethods::LoadExternalComplete()
{
    LoadExternalResponse _resp;
    theTpm.DispatchIn(TPM_CC::LoadExternal, &_resp);
    return _resp;
}

ReadPublicResponse Tpm2::AsyncMethods::ReadPublicComplete()
{
    ReadPublicResponse _resp;
    theTpm.DispatchIn(TPM_CC::ReadPublic, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::ActivateCredentialComplete()
{
    ActivateCredentialResponse _resp;
    theTpm.DispatchIn(TPM_CC::ActivateCredential, &_resp);
    return _resp.certInfo;
}

MakeCredentialResponse Tpm2::AsyncMethods::MakeCredentialComplete()
{
    MakeCredentialResponse _resp;
    theTpm.DispatchIn(TPM_CC::MakeCredential, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::UnsealComplete()
{
    UnsealResponse _resp;
    theTpm.DispatchIn(TPM_CC::Unseal, &_resp);
    return _resp.outData;
}

TPM2B_PRIVATE Tpm2::AsyncMethods::ObjectChangeAuthComplete()
{
    ObjectChangeAuthResponse _resp;
    theTpm.DispatchIn(TPM_CC::ObjectChangeAuth, &_resp);
    return _resp.outPrivate;
}

CreateLoadedResponse Tpm2::AsyncMethods::CreateLoadedComplete()
{
    CreateLoadedResponse _resp;
    theTpm.DispatchIn(TPM_CC::CreateLoaded, &_resp);
    return _resp;
}

DuplicateResponse Tpm2::AsyncMethods::DuplicateComplete()
{
    DuplicateResponse _resp;
    theTpm.DispatchIn(TPM_CC::Duplicate, &_resp);
    return _resp;
}

RewrapResponse Tpm2::AsyncMethods::RewrapComplete()
{
    RewrapResponse _resp;
    theTpm.DispatchIn(TPM_CC::Rewrap, &_resp);
    return _resp;
}

TPM2B_PRIVATE Tpm2::AsyncMethods::ImportComplete()
{
    ImportResponse _resp;
    theTpm.DispatchIn(TPM_CC::Import, &_resp);
    return _resp.outPrivate;
}

ByteVec Tpm2::AsyncMethods::RSA_EncryptComplete()
{
    RSA_EncryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::RSA_Encrypt, &_resp);
    return _resp.outData;
}

ByteVec Tpm2::AsyncMethods::RSA_DecryptComplete()
{
    RSA_DecryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::RSA_Decrypt, &_resp);
    return _resp.message;
}

ECDH_KeyGenResponse Tpm2::AsyncMethods::ECDH_KeyGenComplete()
{
    ECDH_KeyGenResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECDH_KeyGen, &_resp);
    return _resp;
}

TPMS_ECC_POINT Tpm2::AsyncMethods::ECDH_ZGenComplete()
{
    ECDH_ZGenResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECDH_ZGen, &_resp);
    return _resp.outPoint;
}

TPMS_ALGORITHM_DETAIL_ECC Tpm2::AsyncMethods::ECC_ParametersComplete()
{
    ECC_ParametersResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECC_Parameters, &_resp);
    return _resp.parameters;
}

ZGen_2PhaseResponse Tpm2::AsyncMethods::ZGen_2PhaseComplete()
{
    ZGen_2PhaseResponse _resp;
    theTpm.DispatchIn(TPM_CC::ZGen_2Phase, &_resp);
    return _resp;
}

ECC_EncryptResponse Tpm2::AsyncMethods::ECC_EncryptComplete()
{
    ECC_EncryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECC_Encrypt, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::ECC_DecryptComplete()
{
    ECC_DecryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECC_Decrypt, &_resp);
    return _resp.plainText;
}

EncryptDecryptResponse Tpm2::AsyncMethods::EncryptDecryptComplete()
{
    EncryptDecryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::EncryptDecrypt, &_resp);
    return _resp;
}

EncryptDecrypt2Response Tpm2::AsyncMethods::EncryptDecrypt2Complete()
{
    EncryptDecrypt2Response _resp;
    theTpm.DispatchIn(TPM_CC::EncryptDecrypt2, &_resp);
    return _resp;
}

HashResponse Tpm2::AsyncMethods::HashComplete()
{
    HashResponse _resp;
    theTpm.DispatchIn(TPM_CC::Hash, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::HMACComplete()
{
    HMACResponse _resp;
    theTpm.DispatchIn(TPM_CC::HMAC, &_resp);
    return _resp.outHMAC;
}

ByteVec Tpm2::AsyncMethods::MACComplete()
{
    MACResponse _resp;
    theTpm.DispatchIn(TPM_CC::MAC, &_resp);
    return _resp.outMAC;
}

ByteVec Tpm2::AsyncMethods::GetRandomComplete()
{
    GetRandomResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetRandom, &_resp);
    return _resp.randomBytes;
}

void Tpm2::AsyncMethods::StirRandomComplete()
{
    theTpm.DispatchIn(TPM_CC::StirRandom, NULL);
}

TPM_HANDLE Tpm2::AsyncMethods::HMAC_StartComplete()
{
    HMAC_StartResponse _resp;
    theTpm.DispatchIn(TPM_CC::HMAC_Start, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::AsyncMethods::MAC_StartComplete()
{
    MAC_StartResponse _resp;
    theTpm.DispatchIn(TPM_CC::MAC_Start, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::AsyncMethods::HashSequenceStartComplete()
{
    HashSequenceStartResponse _resp;
    theTpm.DispatchIn(TPM_CC::HashSequenceStart, &_resp);
    return _resp.handle;
}

void Tpm2::AsyncMethods::SequenceUpdateComplete()
{
    theTpm.DispatchIn(TPM_CC::SequenceUpdate, NULL);
}

SequenceCompleteResponse Tpm2::AsyncMethods::SequenceCompleteComplete()
{
    SequenceCompleteResponse _resp;
    theTpm.DispatchIn(TPM_CC::SequenceComplete, &_resp);
    return _resp;
}

vector<TPMT_HA> Tpm2::AsyncMethods::EventSequenceCompleteComplete()
{
    EventSequenceCompleteResponse _resp;
    theTpm.DispatchIn(TPM_CC::EventSequenceComplete, &_resp);
    return _resp.results;
}

CertifyResponse Tpm2::AsyncMethods::CertifyComplete()
{
    CertifyResponse _resp;
    theTpm.DispatchIn(TPM_CC::Certify, &_resp);
    return _resp;
}

CertifyCreationResponse Tpm2::AsyncMethods::CertifyCreationComplete()
{
    CertifyCreationResponse _resp;
    theTpm.DispatchIn(TPM_CC::CertifyCreation, &_resp);
    return _resp;
}

QuoteResponse Tpm2::AsyncMethods::QuoteComplete()
{
    QuoteResponse _resp;
    theTpm.DispatchIn(TPM_CC::Quote, &_resp);
    return _resp;
}

GetSessionAuditDigestResponse Tpm2::AsyncMethods::GetSessionAuditDigestComplete()
{
    GetSessionAuditDigestResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetSessionAuditDigest, &_resp);
    return _resp;
}

GetCommandAuditDigestResponse Tpm2::AsyncMethods::GetCommandAuditDigestComplete()
{
    GetCommandAuditDigestResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetCommandAuditDigest, &_resp);
    return _resp;
}

GetTimeResponse Tpm2::AsyncMethods::GetTimeComplete()
{
    GetTimeResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetTime, &_resp);
    return _resp;
}

CertifyX509Response Tpm2::AsyncMethods::CertifyX509Complete()
{
    CertifyX509Response _resp;
    theTpm.DispatchIn(TPM_CC::CertifyX509, &_resp);
    return _resp;
}

CommitResponse Tpm2::AsyncMethods::CommitComplete()
{
    CommitResponse _resp;
    theTpm.DispatchIn(TPM_CC::Commit, &_resp);
    return _resp;
}

EC_EphemeralResponse Tpm2::AsyncMethods::EC_EphemeralComplete()
{
    EC_EphemeralResponse _resp;
    theTpm.DispatchIn(TPM_CC::EC_Ephemeral, &_resp);
    return _resp;
}

TPMT_TK_VERIFIED Tpm2::AsyncMethods::VerifySignatureComplete()
{
    VerifySignatureResponse _resp;
    theTpm.DispatchIn(TPM_CC::VerifySignature, &_resp);
    return _resp.validation;
}

std::shared_ptr<TPMU_SIGNATURE> Tpm2::AsyncMethods::SignComplete()
{
    SignResponse _resp;
    theTpm.DispatchIn(TPM_CC::Sign, &_resp);
    return _resp.signature;
}

void Tpm2::AsyncMethods::SetCommandCodeAuditStatusComplete()
{
    theTpm.DispatchIn(TPM_CC::SetCommandCodeAuditStatus, NULL);
}

void Tpm2::AsyncMethods::PCR_ExtendComplete()
{
    theTpm.DispatchIn(TPM_CC::PCR_Extend, NULL);
}

vector<TPMT_HA> Tpm2::AsyncMethods::PCR_EventComplete()
{
    PCR_EventResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Event, &_resp);
    return _resp.digests;
}

PCR_ReadResponse Tpm2::AsyncMethods::PCR_ReadComplete()
{
    PCR_ReadResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Read, &_resp);
    return _resp;
}

PCR_AllocateResponse Tpm2::AsyncMethods::PCR_AllocateComplete()
{
    PCR_AllocateResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Allocate, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::PCR_SetAuthPolicyComplete()
{
    theTpm.DispatchIn(TPM_CC::PCR_SetAuthPolicy, NULL);
}

void Tpm2::AsyncMethods::PCR_SetAuthValueComplete()
{
    theTpm.DispatchIn(TPM_CC::PCR_SetAuthValue, NULL);
}

void Tpm2::AsyncMethods::PCR_ResetComplete()
{
    theTpm.DispatchIn(TPM_CC::PCR_Reset, NULL);
}

PolicySignedResponse Tpm2::AsyncMethods::PolicySignedComplete()
{
    PolicySignedResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicySigned, &_resp);
    return _resp;
}

PolicySecretResponse Tpm2::AsyncMethods::PolicySecretComplete()
{
    PolicySecretResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicySecret, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::PolicyTicketComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyTicket, NULL);
}

void Tpm2::AsyncMethods::PolicyORComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyOR, NULL);
}

void Tpm2::AsyncMethods::PolicyPCRComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyPCR, NULL);
}

void Tpm2::AsyncMethods::PolicyLocalityComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyLocality, NULL);
}

void Tpm2::AsyncMethods::PolicyNVComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyNV, NULL);
}

void Tpm2::AsyncMethods::PolicyCounterTimerComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyCounterTimer, NULL);
}

void Tpm2::AsyncMethods::PolicyCommandCodeComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyCommandCode, NULL);
}

void Tpm2::AsyncMethods::PolicyPhysicalPresenceComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyPhysicalPresence, NULL);
}

void Tpm2::AsyncMethods::PolicyCpHashComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyCpHash, NULL);
}

void Tpm2::AsyncMethods::PolicyNameHashComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyNameHash, NULL);
}

void Tpm2::AsyncMethods::PolicyDuplicationSelectComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyDuplicationSelect, NULL);
}

void Tpm2::AsyncMethods::PolicyAuthorizeComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyAuthorize, NULL);
}

void Tpm2::AsyncMethods::PolicyAuthValueComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyAuthValue, NULL);
}

void Tpm2::AsyncMethods::PolicyPasswordComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyPassword, NULL);
}

ByteVec Tpm2::AsyncMethods::PolicyGetDigestComplete()
{
    PolicyGetDigestResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyGetDigest, &_resp);
    return _resp.policyDigest;
}

void Tpm2::AsyncMethods::PolicyNvWrittenComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyNvWritten, NULL);
}

void Tpm2::AsyncMethods::PolicyTemplateComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyTemplate, NULL);
}

void Tpm2::AsyncMethods::PolicyAuthorizeNVComplete()
{
    theTpm.DispatchIn(TPM_CC::PolicyAuthorizeNV, NULL);
}

CreatePrimaryResponse Tpm2::AsyncMethods::CreatePrimaryComplete()
{
    CreatePrimaryResponse _resp;
    theTpm.DispatchIn(TPM_CC::CreatePrimary, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::HierarchyControlComplete()
{
    theTpm.DispatchIn(TPM_CC::HierarchyControl, NULL);
}

void Tpm2::AsyncMethods::SetPrimaryPolicyComplete()
{
    theTpm.DispatchIn(TPM_CC::SetPrimaryPolicy, NULL);
}

void Tpm2::AsyncMethods::ChangePPSComplete()
{
    theTpm.DispatchIn(TPM_CC::ChangePPS, NULL);
}

void Tpm2::AsyncMethods::ChangeEPSComplete()
{
    theTpm.DispatchIn(TPM_CC::ChangeEPS, NULL);
}

void Tpm2::AsyncMethods::ClearComplete()
{
    theTpm.DispatchIn(TPM_CC::Clear, NULL);
}

void Tpm2::AsyncMethods::ClearControlComplete()
{
    theTpm.DispatchIn(TPM_CC::ClearControl, NULL);
}

void Tpm2::AsyncMethods::HierarchyChangeAuthComplete()
{
    theTpm.DispatchIn(TPM_CC::HierarchyChangeAuth, NULL);
}

void Tpm2::AsyncMethods::DictionaryAttackLockResetComplete()
{
    theTpm.DispatchIn(TPM_CC::DictionaryAttackLockReset, NULL);
}

void Tpm2::AsyncMethods::DictionaryAttackParametersComplete()
{
    theTpm.DispatchIn(TPM_CC::DictionaryAttackParameters, NULL);
}

void Tpm2::AsyncMethods::PP_CommandsComplete()
{
    theTpm.DispatchIn(TPM_CC::PP_Commands, NULL);
}

void Tpm2::AsyncMethods::SetAlgorithmSetComplete()
{
    theTpm.DispatchIn(TPM_CC::SetAlgorithmSet, NULL);
}

void Tpm2::AsyncMethods::FieldUpgradeStartComplete()
{
    theTpm.DispatchIn(TPM_CC::FieldUpgradeStart, NULL);
}

FieldUpgradeDataResponse Tpm2::AsyncMethods::FieldUpgradeDataComplete()
{
    FieldUpgradeDataResponse _resp;
    theTpm.DispatchIn(TPM_CC::FieldUpgradeData, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::FirmwareReadComplete()
{
    FirmwareReadResponse _resp;
    theTpm.DispatchIn(TPM_CC::FirmwareRead, &_resp);
    return _resp.fuData;
}

TPMS_CONTEXT Tpm2::AsyncMethods::ContextSaveComplete()
{
    ContextSaveResponse _resp;
    theTpm.DispatchIn(TPM_CC::ContextSave, &_resp);
    return _resp.context;
}

TPM_HANDLE Tpm2::AsyncMethods::ContextLoadComplete()
{
    ContextLoadResponse _resp;
    theTpm.DispatchIn(TPM_CC::ContextLoad, &_resp);
    return _resp.handle;
}

void Tpm2::AsyncMethods::FlushContextComplete()
{
    theTpm.DispatchIn(TPM_CC::FlushContext, NULL);
}

void Tpm2::AsyncMethods::EvictControlComplete()
{
    theTpm.DispatchIn(TPM_CC::EvictControl, NULL);
}

TPMS_TIME_INFO Tpm2::AsyncMethods::ReadClockComplete()
{
    ReadClockResponse _resp;
    theTpm.DispatchIn(TPM_CC::ReadClock, &_resp);
    return _resp.currentTime;
}

void Tpm2::AsyncMethods::ClockSetComplete()
{
    theTpm.DispatchIn(TPM_CC::ClockSet, NULL);
}

void Tpm2::AsyncMethods::ClockRateAdjustComplete()
{
    theTpm.DispatchIn(TPM_CC::ClockRateAdjust, NULL);
}

GetCapabilityResponse Tpm2::AsyncMethods::GetCapabilityComplete()
{
    GetCapabilityResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetCapability, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::TestParmsComplete()
{
    theTpm.DispatchIn(TPM_CC::TestParms, NULL);
}

void Tpm2::AsyncMethods::NV_DefineSpaceComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_DefineSpace, NULL);
}

void Tpm2::AsyncMethods::NV_UndefineSpaceComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_UndefineSpace, NULL);
}

void Tpm2::AsyncMethods::NV_UndefineSpaceSpecialComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_UndefineSpaceSpecial, NULL);
}

NV_ReadPublicResponse Tpm2::AsyncMethods::NV_ReadPublicComplete()
{
    NV_ReadPublicResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_ReadPublic, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::NV_WriteComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_Write, NULL);
}

void Tpm2::AsyncMethods::NV_IncrementComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_Increment, NULL);
}

void Tpm2::AsyncMethods::NV_ExtendComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_Extend, NULL);
}

void Tpm2::AsyncMethods::NV_SetBitsComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_SetBits, NULL);
}

void Tpm2::AsyncMethods::NV_WriteLockComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_WriteLock, NULL);
}

void Tpm2::AsyncMethods::NV_GlobalWriteLockComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_GlobalWriteLock, NULL);
}

ByteVec Tpm2::AsyncMethods::NV_ReadComplete()
{
    NV_ReadResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_Read, &_resp);
    return _resp.data;
}

void Tpm2::AsyncMethods::NV_ReadLockComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_ReadLock, NULL);
}

void Tpm2::AsyncMethods::NV_ChangeAuthComplete()
{
    theTpm.DispatchIn(TPM_CC::NV_ChangeAuth, NULL);
}

NV_CertifyResponse Tpm2::AsyncMethods::NV_CertifyComplete()
{
    NV_CertifyResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_Certify, &_resp);
    return _resp;
}

AC_GetCapabilityResponse Tpm2::AsyncMethods::AC_GetCapabilityComplete()
{
    AC_GetCapabilityResponse _resp;
    theTpm.DispatchIn(TPM_CC::AC_GetCapability, &_resp);
    return _resp;
}

TPMS_AC_OUTPUT Tpm2::AsyncMethods::AC_SendComplete()
{
    AC_SendResponse _resp;
    theTpm.DispatchIn(TPM_CC::AC_Send, &_resp);
    return _resp.acDataOut;
}

void Tpm2::AsyncMethods::Policy_AC_SendSelectComplete()
{
    theTpm.DispatchIn(TPM_CC::Policy_AC_SendSelect, NULL);
}

void Tpm2::AsyncMethods::ACT_SetTimeoutComplete()
{
    theTpm.DispatchIn(TPM_CC::ACT_SetTimeout, NULL);
}

ByteVec Tpm2::AsyncMethods::Vendor_TCG_TestComplete()
{
    Vendor_TCG_TestResponse _resp;
    theTpm.DispatchIn(TPM_CC::Vendor_TCG_Test, &_resp);
    return _resp.outputData;
}

TpmTypeId _TPM_HANDLE::GetTypeId() const
{
    return TpmTypeId::TPM_HANDLE_ID;
}

_TPM_HANDLE::_TPM_HANDLE(UINT32 _handle)
{
    handle = _handle;
}

/// <summary> Handle of a loaded TPM key or other object [TSS] </summary>
_TPM_HANDLE::~_TPM_HANDLE() {}

/// <summary> Handle of a loaded TPM key or other object [TSS] </summary>
TpmStructureBase* _TPM_HANDLE::Clone() const
{
    return new TPM_HANDLE(dynamic_cast<const TPM_HANDLE&>(*this));
}

void* _TPM_HANDLE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_UNION::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_UNION_ID;
}

/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TPMS_NULL_UNION::~TPMS_NULL_UNION() {}

/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TpmStructureBase* TPMS_NULL_UNION::Clone() const
{
    return new TPMS_NULL_UNION(*this);
}

void* TPMS_NULL_UNION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_EMPTY::GetTypeId() const
{
    return TpmTypeId::TPMS_EMPTY_ID;
}

/// <summary> This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected. </summary>
TPMS_EMPTY::~TPMS_EMPTY() {}

/// <summary> This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected. </summary>
TpmStructureBase* TPMS_EMPTY::Clone() const
{
    return new TPMS_EMPTY(*this);
}

void* TPMS_EMPTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_ALGORITHM_DESCRIPTION::GetTypeId() const
{
    return TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
}

TPMS_ALGORITHM_DESCRIPTION::TPMS_ALGORITHM_DESCRIPTION(
    TPM_ALG_ID _alg,
    TPMA_ALGORITHM _attributes
)
{
    alg = _alg;
    attributes = _attributes;
}

/// <summary> This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms. </summary>
TPMS_ALGORITHM_DESCRIPTION::~TPMS_ALGORITHM_DESCRIPTION() {}

/// <summary> This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms. </summary>
TpmStructureBase* TPMS_ALGORITHM_DESCRIPTION::Clone() const
{
    return new TPMS_ALGORITHM_DESCRIPTION(*this);
}

void* TPMS_ALGORITHM_DESCRIPTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &alg;
            case 1: return &attributes;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _TPMT_HA::GetTypeId() const
{
    return TpmTypeId::TPMT_HA_ID;
}

_TPMT_HA::_TPMT_HA(
    TPM_ALG_ID _hashAlg,
    const ByteVec& _digest
)
{
    hashAlg = _hashAlg;
    digest = _digest;
}

/// <summary> Table 80 shows the basic hash-agile structure used in this specification. To handle hash agility, this structure uses the hashAlg parameter to indicate the algorithm used to compute the digest and, by implication, the size of the digest. </summary>
_TPMT_HA::~_TPMT_HA() {}

/// <summary> Table 80 shows the basic hash-agile structure used in this specification. To handle hash agility, this structure uses the hashAlg parameter to indicate the algorithm used to compute the digest and, by implication, the size of the digest. </summary>
TpmStructureBase* _TPMT_HA::Clone() const
{
    return new TPMT_HA(dynamic_cast<const TPMT_HA&>(*this));
}

void* _TPMT_HA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DIGEST::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_ID;
}

TPM2B_DIGEST::TPM2B_DIGEST(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM. </summary>
TPM2B_DIGEST::~TPM2B_DIGEST() {}

/// <summary> This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM. </summary>
TpmStructureBase* TPM2B_DIGEST::Clone() const
{
    return new TPM2B_DIGEST(*this);
}

void* TPM2B_DIGEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_DATA_ID;
}

TPM2B_DATA::TPM2B_DATA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used for a data buffer that is required to be no larger than the size of the Name of an object. </summary>
TPM2B_DATA::~TPM2B_DATA() {}

/// <summary> This structure is used for a data buffer that is required to be no larger than the size of the Name of an object. </summary>
TpmStructureBase* TPM2B_DATA::Clone() const
{
    return new TPM2B_DATA(*this);
}

void* TPM2B_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_EVENT::GetTypeId() const
{
    return TpmTypeId::TPM2B_EVENT_ID;
}

TPM2B_EVENT::TPM2B_EVENT(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This type is a sized buffer that can hold event data. </summary>
TPM2B_EVENT::~TPM2B_EVENT() {}

/// <summary> This type is a sized buffer that can hold event data. </summary>
TpmStructureBase* TPM2B_EVENT::Clone() const
{
    return new TPM2B_EVENT(*this);
}

void* TPM2B_EVENT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_MAX_BUFFER::GetTypeId() const
{
    return TpmTypeId::TPM2B_MAX_BUFFER_ID;
}

TPM2B_MAX_BUFFER::TPM2B_MAX_BUFFER(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData(). </summary>
TPM2B_MAX_BUFFER::~TPM2B_MAX_BUFFER() {}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData(). </summary>
TpmStructureBase* TPM2B_MAX_BUFFER::Clone() const
{
    return new TPM2B_MAX_BUFFER(*this);
}

void* TPM2B_MAX_BUFFER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_MAX_NV_BUFFER::GetTypeId() const
{
    return TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
}

TPM2B_MAX_NV_BUFFER::TPM2B_MAX_NV_BUFFER(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify(). </summary>
TPM2B_MAX_NV_BUFFER::~TPM2B_MAX_NV_BUFFER() {}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify(). </summary>
TpmStructureBase* TPM2B_MAX_NV_BUFFER::Clone() const
{
    return new TPM2B_MAX_NV_BUFFER(*this);
}

void* TPM2B_MAX_NV_BUFFER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_TIMEOUT::GetTypeId() const
{
    return TpmTypeId::TPM2B_TIMEOUT_ID;
}

TPM2B_TIMEOUT::TPM2B_TIMEOUT(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less. </summary>
TPM2B_TIMEOUT::~TPM2B_TIMEOUT() {}

/// <summary> This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less. </summary>
TpmStructureBase* TPM2B_TIMEOUT::Clone() const
{
    return new TPM2B_TIMEOUT(*this);
}

void* TPM2B_TIMEOUT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_IV::GetTypeId() const
{
    return TpmTypeId::TPM2B_IV_ID;
}

TPM2B_IV::TPM2B_IV(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM. </summary>
TPM2B_IV::~TPM2B_IV() {}

/// <summary> This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM. </summary>
TpmStructureBase* TPM2B_IV::Clone() const
{
    return new TPM2B_IV(*this);
}

void* TPM2B_IV::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_NAME::GetTypeId() const
{
    return TpmTypeId::TPM2B_NAME_ID;
}

TPM2B_NAME::TPM2B_NAME(
    const ByteVec& _name
)
{
    name = _name;
}

/// <summary> This buffer holds a Name for any entity type. </summary>
TPM2B_NAME::~TPM2B_NAME() {}

/// <summary> This buffer holds a Name for any entity type. </summary>
TpmStructureBase* TPM2B_NAME::Clone() const
{
    return new TPM2B_NAME(*this);
}

void* TPM2B_NAME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_PCR_SELECT::GetTypeId() const
{
    return TpmTypeId::TPMS_PCR_SELECT_ID;
}

TPMS_PCR_SELECT::TPMS_PCR_SELECT(
    const ByteVec& _pcrSelect
)
{
    pcrSelect = _pcrSelect;
}

/// <summary> This structure provides a standard method of specifying a list of PCR. </summary>
TPMS_PCR_SELECT::~TPMS_PCR_SELECT() {}

/// <summary> This structure provides a standard method of specifying a list of PCR. </summary>
TpmStructureBase* TPMS_PCR_SELECT::Clone() const
{
    return new TPMS_PCR_SELECT(*this);
}

void* TPMS_PCR_SELECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sizeofSelect;
            case 1: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &pcrSelect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId _TPMS_PCR_SELECTION::GetTypeId() const
{
    return TpmTypeId::TPMS_PCR_SELECTION_ID;
}

_TPMS_PCR_SELECTION::_TPMS_PCR_SELECTION(
    TPM_ALG_ID _hash,
    const ByteVec& _pcrSelect
)
{
    hash = _hash;
    pcrSelect = _pcrSelect;
}

/// <summary> Table 94  Definition of TPMS_PCR_SELECTION Structure </summary>
_TPMS_PCR_SELECTION::~_TPMS_PCR_SELECTION() {}

/// <summary> Table 94  Definition of TPMS_PCR_SELECTION Structure </summary>
TpmStructureBase* _TPMS_PCR_SELECTION::Clone() const
{
    return new TPMS_PCR_SELECTION(dynamic_cast<const TPMS_PCR_SELECTION&>(*this));
}

void* _TPMS_PCR_SELECTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sizeofSelect;
            case 2: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &pcrSelect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMT_TK_CREATION::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_CREATION_ID;
}

TPMT_TK_CREATION::TPMT_TK_CREATION(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by </summary>
TPMT_TK_CREATION::~TPMT_TK_CREATION() {}

/// <summary> This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by </summary>
TpmStructureBase* TPMT_TK_CREATION::Clone() const
{
    return new TPMT_TK_CREATION(*this);
}

void* TPMT_TK_CREATION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMT_TK_VERIFIED::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_VERIFIED_ID;
}

TPMT_TK_VERIFIED::TPMT_TK_VERIFIED(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by </summary>
TPMT_TK_VERIFIED::~TPMT_TK_VERIFIED() {}

/// <summary> This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by </summary>
TpmStructureBase* TPMT_TK_VERIFIED::Clone() const
{
    return new TPMT_TK_VERIFIED(*this);
}

void* TPMT_TK_VERIFIED::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMT_TK_AUTH::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_AUTH_ID;
}

TPMT_TK_AUTH::TPMT_TK_AUTH(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by </summary>
TPMT_TK_AUTH::~TPMT_TK_AUTH() {}

/// <summary> This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by </summary>
TpmStructureBase* TPMT_TK_AUTH::Clone() const
{
    return new TPMT_TK_AUTH(*this);
}

void* TPMT_TK_AUTH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId _TPMT_TK_HASHCHECK::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_HASHCHECK_ID;
}

_TPMT_TK_HASHCHECK::_TPMT_TK_HASHCHECK(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by </summary>
_TPMT_TK_HASHCHECK::~_TPMT_TK_HASHCHECK() {}

/// <summary> This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by </summary>
TpmStructureBase* _TPMT_TK_HASHCHECK::Clone() const
{
    return new TPMT_TK_HASHCHECK(dynamic_cast<const TPMT_TK_HASHCHECK&>(*this));
}

void* _TPMT_TK_HASHCHECK::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ALG_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPMS_ALG_PROPERTY_ID;
}

TPMS_ALG_PROPERTY::TPMS_ALG_PROPERTY(
    TPM_ALG_ID _alg,
    TPMA_ALGORITHM _algProperties
)
{
    alg = _alg;
    algProperties = _algProperties;
}

/// <summary> This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG. </summary>
TPMS_ALG_PROPERTY::~TPMS_ALG_PROPERTY() {}

/// <summary> This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG. </summary>
TpmStructureBase* TPMS_ALG_PROPERTY::Clone() const
{
    return new TPMS_ALG_PROPERTY(*this);
}

void* TPMS_ALG_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &alg;
            case 1: return &algProperties;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TAGGED_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
}

TPMS_TAGGED_PROPERTY::TPMS_TAGGED_PROPERTY(
    TPM_PT _property,
    UINT32 _value
)
{
    property = _property;
    value = _value;
}

/// <summary> This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability(). </summary>
TPMS_TAGGED_PROPERTY::~TPMS_TAGGED_PROPERTY() {}

/// <summary> This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability(). </summary>
TpmStructureBase* TPMS_TAGGED_PROPERTY::Clone() const
{
    return new TPMS_TAGGED_PROPERTY(*this);
}

void* TPMS_TAGGED_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &property;
            case 1: return &value;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TAGGED_PCR_SELECT::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
}

TPMS_TAGGED_PCR_SELECT::TPMS_TAGGED_PCR_SELECT(
    TPM_PT_PCR _tag,
    const ByteVec& _pcrSelect
)
{
    tag = _tag;
    pcrSelect = _pcrSelect;
}

/// <summary> This structure is used in TPM2_GetCapability() to return the attributes of the PCR. </summary>
TPMS_TAGGED_PCR_SELECT::~TPMS_TAGGED_PCR_SELECT() {}

/// <summary> This structure is used in TPM2_GetCapability() to return the attributes of the PCR. </summary>
TpmStructureBase* TPMS_TAGGED_PCR_SELECT::Clone() const
{
    return new TPMS_TAGGED_PCR_SELECT(*this);
}

void* TPMS_TAGGED_PCR_SELECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: return &sizeofSelect;
            case 2: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &pcrSelect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_TAGGED_POLICY::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_POLICY_ID;
}

TPMS_TAGGED_POLICY::TPMS_TAGGED_POLICY(
    const TPM_HANDLE& _handle,
    const TPMT_HA& _policyHash
)
{
    handle = _handle;
    policyHash = _policyHash;
}

/// <summary> This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle. </summary>
TPMS_TAGGED_POLICY::~TPMS_TAGGED_POLICY() {}

/// <summary> This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle. </summary>
TpmStructureBase* TPMS_TAGGED_POLICY::Clone() const
{
    return new TPMS_TAGGED_POLICY(*this);
}

void* TPMS_TAGGED_POLICY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policyHash); return &policyHash;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ACT_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_ACT_DATA_ID;
}

TPMS_ACT_DATA::TPMS_ACT_DATA(
    const TPM_HANDLE& _handle,
    UINT32 _timeout,
    TPMA_ACT _attributes
)
{
    handle = _handle;
    timeout = _timeout;
    attributes = _attributes;
}

/// <summary> This structure is used in TPM2_GetCapability() to return the ACT data. </summary>
TPMS_ACT_DATA::~TPMS_ACT_DATA() {}

/// <summary> This structure is used in TPM2_GetCapability() to return the ACT data. </summary>
TpmStructureBase* TPMS_ACT_DATA::Clone() const
{
    return new TPMS_ACT_DATA(*this);
}

void* TPMS_ACT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &timeout;
            case 2: return &attributes;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPML_CC::GetTypeId() const
{
    return TpmTypeId::TPML_CC_ID;
}

TPML_CC::TPML_CC(
    const vector<TPM_CC>& _commandCodes
)
{
    commandCodes = _commandCodes;
}

/// <summary> A list of command codes may be input to the TPM or returned by the TPM depending on the command. </summary>
TPML_CC::~TPML_CC() {}

/// <summary> A list of command codes may be input to the TPM or returned by the TPM depending on the command. </summary>
TpmStructureBase* TPML_CC::Clone() const
{
    return new TPML_CC(*this);
}

void* TPML_CC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) commandCodes.resize(newArraySize); arraySize = (int)commandCodes.size(); return &commandCodes; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &commandCodes[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_CCA::GetTypeId() const
{
    return TpmTypeId::TPML_CCA_ID;
}

TPML_CCA::TPML_CCA(
    const vector<TPMA_CC>& _commandAttributes
)
{
    commandAttributes = _commandAttributes;
}

/// <summary> This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS). </summary>
TPML_CCA::~TPML_CCA() {}

/// <summary> This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS). </summary>
TpmStructureBase* TPML_CCA::Clone() const
{
    return new TPML_CCA(*this);
}

void* TPML_CCA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) commandAttributes.resize(newArraySize); arraySize = (int)commandAttributes.size(); return &commandAttributes; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &commandAttributes[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ALG::GetTypeId() const
{
    return TpmTypeId::TPML_ALG_ID;
}

TPML_ALG::TPML_ALG(
    const vector<TPM_ALG_ID>& _algorithms
)
{
    algorithms = _algorithms;
}

/// <summary> This list is returned by TPM2_IncrementalSelfTest(). </summary>
TPML_ALG::~TPML_ALG() {}

/// <summary> This list is returned by TPM2_IncrementalSelfTest(). </summary>
TpmStructureBase* TPML_ALG::Clone() const
{
    return new TPML_ALG(*this);
}

void* TPML_ALG::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) algorithms.resize(newArraySize); arraySize = (int)algorithms.size(); return &algorithms; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &algorithms[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_HANDLE::GetTypeId() const
{
    return TpmTypeId::TPML_HANDLE_ID;
}

TPML_HANDLE::TPML_HANDLE(
    const vector<TPM_HANDLE>& _handle
)
{
    handle = _handle;
}

/// <summary> This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE. </summary>
TPML_HANDLE::~TPML_HANDLE() {}

/// <summary> This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE. </summary>
TpmStructureBase* TPML_HANDLE::Clone() const
{
    return new TPML_HANDLE(*this);
}

void* TPML_HANDLE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) handle.resize(newArraySize); arraySize = (int)handle.size(); return &handle; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&handle[arrayIndex]); return &handle[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_DIGEST::GetTypeId() const
{
    return TpmTypeId::TPML_DIGEST_ID;
}

TPML_DIGEST::TPML_DIGEST(
    const vector<TPM2B_DIGEST>& _digests
)
{
    digests = _digests;
}

/// <summary> This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read(). </summary>
TPML_DIGEST::~TPML_DIGEST() {}

/// <summary> This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read(). </summary>
TpmStructureBase* TPML_DIGEST::Clone() const
{
    return new TPML_DIGEST(*this);
}

void* TPML_DIGEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_DIGEST_VALUES::GetTypeId() const
{
    return TpmTypeId::TPML_DIGEST_VALUES_ID;
}

TPML_DIGEST_VALUES::TPML_DIGEST_VALUES(
    const vector<TPMT_HA>& _digests
)
{
    digests = _digests;
}

/// <summary> This list is used to convey a list of digest values. This type is returned by TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend(). </summary>
TPML_DIGEST_VALUES::~TPML_DIGEST_VALUES() {}

/// <summary> This list is used to convey a list of digest values. This type is returned by TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend(). </summary>
TpmStructureBase* TPML_DIGEST_VALUES::Clone() const
{
    return new TPML_DIGEST_VALUES(*this);
}

void* TPML_DIGEST_VALUES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_PCR_SELECTION::GetTypeId() const
{
    return TpmTypeId::TPML_PCR_SELECTION_ID;
}

TPML_PCR_SELECTION::TPML_PCR_SELECTION(
    const vector<TPMS_PCR_SELECTION>& _pcrSelections
)
{
    pcrSelections = _pcrSelections;
}

/// <summary> This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected. </summary>
TPML_PCR_SELECTION::~TPML_PCR_SELECTION() {}

/// <summary> This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected. </summary>
TpmStructureBase* TPML_PCR_SELECTION::Clone() const
{
    return new TPML_PCR_SELECTION(*this);
}

void* TPML_PCR_SELECTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) pcrSelections.resize(newArraySize); arraySize = (int)pcrSelections.size(); return &pcrSelections; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelections[arrayIndex]); return &pcrSelections[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ALG_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_ALG_PROPERTY_ID;
}

TPML_ALG_PROPERTY::TPML_ALG_PROPERTY(
    const vector<TPMS_ALG_PROPERTY>& _algProperties
)
{
    algProperties = _algProperties;
}

/// <summary> This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability(). </summary>
TPML_ALG_PROPERTY::~TPML_ALG_PROPERTY() {}

/// <summary> This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_ALG_PROPERTY::Clone() const
{
    return new TPML_ALG_PROPERTY(*this);
}

void* TPML_ALG_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) algProperties.resize(newArraySize); arraySize = (int)algProperties.size(); return &algProperties; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&algProperties[arrayIndex]); return &algProperties[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_TAGGED_TPM_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
}

TPML_TAGGED_TPM_PROPERTY::TPML_TAGGED_TPM_PROPERTY(
    const vector<TPMS_TAGGED_PROPERTY>& _tpmProperty
)
{
    tpmProperty = _tpmProperty;
}

/// <summary> This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability(). </summary>
TPML_TAGGED_TPM_PROPERTY::~TPML_TAGGED_TPM_PROPERTY() {}

/// <summary> This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_TAGGED_TPM_PROPERTY::Clone() const
{
    return new TPML_TAGGED_TPM_PROPERTY(*this);
}

void* TPML_TAGGED_TPM_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) tpmProperty.resize(newArraySize); arraySize = (int)tpmProperty.size(); return &tpmProperty; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&tpmProperty[arrayIndex]); return &tpmProperty[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_TAGGED_PCR_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
}

TPML_TAGGED_PCR_PROPERTY::TPML_TAGGED_PCR_PROPERTY(
    const vector<TPMS_TAGGED_PCR_SELECT>& _pcrProperty
)
{
    pcrProperty = _pcrProperty;
}

/// <summary> This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability(). </summary>
TPML_TAGGED_PCR_PROPERTY::~TPML_TAGGED_PCR_PROPERTY() {}

/// <summary> This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_TAGGED_PCR_PROPERTY::Clone() const
{
    return new TPML_TAGGED_PCR_PROPERTY(*this);
}

void* TPML_TAGGED_PCR_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) pcrProperty.resize(newArraySize); arraySize = (int)pcrProperty.size(); return &pcrProperty; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrProperty[arrayIndex]); return &pcrProperty[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ECC_CURVE::GetTypeId() const
{
    return TpmTypeId::TPML_ECC_CURVE_ID;
}

TPML_ECC_CURVE::TPML_ECC_CURVE(
    const vector<TPM_ECC_CURVE>& _eccCurves
)
{
    eccCurves = _eccCurves;
}

/// <summary> This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability(). </summary>
TPML_ECC_CURVE::~TPML_ECC_CURVE() {}

/// <summary> This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_ECC_CURVE::Clone() const
{
    return new TPML_ECC_CURVE(*this);
}

void* TPML_ECC_CURVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) eccCurves.resize(newArraySize); arraySize = (int)eccCurves.size(); return &eccCurves; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &eccCurves[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_TAGGED_POLICY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_POLICY_ID;
}

TPML_TAGGED_POLICY::TPML_TAGGED_POLICY(
    const vector<TPMS_TAGGED_POLICY>& _policies
)
{
    policies = _policies;
}

/// <summary> This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list. </summary>
TPML_TAGGED_POLICY::~TPML_TAGGED_POLICY() {}

/// <summary> This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list. </summary>
TpmStructureBase* TPML_TAGGED_POLICY::Clone() const
{
    return new TPML_TAGGED_POLICY(*this);
}

void* TPML_TAGGED_POLICY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) policies.resize(newArraySize); arraySize = (int)policies.size(); return &policies; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policies[arrayIndex]); return &policies[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ACT_DATA::GetTypeId() const
{
    return TpmTypeId::TPML_ACT_DATA_ID;
}

TPML_ACT_DATA::TPML_ACT_DATA(
    const vector<TPMS_ACT_DATA>& _actData
)
{
    actData = _actData;
}

/// <summary> This list is used to report the timeout and state for the ACT. This list may be generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list </summary>
TPML_ACT_DATA::~TPML_ACT_DATA() {}

/// <summary> This list is used to report the timeout and state for the ACT. This list may be generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list </summary>
TpmStructureBase* TPML_ACT_DATA::Clone() const
{
    return new TPML_ACT_DATA(*this);
}

void* TPML_ACT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) actData.resize(newArraySize); arraySize = (int)actData.size(); return &actData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&actData[arrayIndex]); return &actData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_CAPABILITY_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CAPABILITY_DATA_ID;
}

TPMS_CAPABILITY_DATA::TPMS_CAPABILITY_DATA(
    const TPMU_CAPABILITIES& _data
)
{
    data.reset(dynamic_cast<TPMU_CAPABILITIES*>(_data.Clone()));
}

/// <summary> This data area is returned in response to a TPM2_GetCapability(). </summary>
TPMS_CAPABILITY_DATA::~TPMS_CAPABILITY_DATA() {}

/// <summary> This data area is returned in response to a TPM2_GetCapability(). </summary>
TpmStructureBase* TPMS_CAPABILITY_DATA::Clone() const
{
    return new TPMS_CAPABILITY_DATA(*this);
}

void* TPMS_CAPABILITY_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &capability;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*data); return &data;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CLOCK_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CLOCK_INFO_ID;
}

TPMS_CLOCK_INFO::TPMS_CLOCK_INFO(
    UINT64 _clock,
    UINT32 _resetCount,
    UINT32 _restartCount,
    BYTE _safe
)
{
    clock = _clock;
    resetCount = _resetCount;
    restartCount = _restartCount;
    safe = _safe;
}

/// <summary> This structure is used in each of the attestation commands. </summary>
TPMS_CLOCK_INFO::~TPMS_CLOCK_INFO() {}

/// <summary> This structure is used in each of the attestation commands. </summary>
TpmStructureBase* TPMS_CLOCK_INFO::Clone() const
{
    return new TPMS_CLOCK_INFO(*this);
}

void* TPMS_CLOCK_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &clock;
            case 1: return &resetCount;
            case 2: return &restartCount;
            case 3: return &safe;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TIME_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_TIME_INFO_ID;
}

TPMS_TIME_INFO::TPMS_TIME_INFO(
    UINT64 _time,
    const TPMS_CLOCK_INFO& _clockInfo
)
{
    time = _time;
    clockInfo = _clockInfo;
}

/// <summary> This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock(). </summary>
TPMS_TIME_INFO::~TPMS_TIME_INFO() {}

/// <summary> This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock(). </summary>
TpmStructureBase* TPMS_TIME_INFO::Clone() const
{
    return new TPMS_TIME_INFO(*this);
}

void* TPMS_TIME_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &time;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&clockInfo); return &clockInfo;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TIME_ATTEST_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
}

TPMS_TIME_ATTEST_INFO::TPMS_TIME_ATTEST_INFO(
    const TPMS_TIME_INFO& _time,
    UINT64 _firmwareVersion
)
{
    time = _time;
    firmwareVersion = _firmwareVersion;
}

/// <summary> This structure is used when the TPM performs TPM2_GetTime. </summary>
TPMS_TIME_ATTEST_INFO::~TPMS_TIME_ATTEST_INFO() {}

/// <summary> This structure is used when the TPM performs TPM2_GetTime. </summary>
TpmStructureBase* TPMS_TIME_ATTEST_INFO::Clone() const
{
    return new TPMS_TIME_ATTEST_INFO(*this);
}

void* TPMS_TIME_ATTEST_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&time); return &time;
            case 1: return &firmwareVersion;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CERTIFY_INFO_ID;
}

TPMS_CERTIFY_INFO::TPMS_CERTIFY_INFO(
    const ByteVec& _name,
    const ByteVec& _qualifiedName
)
{
    name = _name;
    qualifiedName = _qualifiedName;
}

/// <summary> This is the attested data for TPM2_Certify(). </summary>
TPMS_CERTIFY_INFO::~TPMS_CERTIFY_INFO() {}

/// <summary> This is the attested data for TPM2_Certify(). </summary>
TpmStructureBase* TPMS_CERTIFY_INFO::Clone() const
{
    return new TPMS_CERTIFY_INFO(*this);
}

void* TPMS_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nameSize;
            case 1: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            case 2: return &qualifiedNameSize;
            case 3: { if (newArraySize != -1) qualifiedName.resize(newArraySize); arraySize = (int)qualifiedName.size(); return &qualifiedName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &name[arrayIndex];
            case 3: return &qualifiedName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_QUOTE_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_QUOTE_INFO_ID;
}

TPMS_QUOTE_INFO::TPMS_QUOTE_INFO(
    const vector<TPMS_PCR_SELECTION>& _pcrSelect,
    const ByteVec& _pcrDigest
)
{
    pcrSelect = _pcrSelect;
    pcrDigest = _pcrDigest;
}

/// <summary> This is the attested data for TPM2_Quote(). </summary>
TPMS_QUOTE_INFO::~TPMS_QUOTE_INFO() {}

/// <summary> This is the attested data for TPM2_Quote(). </summary>
TpmStructureBase* TPMS_QUOTE_INFO::Clone() const
{
    return new TPMS_QUOTE_INFO(*this);
}

void* TPMS_QUOTE_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrSelectCount;
            case 1: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            case 2: return &pcrDigestSize;
            case 3: { if (newArraySize != -1) pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return &pcrDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelect[arrayIndex]); return &pcrSelect[arrayIndex];
            case 3: return &pcrDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_COMMAND_AUDIT_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
}

TPMS_COMMAND_AUDIT_INFO::TPMS_COMMAND_AUDIT_INFO(
    UINT64 _auditCounter,
    TPM_ALG_ID _digestAlg,
    const ByteVec& _auditDigest,
    const ByteVec& _commandDigest
)
{
    auditCounter = _auditCounter;
    digestAlg = _digestAlg;
    auditDigest = _auditDigest;
    commandDigest = _commandDigest;
}

/// <summary> This is the attested data for TPM2_GetCommandAuditDigest(). </summary>
TPMS_COMMAND_AUDIT_INFO::~TPMS_COMMAND_AUDIT_INFO() {}

/// <summary> This is the attested data for TPM2_GetCommandAuditDigest(). </summary>
TpmStructureBase* TPMS_COMMAND_AUDIT_INFO::Clone() const
{
    return new TPMS_COMMAND_AUDIT_INFO(*this);
}

void* TPMS_COMMAND_AUDIT_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &auditCounter;
            case 1: return &digestAlg;
            case 2: return &auditDigestSize;
            case 3: { if (newArraySize != -1) auditDigest.resize(newArraySize); arraySize = (int)auditDigest.size(); return &auditDigest; }
            case 4: return &commandDigestSize;
            case 5: { if (newArraySize != -1) commandDigest.resize(newArraySize); arraySize = (int)commandDigest.size(); return &commandDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &auditDigest[arrayIndex];
            case 5: return &commandDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SESSION_AUDIT_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
}

TPMS_SESSION_AUDIT_INFO::TPMS_SESSION_AUDIT_INFO(
    BYTE _exclusiveSession,
    const ByteVec& _sessionDigest
)
{
    exclusiveSession = _exclusiveSession;
    sessionDigest = _sessionDigest;
}

/// <summary> This is the attested data for TPM2_GetSessionAuditDigest(). </summary>
TPMS_SESSION_AUDIT_INFO::~TPMS_SESSION_AUDIT_INFO() {}

/// <summary> This is the attested data for TPM2_GetSessionAuditDigest(). </summary>
TpmStructureBase* TPMS_SESSION_AUDIT_INFO::Clone() const
{
    return new TPMS_SESSION_AUDIT_INFO(*this);
}

void* TPMS_SESSION_AUDIT_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &exclusiveSession;
            case 1: return &sessionDigestSize;
            case 2: { if (newArraySize != -1) sessionDigest.resize(newArraySize); arraySize = (int)sessionDigest.size(); return &sessionDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sessionDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_CREATION_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CREATION_INFO_ID;
}

TPMS_CREATION_INFO::TPMS_CREATION_INFO(
    const ByteVec& _objectName,
    const ByteVec& _creationHash
)
{
    objectName = _objectName;
    creationHash = _creationHash;
}

/// <summary> This is the attested data for TPM2_CertifyCreation(). </summary>
TPMS_CREATION_INFO::~TPMS_CREATION_INFO() {}

/// <summary> This is the attested data for TPM2_CertifyCreation(). </summary>
TpmStructureBase* TPMS_CREATION_INFO::Clone() const
{
    return new TPMS_CREATION_INFO(*this);
}

void* TPMS_CREATION_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &objectNameSize;
            case 1: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            case 2: return &creationHashSize;
            case 3: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &objectName[arrayIndex];
            case 3: return &creationHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NV_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
}

TPMS_NV_CERTIFY_INFO::TPMS_NV_CERTIFY_INFO(
    const ByteVec& _indexName,
    UINT16 _offset,
    const ByteVec& _nvContents
)
{
    indexName = _indexName;
    offset = _offset;
    nvContents = _nvContents;
}

/// <summary> This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify(). </summary>
TPMS_NV_CERTIFY_INFO::~TPMS_NV_CERTIFY_INFO() {}

/// <summary> This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify(). </summary>
TpmStructureBase* TPMS_NV_CERTIFY_INFO::Clone() const
{
    return new TPMS_NV_CERTIFY_INFO(*this);
}

void* TPMS_NV_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &indexNameSize;
            case 1: { if (newArraySize != -1) indexName.resize(newArraySize); arraySize = (int)indexName.size(); return &indexName; }
            case 2: return &offset;
            case 3: return &nvContentsSize;
            case 4: { if (newArraySize != -1) nvContents.resize(newArraySize); arraySize = (int)nvContents.size(); return &nvContents; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &indexName[arrayIndex];
            case 4: return &nvContents[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NV_DIGEST_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
}

TPMS_NV_DIGEST_CERTIFY_INFO::TPMS_NV_DIGEST_CERTIFY_INFO(
    const ByteVec& _indexName,
    const ByteVec& _nvDigest
)
{
    indexName = _indexName;
    nvDigest = _nvDigest;
}

/// <summary> This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme. </summary>
TPMS_NV_DIGEST_CERTIFY_INFO::~TPMS_NV_DIGEST_CERTIFY_INFO() {}

/// <summary> This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme. </summary>
TpmStructureBase* TPMS_NV_DIGEST_CERTIFY_INFO::Clone() const
{
    return new TPMS_NV_DIGEST_CERTIFY_INFO(*this);
}

void* TPMS_NV_DIGEST_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &indexNameSize;
            case 1: { if (newArraySize != -1) indexName.resize(newArraySize); arraySize = (int)indexName.size(); return &indexName; }
            case 2: return &nvDigestSize;
            case 3: { if (newArraySize != -1) nvDigest.resize(newArraySize); arraySize = (int)nvDigest.size(); return &nvDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &indexName[arrayIndex];
            case 3: return &nvDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ATTEST::GetTypeId() const
{
    return TpmTypeId::TPMS_ATTEST_ID;
}

TPMS_ATTEST::TPMS_ATTEST(
    TPM_GENERATED _magic,
    const ByteVec& _qualifiedSigner,
    const ByteVec& _extraData,
    const TPMS_CLOCK_INFO& _clockInfo,
    UINT64 _firmwareVersion,
    const TPMU_ATTEST& _attested
)
{
    magic = _magic;
    qualifiedSigner = _qualifiedSigner;
    extraData = _extraData;
    clockInfo = _clockInfo;
    firmwareVersion = _firmwareVersion;
    attested.reset(dynamic_cast<TPMU_ATTEST*>(_attested.Clone()));
}

/// <summary> This structure is used on each TPM-generated signed structure. The signature is over this structure. </summary>
TPMS_ATTEST::~TPMS_ATTEST() {}

/// <summary> This structure is used on each TPM-generated signed structure. The signature is over this structure. </summary>
TpmStructureBase* TPMS_ATTEST::Clone() const
{
    return new TPMS_ATTEST(*this);
}

void* TPMS_ATTEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &magic;
            case 1: return &type;
            case 2: return &qualifiedSignerSize;
            case 3: { if (newArraySize != -1) qualifiedSigner.resize(newArraySize); arraySize = (int)qualifiedSigner.size(); return &qualifiedSigner; }
            case 4: return &extraDataSize;
            case 5: { if (newArraySize != -1) extraData.resize(newArraySize); arraySize = (int)extraData.size(); return &extraData; }
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&clockInfo); return &clockInfo;
            case 7: return &firmwareVersion;
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&*attested); return &attested;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifiedSigner[arrayIndex];
            case 5: return &extraData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ATTEST::GetTypeId() const
{
    return TpmTypeId::TPM2B_ATTEST_ID;
}

TPM2B_ATTEST::TPM2B_ATTEST(
    const TPMS_ATTEST& _attestationData
)
{
    attestationData = _attestationData;
}

/// <summary> This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed. </summary>
TPM2B_ATTEST::~TPM2B_ATTEST() {}

/// <summary> This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed. </summary>
TpmStructureBase* TPM2B_ATTEST::Clone() const
{
    return new TPM2B_ATTEST(*this);
}

void* TPM2B_ATTEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&attestationData); return &attestationData;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_AUTH_COMMAND::GetTypeId() const
{
    return TpmTypeId::TPMS_AUTH_COMMAND_ID;
}

TPMS_AUTH_COMMAND::TPMS_AUTH_COMMAND(
    const TPM_HANDLE& _sessionHandle,
    const ByteVec& _nonce,
    TPMA_SESSION _sessionAttributes,
    const ByteVec& _hmac
)
{
    sessionHandle = _sessionHandle;
    nonce = _nonce;
    sessionAttributes = _sessionAttributes;
    hmac = _hmac;
}

/// <summary> This is the format used for each of the authorizations in the session area of a command. </summary>
TPMS_AUTH_COMMAND::~TPMS_AUTH_COMMAND() {}

/// <summary> This is the format used for each of the authorizations in the session area of a command. </summary>
TpmStructureBase* TPMS_AUTH_COMMAND::Clone() const
{
    return new TPMS_AUTH_COMMAND(*this);
}

void* TPMS_AUTH_COMMAND::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return &sessionHandle;
            case 1: return &nonceSize;
            case 2: { if (newArraySize != -1) nonce.resize(newArraySize); arraySize = (int)nonce.size(); return &nonce; }
            case 3: return &sessionAttributes;
            case 4: return &hmacSize;
            case 5: { if (newArraySize != -1) hmac.resize(newArraySize); arraySize = (int)hmac.size(); return &hmac; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nonce[arrayIndex];
            case 5: return &hmac[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId AUTHResponse::GetTypeId() const
{
    return TpmTypeId::AUTHResponse_ID;
}

AUTHResponse::AUTHResponse(
    const ByteVec& _nonce,
    TPMA_SESSION _sessionAttributes,
    const ByteVec& _hmac
)
{
    nonce = _nonce;
    sessionAttributes = _sessionAttributes;
    hmac = _hmac;
}

/// <summary> This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order. </summary>
AUTHResponse::~AUTHResponse() {}

/// <summary> This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order. </summary>
TpmStructureBase* AUTHResponse::Clone() const
{
    return new AUTHResponse(*this);
}

void* AUTHResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nonceSize;
            case 1: { if (newArraySize != -1) nonce.resize(newArraySize); arraySize = (int)nonce.size(); return &nonce; }
            case 2: return &sessionAttributes;
            case 3: return &hmacSize;
            case 4: { if (newArraySize != -1) hmac.resize(newArraySize); arraySize = (int)hmac.size(); return &hmac; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &nonce[arrayIndex];
            case 4: return &hmac[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SYM_KEY_BITS::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TPMS_NULL_SYM_KEY_BITS::~TPMS_NULL_SYM_KEY_BITS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_KEY_BITS::Clone() const
{
    return new TPMS_NULL_SYM_KEY_BITS(*this);
}

void* TPMS_NULL_SYM_KEY_BITS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_XOR_SYM_MODE::GetTypeId() const
{
    return TpmTypeId::TPMS_XOR_SYM_MODE_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TPMS_XOR_SYM_MODE::~TPMS_XOR_SYM_MODE() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TpmStructureBase* TPMS_XOR_SYM_MODE::Clone() const
{
    return new TPMS_XOR_SYM_MODE(*this);
}

void* TPMS_XOR_SYM_MODE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_NULL_SYM_MODE::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_MODE_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TPMS_NULL_SYM_MODE::~TPMS_NULL_SYM_MODE() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_MODE::Clone() const
{
    return new TPMS_NULL_SYM_MODE(*this);
}

void* TPMS_NULL_SYM_MODE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_TDES_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_TDES_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TPMS_TDES_SYM_DETAILS::~TPMS_TDES_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_TDES_SYM_DETAILS::Clone() const
{
    return new TPMS_TDES_SYM_DETAILS(*this);
}

void* TPMS_TDES_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_AES_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_AES_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TPMS_AES_SYM_DETAILS::~TPMS_AES_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_AES_SYM_DETAILS::Clone() const
{
    return new TPMS_AES_SYM_DETAILS(*this);
}

void* TPMS_AES_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_SM4_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_SM4_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TPMS_SM4_SYM_DETAILS::~TPMS_SM4_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_SM4_SYM_DETAILS::Clone() const
{
    return new TPMS_SM4_SYM_DETAILS(*this);
}

void* TPMS_SM4_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_CAMELLIA_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TPMS_CAMELLIA_SYM_DETAILS::~TPMS_CAMELLIA_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_CAMELLIA_SYM_DETAILS::Clone() const
{
    return new TPMS_CAMELLIA_SYM_DETAILS(*this);
}

void* TPMS_CAMELLIA_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_ANY_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_ANY_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TPMS_ANY_SYM_DETAILS::~TPMS_ANY_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_ANY_SYM_DETAILS::Clone() const
{
    return new TPMS_ANY_SYM_DETAILS(*this);
}

void* TPMS_ANY_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_XOR_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_XOR_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TPMS_XOR_SYM_DETAILS::~TPMS_XOR_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_XOR_SYM_DETAILS::Clone() const
{
    return new TPMS_XOR_SYM_DETAILS(*this);
}

void* TPMS_XOR_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_NULL_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TPMS_NULL_SYM_DETAILS::~TPMS_NULL_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_DETAILS::Clone() const
{
    return new TPMS_NULL_SYM_DETAILS(*this);
}

void* TPMS_NULL_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId _TPMT_SYM_DEF::GetTypeId() const
{
    return TpmTypeId::TPMT_SYM_DEF_ID;
}

_TPMT_SYM_DEF::_TPMT_SYM_DEF(
    TPM_ALG_ID _algorithm,
    UINT16 _keyBits,
    TPM_ALG_ID _mode
)
{
    algorithm = _algorithm;
    keyBits = _keyBits;
    mode = _mode;
}

/// <summary> The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected. </summary>
_TPMT_SYM_DEF::~_TPMT_SYM_DEF() {}

/// <summary> The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected. </summary>
TpmStructureBase* _TPMT_SYM_DEF::Clone() const
{
    return new TPMT_SYM_DEF(dynamic_cast<const TPMT_SYM_DEF&>(*this));
}

void* _TPMT_SYM_DEF::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &algorithm;
            case 1: return &keyBits;
            case 2: return &mode;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _TPMT_SYM_DEF_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
}

_TPMT_SYM_DEF_OBJECT::_TPMT_SYM_DEF_OBJECT(
    TPM_ALG_ID _algorithm,
    UINT16 _keyBits,
    TPM_ALG_ID _mode
)
{
    algorithm = _algorithm;
    keyBits = _keyBits;
    mode = _mode;
}

/// <summary> This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field. </summary>
_TPMT_SYM_DEF_OBJECT::~_TPMT_SYM_DEF_OBJECT() {}

/// <summary> This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field. </summary>
TpmStructureBase* _TPMT_SYM_DEF_OBJECT::Clone() const
{
    return new TPMT_SYM_DEF_OBJECT(dynamic_cast<const TPMT_SYM_DEF_OBJECT&>(*this));
}

void* _TPMT_SYM_DEF_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &algorithm;
            case 1: return &keyBits;
            case 2: return &mode;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_SYM_KEY::GetTypeId() const
{
    return TpmTypeId::TPM2B_SYM_KEY_ID;
}

TPM2B_SYM_KEY::TPM2B_SYM_KEY(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used to hold a symmetric key in the sensitive area of an asymmetric object. </summary>
TPM2B_SYM_KEY::~TPM2B_SYM_KEY() {}

/// <summary> This structure is used to hold a symmetric key in the sensitive area of an asymmetric object. </summary>
TpmStructureBase* TPM2B_SYM_KEY::Clone() const
{
    return new TPM2B_SYM_KEY(*this);
}

void* TPM2B_SYM_KEY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SYMCIPHER_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
}

TPMS_SYMCIPHER_PARMS::TPMS_SYMCIPHER_PARMS(const TPMT_SYM_DEF_OBJECT& _sym)
{
    sym = _sym;
}

/// <summary> This structure contains the parameters for a symmetric block cipher object. </summary>
TPMS_SYMCIPHER_PARMS::~TPMS_SYMCIPHER_PARMS() {}

/// <summary> This structure contains the parameters for a symmetric block cipher object. </summary>
TpmStructureBase* TPMS_SYMCIPHER_PARMS::Clone() const
{
    return new TPMS_SYMCIPHER_PARMS(*this);
}

void* TPMS_SYMCIPHER_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sym); return &sym;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_LABEL::GetTypeId() const
{
    return TpmTypeId::TPM2B_LABEL_ID;
}

TPM2B_LABEL::TPM2B_LABEL(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes. </summary>
TPM2B_LABEL::~TPM2B_LABEL() {}

/// <summary> This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes. </summary>
TpmStructureBase* TPM2B_LABEL::Clone() const
{
    return new TPM2B_LABEL(*this);
}

void* TPM2B_LABEL::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_DERIVE::GetTypeId() const
{
    return TpmTypeId::TPMS_DERIVE_ID;
}

TPMS_DERIVE::TPMS_DERIVE(
    const ByteVec& _label,
    const ByteVec& _context
)
{
    label = _label;
    context = _context;
}

/// <summary> This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter. </summary>
TPMS_DERIVE::~TPMS_DERIVE() {}

/// <summary> This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter. </summary>
TpmStructureBase* TPMS_DERIVE::Clone() const
{
    return new TPMS_DERIVE(*this);
}

void* TPMS_DERIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &labelSize;
            case 1: { if (newArraySize != -1) label.resize(newArraySize); arraySize = (int)label.size(); return &label; }
            case 2: return &contextSize;
            case 3: { if (newArraySize != -1) context.resize(newArraySize); arraySize = (int)context.size(); return &context; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &label[arrayIndex];
            case 3: return &context[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DERIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_DERIVE_ID;
}

TPM2B_DERIVE::TPM2B_DERIVE(
    const TPMS_DERIVE& _buffer
)
{
    buffer = _buffer;
}

/// <summary> Table 147  Definition of TPM2B_DERIVE Structure </summary>
TPM2B_DERIVE::~TPM2B_DERIVE() {}

/// <summary> Table 147  Definition of TPM2B_DERIVE Structure </summary>
TpmStructureBase* TPM2B_DERIVE::Clone() const
{
    return new TPM2B_DERIVE(*this);
}

void* TPM2B_DERIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&buffer); return &buffer;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_SENSITIVE_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
}

TPM2B_SENSITIVE_DATA::TPM2B_SENSITIVE_DATA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This buffer wraps the TPMU_SENSITIVE_CREATE structure. </summary>
TPM2B_SENSITIVE_DATA::~TPM2B_SENSITIVE_DATA() {}

/// <summary> This buffer wraps the TPMU_SENSITIVE_CREATE structure. </summary>
TpmStructureBase* TPM2B_SENSITIVE_DATA::Clone() const
{
    return new TPM2B_SENSITIVE_DATA(*this);
}

void* TPM2B_SENSITIVE_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SENSITIVE_CREATE::GetTypeId() const
{
    return TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
}

TPMS_SENSITIVE_CREATE::TPMS_SENSITIVE_CREATE(
    const ByteVec& _userAuth,
    const ByteVec& _data
)
{
    userAuth = _userAuth;
    data = _data;
}

/// <summary> This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure. </summary>
TPMS_SENSITIVE_CREATE::~TPMS_SENSITIVE_CREATE() {}

/// <summary> This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure. </summary>
TpmStructureBase* TPMS_SENSITIVE_CREATE::Clone() const
{
    return new TPMS_SENSITIVE_CREATE(*this);
}

void* TPMS_SENSITIVE_CREATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &userAuthSize;
            case 1: { if (newArraySize != -1) userAuth.resize(newArraySize); arraySize = (int)userAuth.size(); return &userAuth; }
            case 2: return &dataSize;
            case 3: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &userAuth[arrayIndex];
            case 3: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_SENSITIVE_CREATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
}

TPM2B_SENSITIVE_CREATE::TPM2B_SENSITIVE_CREATE(
    const TPMS_SENSITIVE_CREATE& _sensitive
)
{
    sensitive = _sensitive;
}

/// <summary> This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes. </summary>
TPM2B_SENSITIVE_CREATE::~TPM2B_SENSITIVE_CREATE() {}

/// <summary> This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes. </summary>
TpmStructureBase* TPM2B_SENSITIVE_CREATE::Clone() const
{
    return new TPM2B_SENSITIVE_CREATE(*this);
}

void* TPM2B_SENSITIVE_CREATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sensitive); return &sensitive;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_HASH::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_HASH_ID;
}

TPMS_SCHEME_HASH::TPMS_SCHEME_HASH(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> This structure is the scheme data for schemes that only require a hash to complete their definition. </summary>
TPMS_SCHEME_HASH::~TPMS_SCHEME_HASH() {}

/// <summary> This structure is the scheme data for schemes that only require a hash to complete their definition. </summary>
TpmStructureBase* TPMS_SCHEME_HASH::Clone() const
{
    return new TPMS_SCHEME_HASH(*this);
}

void* TPMS_SCHEME_HASH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_ECDAA_ID;
}

TPMS_SCHEME_ECDAA::TPMS_SCHEME_ECDAA(
    TPM_ALG_ID _hashAlg,
    UINT16 _count
)
{
    hashAlg = _hashAlg;
    count = _count;
}

/// <summary> This definition is for split signing schemes that require a commit count. </summary>
TPMS_SCHEME_ECDAA::~TPMS_SCHEME_ECDAA() {}

/// <summary> This definition is for split signing schemes that require a commit count. </summary>
TpmStructureBase* TPMS_SCHEME_ECDAA::Clone() const
{
    return new TPMS_SCHEME_ECDAA(*this);
}

void* TPMS_SCHEME_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: return &count;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_HMAC::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_HMAC_ID;
}

TPMS_SCHEME_HMAC::TPMS_SCHEME_HMAC(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Table 155  Definition of Types for HMAC_SIG_SCHEME </summary>
TPMS_SCHEME_HMAC::~TPMS_SCHEME_HMAC() {}

/// <summary> Table 155  Definition of Types for HMAC_SIG_SCHEME </summary>
TpmStructureBase* TPMS_SCHEME_HMAC::Clone() const
{
    return new TPMS_SCHEME_HMAC(*this);
}

void* TPMS_SCHEME_HMAC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_XOR::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_XOR_ID;
}

TPMS_SCHEME_XOR::TPMS_SCHEME_XOR(
    TPM_ALG_ID _hashAlg,
    TPM_ALG_ID _kdf
)
{
    hashAlg = _hashAlg;
    kdf = _kdf;
}

/// <summary> This structure is for the XOR encryption scheme. </summary>
TPMS_SCHEME_XOR::~TPMS_SCHEME_XOR() {}

/// <summary> This structure is for the XOR encryption scheme. </summary>
TpmStructureBase* TPMS_SCHEME_XOR::Clone() const
{
    return new TPMS_SCHEME_XOR(*this);
}

void* TPMS_SCHEME_XOR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: return &kdf;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SCHEME_KEYEDHASH::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TPMS_NULL_SCHEME_KEYEDHASH::~TPMS_NULL_SCHEME_KEYEDHASH() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TpmStructureBase* TPMS_NULL_SCHEME_KEYEDHASH::Clone() const
{
    return new TPMS_NULL_SCHEME_KEYEDHASH(*this);
}

void* TPMS_NULL_SCHEME_KEYEDHASH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_KEYEDHASH_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
}

TPMT_KEYEDHASH_SCHEME::TPMT_KEYEDHASH_SCHEME(
    const TPMU_SCHEME_KEYEDHASH& _details
)
{
    details.reset(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_details.Clone()));
}

/// <summary> This structure is used for a hash signing object. </summary>
TPMT_KEYEDHASH_SCHEME::~TPMT_KEYEDHASH_SCHEME() {}

/// <summary> This structure is used for a hash signing object. </summary>
TpmStructureBase* TPMT_KEYEDHASH_SCHEME::Clone() const
{
    return new TPMT_KEYEDHASH_SCHEME(*this);
}

void* TPMT_KEYEDHASH_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_RSASSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
}

TPMS_SIG_SCHEME_RSASSA::TPMS_SIG_SCHEME_RSASSA(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TPMS_SIG_SCHEME_RSASSA::~TPMS_SIG_SCHEME_RSASSA() {}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_RSASSA::Clone() const
{
    return new TPMS_SIG_SCHEME_RSASSA(*this);
}

void* TPMS_SIG_SCHEME_RSASSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_RSAPSS::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
}

TPMS_SIG_SCHEME_RSAPSS::TPMS_SIG_SCHEME_RSAPSS(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TPMS_SIG_SCHEME_RSAPSS::~TPMS_SIG_SCHEME_RSAPSS() {}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_RSAPSS::Clone() const
{
    return new TPMS_SIG_SCHEME_RSAPSS(*this);
}

void* TPMS_SIG_SCHEME_RSAPSS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_ECDSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
}

TPMS_SIG_SCHEME_ECDSA::TPMS_SIG_SCHEME_ECDSA(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_ECDSA::~TPMS_SIG_SCHEME_ECDSA() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECDSA::Clone() const
{
    return new TPMS_SIG_SCHEME_ECDSA(*this);
}

void* TPMS_SIG_SCHEME_ECDSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_SM2::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
}

TPMS_SIG_SCHEME_SM2::TPMS_SIG_SCHEME_SM2(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_SM2::~TPMS_SIG_SCHEME_SM2() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_SM2::Clone() const
{
    return new TPMS_SIG_SCHEME_SM2(*this);
}

void* TPMS_SIG_SCHEME_SM2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_ECSCHNORR::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
}

TPMS_SIG_SCHEME_ECSCHNORR::TPMS_SIG_SCHEME_ECSCHNORR(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_ECSCHNORR::~TPMS_SIG_SCHEME_ECSCHNORR() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECSCHNORR::Clone() const
{
    return new TPMS_SIG_SCHEME_ECSCHNORR(*this);
}

void* TPMS_SIG_SCHEME_ECSCHNORR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
}

TPMS_SIG_SCHEME_ECDAA::TPMS_SIG_SCHEME_ECDAA(
    TPM_ALG_ID _hashAlg,
    UINT16 _count
)
{
    hashAlg = _hashAlg;
    count = _count;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_ECDAA::~TPMS_SIG_SCHEME_ECDAA() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECDAA::Clone() const
{
    return new TPMS_SIG_SCHEME_ECDAA(*this);
}

void* TPMS_SIG_SCHEME_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: return &count;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SIG_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SIG_SCHEME_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TPMS_NULL_SIG_SCHEME::~TPMS_NULL_SIG_SCHEME() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TpmStructureBase* TPMS_NULL_SIG_SCHEME::Clone() const
{
    return new TPMS_NULL_SIG_SCHEME(*this);
}

void* TPMS_NULL_SIG_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_SIG_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_SIG_SCHEME_ID;
}

TPMT_SIG_SCHEME::TPMT_SIG_SCHEME(
    const TPMU_SIG_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_details.Clone()));
}

/// <summary> Table 162  Definition of TPMT_SIG_SCHEME Structure </summary>
TPMT_SIG_SCHEME::~TPMT_SIG_SCHEME() {}

/// <summary> Table 162  Definition of TPMT_SIG_SCHEME Structure </summary>
TpmStructureBase* TPMT_SIG_SCHEME::Clone() const
{
    return new TPMT_SIG_SCHEME(*this);
}

void* TPMT_SIG_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ENC_SCHEME_OAEP::GetTypeId() const
{
    return TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
}

TPMS_ENC_SCHEME_OAEP::TPMS_ENC_SCHEME_OAEP(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_ENC_SCHEME_OAEP::~TPMS_ENC_SCHEME_OAEP() {}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_ENC_SCHEME_OAEP::Clone() const
{
    return new TPMS_ENC_SCHEME_OAEP(*this);
}

void* TPMS_ENC_SCHEME_OAEP::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ENC_SCHEME_RSAES::GetTypeId() const
{
    return TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID;
}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_ENC_SCHEME_RSAES::~TPMS_ENC_SCHEME_RSAES() {}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_ENC_SCHEME_RSAES::Clone() const
{
    return new TPMS_ENC_SCHEME_RSAES(*this);
}

void* TPMS_ENC_SCHEME_RSAES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_KEY_SCHEME_ECDH::GetTypeId() const
{
    return TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
}

TPMS_KEY_SCHEME_ECDH::TPMS_KEY_SCHEME_ECDH(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_KEY_SCHEME_ECDH::~TPMS_KEY_SCHEME_ECDH() {}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_KEY_SCHEME_ECDH::Clone() const
{
    return new TPMS_KEY_SCHEME_ECDH(*this);
}

void* TPMS_KEY_SCHEME_ECDH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KEY_SCHEME_ECMQV::GetTypeId() const
{
    return TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
}

TPMS_KEY_SCHEME_ECMQV::TPMS_KEY_SCHEME_ECMQV(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_KEY_SCHEME_ECMQV::~TPMS_KEY_SCHEME_ECMQV() {}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_KEY_SCHEME_ECMQV::Clone() const
{
    return new TPMS_KEY_SCHEME_ECMQV(*this);
}

void* TPMS_KEY_SCHEME_ECMQV::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_MGF1::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID;
}

TPMS_KDF_SCHEME_MGF1::TPMS_KDF_SCHEME_MGF1(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_MGF1::~TPMS_KDF_SCHEME_MGF1() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_MGF1::Clone() const
{
    return new TPMS_KDF_SCHEME_MGF1(*this);
}

void* TPMS_KDF_SCHEME_MGF1::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_KDF1_SP800_56A::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID;
}

TPMS_KDF_SCHEME_KDF1_SP800_56A::TPMS_KDF_SCHEME_KDF1_SP800_56A(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_KDF1_SP800_56A::~TPMS_KDF_SCHEME_KDF1_SP800_56A() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_KDF1_SP800_56A::Clone() const
{
    return new TPMS_KDF_SCHEME_KDF1_SP800_56A(*this);
}

void* TPMS_KDF_SCHEME_KDF1_SP800_56A::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_KDF2::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID;
}

TPMS_KDF_SCHEME_KDF2::TPMS_KDF_SCHEME_KDF2(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_KDF2::~TPMS_KDF_SCHEME_KDF2() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_KDF2::Clone() const
{
    return new TPMS_KDF_SCHEME_KDF2(*this);
}

void* TPMS_KDF_SCHEME_KDF2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_KDF1_SP800_108::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID;
}

TPMS_KDF_SCHEME_KDF1_SP800_108::TPMS_KDF_SCHEME_KDF1_SP800_108(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_KDF1_SP800_108::~TPMS_KDF_SCHEME_KDF1_SP800_108() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_KDF1_SP800_108::Clone() const
{
    return new TPMS_KDF_SCHEME_KDF1_SP800_108(*this);
}

void* TPMS_KDF_SCHEME_KDF1_SP800_108::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_KDF_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_KDF_SCHEME_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TPMS_NULL_KDF_SCHEME::~TPMS_NULL_KDF_SCHEME() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TpmStructureBase* TPMS_NULL_KDF_SCHEME::Clone() const
{
    return new TPMS_NULL_KDF_SCHEME(*this);
}

void* TPMS_NULL_KDF_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_KDF_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_KDF_SCHEME_ID;
}

TPMT_KDF_SCHEME::TPMT_KDF_SCHEME(
    const TPMU_KDF_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_details.Clone()));
}

/// <summary> Table 167  Definition of TPMT_KDF_SCHEME Structure </summary>
TPMT_KDF_SCHEME::~TPMT_KDF_SCHEME() {}

/// <summary> Table 167  Definition of TPMT_KDF_SCHEME Structure </summary>
TpmStructureBase* TPMT_KDF_SCHEME::Clone() const
{
    return new TPMT_KDF_SCHEME(*this);
}

void* TPMT_KDF_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_ASYM_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TPMS_NULL_ASYM_SCHEME::~TPMS_NULL_ASYM_SCHEME() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TpmStructureBase* TPMS_NULL_ASYM_SCHEME::Clone() const
{
    return new TPMS_NULL_ASYM_SCHEME(*this);
}

void* TPMS_NULL_ASYM_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_ASYM_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_ASYM_SCHEME_ID;
}

TPMT_ASYM_SCHEME::TPMT_ASYM_SCHEME(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure. </summary>
TPMT_ASYM_SCHEME::~TPMT_ASYM_SCHEME() {}

/// <summary> This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure. </summary>
TpmStructureBase* TPMT_ASYM_SCHEME::Clone() const
{
    return new TPMT_ASYM_SCHEME(*this);
}

void* TPMT_ASYM_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_RSA_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_RSA_SCHEME_ID;
}

TPMT_RSA_SCHEME::TPMT_RSA_SCHEME(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> Table 172  Definition of {RSA} TPMT_RSA_SCHEME Structure </summary>
TPMT_RSA_SCHEME::~TPMT_RSA_SCHEME() {}

/// <summary> Table 172  Definition of {RSA} TPMT_RSA_SCHEME Structure </summary>
TpmStructureBase* TPMT_RSA_SCHEME::Clone() const
{
    return new TPMT_RSA_SCHEME(*this);
}

void* TPMT_RSA_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_RSA_DECRYPT::GetTypeId() const
{
    return TpmTypeId::TPMT_RSA_DECRYPT_ID;
}

TPMT_RSA_DECRYPT::TPMT_RSA_DECRYPT(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> Table 174  Definition of {RSA} TPMT_RSA_DECRYPT Structure </summary>
TPMT_RSA_DECRYPT::~TPMT_RSA_DECRYPT() {}

/// <summary> Table 174  Definition of {RSA} TPMT_RSA_DECRYPT Structure </summary>
TpmStructureBase* TPMT_RSA_DECRYPT::Clone() const
{
    return new TPMT_RSA_DECRYPT(*this);
}

void* TPMT_RSA_DECRYPT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_PUBLIC_KEY_RSA::GetTypeId() const
{
    return TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
}

TPM2B_PUBLIC_KEY_RSA::TPM2B_PUBLIC_KEY_RSA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer holds the largest RSA public key supported by the TPM. </summary>
TPM2B_PUBLIC_KEY_RSA::~TPM2B_PUBLIC_KEY_RSA() {}

/// <summary> This sized buffer holds the largest RSA public key supported by the TPM. </summary>
TpmStructureBase* TPM2B_PUBLIC_KEY_RSA::Clone() const
{
    return new TPM2B_PUBLIC_KEY_RSA(*this);
}

void* TPM2B_PUBLIC_KEY_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PRIVATE_KEY_RSA::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
}

TPM2B_PRIVATE_KEY_RSA::TPM2B_PRIVATE_KEY_RSA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer holds the largest RSA prime number supported by the TPM. </summary>
TPM2B_PRIVATE_KEY_RSA::~TPM2B_PRIVATE_KEY_RSA() {}

/// <summary> This sized buffer holds the largest RSA prime number supported by the TPM. </summary>
TpmStructureBase* TPM2B_PRIVATE_KEY_RSA::Clone() const
{
    return new TPM2B_PRIVATE_KEY_RSA(*this);
}

void* TPM2B_PRIVATE_KEY_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ECC_PARAMETER::GetTypeId() const
{
    return TpmTypeId::TPM2B_ECC_PARAMETER_ID;
}

TPM2B_ECC_PARAMETER::TPM2B_ECC_PARAMETER(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM. </summary>
TPM2B_ECC_PARAMETER::~TPM2B_ECC_PARAMETER() {}

/// <summary> This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM. </summary>
TpmStructureBase* TPM2B_ECC_PARAMETER::Clone() const
{
    return new TPM2B_ECC_PARAMETER(*this);
}

void* TPM2B_ECC_PARAMETER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ECC_POINT::GetTypeId() const
{
    return TpmTypeId::TPMS_ECC_POINT_ID;
}

TPMS_ECC_POINT::TPMS_ECC_POINT(
    const ByteVec& _x,
    const ByteVec& _y
)
{
    x = _x;
    y = _y;
}

/// <summary> This structure holds two ECC coordinates that, together, make up an ECC point. </summary>
TPMS_ECC_POINT::~TPMS_ECC_POINT() {}

/// <summary> This structure holds two ECC coordinates that, together, make up an ECC point. </summary>
TpmStructureBase* TPMS_ECC_POINT::Clone() const
{
    return new TPMS_ECC_POINT(*this);
}

void* TPMS_ECC_POINT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &xSize;
            case 1: { if (newArraySize != -1) x.resize(newArraySize); arraySize = (int)x.size(); return &x; }
            case 2: return &ySize;
            case 3: { if (newArraySize != -1) y.resize(newArraySize); arraySize = (int)y.size(); return &y; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &x[arrayIndex];
            case 3: return &y[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ECC_POINT::GetTypeId() const
{
    return TpmTypeId::TPM2B_ECC_POINT_ID;
}

TPM2B_ECC_POINT::TPM2B_ECC_POINT(
    const TPMS_ECC_POINT& _point
)
{
    point = _point;
}

/// <summary> This structure is defined to allow a point to be a single sized parameter so that it may be encrypted. </summary>
TPM2B_ECC_POINT::~TPM2B_ECC_POINT() {}

/// <summary> This structure is defined to allow a point to be a single sized parameter so that it may be encrypted. </summary>
TpmStructureBase* TPM2B_ECC_POINT::Clone() const
{
    return new TPM2B_ECC_POINT(*this);
}

void* TPM2B_ECC_POINT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&point); return &point;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_ECC_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_ECC_SCHEME_ID;
}

TPMT_ECC_SCHEME::TPMT_ECC_SCHEME(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> Table 183  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure </summary>
TPMT_ECC_SCHEME::~TPMT_ECC_SCHEME() {}

/// <summary> Table 183  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure </summary>
TpmStructureBase* TPMT_ECC_SCHEME::Clone() const
{
    return new TPMT_ECC_SCHEME(*this);
}

void* TPMT_ECC_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ALGORITHM_DETAIL_ECC::GetTypeId() const
{
    return TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
}

TPMS_ALGORITHM_DETAIL_ECC::TPMS_ALGORITHM_DETAIL_ECC(
    TPM_ECC_CURVE _curveID,
    UINT16 _keySize,
    const TPMU_KDF_SCHEME& _kdf,
    const TPMU_ASYM_SCHEME& _sign,
    const ByteVec& _p,
    const ByteVec& _a,
    const ByteVec& _b,
    const ByteVec& _gX,
    const ByteVec& _gY,
    const ByteVec& _n,
    const ByteVec& _h
)
{
    curveID = _curveID;
    keySize = _keySize;
    kdf.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone()));
    sign.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_sign.Clone()));
    p = _p;
    a = _a;
    b = _b;
    gX = _gX;
    gY = _gY;
    n = _n;
    h = _h;
}

/// <summary> This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters(). </summary>
TPMS_ALGORITHM_DETAIL_ECC::~TPMS_ALGORITHM_DETAIL_ECC() {}

/// <summary> This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters(). </summary>
TpmStructureBase* TPMS_ALGORITHM_DETAIL_ECC::Clone() const
{
    return new TPMS_ALGORITHM_DETAIL_ECC(*this);
}

void* TPMS_ALGORITHM_DETAIL_ECC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &curveID;
            case 1: return &keySize;
            case 2: return &kdfScheme;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*kdf); return &kdf;
            case 4: return &signScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*sign); return &sign;
            case 6: return &pSize;
            case 7: { if (newArraySize != -1) p.resize(newArraySize); arraySize = (int)p.size(); return &p; }
            case 8: return &aSize;
            case 9: { if (newArraySize != -1) a.resize(newArraySize); arraySize = (int)a.size(); return &a; }
            case 10: return &bSize;
            case 11: { if (newArraySize != -1) b.resize(newArraySize); arraySize = (int)b.size(); return &b; }
            case 12: return &gXSize;
            case 13: { if (newArraySize != -1) gX.resize(newArraySize); arraySize = (int)gX.size(); return &gX; }
            case 14: return &gYSize;
            case 15: { if (newArraySize != -1) gY.resize(newArraySize); arraySize = (int)gY.size(); return &gY; }
            case 16: return &nSize;
            case 17: { if (newArraySize != -1) n.resize(newArraySize); arraySize = (int)n.size(); return &n; }
            case 18: return &hSize;
            case 19: { if (newArraySize != -1) h.resize(newArraySize); arraySize = (int)h.size(); return &h; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 7: return &p[arrayIndex];
            case 9: return &a[arrayIndex];
            case 11: return &b[arrayIndex];
            case 13: return &gX[arrayIndex];
            case 15: return &gY[arrayIndex];
            case 17: return &n[arrayIndex];
            case 19: return &h[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_RSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSA_ID;
}

TPMS_SIGNATURE_RSA::TPMS_SIGNATURE_RSA(
    TPM_ALG_ID _hash,
    const ByteVec& _sig
)
{
    hash = _hash;
    sig = _sig;
}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TPMS_SIGNATURE_RSA::~TPMS_SIGNATURE_RSA() {}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_RSA::Clone() const
{
    return new TPMS_SIGNATURE_RSA(*this);
}

void* TPMS_SIGNATURE_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sigSize;
            case 2: { if (newArraySize != -1) sig.resize(newArraySize); arraySize = (int)sig.size(); return &sig; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sig[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_RSASSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
}

TPMS_SIGNATURE_RSASSA::TPMS_SIGNATURE_RSASSA(
    TPM_ALG_ID _hash,
    const ByteVec& _sig
)
{
    hash = _hash;
    sig = _sig;
}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TPMS_SIGNATURE_RSASSA::~TPMS_SIGNATURE_RSASSA() {}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_RSASSA::Clone() const
{
    return new TPMS_SIGNATURE_RSASSA(*this);
}

void* TPMS_SIGNATURE_RSASSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sigSize;
            case 2: { if (newArraySize != -1) sig.resize(newArraySize); arraySize = (int)sig.size(); return &sig; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sig[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_RSAPSS::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
}

TPMS_SIGNATURE_RSAPSS::TPMS_SIGNATURE_RSAPSS(
    TPM_ALG_ID _hash,
    const ByteVec& _sig
)
{
    hash = _hash;
    sig = _sig;
}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TPMS_SIGNATURE_RSAPSS::~TPMS_SIGNATURE_RSAPSS() {}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_RSAPSS::Clone() const
{
    return new TPMS_SIGNATURE_RSAPSS(*this);
}

void* TPMS_SIGNATURE_RSAPSS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sigSize;
            case 2: { if (newArraySize != -1) sig.resize(newArraySize); arraySize = (int)sig.size(); return &sig; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sig[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECC::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECC_ID;
}

TPMS_SIGNATURE_ECC::TPMS_SIGNATURE_ECC(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECC::~TPMS_SIGNATURE_ECC() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECC::Clone() const
{
    return new TPMS_SIGNATURE_ECC(*this);
}

void* TPMS_SIGNATURE_ECC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECDSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
}

TPMS_SIGNATURE_ECDSA::TPMS_SIGNATURE_ECDSA(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECDSA::~TPMS_SIGNATURE_ECDSA() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECDSA::Clone() const
{
    return new TPMS_SIGNATURE_ECDSA(*this);
}

void* TPMS_SIGNATURE_ECDSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
}

TPMS_SIGNATURE_ECDAA::TPMS_SIGNATURE_ECDAA(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECDAA::~TPMS_SIGNATURE_ECDAA() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECDAA::Clone() const
{
    return new TPMS_SIGNATURE_ECDAA(*this);
}

void* TPMS_SIGNATURE_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_SM2::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_SM2_ID;
}

TPMS_SIGNATURE_SM2::TPMS_SIGNATURE_SM2(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_SM2::~TPMS_SIGNATURE_SM2() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_SM2::Clone() const
{
    return new TPMS_SIGNATURE_SM2(*this);
}

void* TPMS_SIGNATURE_SM2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECSCHNORR::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
}

TPMS_SIGNATURE_ECSCHNORR::TPMS_SIGNATURE_ECSCHNORR(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECSCHNORR::~TPMS_SIGNATURE_ECSCHNORR() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECSCHNORR::Clone() const
{
    return new TPMS_SIGNATURE_ECSCHNORR(*this);
}

void* TPMS_SIGNATURE_ECSCHNORR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SIGNATURE::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SIGNATURE_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TPMS_NULL_SIGNATURE::~TPMS_NULL_SIGNATURE() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TpmStructureBase* TPMS_NULL_SIGNATURE::Clone() const
{
    return new TPMS_NULL_SIGNATURE(*this);
}

void* TPMS_NULL_SIGNATURE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_SIGNATURE::GetTypeId() const
{
    return TpmTypeId::TPMT_SIGNATURE_ID;
}

TPMT_SIGNATURE::TPMT_SIGNATURE(
    const TPMU_SIGNATURE& _signature
)
{
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart(). </summary>
TPMT_SIGNATURE::~TPMT_SIGNATURE() {}

/// <summary> Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart(). </summary>
TpmStructureBase* TPMT_SIGNATURE::Clone() const
{
    return new TPMT_SIGNATURE(*this);
}

void* TPMT_SIGNATURE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sigAlg;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_ENCRYPTED_SECRET::GetTypeId() const
{
    return TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
}

TPM2B_ENCRYPTED_SECRET::TPM2B_ENCRYPTED_SECRET(
    const ByteVec& _secret
)
{
    secret = _secret;
}

/// <summary> Table 192  Definition of TPM2B_ENCRYPTED_SECRET Structure </summary>
TPM2B_ENCRYPTED_SECRET::~TPM2B_ENCRYPTED_SECRET() {}

/// <summary> Table 192  Definition of TPM2B_ENCRYPTED_SECRET Structure </summary>
TpmStructureBase* TPM2B_ENCRYPTED_SECRET::Clone() const
{
    return new TPM2B_ENCRYPTED_SECRET(*this);
}

void* TPM2B_ENCRYPTED_SECRET::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) secret.resize(newArraySize); arraySize = (int)secret.size(); return &secret; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &secret[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_KEYEDHASH_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
}

TPMS_KEYEDHASH_PARMS::TPMS_KEYEDHASH_PARMS(
    const TPMU_SCHEME_KEYEDHASH& _scheme
)
{
    scheme.reset(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_scheme.Clone()));
}

/// <summary> This structure describes the parameters that would appear in the public area of a KEYEDHASH object. </summary>
TPMS_KEYEDHASH_PARMS::~TPMS_KEYEDHASH_PARMS() {}

/// <summary> This structure describes the parameters that would appear in the public area of a KEYEDHASH object. </summary>
TpmStructureBase* TPMS_KEYEDHASH_PARMS::Clone() const
{
    return new TPMS_KEYEDHASH_PARMS(*this);
}

void* TPMS_KEYEDHASH_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &schemeScheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ASYM_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_ASYM_PARMS_ID;
}

TPMS_ASYM_PARMS::TPMS_ASYM_PARMS(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme
)
{
    symmetric = _symmetric;
    scheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()));
}

/// <summary> This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components. </summary>
TPMS_ASYM_PARMS::~TPMS_ASYM_PARMS() {}

/// <summary> This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components. </summary>
TpmStructureBase* TPMS_ASYM_PARMS::Clone() const
{
    return new TPMS_ASYM_PARMS(*this);
}

void* TPMS_ASYM_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 1: return &schemeScheme;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_RSA_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_RSA_PARMS_ID;
}

TPMS_RSA_PARMS::TPMS_RSA_PARMS(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme,
    UINT16 _keyBits,
    UINT32 _exponent
)
{
    symmetric = _symmetric;
    scheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()));
    keyBits = _keyBits;
    exponent = _exponent;
}

/// <summary> A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs. </summary>
TPMS_RSA_PARMS::~TPMS_RSA_PARMS() {}

/// <summary> A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs. </summary>
TpmStructureBase* TPMS_RSA_PARMS::Clone() const
{
    return new TPMS_RSA_PARMS(*this);
}

void* TPMS_RSA_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 1: return &schemeScheme;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            case 3: return &keyBits;
            case 4: return &exponent;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ECC_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_ECC_PARMS_ID;
}

TPMS_ECC_PARMS::TPMS_ECC_PARMS(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme,
    TPM_ECC_CURVE _curveID,
    const TPMU_KDF_SCHEME& _kdf
)
{
    symmetric = _symmetric;
    scheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()));
    curveID = _curveID;
    kdf.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone()));
}

/// <summary> This structure contains the parameters for prime modulus ECC. </summary>
TPMS_ECC_PARMS::~TPMS_ECC_PARMS() {}

/// <summary> This structure contains the parameters for prime modulus ECC. </summary>
TpmStructureBase* TPMS_ECC_PARMS::Clone() const
{
    return new TPMS_ECC_PARMS(*this);
}

void* TPMS_ECC_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 1: return &schemeScheme;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            case 3: return &curveID;
            case 4: return &kdfScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*kdf); return &kdf;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_PUBLIC_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMT_PUBLIC_PARMS_ID;
}

TPMT_PUBLIC_PARMS::TPMT_PUBLIC_PARMS(
    const TPMU_PUBLIC_PARMS& _parameters
)
{
    parameters.reset(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()));
}

/// <summary> This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM. </summary>
TPMT_PUBLIC_PARMS::~TPMT_PUBLIC_PARMS() {}

/// <summary> This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM. </summary>
TpmStructureBase* TPMT_PUBLIC_PARMS::Clone() const
{
    return new TPMT_PUBLIC_PARMS(*this);
}

void* TPMT_PUBLIC_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &type;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*parameters); return &parameters;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _TPMT_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPMT_PUBLIC_ID;
}

_TPMT_PUBLIC::_TPMT_PUBLIC(
    TPM_ALG_ID _nameAlg,
    TPMA_OBJECT _objectAttributes,
    const ByteVec& _authPolicy,
    const TPMU_PUBLIC_PARMS& _parameters,
    const TPMU_PUBLIC_ID& _unique
)
{
    nameAlg = _nameAlg;
    objectAttributes = _objectAttributes;
    authPolicy = _authPolicy;
    parameters.reset(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()));
    unique.reset(dynamic_cast<TPMU_PUBLIC_ID*>(_unique.Clone()));
}

/// <summary> Table 201 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg. </summary>
_TPMT_PUBLIC::~_TPMT_PUBLIC() {}

/// <summary> Table 201 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg. </summary>
TpmStructureBase* _TPMT_PUBLIC::Clone() const
{
    return new TPMT_PUBLIC(dynamic_cast<const TPMT_PUBLIC&>(*this));
}

void* _TPMT_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &type;
            case 1: return &nameAlg;
            case 2: return &objectAttributes;
            case 3: return &authPolicySize;
            case 4: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*parameters); return &parameters;
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&*unique); return &unique;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_PUBLIC_ID;
}

TPM2B_PUBLIC::TPM2B_PUBLIC(
    const TPMT_PUBLIC& _publicArea
)
{
    publicArea = _publicArea;
}

/// <summary> This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area. </summary>
TPM2B_PUBLIC::~TPM2B_PUBLIC() {}

/// <summary> This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area. </summary>
TpmStructureBase* TPM2B_PUBLIC::Clone() const
{
    return new TPM2B_PUBLIC(*this);
}

void* TPM2B_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&publicArea); return &publicArea;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_TEMPLATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_TEMPLATE_ID;
}

TPM2B_TEMPLATE::TPM2B_TEMPLATE(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded(). </summary>
TPM2B_TEMPLATE::~TPM2B_TEMPLATE() {}

/// <summary> This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded(). </summary>
TpmStructureBase* TPM2B_TEMPLATE::Clone() const
{
    return new TPM2B_TEMPLATE(*this);
}

void* TPM2B_TEMPLATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PRIVATE_VENDOR_SPECIFIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
}

TPM2B_PRIVATE_VENDOR_SPECIFIC::TPM2B_PRIVATE_VENDOR_SPECIFIC(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations. </summary>
TPM2B_PRIVATE_VENDOR_SPECIFIC::~TPM2B_PRIVATE_VENDOR_SPECIFIC() {}

/// <summary> This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations. </summary>
TpmStructureBase* TPM2B_PRIVATE_VENDOR_SPECIFIC::Clone() const
{
    return new TPM2B_PRIVATE_VENDOR_SPECIFIC(*this);
}

void* TPM2B_PRIVATE_VENDOR_SPECIFIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId _TPMT_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPMT_SENSITIVE_ID;
}

_TPMT_SENSITIVE::_TPMT_SENSITIVE(
    const ByteVec& _authValue,
    const ByteVec& _seedValue,
    const TPMU_SENSITIVE_COMPOSITE& _sensitive
)
{
    authValue = _authValue;
    seedValue = _seedValue;
    sensitive.reset(dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(_sensitive.Clone()));
}

/// <summary> authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object. </summary>
_TPMT_SENSITIVE::~_TPMT_SENSITIVE() {}

/// <summary> authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object. </summary>
TpmStructureBase* _TPMT_SENSITIVE::Clone() const
{
    return new TPMT_SENSITIVE(dynamic_cast<const TPMT_SENSITIVE&>(*this));
}

void* _TPMT_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sensitiveType;
            case 1: return &authValueSize;
            case 2: { if (newArraySize != -1) authValue.resize(newArraySize); arraySize = (int)authValue.size(); return &authValue; }
            case 3: return &seedValueSize;
            case 4: { if (newArraySize != -1) seedValue.resize(newArraySize); arraySize = (int)seedValue.size(); return &seedValue; }
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*sensitive); return &sensitive;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &authValue[arrayIndex];
            case 4: return &seedValue[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_ID;
}

TPM2B_SENSITIVE::TPM2B_SENSITIVE(
    const TPMT_SENSITIVE& _sensitiveArea
)
{
    sensitiveArea = _sensitiveArea;
}

/// <summary> The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption. </summary>
TPM2B_SENSITIVE::~TPM2B_SENSITIVE() {}

/// <summary> The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption. </summary>
TpmStructureBase* TPM2B_SENSITIVE::Clone() const
{
    return new TPM2B_SENSITIVE(*this);
}

void* TPM2B_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sensitiveArea); return &sensitiveArea;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _PRIVATE::GetTypeId() const
{
    return TpmTypeId::_PRIVATE_ID;
}

_PRIVATE::_PRIVATE(
    const ByteVec& _integrityOuter,
    const ByteVec& _integrityInner,
    const TPMT_SENSITIVE& _sensitive
)
{
    integrityOuter = _integrityOuter;
    integrityInner = _integrityInner;
    sensitive = _sensitive;
}

/// <summary> This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled. </summary>
_PRIVATE::~_PRIVATE() {}

/// <summary> This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled. </summary>
TpmStructureBase* _PRIVATE::Clone() const
{
    return new _PRIVATE(*this);
}

void* _PRIVATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &integrityOuterSize;
            case 1: { if (newArraySize != -1) integrityOuter.resize(newArraySize); arraySize = (int)integrityOuter.size(); return &integrityOuter; }
            case 2: return &integrityInnerSize;
            case 3: { if (newArraySize != -1) integrityInner.resize(newArraySize); arraySize = (int)integrityInner.size(); return &integrityInner; }
            case 4: return &sensitiveSize;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&sensitive); return &sensitive;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &integrityOuter[arrayIndex];
            case 3: return &integrityInner[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PRIVATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_ID;
}

TPM2B_PRIVATE::TPM2B_PRIVATE(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object. </summary>
TPM2B_PRIVATE::~TPM2B_PRIVATE() {}

/// <summary> The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object. </summary>
TpmStructureBase* TPM2B_PRIVATE::Clone() const
{
    return new TPM2B_PRIVATE(*this);
}

void* TPM2B_PRIVATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ID_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPMS_ID_OBJECT_ID;
}

TPMS_ID_OBJECT::TPMS_ID_OBJECT(
    const ByteVec& _integrityHMAC,
    const ByteVec& _encIdentity
)
{
    integrityHMAC = _integrityHMAC;
    encIdentity = _encIdentity;
}

/// <summary> This structure is used for sizing the TPM2B_ID_OBJECT. </summary>
TPMS_ID_OBJECT::~TPMS_ID_OBJECT() {}

/// <summary> This structure is used for sizing the TPM2B_ID_OBJECT. </summary>
TpmStructureBase* TPMS_ID_OBJECT::Clone() const
{
    return new TPMS_ID_OBJECT(*this);
}

void* TPMS_ID_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &integrityHMACSize;
            case 1: { if (newArraySize != -1) integrityHMAC.resize(newArraySize); arraySize = (int)integrityHMAC.size(); return &integrityHMAC; }
            case 2: { if (newArraySize != -1) encIdentity.resize(newArraySize); arraySize = (int)encIdentity.size(); return &encIdentity; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &integrityHMAC[arrayIndex];
            case 2: return &encIdentity[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ID_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPM2B_ID_OBJECT_ID;
}

TPM2B_ID_OBJECT::TPM2B_ID_OBJECT(
    const TPMS_ID_OBJECT& _credential
)
{
    credential = _credential;
}

/// <summary> This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential(). </summary>
TPM2B_ID_OBJECT::~TPM2B_ID_OBJECT() {}

/// <summary> This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential(). </summary>
TpmStructureBase* TPM2B_ID_OBJECT::Clone() const
{
    return new TPM2B_ID_OBJECT(*this);
}

void* TPM2B_ID_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&credential); return &credential;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NV_PIN_COUNTER_PARAMETERS::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
}

TPMS_NV_PIN_COUNTER_PARAMETERS::TPMS_NV_PIN_COUNTER_PARAMETERS(
    UINT32 _pinCount,
    UINT32 _pinLimit
)
{
    pinCount = _pinCount;
    pinLimit = _pinLimit;
}

/// <summary> This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets. </summary>
TPMS_NV_PIN_COUNTER_PARAMETERS::~TPMS_NV_PIN_COUNTER_PARAMETERS() {}

/// <summary> This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets. </summary>
TpmStructureBase* TPMS_NV_PIN_COUNTER_PARAMETERS::Clone() const
{
    return new TPMS_NV_PIN_COUNTER_PARAMETERS(*this);
}

void* TPMS_NV_PIN_COUNTER_PARAMETERS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pinCount;
            case 1: return &pinLimit;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NV_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_PUBLIC_ID;
}

TPMS_NV_PUBLIC::TPMS_NV_PUBLIC(
    const TPM_HANDLE& _nvIndex,
    TPM_ALG_ID _nameAlg,
    TPMA_NV _attributes,
    const ByteVec& _authPolicy,
    UINT16 _dataSize
)
{
    nvIndex = _nvIndex;
    nameAlg = _nameAlg;
    attributes = _attributes;
    authPolicy = _authPolicy;
    dataSize = _dataSize;
}

/// <summary> This structure describes an NV Index. </summary>
TPMS_NV_PUBLIC::~TPMS_NV_PUBLIC() {}

/// <summary> This structure describes an NV Index. </summary>
TpmStructureBase* TPMS_NV_PUBLIC::Clone() const
{
    return new TPMS_NV_PUBLIC(*this);
}

void* TPMS_NV_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 1: return &nameAlg;
            case 2: return &attributes;
            case 3: return &authPolicySize;
            case 4: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 5: return &dataSize;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_NV_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_NV_PUBLIC_ID;
}

TPM2B_NV_PUBLIC::TPM2B_NV_PUBLIC(
    const TPMS_NV_PUBLIC& _nvPublic
)
{
    nvPublic = _nvPublic;
}

/// <summary> This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface. </summary>
TPM2B_NV_PUBLIC::~TPM2B_NV_PUBLIC() {}

/// <summary> This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface. </summary>
TpmStructureBase* TPM2B_NV_PUBLIC::Clone() const
{
    return new TPM2B_NV_PUBLIC(*this);
}

void* TPM2B_NV_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvPublic); return &nvPublic;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_CONTEXT_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
}

TPM2B_CONTEXT_SENSITIVE::TPM2B_CONTEXT_SENSITIVE(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure holds the object or session context data. When saved, the full structure is encrypted. </summary>
TPM2B_CONTEXT_SENSITIVE::~TPM2B_CONTEXT_SENSITIVE() {}

/// <summary> This structure holds the object or session context data. When saved, the full structure is encrypted. </summary>
TpmStructureBase* TPM2B_CONTEXT_SENSITIVE::Clone() const
{
    return new TPM2B_CONTEXT_SENSITIVE(*this);
}

void* TPM2B_CONTEXT_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_CONTEXT_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CONTEXT_DATA_ID;
}

TPMS_CONTEXT_DATA::TPMS_CONTEXT_DATA(
    const ByteVec& _integrity,
    const ByteVec& _encrypted
)
{
    integrity = _integrity;
    encrypted = _encrypted;
}

/// <summary> This structure holds the integrity value and the encrypted data for a context. </summary>
TPMS_CONTEXT_DATA::~TPMS_CONTEXT_DATA() {}

/// <summary> This structure holds the integrity value and the encrypted data for a context. </summary>
TpmStructureBase* TPMS_CONTEXT_DATA::Clone() const
{
    return new TPMS_CONTEXT_DATA(*this);
}

void* TPMS_CONTEXT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &integritySize;
            case 1: { if (newArraySize != -1) integrity.resize(newArraySize); arraySize = (int)integrity.size(); return &integrity; }
            case 2: { if (newArraySize != -1) encrypted.resize(newArraySize); arraySize = (int)encrypted.size(); return &encrypted; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &integrity[arrayIndex];
            case 2: return &encrypted[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_CONTEXT_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_CONTEXT_DATA_ID;
}

TPM2B_CONTEXT_DATA::TPM2B_CONTEXT_DATA(
    const TPMS_CONTEXT_DATA& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used in a TPMS_CONTEXT. </summary>
TPM2B_CONTEXT_DATA::~TPM2B_CONTEXT_DATA() {}

/// <summary> This structure is used in a TPMS_CONTEXT. </summary>
TpmStructureBase* TPM2B_CONTEXT_DATA::Clone() const
{
    return new TPM2B_CONTEXT_DATA(*this);
}

void* TPM2B_CONTEXT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&buffer); return &buffer;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CONTEXT::GetTypeId() const
{
    return TpmTypeId::TPMS_CONTEXT_ID;
}

TPMS_CONTEXT::TPMS_CONTEXT(
    UINT64 _sequence,
    const TPM_HANDLE& _savedHandle,
    const TPM_HANDLE& _hierarchy,
    const TPMS_CONTEXT_DATA& _contextBlob
)
{
    sequence = _sequence;
    savedHandle = _savedHandle;
    hierarchy = _hierarchy;
    contextBlob = _contextBlob;
}

/// <summary> This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context. </summary>
TPMS_CONTEXT::~TPMS_CONTEXT() {}

/// <summary> This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context. </summary>
TpmStructureBase* TPMS_CONTEXT::Clone() const
{
    return new TPMS_CONTEXT(*this);
}

void* TPMS_CONTEXT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sequence;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&savedHandle); return &savedHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 3: return &contextBlobSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&contextBlob); return &contextBlob;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CREATION_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CREATION_DATA_ID;
}

TPMS_CREATION_DATA::TPMS_CREATION_DATA(
    const vector<TPMS_PCR_SELECTION>& _pcrSelect,
    const ByteVec& _pcrDigest,
    TPMA_LOCALITY _locality,
    TPM_ALG_ID _parentNameAlg,
    const ByteVec& _parentName,
    const ByteVec& _parentQualifiedName,
    const ByteVec& _outsideInfo
)
{
    pcrSelect = _pcrSelect;
    pcrDigest = _pcrDigest;
    locality = _locality;
    parentNameAlg = _parentNameAlg;
    parentName = _parentName;
    parentQualifiedName = _parentQualifiedName;
    outsideInfo = _outsideInfo;
}

/// <summary> This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present. </summary>
TPMS_CREATION_DATA::~TPMS_CREATION_DATA() {}

/// <summary> This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present. </summary>
TpmStructureBase* TPMS_CREATION_DATA::Clone() const
{
    return new TPMS_CREATION_DATA(*this);
}

void* TPMS_CREATION_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrSelectCount;
            case 1: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            case 2: return &pcrDigestSize;
            case 3: { if (newArraySize != -1) pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return &pcrDigest; }
            case 4: return &locality;
            case 5: return &parentNameAlg;
            case 6: return &parentNameSize;
            case 7: { if (newArraySize != -1) parentName.resize(newArraySize); arraySize = (int)parentName.size(); return &parentName; }
            case 8: return &parentQualifiedNameSize;
            case 9: { if (newArraySize != -1) parentQualifiedName.resize(newArraySize); arraySize = (int)parentQualifiedName.size(); return &parentQualifiedName; }
            case 10: return &outsideInfoSize;
            case 11: { if (newArraySize != -1) outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return &outsideInfo; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelect[arrayIndex]); return &pcrSelect[arrayIndex];
            case 3: return &pcrDigest[arrayIndex];
            case 7: return &parentName[arrayIndex];
            case 9: return &parentQualifiedName[arrayIndex];
            case 11: return &outsideInfo[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_CREATION_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_CREATION_DATA_ID;
}

TPM2B_CREATION_DATA::TPM2B_CREATION_DATA(
    const TPMS_CREATION_DATA& _creationData
)
{
    creationData = _creationData;
}

/// <summary> This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero. </summary>
TPM2B_CREATION_DATA::~TPM2B_CREATION_DATA() {}

/// <summary> This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero. </summary>
TpmStructureBase* TPM2B_CREATION_DATA::Clone() const
{
    return new TPM2B_CREATION_DATA(*this);
}

void* TPM2B_CREATION_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return &creationData;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_AC_OUTPUT::GetTypeId() const
{
    return TpmTypeId::TPMS_AC_OUTPUT_ID;
}

TPMS_AC_OUTPUT::TPMS_AC_OUTPUT(
    TPM_AT _tag,
    UINT32 _data
)
{
    tag = _tag;
    data = _data;
}

/// <summary> TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value. </summary>
TPMS_AC_OUTPUT::~TPMS_AC_OUTPUT() {}

/// <summary> TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value. </summary>
TpmStructureBase* TPMS_AC_OUTPUT::Clone() const
{
    return new TPMS_AC_OUTPUT(*this);
}

void* TPMS_AC_OUTPUT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: return &data;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPML_AC_CAPABILITIES::GetTypeId() const
{
    return TpmTypeId::TPML_AC_CAPABILITIES_ID;
}

TPML_AC_CAPABILITIES::TPML_AC_CAPABILITIES(
    const vector<TPMS_AC_OUTPUT>& _acCapabilities
)
{
    acCapabilities = _acCapabilities;
}

/// <summary> This list is only used in TPM2_AC_GetCapability(). </summary>
TPML_AC_CAPABILITIES::~TPML_AC_CAPABILITIES() {}

/// <summary> This list is only used in TPM2_AC_GetCapability(). </summary>
TpmStructureBase* TPML_AC_CAPABILITIES::Clone() const
{
    return new TPML_AC_CAPABILITIES(*this);
}

void* TPML_AC_CAPABILITIES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) acCapabilities.resize(newArraySize); arraySize = (int)acCapabilities.size(); return &acCapabilities; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&acCapabilities[arrayIndex]); return &acCapabilities[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Startup_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Startup_REQUEST_ID;
}

TPM2_Startup_REQUEST::TPM2_Startup_REQUEST(TPM_SU _startupType)
{
    startupType = _startupType;
}

/// <summary> TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE. </summary>
TPM2_Startup_REQUEST::~TPM2_Startup_REQUEST() {}

/// <summary> TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE. </summary>
TpmStructureBase* TPM2_Startup_REQUEST::Clone() const
{
    return new TPM2_Startup_REQUEST(*this);
}

void* TPM2_Startup_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &startupType;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Shutdown_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Shutdown_REQUEST_ID;
}

TPM2_Shutdown_REQUEST::TPM2_Shutdown_REQUEST(TPM_SU _shutdownType)
{
    shutdownType = _shutdownType;
}

/// <summary> This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed. </summary>
TPM2_Shutdown_REQUEST::~TPM2_Shutdown_REQUEST() {}

/// <summary> This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed. </summary>
TpmStructureBase* TPM2_Shutdown_REQUEST::Clone() const
{
    return new TPM2_Shutdown_REQUEST(*this);
}

void* TPM2_Shutdown_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &shutdownType;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_SelfTest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SelfTest_REQUEST_ID;
}

TPM2_SelfTest_REQUEST::TPM2_SelfTest_REQUEST(BYTE _fullTest)
{
    fullTest = _fullTest;
}

/// <summary> This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested. </summary>
TPM2_SelfTest_REQUEST::~TPM2_SelfTest_REQUEST() {}

/// <summary> This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested. </summary>
TpmStructureBase* TPM2_SelfTest_REQUEST::Clone() const
{
    return new TPM2_SelfTest_REQUEST(*this);
}

void* TPM2_SelfTest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &fullTest;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_IncrementalSelfTest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
}

TPM2_IncrementalSelfTest_REQUEST::TPM2_IncrementalSelfTest_REQUEST(
    const vector<TPM_ALG_ID>& _toTest
)
{
    toTest = _toTest;
}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
TPM2_IncrementalSelfTest_REQUEST::~TPM2_IncrementalSelfTest_REQUEST() {}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
TpmStructureBase* TPM2_IncrementalSelfTest_REQUEST::Clone() const
{
    return new TPM2_IncrementalSelfTest_REQUEST(*this);
}

void* TPM2_IncrementalSelfTest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &toTestCount;
            case 1: { if (newArraySize != -1) toTest.resize(newArraySize); arraySize = (int)toTest.size(); return &toTest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &toTest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId IncrementalSelfTestResponse::GetTypeId() const
{
    return TpmTypeId::IncrementalSelfTestResponse_ID;
}

IncrementalSelfTestResponse::IncrementalSelfTestResponse(
    const vector<TPM_ALG_ID>& _toDoList
)
{
    toDoList = _toDoList;
}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
IncrementalSelfTestResponse::~IncrementalSelfTestResponse() {}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
TpmStructureBase* IncrementalSelfTestResponse::Clone() const
{
    return new IncrementalSelfTestResponse(*this);
}

void* IncrementalSelfTestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &toDoListCount;
            case 1: { if (newArraySize != -1) toDoList.resize(newArraySize); arraySize = (int)toDoList.size(); return &toDoList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &toDoList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_GetTestResult_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetTestResult_REQUEST_ID;
}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
TPM2_GetTestResult_REQUEST::~TPM2_GetTestResult_REQUEST() {}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
TpmStructureBase* TPM2_GetTestResult_REQUEST::Clone() const
{
    return new TPM2_GetTestResult_REQUEST(*this);
}

void* TPM2_GetTestResult_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId GetTestResultResponse::GetTypeId() const
{
    return TpmTypeId::GetTestResultResponse_ID;
}

GetTestResultResponse::GetTestResultResponse(
    const ByteVec& _outData,
    TPM_RC _testResult
)
{
    outData = _outData;
    testResult = _testResult;
}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
GetTestResultResponse::~GetTestResultResponse() {}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
TpmStructureBase* GetTestResultResponse::Clone() const
{
    return new GetTestResultResponse(*this);
}

void* GetTestResultResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            case 2: return &testResult;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_StartAuthSession_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
}

TPM2_StartAuthSession_REQUEST::TPM2_StartAuthSession_REQUEST(
    const TPM_HANDLE& _tpmKey,
    const TPM_HANDLE& _bind,
    const ByteVec& _nonceCaller,
    const ByteVec& _encryptedSalt,
    TPM_SE _sessionType,
    const TPMT_SYM_DEF& _symmetric,
    TPM_ALG_ID _authHash
)
{
    tpmKey = _tpmKey;
    bind = _bind;
    nonceCaller = _nonceCaller;
    encryptedSalt = _encryptedSalt;
    sessionType = _sessionType;
    symmetric = _symmetric;
    authHash = _authHash;
}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
TPM2_StartAuthSession_REQUEST::~TPM2_StartAuthSession_REQUEST() {}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
TpmStructureBase* TPM2_StartAuthSession_REQUEST::Clone() const
{
    return new TPM2_StartAuthSession_REQUEST(*this);
}

void* TPM2_StartAuthSession_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&tpmKey); return &tpmKey;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&bind); return &bind;
            case 2: return &nonceCallerSize;
            case 3: { if (newArraySize != -1) nonceCaller.resize(newArraySize); arraySize = (int)nonceCaller.size(); return &nonceCaller; }
            case 4: return &encryptedSaltSize;
            case 5: { if (newArraySize != -1) encryptedSalt.resize(newArraySize); arraySize = (int)encryptedSalt.size(); return &encryptedSalt; }
            case 6: return &sessionType;
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 8: return &authHash;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nonceCaller[arrayIndex];
            case 5: return &encryptedSalt[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId StartAuthSessionResponse::GetTypeId() const
{
    return TpmTypeId::StartAuthSessionResponse_ID;
}

StartAuthSessionResponse::StartAuthSessionResponse(
    const TPM_HANDLE& _handle,
    const ByteVec& _nonceTPM
)
{
    handle = _handle;
    nonceTPM = _nonceTPM;
}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
StartAuthSessionResponse::~StartAuthSessionResponse() {}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
TpmStructureBase* StartAuthSessionResponse::Clone() const
{
    return new StartAuthSessionResponse(*this);
}

void* StartAuthSessionResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nonceTPMSize;
            case 2: { if (newArraySize != -1) nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return &nonceTPM; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nonceTPM[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyRestart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyRestart_REQUEST_ID;
}

TPM2_PolicyRestart_REQUEST::TPM2_PolicyRestart_REQUEST(const TPM_HANDLE& _sessionHandle)
{
    sessionHandle = _sessionHandle;
}

/// <summary> This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed. </summary>
TPM2_PolicyRestart_REQUEST::~TPM2_PolicyRestart_REQUEST() {}

/// <summary> This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed. </summary>
TpmStructureBase* TPM2_PolicyRestart_REQUEST::Clone() const
{
    return new TPM2_PolicyRestart_REQUEST(*this);
}

void* TPM2_PolicyRestart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return &sessionHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Create_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Create_REQUEST_ID;
}

TPM2_Create_REQUEST::TPM2_Create_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const TPMT_PUBLIC& _inPublic,
    const ByteVec& _outsideInfo,
    const vector<TPMS_PCR_SELECTION>& _creationPCR
)
{
    parentHandle = _parentHandle;
    inSensitive = _inSensitive;
    inPublic = _inPublic;
    outsideInfo = _outsideInfo;
    creationPCR = _creationPCR;
}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
TPM2_Create_REQUEST::~TPM2_Create_REQUEST() {}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
TpmStructureBase* TPM2_Create_REQUEST::Clone() const
{
    return new TPM2_Create_REQUEST(*this);
}

void* TPM2_Create_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: return &inSensitiveSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return &inSensitive;
            case 3: return &inPublicSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            case 5: return &outsideInfoSize;
            case 6: { if (newArraySize != -1) outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return &outsideInfo; }
            case 7: return &creationPCRCount;
            case 8: { if (newArraySize != -1) creationPCR.resize(newArraySize); arraySize = (int)creationPCR.size(); return &creationPCR; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &outsideInfo[arrayIndex];
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationPCR[arrayIndex]); return &creationPCR[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CreateResponse::GetTypeId() const
{
    return TpmTypeId::CreateResponse_ID;
}

CreateResponse::CreateResponse(
    const TPM2B_PRIVATE& _outPrivate,
    const TPMT_PUBLIC& _outPublic,
    const TPMS_CREATION_DATA& _creationData,
    const ByteVec& _creationHash,
    const TPMT_TK_CREATION& _creationTicket
)
{
    outPrivate = _outPrivate;
    outPublic = _outPublic;
    creationData = _creationData;
    creationHash = _creationHash;
    creationTicket = _creationTicket;
}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
CreateResponse::~CreateResponse() {}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
TpmStructureBase* CreateResponse::Clone() const
{
    return new CreateResponse(*this);
}

void* CreateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            case 1: return &outPublicSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 3: return &creationDataSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return &creationData;
            case 5: return &creationHashSize;
            case 6: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return &creationTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &creationHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Load_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Load_REQUEST_ID;
}

TPM2_Load_REQUEST::TPM2_Load_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const TPM2B_PRIVATE& _inPrivate,
    const TPMT_PUBLIC& _inPublic
)
{
    parentHandle = _parentHandle;
    inPrivate = _inPrivate;
    inPublic = _inPublic;
}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
TPM2_Load_REQUEST::~TPM2_Load_REQUEST() {}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
TpmStructureBase* TPM2_Load_REQUEST::Clone() const
{
    return new TPM2_Load_REQUEST(*this);
}

void* TPM2_Load_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&inPrivate); return &inPrivate;
            case 2: return &inPublicSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId LoadResponse::GetTypeId() const
{
    return TpmTypeId::LoadResponse_ID;
}

LoadResponse::LoadResponse(
    const TPM_HANDLE& _handle,
    const ByteVec& _name
)
{
    handle = _handle;
    name = _name;
}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
LoadResponse::~LoadResponse() {}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
TpmStructureBase* LoadResponse::Clone() const
{
    return new LoadResponse(*this);
}

void* LoadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nameSize;
            case 2: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_LoadExternal_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
}

TPM2_LoadExternal_REQUEST::TPM2_LoadExternal_REQUEST(
    const TPMT_SENSITIVE& _inPrivate,
    const TPMT_PUBLIC& _inPublic,
    const TPM_HANDLE& _hierarchy
)
{
    inPrivate = _inPrivate;
    inPublic = _inPublic;
    hierarchy = _hierarchy;
}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
TPM2_LoadExternal_REQUEST::~TPM2_LoadExternal_REQUEST() {}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
TpmStructureBase* TPM2_LoadExternal_REQUEST::Clone() const
{
    return new TPM2_LoadExternal_REQUEST(*this);
}

void* TPM2_LoadExternal_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &inPrivateSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&inPrivate); return &inPrivate;
            case 2: return &inPublicSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId LoadExternalResponse::GetTypeId() const
{
    return TpmTypeId::LoadExternalResponse_ID;
}

LoadExternalResponse::LoadExternalResponse(
    const TPM_HANDLE& _handle,
    const ByteVec& _name
)
{
    handle = _handle;
    name = _name;
}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
LoadExternalResponse::~LoadExternalResponse() {}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
TpmStructureBase* LoadExternalResponse::Clone() const
{
    return new LoadExternalResponse(*this);
}

void* LoadExternalResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nameSize;
            case 2: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ReadPublic_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ReadPublic_REQUEST_ID;
}

TPM2_ReadPublic_REQUEST::TPM2_ReadPublic_REQUEST(const TPM_HANDLE& _objectHandle)
{
    objectHandle = _objectHandle;
}

/// <summary> This command allows access to the public area of a loaded object. </summary>
TPM2_ReadPublic_REQUEST::~TPM2_ReadPublic_REQUEST() {}

/// <summary> This command allows access to the public area of a loaded object. </summary>
TpmStructureBase* TPM2_ReadPublic_REQUEST::Clone() const
{
    return new TPM2_ReadPublic_REQUEST(*this);
}

void* TPM2_ReadPublic_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ReadPublicResponse::GetTypeId() const
{
    return TpmTypeId::ReadPublicResponse_ID;
}

ReadPublicResponse::ReadPublicResponse(
    const TPMT_PUBLIC& _outPublic,
    const ByteVec& _name,
    const ByteVec& _qualifiedName
)
{
    outPublic = _outPublic;
    name = _name;
    qualifiedName = _qualifiedName;
}

/// <summary> This command allows access to the public area of a loaded object. </summary>
ReadPublicResponse::~ReadPublicResponse() {}

/// <summary> This command allows access to the public area of a loaded object. </summary>
TpmStructureBase* ReadPublicResponse::Clone() const
{
    return new ReadPublicResponse(*this);
}

void* ReadPublicResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outPublicSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 2: return &nameSize;
            case 3: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            case 4: return &qualifiedNameSize;
            case 5: { if (newArraySize != -1) qualifiedName.resize(newArraySize); arraySize = (int)qualifiedName.size(); return &qualifiedName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &name[arrayIndex];
            case 5: return &qualifiedName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ActivateCredential_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
}

TPM2_ActivateCredential_REQUEST::TPM2_ActivateCredential_REQUEST(
    const TPM_HANDLE& _activateHandle,
    const TPM_HANDLE& _keyHandle,
    const TPMS_ID_OBJECT& _credentialBlob,
    const ByteVec& _secret
)
{
    activateHandle = _activateHandle;
    keyHandle = _keyHandle;
    credentialBlob = _credentialBlob;
    secret = _secret;
}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
TPM2_ActivateCredential_REQUEST::~TPM2_ActivateCredential_REQUEST() {}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
TpmStructureBase* TPM2_ActivateCredential_REQUEST::Clone() const
{
    return new TPM2_ActivateCredential_REQUEST(*this);
}

void* TPM2_ActivateCredential_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&activateHandle); return &activateHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 2: return &credentialBlobSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&credentialBlob); return &credentialBlob;
            case 4: return &secretSize;
            case 5: { if (newArraySize != -1) secret.resize(newArraySize); arraySize = (int)secret.size(); return &secret; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 5: return &secret[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ActivateCredentialResponse::GetTypeId() const
{
    return TpmTypeId::ActivateCredentialResponse_ID;
}

ActivateCredentialResponse::ActivateCredentialResponse(
    const ByteVec& _certInfo
)
{
    certInfo = _certInfo;
}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
ActivateCredentialResponse::~ActivateCredentialResponse() {}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
TpmStructureBase* ActivateCredentialResponse::Clone() const
{
    return new ActivateCredentialResponse(*this);
}

void* ActivateCredentialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certInfoSize;
            case 1: { if (newArraySize != -1) certInfo.resize(newArraySize); arraySize = (int)certInfo.size(); return &certInfo; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &certInfo[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_MakeCredential_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
}

TPM2_MakeCredential_REQUEST::TPM2_MakeCredential_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _credential,
    const ByteVec& _objectName
)
{
    handle = _handle;
    credential = _credential;
    objectName = _objectName;
}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
TPM2_MakeCredential_REQUEST::~TPM2_MakeCredential_REQUEST() {}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
TpmStructureBase* TPM2_MakeCredential_REQUEST::Clone() const
{
    return new TPM2_MakeCredential_REQUEST(*this);
}

void* TPM2_MakeCredential_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &credentialSize;
            case 2: { if (newArraySize != -1) credential.resize(newArraySize); arraySize = (int)credential.size(); return &credential; }
            case 3: return &objectNameSize;
            case 4: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &credential[arrayIndex];
            case 4: return &objectName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId MakeCredentialResponse::GetTypeId() const
{
    return TpmTypeId::MakeCredentialResponse_ID;
}

MakeCredentialResponse::MakeCredentialResponse(
    const TPMS_ID_OBJECT& _credentialBlob,
    const ByteVec& _secret
)
{
    credentialBlob = _credentialBlob;
    secret = _secret;
}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
MakeCredentialResponse::~MakeCredentialResponse() {}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
TpmStructureBase* MakeCredentialResponse::Clone() const
{
    return new MakeCredentialResponse(*this);
}

void* MakeCredentialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &credentialBlobSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&credentialBlob); return &credentialBlob;
            case 2: return &secretSize;
            case 3: { if (newArraySize != -1) secret.resize(newArraySize); arraySize = (int)secret.size(); return &secret; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &secret[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Unseal_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Unseal_REQUEST_ID;
}

TPM2_Unseal_REQUEST::TPM2_Unseal_REQUEST(const TPM_HANDLE& _itemHandle)
{
    itemHandle = _itemHandle;
}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
TPM2_Unseal_REQUEST::~TPM2_Unseal_REQUEST() {}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
TpmStructureBase* TPM2_Unseal_REQUEST::Clone() const
{
    return new TPM2_Unseal_REQUEST(*this);
}

void* TPM2_Unseal_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&itemHandle); return &itemHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId UnsealResponse::GetTypeId() const
{
    return TpmTypeId::UnsealResponse_ID;
}

UnsealResponse::UnsealResponse(
    const ByteVec& _outData
)
{
    outData = _outData;
}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
UnsealResponse::~UnsealResponse() {}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
TpmStructureBase* UnsealResponse::Clone() const
{
    return new UnsealResponse(*this);
}

void* UnsealResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ObjectChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
}

TPM2_ObjectChangeAuth_REQUEST::TPM2_ObjectChangeAuth_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _parentHandle,
    const ByteVec& _newAuth
)
{
    objectHandle = _objectHandle;
    parentHandle = _parentHandle;
    newAuth = _newAuth;
}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
TPM2_ObjectChangeAuth_REQUEST::~TPM2_ObjectChangeAuth_REQUEST() {}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
TpmStructureBase* TPM2_ObjectChangeAuth_REQUEST::Clone() const
{
    return new TPM2_ObjectChangeAuth_REQUEST(*this);
}

void* TPM2_ObjectChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 2: return &newAuthSize;
            case 3: { if (newArraySize != -1) newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return &newAuth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &newAuth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ObjectChangeAuthResponse::GetTypeId() const
{
    return TpmTypeId::ObjectChangeAuthResponse_ID;
}

ObjectChangeAuthResponse::ObjectChangeAuthResponse(const TPM2B_PRIVATE& _outPrivate)
{
    outPrivate = _outPrivate;
}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
ObjectChangeAuthResponse::~ObjectChangeAuthResponse() {}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
TpmStructureBase* ObjectChangeAuthResponse::Clone() const
{
    return new ObjectChangeAuthResponse(*this);
}

void* ObjectChangeAuthResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_CreateLoaded_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
}

TPM2_CreateLoaded_REQUEST::TPM2_CreateLoaded_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const ByteVec& _inPublic
)
{
    parentHandle = _parentHandle;
    inSensitive = _inSensitive;
    inPublic = _inPublic;
}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
TPM2_CreateLoaded_REQUEST::~TPM2_CreateLoaded_REQUEST() {}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
TpmStructureBase* TPM2_CreateLoaded_REQUEST::Clone() const
{
    return new TPM2_CreateLoaded_REQUEST(*this);
}

void* TPM2_CreateLoaded_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: return &inSensitiveSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return &inSensitive;
            case 3: return &inPublicSize;
            case 4: { if (newArraySize != -1) inPublic.resize(newArraySize); arraySize = (int)inPublic.size(); return &inPublic; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &inPublic[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CreateLoadedResponse::GetTypeId() const
{
    return TpmTypeId::CreateLoadedResponse_ID;
}

CreateLoadedResponse::CreateLoadedResponse(
    const TPM_HANDLE& _handle,
    const TPM2B_PRIVATE& _outPrivate,
    const TPMT_PUBLIC& _outPublic,
    const ByteVec& _name
)
{
    handle = _handle;
    outPrivate = _outPrivate;
    outPublic = _outPublic;
    name = _name;
}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
CreateLoadedResponse::~CreateLoadedResponse() {}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
TpmStructureBase* CreateLoadedResponse::Clone() const
{
    return new CreateLoadedResponse(*this);
}

void* CreateLoadedResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            case 2: return &outPublicSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 4: return &nameSize;
            case 5: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 5: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Duplicate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Duplicate_REQUEST_ID;
}

TPM2_Duplicate_REQUEST::TPM2_Duplicate_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _newParentHandle,
    const ByteVec& _encryptionKeyIn,
    const TPMT_SYM_DEF_OBJECT& _symmetricAlg
)
{
    objectHandle = _objectHandle;
    newParentHandle = _newParentHandle;
    encryptionKeyIn = _encryptionKeyIn;
    symmetricAlg = _symmetricAlg;
}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
TPM2_Duplicate_REQUEST::~TPM2_Duplicate_REQUEST() {}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
TpmStructureBase* TPM2_Duplicate_REQUEST::Clone() const
{
    return new TPM2_Duplicate_REQUEST(*this);
}

void* TPM2_Duplicate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&newParentHandle); return &newParentHandle;
            case 2: return &encryptionKeyInSize;
            case 3: { if (newArraySize != -1) encryptionKeyIn.resize(newArraySize); arraySize = (int)encryptionKeyIn.size(); return &encryptionKeyIn; }
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&symmetricAlg); return &symmetricAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &encryptionKeyIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId DuplicateResponse::GetTypeId() const
{
    return TpmTypeId::DuplicateResponse_ID;
}

DuplicateResponse::DuplicateResponse(
    const ByteVec& _encryptionKeyOut,
    const TPM2B_PRIVATE& _duplicate,
    const ByteVec& _outSymSeed
)
{
    encryptionKeyOut = _encryptionKeyOut;
    duplicate = _duplicate;
    outSymSeed = _outSymSeed;
}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
DuplicateResponse::~DuplicateResponse() {}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
TpmStructureBase* DuplicateResponse::Clone() const
{
    return new DuplicateResponse(*this);
}

void* DuplicateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &encryptionKeyOutSize;
            case 1: { if (newArraySize != -1) encryptionKeyOut.resize(newArraySize); arraySize = (int)encryptionKeyOut.size(); return &encryptionKeyOut; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&duplicate); return &duplicate;
            case 3: return &outSymSeedSize;
            case 4: { if (newArraySize != -1) outSymSeed.resize(newArraySize); arraySize = (int)outSymSeed.size(); return &outSymSeed; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &encryptionKeyOut[arrayIndex];
            case 4: return &outSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Rewrap_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Rewrap_REQUEST_ID;
}

TPM2_Rewrap_REQUEST::TPM2_Rewrap_REQUEST(
    const TPM_HANDLE& _oldParent,
    const TPM_HANDLE& _newParent,
    const TPM2B_PRIVATE& _inDuplicate,
    const ByteVec& _name,
    const ByteVec& _inSymSeed
)
{
    oldParent = _oldParent;
    newParent = _newParent;
    inDuplicate = _inDuplicate;
    name = _name;
    inSymSeed = _inSymSeed;
}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
TPM2_Rewrap_REQUEST::~TPM2_Rewrap_REQUEST() {}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
TpmStructureBase* TPM2_Rewrap_REQUEST::Clone() const
{
    return new TPM2_Rewrap_REQUEST(*this);
}

void* TPM2_Rewrap_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&oldParent); return &oldParent;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&newParent); return &newParent;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inDuplicate); return &inDuplicate;
            case 3: return &nameSize;
            case 4: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            case 5: return &inSymSeedSize;
            case 6: { if (newArraySize != -1) inSymSeed.resize(newArraySize); arraySize = (int)inSymSeed.size(); return &inSymSeed; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &name[arrayIndex];
            case 6: return &inSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId RewrapResponse::GetTypeId() const
{
    return TpmTypeId::RewrapResponse_ID;
}

RewrapResponse::RewrapResponse(
    const TPM2B_PRIVATE& _outDuplicate,
    const ByteVec& _outSymSeed
)
{
    outDuplicate = _outDuplicate;
    outSymSeed = _outSymSeed;
}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
RewrapResponse::~RewrapResponse() {}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
TpmStructureBase* RewrapResponse::Clone() const
{
    return new RewrapResponse(*this);
}

void* RewrapResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outDuplicate); return &outDuplicate;
            case 1: return &outSymSeedSize;
            case 2: { if (newArraySize != -1) outSymSeed.resize(newArraySize); arraySize = (int)outSymSeed.size(); return &outSymSeed; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &outSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Import_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Import_REQUEST_ID;
}

TPM2_Import_REQUEST::TPM2_Import_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const ByteVec& _encryptionKey,
    const TPMT_PUBLIC& _objectPublic,
    const TPM2B_PRIVATE& _duplicate,
    const ByteVec& _inSymSeed,
    const TPMT_SYM_DEF_OBJECT& _symmetricAlg
)
{
    parentHandle = _parentHandle;
    encryptionKey = _encryptionKey;
    objectPublic = _objectPublic;
    duplicate = _duplicate;
    inSymSeed = _inSymSeed;
    symmetricAlg = _symmetricAlg;
}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
TPM2_Import_REQUEST::~TPM2_Import_REQUEST() {}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
TpmStructureBase* TPM2_Import_REQUEST::Clone() const
{
    return new TPM2_Import_REQUEST(*this);
}

void* TPM2_Import_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: return &encryptionKeySize;
            case 2: { if (newArraySize != -1) encryptionKey.resize(newArraySize); arraySize = (int)encryptionKey.size(); return &encryptionKey; }
            case 3: return &objectPublicSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&objectPublic); return &objectPublic;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&duplicate); return &duplicate;
            case 6: return &inSymSeedSize;
            case 7: { if (newArraySize != -1) inSymSeed.resize(newArraySize); arraySize = (int)inSymSeed.size(); return &inSymSeed; }
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&symmetricAlg); return &symmetricAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &encryptionKey[arrayIndex];
            case 7: return &inSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ImportResponse::GetTypeId() const
{
    return TpmTypeId::ImportResponse_ID;
}

ImportResponse::ImportResponse(const TPM2B_PRIVATE& _outPrivate)
{
    outPrivate = _outPrivate;
}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
ImportResponse::~ImportResponse() {}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
TpmStructureBase* ImportResponse::Clone() const
{
    return new ImportResponse(*this);
}

void* ImportResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_RSA_Encrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
}

TPM2_RSA_Encrypt_REQUEST::TPM2_RSA_Encrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _message,
    const TPMU_ASYM_SCHEME& _inScheme,
    const ByteVec& _label
)
{
    keyHandle = _keyHandle;
    message = _message;
    inScheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone()));
    label = _label;
}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
TPM2_RSA_Encrypt_REQUEST::~TPM2_RSA_Encrypt_REQUEST() {}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
TpmStructureBase* TPM2_RSA_Encrypt_REQUEST::Clone() const
{
    return new TPM2_RSA_Encrypt_REQUEST(*this);
}

void* TPM2_RSA_Encrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &messageSize;
            case 2: { if (newArraySize != -1) message.resize(newArraySize); arraySize = (int)message.size(); return &message; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: return &labelSize;
            case 6: { if (newArraySize != -1) label.resize(newArraySize); arraySize = (int)label.size(); return &label; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &message[arrayIndex];
            case 6: return &label[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId RSA_EncryptResponse::GetTypeId() const
{
    return TpmTypeId::RSA_EncryptResponse_ID;
}

RSA_EncryptResponse::RSA_EncryptResponse(
    const ByteVec& _outData
)
{
    outData = _outData;
}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
RSA_EncryptResponse::~RSA_EncryptResponse() {}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
TpmStructureBase* RSA_EncryptResponse::Clone() const
{
    return new RSA_EncryptResponse(*this);
}

void* RSA_EncryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_RSA_Decrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
}

TPM2_RSA_Decrypt_REQUEST::TPM2_RSA_Decrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _cipherText,
    const TPMU_ASYM_SCHEME& _inScheme,
    const ByteVec& _label
)
{
    keyHandle = _keyHandle;
    cipherText = _cipherText;
    inScheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone()));
    label = _label;
}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
TPM2_RSA_Decrypt_REQUEST::~TPM2_RSA_Decrypt_REQUEST() {}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
TpmStructureBase* TPM2_RSA_Decrypt_REQUEST::Clone() const
{
    return new TPM2_RSA_Decrypt_REQUEST(*this);
}

void* TPM2_RSA_Decrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &cipherTextSize;
            case 2: { if (newArraySize != -1) cipherText.resize(newArraySize); arraySize = (int)cipherText.size(); return &cipherText; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: return &labelSize;
            case 6: { if (newArraySize != -1) label.resize(newArraySize); arraySize = (int)label.size(); return &label; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &cipherText[arrayIndex];
            case 6: return &label[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId RSA_DecryptResponse::GetTypeId() const
{
    return TpmTypeId::RSA_DecryptResponse_ID;
}

RSA_DecryptResponse::RSA_DecryptResponse(
    const ByteVec& _message
)
{
    message = _message;
}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
RSA_DecryptResponse::~RSA_DecryptResponse() {}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
TpmStructureBase* RSA_DecryptResponse::Clone() const
{
    return new RSA_DecryptResponse(*this);
}

void* RSA_DecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &messageSize;
            case 1: { if (newArraySize != -1) message.resize(newArraySize); arraySize = (int)message.size(); return &message; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &message[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ECDH_KeyGen_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID;
}

TPM2_ECDH_KeyGen_REQUEST::TPM2_ECDH_KeyGen_REQUEST(const TPM_HANDLE& _keyHandle)
{
    keyHandle = _keyHandle;
}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
TPM2_ECDH_KeyGen_REQUEST::~TPM2_ECDH_KeyGen_REQUEST() {}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
TpmStructureBase* TPM2_ECDH_KeyGen_REQUEST::Clone() const
{
    return new TPM2_ECDH_KeyGen_REQUEST(*this);
}

void* TPM2_ECDH_KeyGen_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ECDH_KeyGenResponse::GetTypeId() const
{
    return TpmTypeId::ECDH_KeyGenResponse_ID;
}

ECDH_KeyGenResponse::ECDH_KeyGenResponse(
    const TPMS_ECC_POINT& _zPoint,
    const TPMS_ECC_POINT& _pubPoint
)
{
    zPoint = _zPoint;
    pubPoint = _pubPoint;
}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
ECDH_KeyGenResponse::~ECDH_KeyGenResponse() {}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
TpmStructureBase* ECDH_KeyGenResponse::Clone() const
{
    return new ECDH_KeyGenResponse(*this);
}

void* ECDH_KeyGenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &zPointSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&zPoint); return &zPoint;
            case 2: return &pubPointSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&pubPoint); return &pubPoint;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ECDH_ZGen_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
}

TPM2_ECDH_ZGen_REQUEST::TPM2_ECDH_ZGen_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const TPMS_ECC_POINT& _inPoint
)
{
    keyHandle = _keyHandle;
    inPoint = _inPoint;
}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
TPM2_ECDH_ZGen_REQUEST::~TPM2_ECDH_ZGen_REQUEST() {}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
TpmStructureBase* TPM2_ECDH_ZGen_REQUEST::Clone() const
{
    return new TPM2_ECDH_ZGen_REQUEST(*this);
}

void* TPM2_ECDH_ZGen_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &inPointSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inPoint); return &inPoint;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ECDH_ZGenResponse::GetTypeId() const
{
    return TpmTypeId::ECDH_ZGenResponse_ID;
}

ECDH_ZGenResponse::ECDH_ZGenResponse(
    const TPMS_ECC_POINT& _outPoint
)
{
    outPoint = _outPoint;
}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
ECDH_ZGenResponse::~ECDH_ZGenResponse() {}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
TpmStructureBase* ECDH_ZGenResponse::Clone() const
{
    return new ECDH_ZGenResponse(*this);
}

void* ECDH_ZGenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outPointSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPoint); return &outPoint;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ECC_Parameters_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID;
}

TPM2_ECC_Parameters_REQUEST::TPM2_ECC_Parameters_REQUEST(TPM_ECC_CURVE _curveID)
{
    curveID = _curveID;
}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
TPM2_ECC_Parameters_REQUEST::~TPM2_ECC_Parameters_REQUEST() {}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
TpmStructureBase* TPM2_ECC_Parameters_REQUEST::Clone() const
{
    return new TPM2_ECC_Parameters_REQUEST(*this);
}

void* TPM2_ECC_Parameters_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &curveID;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ECC_ParametersResponse::GetTypeId() const
{
    return TpmTypeId::ECC_ParametersResponse_ID;
}

ECC_ParametersResponse::ECC_ParametersResponse(const TPMS_ALGORITHM_DETAIL_ECC& _parameters)
{
    parameters = _parameters;
}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
ECC_ParametersResponse::~ECC_ParametersResponse() {}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
TpmStructureBase* ECC_ParametersResponse::Clone() const
{
    return new ECC_ParametersResponse(*this);
}

void* ECC_ParametersResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parameters); return &parameters;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ZGen_2Phase_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
}

TPM2_ZGen_2Phase_REQUEST::TPM2_ZGen_2Phase_REQUEST(
    const TPM_HANDLE& _keyA,
    const TPMS_ECC_POINT& _inQsB,
    const TPMS_ECC_POINT& _inQeB,
    TPM_ALG_ID _inScheme,
    UINT16 _counter
)
{
    keyA = _keyA;
    inQsB = _inQsB;
    inQeB = _inQeB;
    inScheme = _inScheme;
    counter = _counter;
}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
TPM2_ZGen_2Phase_REQUEST::~TPM2_ZGen_2Phase_REQUEST() {}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
TpmStructureBase* TPM2_ZGen_2Phase_REQUEST::Clone() const
{
    return new TPM2_ZGen_2Phase_REQUEST(*this);
}

void* TPM2_ZGen_2Phase_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyA); return &keyA;
            case 1: return &inQsBSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inQsB); return &inQsB;
            case 3: return &inQeBSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inQeB); return &inQeB;
            case 5: return &inScheme;
            case 6: return &counter;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ZGen_2PhaseResponse::GetTypeId() const
{
    return TpmTypeId::ZGen_2PhaseResponse_ID;
}

ZGen_2PhaseResponse::ZGen_2PhaseResponse(
    const TPMS_ECC_POINT& _outZ1,
    const TPMS_ECC_POINT& _outZ2
)
{
    outZ1 = _outZ1;
    outZ2 = _outZ2;
}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
ZGen_2PhaseResponse::~ZGen_2PhaseResponse() {}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
TpmStructureBase* ZGen_2PhaseResponse::Clone() const
{
    return new ZGen_2PhaseResponse(*this);
}

void* ZGen_2PhaseResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outZ1Size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outZ1); return &outZ1;
            case 2: return &outZ2Size;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&outZ2); return &outZ2;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ECC_Encrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
}

TPM2_ECC_Encrypt_REQUEST::TPM2_ECC_Encrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _plainText,
    const TPMU_KDF_SCHEME& _inScheme
)
{
    keyHandle = _keyHandle;
    plainText = _plainText;
    inScheme.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
TPM2_ECC_Encrypt_REQUEST::~TPM2_ECC_Encrypt_REQUEST() {}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
TpmStructureBase* TPM2_ECC_Encrypt_REQUEST::Clone() const
{
    return new TPM2_ECC_Encrypt_REQUEST(*this);
}

void* TPM2_ECC_Encrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &plainTextSize;
            case 2: { if (newArraySize != -1) plainText.resize(newArraySize); arraySize = (int)plainText.size(); return &plainText; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &plainText[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ECC_EncryptResponse::GetTypeId() const
{
    return TpmTypeId::ECC_EncryptResponse_ID;
}

ECC_EncryptResponse::ECC_EncryptResponse(
    const TPMS_ECC_POINT& _C1,
    const ByteVec& _C2,
    const ByteVec& _C3
)
{
    C1 = _C1;
    C2 = _C2;
    C3 = _C3;
}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
ECC_EncryptResponse::~ECC_EncryptResponse() {}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
TpmStructureBase* ECC_EncryptResponse::Clone() const
{
    return new ECC_EncryptResponse(*this);
}

void* ECC_EncryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &C1Size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&C1); return &C1;
            case 2: return &C2Size;
            case 3: { if (newArraySize != -1) C2.resize(newArraySize); arraySize = (int)C2.size(); return &C2; }
            case 4: return &C3Size;
            case 5: { if (newArraySize != -1) C3.resize(newArraySize); arraySize = (int)C3.size(); return &C3; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &C2[arrayIndex];
            case 5: return &C3[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ECC_Decrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
}

TPM2_ECC_Decrypt_REQUEST::TPM2_ECC_Decrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const TPMS_ECC_POINT& _C1,
    const ByteVec& _C2,
    const ByteVec& _C3,
    const TPMU_KDF_SCHEME& _inScheme
)
{
    keyHandle = _keyHandle;
    C1 = _C1;
    C2 = _C2;
    C3 = _C3;
    inScheme.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command performs ECC decryption. </summary>
TPM2_ECC_Decrypt_REQUEST::~TPM2_ECC_Decrypt_REQUEST() {}

/// <summary> This command performs ECC decryption. </summary>
TpmStructureBase* TPM2_ECC_Decrypt_REQUEST::Clone() const
{
    return new TPM2_ECC_Decrypt_REQUEST(*this);
}

void* TPM2_ECC_Decrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &C1Size;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&C1); return &C1;
            case 3: return &C2Size;
            case 4: { if (newArraySize != -1) C2.resize(newArraySize); arraySize = (int)C2.size(); return &C2; }
            case 5: return &C3Size;
            case 6: { if (newArraySize != -1) C3.resize(newArraySize); arraySize = (int)C3.size(); return &C3; }
            case 7: return &inSchemeScheme;
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &C2[arrayIndex];
            case 6: return &C3[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ECC_DecryptResponse::GetTypeId() const
{
    return TpmTypeId::ECC_DecryptResponse_ID;
}

ECC_DecryptResponse::ECC_DecryptResponse(
    const ByteVec& _plainText
)
{
    plainText = _plainText;
}

/// <summary> This command performs ECC decryption. </summary>
ECC_DecryptResponse::~ECC_DecryptResponse() {}

/// <summary> This command performs ECC decryption. </summary>
TpmStructureBase* ECC_DecryptResponse::Clone() const
{
    return new ECC_DecryptResponse(*this);
}

void* ECC_DecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &plainTextSize;
            case 1: { if (newArraySize != -1) plainText.resize(newArraySize); arraySize = (int)plainText.size(); return &plainText; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &plainText[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_EncryptDecrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
}

TPM2_EncryptDecrypt_REQUEST::TPM2_EncryptDecrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    BYTE _decrypt,
    TPM_ALG_ID _mode,
    const ByteVec& _ivIn,
    const ByteVec& _inData
)
{
    keyHandle = _keyHandle;
    decrypt = _decrypt;
    mode = _mode;
    ivIn = _ivIn;
    inData = _inData;
}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
TPM2_EncryptDecrypt_REQUEST::~TPM2_EncryptDecrypt_REQUEST() {}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
TpmStructureBase* TPM2_EncryptDecrypt_REQUEST::Clone() const
{
    return new TPM2_EncryptDecrypt_REQUEST(*this);
}

void* TPM2_EncryptDecrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &decrypt;
            case 2: return &mode;
            case 3: return &ivInSize;
            case 4: { if (newArraySize != -1) ivIn.resize(newArraySize); arraySize = (int)ivIn.size(); return &ivIn; }
            case 5: return &inDataSize;
            case 6: { if (newArraySize != -1) inData.resize(newArraySize); arraySize = (int)inData.size(); return &inData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &ivIn[arrayIndex];
            case 6: return &inData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId EncryptDecryptResponse::GetTypeId() const
{
    return TpmTypeId::EncryptDecryptResponse_ID;
}

EncryptDecryptResponse::EncryptDecryptResponse(
    const ByteVec& _outData,
    const ByteVec& _ivOut
)
{
    outData = _outData;
    ivOut = _ivOut;
}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
EncryptDecryptResponse::~EncryptDecryptResponse() {}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
TpmStructureBase* EncryptDecryptResponse::Clone() const
{
    return new EncryptDecryptResponse(*this);
}

void* EncryptDecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            case 2: return &ivOutSize;
            case 3: { if (newArraySize != -1) ivOut.resize(newArraySize); arraySize = (int)ivOut.size(); return &ivOut; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            case 3: return &ivOut[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_EncryptDecrypt2_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
}

TPM2_EncryptDecrypt2_REQUEST::TPM2_EncryptDecrypt2_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _inData,
    BYTE _decrypt,
    TPM_ALG_ID _mode,
    const ByteVec& _ivIn
)
{
    keyHandle = _keyHandle;
    inData = _inData;
    decrypt = _decrypt;
    mode = _mode;
    ivIn = _ivIn;
}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
TPM2_EncryptDecrypt2_REQUEST::~TPM2_EncryptDecrypt2_REQUEST() {}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
TpmStructureBase* TPM2_EncryptDecrypt2_REQUEST::Clone() const
{
    return new TPM2_EncryptDecrypt2_REQUEST(*this);
}

void* TPM2_EncryptDecrypt2_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &inDataSize;
            case 2: { if (newArraySize != -1) inData.resize(newArraySize); arraySize = (int)inData.size(); return &inData; }
            case 3: return &decrypt;
            case 4: return &mode;
            case 5: return &ivInSize;
            case 6: { if (newArraySize != -1) ivIn.resize(newArraySize); arraySize = (int)ivIn.size(); return &ivIn; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &inData[arrayIndex];
            case 6: return &ivIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId EncryptDecrypt2Response::GetTypeId() const
{
    return TpmTypeId::EncryptDecrypt2Response_ID;
}

EncryptDecrypt2Response::EncryptDecrypt2Response(
    const ByteVec& _outData,
    const ByteVec& _ivOut
)
{
    outData = _outData;
    ivOut = _ivOut;
}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
EncryptDecrypt2Response::~EncryptDecrypt2Response() {}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
TpmStructureBase* EncryptDecrypt2Response::Clone() const
{
    return new EncryptDecrypt2Response(*this);
}

void* EncryptDecrypt2Response::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            case 2: return &ivOutSize;
            case 3: { if (newArraySize != -1) ivOut.resize(newArraySize); arraySize = (int)ivOut.size(); return &ivOut; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            case 3: return &ivOut[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Hash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Hash_REQUEST_ID;
}

TPM2_Hash_REQUEST::TPM2_Hash_REQUEST(
    const ByteVec& _data,
    TPM_ALG_ID _hashAlg,
    const TPM_HANDLE& _hierarchy
)
{
    data = _data;
    hashAlg = _hashAlg;
    hierarchy = _hierarchy;
}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
TPM2_Hash_REQUEST::~TPM2_Hash_REQUEST() {}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
TpmStructureBase* TPM2_Hash_REQUEST::Clone() const
{
    return new TPM2_Hash_REQUEST(*this);
}

void* TPM2_Hash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &dataSize;
            case 1: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            case 2: return &hashAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HashResponse::GetTypeId() const
{
    return TpmTypeId::HashResponse_ID;
}

HashResponse::HashResponse(
    const ByteVec& _outHash,
    const TPMT_TK_HASHCHECK& _validation
)
{
    outHash = _outHash;
    validation = _validation;
}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
HashResponse::~HashResponse() {}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
TpmStructureBase* HashResponse::Clone() const
{
    return new HashResponse(*this);
}

void* HashResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outHashSize;
            case 1: { if (newArraySize != -1) outHash.resize(newArraySize); arraySize = (int)outHash.size(); return &outHash; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_HMAC_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HMAC_REQUEST_ID;
}

TPM2_HMAC_REQUEST::TPM2_HMAC_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _buffer,
    TPM_ALG_ID _hashAlg
)
{
    handle = _handle;
    buffer = _buffer;
    hashAlg = _hashAlg;
}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
TPM2_HMAC_REQUEST::~TPM2_HMAC_REQUEST() {}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
TpmStructureBase* TPM2_HMAC_REQUEST::Clone() const
{
    return new TPM2_HMAC_REQUEST(*this);
}

void* TPM2_HMAC_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            case 3: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HMACResponse::GetTypeId() const
{
    return TpmTypeId::HMACResponse_ID;
}

HMACResponse::HMACResponse(
    const ByteVec& _outHMAC
)
{
    outHMAC = _outHMAC;
}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
HMACResponse::~HMACResponse() {}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
TpmStructureBase* HMACResponse::Clone() const
{
    return new HMACResponse(*this);
}

void* HMACResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outHMACSize;
            case 1: { if (newArraySize != -1) outHMAC.resize(newArraySize); arraySize = (int)outHMAC.size(); return &outHMAC; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outHMAC[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_MAC_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MAC_REQUEST_ID;
}

TPM2_MAC_REQUEST::TPM2_MAC_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _buffer,
    TPM_ALG_ID _inScheme
)
{
    handle = _handle;
    buffer = _buffer;
    inScheme = _inScheme;
}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
TPM2_MAC_REQUEST::~TPM2_MAC_REQUEST() {}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
TpmStructureBase* TPM2_MAC_REQUEST::Clone() const
{
    return new TPM2_MAC_REQUEST(*this);
}

void* TPM2_MAC_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            case 3: return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId MACResponse::GetTypeId() const
{
    return TpmTypeId::MACResponse_ID;
}

MACResponse::MACResponse(
    const ByteVec& _outMAC
)
{
    outMAC = _outMAC;
}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
MACResponse::~MACResponse() {}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
TpmStructureBase* MACResponse::Clone() const
{
    return new MACResponse(*this);
}

void* MACResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outMACSize;
            case 1: { if (newArraySize != -1) outMAC.resize(newArraySize); arraySize = (int)outMAC.size(); return &outMAC; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outMAC[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_GetRandom_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetRandom_REQUEST_ID;
}

TPM2_GetRandom_REQUEST::TPM2_GetRandom_REQUEST(UINT16 _bytesRequested)
{
    bytesRequested = _bytesRequested;
}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
TPM2_GetRandom_REQUEST::~TPM2_GetRandom_REQUEST() {}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
TpmStructureBase* TPM2_GetRandom_REQUEST::Clone() const
{
    return new TPM2_GetRandom_REQUEST(*this);
}

void* TPM2_GetRandom_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &bytesRequested;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId GetRandomResponse::GetTypeId() const
{
    return TpmTypeId::GetRandomResponse_ID;
}

GetRandomResponse::GetRandomResponse(
    const ByteVec& _randomBytes
)
{
    randomBytes = _randomBytes;
}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
GetRandomResponse::~GetRandomResponse() {}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
TpmStructureBase* GetRandomResponse::Clone() const
{
    return new GetRandomResponse(*this);
}

void* GetRandomResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &randomBytesSize;
            case 1: { if (newArraySize != -1) randomBytes.resize(newArraySize); arraySize = (int)randomBytes.size(); return &randomBytes; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &randomBytes[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_StirRandom_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_StirRandom_REQUEST_ID;
}

TPM2_StirRandom_REQUEST::TPM2_StirRandom_REQUEST(
    const ByteVec& _inData
)
{
    inData = _inData;
}

/// <summary> This command is used to add "additional information" to the RNG state. </summary>
TPM2_StirRandom_REQUEST::~TPM2_StirRandom_REQUEST() {}

/// <summary> This command is used to add "additional information" to the RNG state. </summary>
TpmStructureBase* TPM2_StirRandom_REQUEST::Clone() const
{
    return new TPM2_StirRandom_REQUEST(*this);
}

void* TPM2_StirRandom_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &inDataSize;
            case 1: { if (newArraySize != -1) inData.resize(newArraySize); arraySize = (int)inData.size(); return &inData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &inData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_HMAC_Start_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
}

TPM2_HMAC_Start_REQUEST::TPM2_HMAC_Start_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _auth,
    TPM_ALG_ID _hashAlg
)
{
    handle = _handle;
    auth = _auth;
    hashAlg = _hashAlg;
}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TPM2_HMAC_Start_REQUEST::~TPM2_HMAC_Start_REQUEST() {}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* TPM2_HMAC_Start_REQUEST::Clone() const
{
    return new TPM2_HMAC_Start_REQUEST(*this);
}

void* TPM2_HMAC_Start_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 3: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HMAC_StartResponse::GetTypeId() const
{
    return TpmTypeId::HMAC_StartResponse_ID;
}

HMAC_StartResponse::HMAC_StartResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
HMAC_StartResponse::~HMAC_StartResponse() {}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* HMAC_StartResponse::Clone() const
{
    return new HMAC_StartResponse(*this);
}

void* HMAC_StartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_MAC_Start_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
}

TPM2_MAC_Start_REQUEST::TPM2_MAC_Start_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _auth,
    TPM_ALG_ID _inScheme
)
{
    handle = _handle;
    auth = _auth;
    inScheme = _inScheme;
}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TPM2_MAC_Start_REQUEST::~TPM2_MAC_Start_REQUEST() {}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* TPM2_MAC_Start_REQUEST::Clone() const
{
    return new TPM2_MAC_Start_REQUEST(*this);
}

void* TPM2_MAC_Start_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 3: return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId MAC_StartResponse::GetTypeId() const
{
    return TpmTypeId::MAC_StartResponse_ID;
}

MAC_StartResponse::MAC_StartResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
MAC_StartResponse::~MAC_StartResponse() {}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* MAC_StartResponse::Clone() const
{
    return new MAC_StartResponse(*this);
}

void* MAC_StartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_HashSequenceStart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
}

TPM2_HashSequenceStart_REQUEST::TPM2_HashSequenceStart_REQUEST(
    const ByteVec& _auth,
    TPM_ALG_ID _hashAlg
)
{
    auth = _auth;
    hashAlg = _hashAlg;
}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
TPM2_HashSequenceStart_REQUEST::~TPM2_HashSequenceStart_REQUEST() {}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
TpmStructureBase* TPM2_HashSequenceStart_REQUEST::Clone() const
{
    return new TPM2_HashSequenceStart_REQUEST(*this);
}

void* TPM2_HashSequenceStart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &authSize;
            case 1: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 2: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HashSequenceStartResponse::GetTypeId() const
{
    return TpmTypeId::HashSequenceStartResponse_ID;
}

HashSequenceStartResponse::HashSequenceStartResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
HashSequenceStartResponse::~HashSequenceStartResponse() {}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
TpmStructureBase* HashSequenceStartResponse::Clone() const
{
    return new HashSequenceStartResponse(*this);
}

void* HashSequenceStartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_SequenceUpdate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
}

TPM2_SequenceUpdate_REQUEST::TPM2_SequenceUpdate_REQUEST(
    const TPM_HANDLE& _sequenceHandle,
    const ByteVec& _buffer
)
{
    sequenceHandle = _sequenceHandle;
    buffer = _buffer;
}

/// <summary> This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM. </summary>
TPM2_SequenceUpdate_REQUEST::~TPM2_SequenceUpdate_REQUEST() {}

/// <summary> This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM. </summary>
TpmStructureBase* TPM2_SequenceUpdate_REQUEST::Clone() const
{
    return new TPM2_SequenceUpdate_REQUEST(*this);
}

void* TPM2_SequenceUpdate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return &sequenceHandle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_SequenceComplete_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
}

TPM2_SequenceComplete_REQUEST::TPM2_SequenceComplete_REQUEST(
    const TPM_HANDLE& _sequenceHandle,
    const ByteVec& _buffer,
    const TPM_HANDLE& _hierarchy
)
{
    sequenceHandle = _sequenceHandle;
    buffer = _buffer;
    hierarchy = _hierarchy;
}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
TPM2_SequenceComplete_REQUEST::~TPM2_SequenceComplete_REQUEST() {}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
TpmStructureBase* TPM2_SequenceComplete_REQUEST::Clone() const
{
    return new TPM2_SequenceComplete_REQUEST(*this);
}

void* TPM2_SequenceComplete_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return &sequenceHandle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SequenceCompleteResponse::GetTypeId() const
{
    return TpmTypeId::SequenceCompleteResponse_ID;
}

SequenceCompleteResponse::SequenceCompleteResponse(
    const ByteVec& _result,
    const TPMT_TK_HASHCHECK& _validation
)
{
    result = _result;
    validation = _validation;
}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
SequenceCompleteResponse::~SequenceCompleteResponse() {}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
TpmStructureBase* SequenceCompleteResponse::Clone() const
{
    return new SequenceCompleteResponse(*this);
}

void* SequenceCompleteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &resultSize;
            case 1: { if (newArraySize != -1) result.resize(newArraySize); arraySize = (int)result.size(); return &result; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &result[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_EventSequenceComplete_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
}

TPM2_EventSequenceComplete_REQUEST::TPM2_EventSequenceComplete_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const TPM_HANDLE& _sequenceHandle,
    const ByteVec& _buffer
)
{
    pcrHandle = _pcrHandle;
    sequenceHandle = _sequenceHandle;
    buffer = _buffer;
}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
TPM2_EventSequenceComplete_REQUEST::~TPM2_EventSequenceComplete_REQUEST() {}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
TpmStructureBase* TPM2_EventSequenceComplete_REQUEST::Clone() const
{
    return new TPM2_EventSequenceComplete_REQUEST(*this);
}

void* TPM2_EventSequenceComplete_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return &sequenceHandle;
            case 2: return &bufferSize;
            case 3: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId EventSequenceCompleteResponse::GetTypeId() const
{
    return TpmTypeId::EventSequenceCompleteResponse_ID;
}

EventSequenceCompleteResponse::EventSequenceCompleteResponse(
    const vector<TPMT_HA>& _results
)
{
    results = _results;
}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
EventSequenceCompleteResponse::~EventSequenceCompleteResponse() {}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
TpmStructureBase* EventSequenceCompleteResponse::Clone() const
{
    return new EventSequenceCompleteResponse(*this);
}

void* EventSequenceCompleteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &resultsCount;
            case 1: { if (newArraySize != -1) results.resize(newArraySize); arraySize = (int)results.size(); return &results; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&results[arrayIndex]); return &results[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Certify_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Certify_REQUEST_ID;
}

TPM2_Certify_REQUEST::TPM2_Certify_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    objectHandle = _objectHandle;
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
TPM2_Certify_REQUEST::~TPM2_Certify_REQUEST() {}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
TpmStructureBase* TPM2_Certify_REQUEST::Clone() const
{
    return new TPM2_Certify_REQUEST(*this);
}

void* TPM2_Certify_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CertifyResponse::GetTypeId() const
{
    return TpmTypeId::CertifyResponse_ID;
}

CertifyResponse::CertifyResponse(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo = _certifyInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
CertifyResponse::~CertifyResponse() {}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
TpmStructureBase* CertifyResponse::Clone() const
{
    return new CertifyResponse(*this);
}

void* CertifyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certifyInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return &certifyInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_CertifyCreation_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
}

TPM2_CertifyCreation_REQUEST::TPM2_CertifyCreation_REQUEST(
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _objectHandle,
    const ByteVec& _qualifyingData,
    const ByteVec& _creationHash,
    const TPMU_SIG_SCHEME& _inScheme,
    const TPMT_TK_CREATION& _creationTicket
)
{
    signHandle = _signHandle;
    objectHandle = _objectHandle;
    qualifyingData = _qualifyingData;
    creationHash = _creationHash;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    creationTicket = _creationTicket;
}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
TPM2_CertifyCreation_REQUEST::~TPM2_CertifyCreation_REQUEST() {}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
TpmStructureBase* TPM2_CertifyCreation_REQUEST::Clone() const
{
    return new TPM2_CertifyCreation_REQUEST(*this);
}

void* TPM2_CertifyCreation_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &creationHashSize;
            case 5: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            case 6: return &inSchemeScheme;
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return &creationTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            case 5: return &creationHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CertifyCreationResponse::GetTypeId() const
{
    return TpmTypeId::CertifyCreationResponse_ID;
}

CertifyCreationResponse::CertifyCreationResponse(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo = _certifyInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
CertifyCreationResponse::~CertifyCreationResponse() {}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
TpmStructureBase* CertifyCreationResponse::Clone() const
{
    return new CertifyCreationResponse(*this);
}

void* CertifyCreationResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certifyInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return &certifyInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Quote_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Quote_REQUEST_ID;
}

TPM2_Quote_REQUEST::TPM2_Quote_REQUEST(
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme,
    const vector<TPMS_PCR_SELECTION>& _PCRselect
)
{
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    PCRselect = _PCRselect;
}

/// <summary> This command is used to quote PCR values. </summary>
TPM2_Quote_REQUEST::~TPM2_Quote_REQUEST() {}

/// <summary> This command is used to quote PCR values. </summary>
TpmStructureBase* TPM2_Quote_REQUEST::Clone() const
{
    return new TPM2_Quote_REQUEST(*this);
}

void* TPM2_Quote_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: return &qualifyingDataSize;
            case 2: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: return &PCRselectCount;
            case 6: { if (newArraySize != -1) PCRselect.resize(newArraySize); arraySize = (int)PCRselect.size(); return &PCRselect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &qualifyingData[arrayIndex];
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&PCRselect[arrayIndex]); return &PCRselect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId QuoteResponse::GetTypeId() const
{
    return TpmTypeId::QuoteResponse_ID;
}

QuoteResponse::QuoteResponse(
    const TPMS_ATTEST& _quoted,
    const TPMU_SIGNATURE& _signature
)
{
    quoted = _quoted;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command is used to quote PCR values. </summary>
QuoteResponse::~QuoteResponse() {}

/// <summary> This command is used to quote PCR values. </summary>
TpmStructureBase* QuoteResponse::Clone() const
{
    return new QuoteResponse(*this);
}

void* QuoteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &quotedSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&quoted); return &quoted;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_GetSessionAuditDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
}

TPM2_GetSessionAuditDigest_REQUEST::TPM2_GetSessionAuditDigest_REQUEST(
    const TPM_HANDLE& _privacyAdminHandle,
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _sessionHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyAdminHandle = _privacyAdminHandle;
    signHandle = _signHandle;
    sessionHandle = _sessionHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
TPM2_GetSessionAuditDigest_REQUEST::~TPM2_GetSessionAuditDigest_REQUEST() {}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
TpmStructureBase* TPM2_GetSessionAuditDigest_REQUEST::Clone() const
{
    return new TPM2_GetSessionAuditDigest_REQUEST(*this);
}

void* TPM2_GetSessionAuditDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyAdminHandle); return &privacyAdminHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return &sessionHandle;
            case 3: return &qualifyingDataSize;
            case 4: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 5: return &inSchemeScheme;
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId GetSessionAuditDigestResponse::GetTypeId() const
{
    return TpmTypeId::GetSessionAuditDigestResponse_ID;
}

GetSessionAuditDigestResponse::GetSessionAuditDigestResponse(
    const TPMS_ATTEST& _auditInfo,
    const TPMU_SIGNATURE& _signature
)
{
    auditInfo = _auditInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
GetSessionAuditDigestResponse::~GetSessionAuditDigestResponse() {}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
TpmStructureBase* GetSessionAuditDigestResponse::Clone() const
{
    return new GetSessionAuditDigestResponse(*this);
}

void* GetSessionAuditDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &auditInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&auditInfo); return &auditInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_GetCommandAuditDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
}

TPM2_GetCommandAuditDigest_REQUEST::TPM2_GetCommandAuditDigest_REQUEST(
    const TPM_HANDLE& _privacyHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyHandle = _privacyHandle;
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
TPM2_GetCommandAuditDigest_REQUEST::~TPM2_GetCommandAuditDigest_REQUEST() {}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
TpmStructureBase* TPM2_GetCommandAuditDigest_REQUEST::Clone() const
{
    return new TPM2_GetCommandAuditDigest_REQUEST(*this);
}

void* TPM2_GetCommandAuditDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyHandle); return &privacyHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId GetCommandAuditDigestResponse::GetTypeId() const
{
    return TpmTypeId::GetCommandAuditDigestResponse_ID;
}

GetCommandAuditDigestResponse::GetCommandAuditDigestResponse(
    const TPMS_ATTEST& _auditInfo,
    const TPMU_SIGNATURE& _signature
)
{
    auditInfo = _auditInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
GetCommandAuditDigestResponse::~GetCommandAuditDigestResponse() {}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
TpmStructureBase* GetCommandAuditDigestResponse::Clone() const
{
    return new GetCommandAuditDigestResponse(*this);
}

void* GetCommandAuditDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &auditInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&auditInfo); return &auditInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_GetTime_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetTime_REQUEST_ID;
}

TPM2_GetTime_REQUEST::TPM2_GetTime_REQUEST(
    const TPM_HANDLE& _privacyAdminHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyAdminHandle = _privacyAdminHandle;
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command returns the current values of Time and Clock. </summary>
TPM2_GetTime_REQUEST::~TPM2_GetTime_REQUEST() {}

/// <summary> This command returns the current values of Time and Clock. </summary>
TpmStructureBase* TPM2_GetTime_REQUEST::Clone() const
{
    return new TPM2_GetTime_REQUEST(*this);
}

void* TPM2_GetTime_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyAdminHandle); return &privacyAdminHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId GetTimeResponse::GetTypeId() const
{
    return TpmTypeId::GetTimeResponse_ID;
}

GetTimeResponse::GetTimeResponse(
    const TPMS_ATTEST& _timeInfo,
    const TPMU_SIGNATURE& _signature
)
{
    timeInfo = _timeInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command returns the current values of Time and Clock. </summary>
GetTimeResponse::~GetTimeResponse() {}

/// <summary> This command returns the current values of Time and Clock. </summary>
TpmStructureBase* GetTimeResponse::Clone() const
{
    return new GetTimeResponse(*this);
}

void* GetTimeResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &timeInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&timeInfo); return &timeInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_CertifyX509_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
}

TPM2_CertifyX509_REQUEST::TPM2_CertifyX509_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _reserved,
    const TPMU_SIG_SCHEME& _inScheme,
    const ByteVec& _partialCertificate
)
{
    objectHandle = _objectHandle;
    signHandle = _signHandle;
    reserved = _reserved;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    partialCertificate = _partialCertificate;
}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
TPM2_CertifyX509_REQUEST::~TPM2_CertifyX509_REQUEST() {}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
TpmStructureBase* TPM2_CertifyX509_REQUEST::Clone() const
{
    return new TPM2_CertifyX509_REQUEST(*this);
}

void* TPM2_CertifyX509_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &reservedSize;
            case 3: { if (newArraySize != -1) reserved.resize(newArraySize); arraySize = (int)reserved.size(); return &reserved; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 6: return &partialCertificateSize;
            case 7: { if (newArraySize != -1) partialCertificate.resize(newArraySize); arraySize = (int)partialCertificate.size(); return &partialCertificate; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &reserved[arrayIndex];
            case 7: return &partialCertificate[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CertifyX509Response::GetTypeId() const
{
    return TpmTypeId::CertifyX509Response_ID;
}

CertifyX509Response::CertifyX509Response(
    const ByteVec& _addedToCertificate,
    const ByteVec& _tbsDigest,
    const TPMU_SIGNATURE& _signature
)
{
    addedToCertificate = _addedToCertificate;
    tbsDigest = _tbsDigest;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
CertifyX509Response::~CertifyX509Response() {}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
TpmStructureBase* CertifyX509Response::Clone() const
{
    return new CertifyX509Response(*this);
}

void* CertifyX509Response::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &addedToCertificateSize;
            case 1: { if (newArraySize != -1) addedToCertificate.resize(newArraySize); arraySize = (int)addedToCertificate.size(); return &addedToCertificate; }
            case 2: return &tbsDigestSize;
            case 3: { if (newArraySize != -1) tbsDigest.resize(newArraySize); arraySize = (int)tbsDigest.size(); return &tbsDigest; }
            case 4: return &signatureSigAlg;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &addedToCertificate[arrayIndex];
            case 3: return &tbsDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Commit_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Commit_REQUEST_ID;
}

TPM2_Commit_REQUEST::TPM2_Commit_REQUEST(
    const TPM_HANDLE& _signHandle,
    const TPMS_ECC_POINT& _P1,
    const ByteVec& _s2,
    const ByteVec& _y2
)
{
    signHandle = _signHandle;
    P1 = _P1;
    s2 = _s2;
    y2 = _y2;
}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
TPM2_Commit_REQUEST::~TPM2_Commit_REQUEST() {}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
TpmStructureBase* TPM2_Commit_REQUEST::Clone() const
{
    return new TPM2_Commit_REQUEST(*this);
}

void* TPM2_Commit_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: return &P1Size;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&P1); return &P1;
            case 3: return &s2Size;
            case 4: { if (newArraySize != -1) s2.resize(newArraySize); arraySize = (int)s2.size(); return &s2; }
            case 5: return &y2Size;
            case 6: { if (newArraySize != -1) y2.resize(newArraySize); arraySize = (int)y2.size(); return &y2; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &s2[arrayIndex];
            case 6: return &y2[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CommitResponse::GetTypeId() const
{
    return TpmTypeId::CommitResponse_ID;
}

CommitResponse::CommitResponse(
    const TPMS_ECC_POINT& _K,
    const TPMS_ECC_POINT& _L,
    const TPMS_ECC_POINT& _E,
    UINT16 _counter
)
{
    K = _K;
    L = _L;
    E = _E;
    counter = _counter;
}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
CommitResponse::~CommitResponse() {}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
TpmStructureBase* CommitResponse::Clone() const
{
    return new CommitResponse(*this);
}

void* CommitResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &KSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&K); return &K;
            case 2: return &LSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&L); return &L;
            case 4: return &ESize;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&E); return &E;
            case 6: return &counter;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_EC_Ephemeral_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID;
}

TPM2_EC_Ephemeral_REQUEST::TPM2_EC_Ephemeral_REQUEST(TPM_ECC_CURVE _curveID)
{
    curveID = _curveID;
}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
TPM2_EC_Ephemeral_REQUEST::~TPM2_EC_Ephemeral_REQUEST() {}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
TpmStructureBase* TPM2_EC_Ephemeral_REQUEST::Clone() const
{
    return new TPM2_EC_Ephemeral_REQUEST(*this);
}

void* TPM2_EC_Ephemeral_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &curveID;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId EC_EphemeralResponse::GetTypeId() const
{
    return TpmTypeId::EC_EphemeralResponse_ID;
}

EC_EphemeralResponse::EC_EphemeralResponse(
    const TPMS_ECC_POINT& _Q,
    UINT16 _counter
)
{
    Q = _Q;
    counter = _counter;
}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
EC_EphemeralResponse::~EC_EphemeralResponse() {}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
TpmStructureBase* EC_EphemeralResponse::Clone() const
{
    return new EC_EphemeralResponse(*this);
}

void* EC_EphemeralResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &QSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&Q); return &Q;
            case 2: return &counter;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_VerifySignature_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
}

TPM2_VerifySignature_REQUEST::TPM2_VerifySignature_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _digest,
    const TPMU_SIGNATURE& _signature
)
{
    keyHandle = _keyHandle;
    digest = _digest;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
TPM2_VerifySignature_REQUEST::~TPM2_VerifySignature_REQUEST() {}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
TpmStructureBase* TPM2_VerifySignature_REQUEST::Clone() const
{
    return new TPM2_VerifySignature_REQUEST(*this);
}

void* TPM2_VerifySignature_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &digestSize;
            case 2: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            case 3: return &signatureSigAlg;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId VerifySignatureResponse::GetTypeId() const
{
    return TpmTypeId::VerifySignatureResponse_ID;
}

VerifySignatureResponse::VerifySignatureResponse(const TPMT_TK_VERIFIED& _validation)
{
    validation = _validation;
}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
VerifySignatureResponse::~VerifySignatureResponse() {}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
TpmStructureBase* VerifySignatureResponse::Clone() const
{
    return new VerifySignatureResponse(*this);
}

void* VerifySignatureResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Sign_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Sign_REQUEST_ID;
}

TPM2_Sign_REQUEST::TPM2_Sign_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _digest,
    const TPMU_SIG_SCHEME& _inScheme,
    const TPMT_TK_HASHCHECK& _validation
)
{
    keyHandle = _keyHandle;
    digest = _digest;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    validation = _validation;
}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
TPM2_Sign_REQUEST::~TPM2_Sign_REQUEST() {}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
TpmStructureBase* TPM2_Sign_REQUEST::Clone() const
{
    return new TPM2_Sign_REQUEST(*this);
}

void* TPM2_Sign_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &digestSize;
            case 2: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SignResponse::GetTypeId() const
{
    return TpmTypeId::SignResponse_ID;
}

SignResponse::SignResponse(
    const TPMU_SIGNATURE& _signature
)
{
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
SignResponse::~SignResponse() {}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
TpmStructureBase* SignResponse::Clone() const
{
    return new SignResponse(*this);
}

void* SignResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &signatureSigAlg;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_SetCommandCodeAuditStatus_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
}

TPM2_SetCommandCodeAuditStatus_REQUEST::TPM2_SetCommandCodeAuditStatus_REQUEST(
    const TPM_HANDLE& _auth,
    TPM_ALG_ID _auditAlg,
    const vector<TPM_CC>& _setList,
    const vector<TPM_CC>& _clearList
)
{
    auth = _auth;
    auditAlg = _auditAlg;
    setList = _setList;
    clearList = _clearList;
}

/// <summary> This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time. </summary>
TPM2_SetCommandCodeAuditStatus_REQUEST::~TPM2_SetCommandCodeAuditStatus_REQUEST() {}

/// <summary> This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time. </summary>
TpmStructureBase* TPM2_SetCommandCodeAuditStatus_REQUEST::Clone() const
{
    return new TPM2_SetCommandCodeAuditStatus_REQUEST(*this);
}

void* TPM2_SetCommandCodeAuditStatus_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &auditAlg;
            case 2: return &setListCount;
            case 3: { if (newArraySize != -1) setList.resize(newArraySize); arraySize = (int)setList.size(); return &setList; }
            case 4: return &clearListCount;
            case 5: { if (newArraySize != -1) clearList.resize(newArraySize); arraySize = (int)clearList.size(); return &clearList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &setList[arrayIndex];
            case 5: return &clearList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_Extend_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
}

TPM2_PCR_Extend_REQUEST::TPM2_PCR_Extend_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const vector<TPMT_HA>& _digests
)
{
    pcrHandle = _pcrHandle;
    digests = _digests;
}

/// <summary> This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg). </summary>
TPM2_PCR_Extend_REQUEST::~TPM2_PCR_Extend_REQUEST() {}

/// <summary> This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg). </summary>
TpmStructureBase* TPM2_PCR_Extend_REQUEST::Clone() const
{
    return new TPM2_PCR_Extend_REQUEST(*this);
}

void* TPM2_PCR_Extend_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: return &digestsCount;
            case 2: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_Event_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
}

TPM2_PCR_Event_REQUEST::TPM2_PCR_Event_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const ByteVec& _eventData
)
{
    pcrHandle = _pcrHandle;
    eventData = _eventData;
}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
TPM2_PCR_Event_REQUEST::~TPM2_PCR_Event_REQUEST() {}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
TpmStructureBase* TPM2_PCR_Event_REQUEST::Clone() const
{
    return new TPM2_PCR_Event_REQUEST(*this);
}

void* TPM2_PCR_Event_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: return &eventDataSize;
            case 2: { if (newArraySize != -1) eventData.resize(newArraySize); arraySize = (int)eventData.size(); return &eventData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &eventData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_EventResponse::GetTypeId() const
{
    return TpmTypeId::PCR_EventResponse_ID;
}

PCR_EventResponse::PCR_EventResponse(
    const vector<TPMT_HA>& _digests
)
{
    digests = _digests;
}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
PCR_EventResponse::~PCR_EventResponse() {}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
TpmStructureBase* PCR_EventResponse::Clone() const
{
    return new PCR_EventResponse(*this);
}

void* PCR_EventResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &digestsCount;
            case 1: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_Read_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
}

TPM2_PCR_Read_REQUEST::TPM2_PCR_Read_REQUEST(
    const vector<TPMS_PCR_SELECTION>& _pcrSelectionIn
)
{
    pcrSelectionIn = _pcrSelectionIn;
}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
TPM2_PCR_Read_REQUEST::~TPM2_PCR_Read_REQUEST() {}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
TpmStructureBase* TPM2_PCR_Read_REQUEST::Clone() const
{
    return new TPM2_PCR_Read_REQUEST(*this);
}

void* TPM2_PCR_Read_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrSelectionInCount;
            case 1: { if (newArraySize != -1) pcrSelectionIn.resize(newArraySize); arraySize = (int)pcrSelectionIn.size(); return &pcrSelectionIn; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelectionIn[arrayIndex]); return &pcrSelectionIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_ReadResponse::GetTypeId() const
{
    return TpmTypeId::PCR_ReadResponse_ID;
}

PCR_ReadResponse::PCR_ReadResponse(
    UINT32 _pcrUpdateCounter,
    const vector<TPMS_PCR_SELECTION>& _pcrSelectionOut,
    const vector<TPM2B_DIGEST>& _pcrValues
)
{
    pcrUpdateCounter = _pcrUpdateCounter;
    pcrSelectionOut = _pcrSelectionOut;
    pcrValues = _pcrValues;
}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
PCR_ReadResponse::~PCR_ReadResponse() {}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
TpmStructureBase* PCR_ReadResponse::Clone() const
{
    return new PCR_ReadResponse(*this);
}

void* PCR_ReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrUpdateCounter;
            case 1: return &pcrSelectionOutCount;
            case 2: { if (newArraySize != -1) pcrSelectionOut.resize(newArraySize); arraySize = (int)pcrSelectionOut.size(); return &pcrSelectionOut; }
            case 3: return &pcrValuesCount;
            case 4: { if (newArraySize != -1) pcrValues.resize(newArraySize); arraySize = (int)pcrValues.size(); return &pcrValues; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelectionOut[arrayIndex]); return &pcrSelectionOut[arrayIndex];
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrValues[arrayIndex]); return &pcrValues[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_Allocate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
}

TPM2_PCR_Allocate_REQUEST::TPM2_PCR_Allocate_REQUEST(
    const TPM_HANDLE& _authHandle,
    const vector<TPMS_PCR_SELECTION>& _pcrAllocation
)
{
    authHandle = _authHandle;
    pcrAllocation = _pcrAllocation;
}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
TPM2_PCR_Allocate_REQUEST::~TPM2_PCR_Allocate_REQUEST() {}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
TpmStructureBase* TPM2_PCR_Allocate_REQUEST::Clone() const
{
    return new TPM2_PCR_Allocate_REQUEST(*this);
}

void* TPM2_PCR_Allocate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &pcrAllocationCount;
            case 2: { if (newArraySize != -1) pcrAllocation.resize(newArraySize); arraySize = (int)pcrAllocation.size(); return &pcrAllocation; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pcrAllocation[arrayIndex]); return &pcrAllocation[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_AllocateResponse::GetTypeId() const
{
    return TpmTypeId::PCR_AllocateResponse_ID;
}

PCR_AllocateResponse::PCR_AllocateResponse(
    BYTE _allocationSuccess,
    UINT32 _maxPCR,
    UINT32 _sizeNeeded,
    UINT32 _sizeAvailable
)
{
    allocationSuccess = _allocationSuccess;
    maxPCR = _maxPCR;
    sizeNeeded = _sizeNeeded;
    sizeAvailable = _sizeAvailable;
}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
PCR_AllocateResponse::~PCR_AllocateResponse() {}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
TpmStructureBase* PCR_AllocateResponse::Clone() const
{
    return new PCR_AllocateResponse(*this);
}

void* PCR_AllocateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &allocationSuccess;
            case 1: return &maxPCR;
            case 2: return &sizeNeeded;
            case 3: return &sizeAvailable;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PCR_SetAuthPolicy_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
}

TPM2_PCR_SetAuthPolicy_REQUEST::TPM2_PCR_SetAuthPolicy_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _authPolicy,
    TPM_ALG_ID _hashAlg,
    const TPM_HANDLE& _pcrNum
)
{
    authHandle = _authHandle;
    authPolicy = _authPolicy;
    hashAlg = _hashAlg;
    pcrNum = _pcrNum;
}

/// <summary> This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset. </summary>
TPM2_PCR_SetAuthPolicy_REQUEST::~TPM2_PCR_SetAuthPolicy_REQUEST() {}

/// <summary> This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset. </summary>
TpmStructureBase* TPM2_PCR_SetAuthPolicy_REQUEST::Clone() const
{
    return new TPM2_PCR_SetAuthPolicy_REQUEST(*this);
}

void* TPM2_PCR_SetAuthPolicy_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &authPolicySize;
            case 2: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 3: return &hashAlg;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrNum); return &pcrNum;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_SetAuthValue_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
}

TPM2_PCR_SetAuthValue_REQUEST::TPM2_PCR_SetAuthValue_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const ByteVec& _auth
)
{
    pcrHandle = _pcrHandle;
    auth = _auth;
}

/// <summary> This command changes the authValue of a PCR or group of PCR. </summary>
TPM2_PCR_SetAuthValue_REQUEST::~TPM2_PCR_SetAuthValue_REQUEST() {}

/// <summary> This command changes the authValue of a PCR or group of PCR. </summary>
TpmStructureBase* TPM2_PCR_SetAuthValue_REQUEST::Clone() const
{
    return new TPM2_PCR_SetAuthValue_REQUEST(*this);
}

void* TPM2_PCR_SetAuthValue_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_Reset_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Reset_REQUEST_ID;
}

TPM2_PCR_Reset_REQUEST::TPM2_PCR_Reset_REQUEST(const TPM_HANDLE& _pcrHandle)
{
    pcrHandle = _pcrHandle;
}

/// <summary> If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation. </summary>
TPM2_PCR_Reset_REQUEST::~TPM2_PCR_Reset_REQUEST() {}

/// <summary> If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation. </summary>
TpmStructureBase* TPM2_PCR_Reset_REQUEST::Clone() const
{
    return new TPM2_PCR_Reset_REQUEST(*this);
}

void* TPM2_PCR_Reset_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PolicySigned_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
}

TPM2_PolicySigned_REQUEST::TPM2_PolicySigned_REQUEST(
    const TPM_HANDLE& _authObject,
    const TPM_HANDLE& _policySession,
    const ByteVec& _nonceTPM,
    const ByteVec& _cpHashA,
    const ByteVec& _policyRef,
    INT32 _expiration,
    const TPMU_SIGNATURE& _auth
)
{
    authObject = _authObject;
    policySession = _policySession;
    nonceTPM = _nonceTPM;
    cpHashA = _cpHashA;
    policyRef = _policyRef;
    expiration = _expiration;
    auth.reset(dynamic_cast<TPMU_SIGNATURE*>(_auth.Clone()));
}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
TPM2_PolicySigned_REQUEST::~TPM2_PolicySigned_REQUEST() {}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
TpmStructureBase* TPM2_PolicySigned_REQUEST::Clone() const
{
    return new TPM2_PolicySigned_REQUEST(*this);
}

void* TPM2_PolicySigned_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authObject); return &authObject;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 2: return &nonceTPMSize;
            case 3: { if (newArraySize != -1) nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return &nonceTPM; }
            case 4: return &cpHashASize;
            case 5: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            case 6: return &policyRefSize;
            case 7: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 8: return &expiration;
            case 9: return &authSigAlg;
            case 10: pStruct = dynamic_cast<TpmStructureBase*>(&*auth); return &auth;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nonceTPM[arrayIndex];
            case 5: return &cpHashA[arrayIndex];
            case 7: return &policyRef[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicySignedResponse::GetTypeId() const
{
    return TpmTypeId::PolicySignedResponse_ID;
}

PolicySignedResponse::PolicySignedResponse(
    const ByteVec& _timeout,
    const TPMT_TK_AUTH& _policyTicket
)
{
    timeout = _timeout;
    policyTicket = _policyTicket;
}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
PolicySignedResponse::~PolicySignedResponse() {}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
TpmStructureBase* PolicySignedResponse::Clone() const
{
    return new PolicySignedResponse(*this);
}

void* PolicySignedResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &timeoutSize;
            case 1: { if (newArraySize != -1) timeout.resize(newArraySize); arraySize = (int)timeout.size(); return &timeout; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policyTicket); return &policyTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &timeout[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicySecret_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
}

TPM2_PolicySecret_REQUEST::TPM2_PolicySecret_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _policySession,
    const ByteVec& _nonceTPM,
    const ByteVec& _cpHashA,
    const ByteVec& _policyRef,
    INT32 _expiration
)
{
    authHandle = _authHandle;
    policySession = _policySession;
    nonceTPM = _nonceTPM;
    cpHashA = _cpHashA;
    policyRef = _policyRef;
    expiration = _expiration;
}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
TPM2_PolicySecret_REQUEST::~TPM2_PolicySecret_REQUEST() {}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
TpmStructureBase* TPM2_PolicySecret_REQUEST::Clone() const
{
    return new TPM2_PolicySecret_REQUEST(*this);
}

void* TPM2_PolicySecret_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 2: return &nonceTPMSize;
            case 3: { if (newArraySize != -1) nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return &nonceTPM; }
            case 4: return &cpHashASize;
            case 5: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            case 6: return &policyRefSize;
            case 7: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 8: return &expiration;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nonceTPM[arrayIndex];
            case 5: return &cpHashA[arrayIndex];
            case 7: return &policyRef[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicySecretResponse::GetTypeId() const
{
    return TpmTypeId::PolicySecretResponse_ID;
}

PolicySecretResponse::PolicySecretResponse(
    const ByteVec& _timeout,
    const TPMT_TK_AUTH& _policyTicket
)
{
    timeout = _timeout;
    policyTicket = _policyTicket;
}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
PolicySecretResponse::~PolicySecretResponse() {}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
TpmStructureBase* PolicySecretResponse::Clone() const
{
    return new PolicySecretResponse(*this);
}

void* PolicySecretResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &timeoutSize;
            case 1: { if (newArraySize != -1) timeout.resize(newArraySize); arraySize = (int)timeout.size(); return &timeout; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policyTicket); return &policyTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &timeout[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyTicket_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
}

TPM2_PolicyTicket_REQUEST::TPM2_PolicyTicket_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _timeout,
    const ByteVec& _cpHashA,
    const ByteVec& _policyRef,
    const ByteVec& _authName,
    const TPMT_TK_AUTH& _ticket
)
{
    policySession = _policySession;
    timeout = _timeout;
    cpHashA = _cpHashA;
    policyRef = _policyRef;
    authName = _authName;
    ticket = _ticket;
}

/// <summary> This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it. </summary>
TPM2_PolicyTicket_REQUEST::~TPM2_PolicyTicket_REQUEST() {}

/// <summary> This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it. </summary>
TpmStructureBase* TPM2_PolicyTicket_REQUEST::Clone() const
{
    return new TPM2_PolicyTicket_REQUEST(*this);
}

void* TPM2_PolicyTicket_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &timeoutSize;
            case 2: { if (newArraySize != -1) timeout.resize(newArraySize); arraySize = (int)timeout.size(); return &timeout; }
            case 3: return &cpHashASize;
            case 4: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            case 5: return &policyRefSize;
            case 6: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 7: return &authNameSize;
            case 8: { if (newArraySize != -1) authName.resize(newArraySize); arraySize = (int)authName.size(); return &authName; }
            case 9: pStruct = dynamic_cast<TpmStructureBase*>(&ticket); return &ticket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &timeout[arrayIndex];
            case 4: return &cpHashA[arrayIndex];
            case 6: return &policyRef[arrayIndex];
            case 8: return &authName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyOR_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
}

TPM2_PolicyOR_REQUEST::TPM2_PolicyOR_REQUEST(
    const TPM_HANDLE& _policySession,
    const vector<TPM2B_DIGEST>& _pHashList
)
{
    policySession = _policySession;
    pHashList = _pHashList;
}

/// <summary> This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied. </summary>
TPM2_PolicyOR_REQUEST::~TPM2_PolicyOR_REQUEST() {}

/// <summary> This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied. </summary>
TpmStructureBase* TPM2_PolicyOR_REQUEST::Clone() const
{
    return new TPM2_PolicyOR_REQUEST(*this);
}

void* TPM2_PolicyOR_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &pHashListCount;
            case 2: { if (newArraySize != -1) pHashList.resize(newArraySize); arraySize = (int)pHashList.size(); return &pHashList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pHashList[arrayIndex]); return &pHashList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyPCR_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
}

TPM2_PolicyPCR_REQUEST::TPM2_PolicyPCR_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _pcrDigest,
    const vector<TPMS_PCR_SELECTION>& _pcrs
)
{
    policySession = _policySession;
    pcrDigest = _pcrDigest;
    pcrs = _pcrs;
}

/// <summary> This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state. </summary>
TPM2_PolicyPCR_REQUEST::~TPM2_PolicyPCR_REQUEST() {}

/// <summary> This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state. </summary>
TpmStructureBase* TPM2_PolicyPCR_REQUEST::Clone() const
{
    return new TPM2_PolicyPCR_REQUEST(*this);
}

void* TPM2_PolicyPCR_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &pcrDigestSize;
            case 2: { if (newArraySize != -1) pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return &pcrDigest; }
            case 3: return &pcrsCount;
            case 4: { if (newArraySize != -1) pcrs.resize(newArraySize); arraySize = (int)pcrs.size(); return &pcrs; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &pcrDigest[arrayIndex];
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrs[arrayIndex]); return &pcrs[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyLocality_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
}

TPM2_PolicyLocality_REQUEST::TPM2_PolicyLocality_REQUEST(
    const TPM_HANDLE& _policySession,
    TPMA_LOCALITY _locality
)
{
    policySession = _policySession;
    locality = _locality;
}

/// <summary> This command indicates that the authorization will be limited to a specific locality. </summary>
TPM2_PolicyLocality_REQUEST::~TPM2_PolicyLocality_REQUEST() {}

/// <summary> This command indicates that the authorization will be limited to a specific locality. </summary>
TpmStructureBase* TPM2_PolicyLocality_REQUEST::Clone() const
{
    return new TPM2_PolicyLocality_REQUEST(*this);
}

void* TPM2_PolicyLocality_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &locality;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PolicyNV_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
}

TPM2_PolicyNV_REQUEST::TPM2_PolicyNV_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _policySession,
    const ByteVec& _operandB,
    UINT16 _offset,
    TPM_EO _operation
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    policySession = _policySession;
    operandB = _operandB;
    offset = _offset;
    operation = _operation;
}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization. </summary>
TPM2_PolicyNV_REQUEST::~TPM2_PolicyNV_REQUEST() {}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization. </summary>
TpmStructureBase* TPM2_PolicyNV_REQUEST::Clone() const
{
    return new TPM2_PolicyNV_REQUEST(*this);
}

void* TPM2_PolicyNV_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 3: return &operandBSize;
            case 4: { if (newArraySize != -1) operandB.resize(newArraySize); arraySize = (int)operandB.size(); return &operandB; }
            case 5: return &offset;
            case 6: return &operation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &operandB[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyCounterTimer_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
}

TPM2_PolicyCounterTimer_REQUEST::TPM2_PolicyCounterTimer_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _operandB,
    UINT16 _offset,
    TPM_EO _operation
)
{
    policySession = _policySession;
    operandB = _operandB;
    offset = _offset;
    operation = _operation;
}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure. </summary>
TPM2_PolicyCounterTimer_REQUEST::~TPM2_PolicyCounterTimer_REQUEST() {}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure. </summary>
TpmStructureBase* TPM2_PolicyCounterTimer_REQUEST::Clone() const
{
    return new TPM2_PolicyCounterTimer_REQUEST(*this);
}

void* TPM2_PolicyCounterTimer_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &operandBSize;
            case 2: { if (newArraySize != -1) operandB.resize(newArraySize); arraySize = (int)operandB.size(); return &operandB; }
            case 3: return &offset;
            case 4: return &operation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &operandB[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyCommandCode_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
}

TPM2_PolicyCommandCode_REQUEST::TPM2_PolicyCommandCode_REQUEST(
    const TPM_HANDLE& _policySession,
    TPM_CC _code
)
{
    policySession = _policySession;
    code = _code;
}

/// <summary> This command indicates that the authorization will be limited to a specific command code. </summary>
TPM2_PolicyCommandCode_REQUEST::~TPM2_PolicyCommandCode_REQUEST() {}

/// <summary> This command indicates that the authorization will be limited to a specific command code. </summary>
TpmStructureBase* TPM2_PolicyCommandCode_REQUEST::Clone() const
{
    return new TPM2_PolicyCommandCode_REQUEST(*this);
}

void* TPM2_PolicyCommandCode_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &code;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PolicyPhysicalPresence_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID;
}

TPM2_PolicyPhysicalPresence_REQUEST::TPM2_PolicyPhysicalPresence_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command indicates that physical presence will need to be asserted at the time the authorization is performed. </summary>
TPM2_PolicyPhysicalPresence_REQUEST::~TPM2_PolicyPhysicalPresence_REQUEST() {}

/// <summary> This command indicates that physical presence will need to be asserted at the time the authorization is performed. </summary>
TpmStructureBase* TPM2_PolicyPhysicalPresence_REQUEST::Clone() const
{
    return new TPM2_PolicyPhysicalPresence_REQUEST(*this);
}

void* TPM2_PolicyPhysicalPresence_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PolicyCpHash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
}

TPM2_PolicyCpHash_REQUEST::TPM2_PolicyCpHash_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _cpHashA
)
{
    policySession = _policySession;
    cpHashA = _cpHashA;
}

/// <summary> This command is used to allow a policy to be bound to a specific command and command parameters. </summary>
TPM2_PolicyCpHash_REQUEST::~TPM2_PolicyCpHash_REQUEST() {}

/// <summary> This command is used to allow a policy to be bound to a specific command and command parameters. </summary>
TpmStructureBase* TPM2_PolicyCpHash_REQUEST::Clone() const
{
    return new TPM2_PolicyCpHash_REQUEST(*this);
}

void* TPM2_PolicyCpHash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &cpHashASize;
            case 2: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &cpHashA[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyNameHash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
}

TPM2_PolicyNameHash_REQUEST::TPM2_PolicyNameHash_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _nameHash
)
{
    policySession = _policySession;
    nameHash = _nameHash;
}

/// <summary> This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy. </summary>
TPM2_PolicyNameHash_REQUEST::~TPM2_PolicyNameHash_REQUEST() {}

/// <summary> This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy. </summary>
TpmStructureBase* TPM2_PolicyNameHash_REQUEST::Clone() const
{
    return new TPM2_PolicyNameHash_REQUEST(*this);
}

void* TPM2_PolicyNameHash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &nameHashSize;
            case 2: { if (newArraySize != -1) nameHash.resize(newArraySize); arraySize = (int)nameHash.size(); return &nameHash; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nameHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyDuplicationSelect_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
}

TPM2_PolicyDuplicationSelect_REQUEST::TPM2_PolicyDuplicationSelect_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _objectName,
    const ByteVec& _newParentName,
    BYTE _includeObject
)
{
    policySession = _policySession;
    objectName = _objectName;
    newParentName = _newParentName;
    includeObject = _includeObject;
}

/// <summary> This command allows qualification of duplication to allow duplication to a selected new parent. </summary>
TPM2_PolicyDuplicationSelect_REQUEST::~TPM2_PolicyDuplicationSelect_REQUEST() {}

/// <summary> This command allows qualification of duplication to allow duplication to a selected new parent. </summary>
TpmStructureBase* TPM2_PolicyDuplicationSelect_REQUEST::Clone() const
{
    return new TPM2_PolicyDuplicationSelect_REQUEST(*this);
}

void* TPM2_PolicyDuplicationSelect_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &objectNameSize;
            case 2: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            case 3: return &newParentNameSize;
            case 4: { if (newArraySize != -1) newParentName.resize(newArraySize); arraySize = (int)newParentName.size(); return &newParentName; }
            case 5: return &includeObject;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &objectName[arrayIndex];
            case 4: return &newParentName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyAuthorize_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
}

TPM2_PolicyAuthorize_REQUEST::TPM2_PolicyAuthorize_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _approvedPolicy,
    const ByteVec& _policyRef,
    const ByteVec& _keySign,
    const TPMT_TK_VERIFIED& _checkTicket
)
{
    policySession = _policySession;
    approvedPolicy = _approvedPolicy;
    policyRef = _policyRef;
    keySign = _keySign;
    checkTicket = _checkTicket;
}

/// <summary> This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy. </summary>
TPM2_PolicyAuthorize_REQUEST::~TPM2_PolicyAuthorize_REQUEST() {}

/// <summary> This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy. </summary>
TpmStructureBase* TPM2_PolicyAuthorize_REQUEST::Clone() const
{
    return new TPM2_PolicyAuthorize_REQUEST(*this);
}

void* TPM2_PolicyAuthorize_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &approvedPolicySize;
            case 2: { if (newArraySize != -1) approvedPolicy.resize(newArraySize); arraySize = (int)approvedPolicy.size(); return &approvedPolicy; }
            case 3: return &policyRefSize;
            case 4: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 5: return &keySignSize;
            case 6: { if (newArraySize != -1) keySign.resize(newArraySize); arraySize = (int)keySign.size(); return &keySign; }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&checkTicket); return &checkTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &approvedPolicy[arrayIndex];
            case 4: return &policyRef[arrayIndex];
            case 6: return &keySign[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyAuthValue_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID;
}

TPM2_PolicyAuthValue_REQUEST::TPM2_PolicyAuthValue_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized entity. </summary>
TPM2_PolicyAuthValue_REQUEST::~TPM2_PolicyAuthValue_REQUEST() {}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized entity. </summary>
TpmStructureBase* TPM2_PolicyAuthValue_REQUEST::Clone() const
{
    return new TPM2_PolicyAuthValue_REQUEST(*this);
}

void* TPM2_PolicyAuthValue_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PolicyPassword_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPassword_REQUEST_ID;
}

TPM2_PolicyPassword_REQUEST::TPM2_PolicyPassword_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized object. </summary>
TPM2_PolicyPassword_REQUEST::~TPM2_PolicyPassword_REQUEST() {}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized object. </summary>
TpmStructureBase* TPM2_PolicyPassword_REQUEST::Clone() const
{
    return new TPM2_PolicyPassword_REQUEST(*this);
}

void* TPM2_PolicyPassword_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PolicyGetDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID;
}

TPM2_PolicyGetDigest_REQUEST::TPM2_PolicyGetDigest_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
TPM2_PolicyGetDigest_REQUEST::~TPM2_PolicyGetDigest_REQUEST() {}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
TpmStructureBase* TPM2_PolicyGetDigest_REQUEST::Clone() const
{
    return new TPM2_PolicyGetDigest_REQUEST(*this);
}

void* TPM2_PolicyGetDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyGetDigestResponse::GetTypeId() const
{
    return TpmTypeId::PolicyGetDigestResponse_ID;
}

PolicyGetDigestResponse::PolicyGetDigestResponse(
    const ByteVec& _policyDigest
)
{
    policyDigest = _policyDigest;
}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
PolicyGetDigestResponse::~PolicyGetDigestResponse() {}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
TpmStructureBase* PolicyGetDigestResponse::Clone() const
{
    return new PolicyGetDigestResponse(*this);
}

void* PolicyGetDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &policyDigestSize;
            case 1: { if (newArraySize != -1) policyDigest.resize(newArraySize); arraySize = (int)policyDigest.size(); return &policyDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &policyDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyNvWritten_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
}

TPM2_PolicyNvWritten_REQUEST::TPM2_PolicyNvWritten_REQUEST(
    const TPM_HANDLE& _policySession,
    BYTE _writtenSet
)
{
    policySession = _policySession;
    writtenSet = _writtenSet;
}

/// <summary> This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization. </summary>
TPM2_PolicyNvWritten_REQUEST::~TPM2_PolicyNvWritten_REQUEST() {}

/// <summary> This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization. </summary>
TpmStructureBase* TPM2_PolicyNvWritten_REQUEST::Clone() const
{
    return new TPM2_PolicyNvWritten_REQUEST(*this);
}

void* TPM2_PolicyNvWritten_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &writtenSet;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PolicyTemplate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
}

TPM2_PolicyTemplate_REQUEST::TPM2_PolicyTemplate_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _templateHash
)
{
    policySession = _policySession;
    templateHash = _templateHash;
}

/// <summary> This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded(). </summary>
TPM2_PolicyTemplate_REQUEST::~TPM2_PolicyTemplate_REQUEST() {}

/// <summary> This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded(). </summary>
TpmStructureBase* TPM2_PolicyTemplate_REQUEST::Clone() const
{
    return new TPM2_PolicyTemplate_REQUEST(*this);
}

void* TPM2_PolicyTemplate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &templateHashSize;
            case 2: { if (newArraySize != -1) templateHash.resize(newArraySize); arraySize = (int)templateHash.size(); return &templateHash; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &templateHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyAuthorizeNV_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
}

TPM2_PolicyAuthorizeNV_REQUEST::TPM2_PolicyAuthorizeNV_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _policySession
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    policySession = _policySession;
}

/// <summary> This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable. </summary>
TPM2_PolicyAuthorizeNV_REQUEST::~TPM2_PolicyAuthorizeNV_REQUEST() {}

/// <summary> This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable. </summary>
TpmStructureBase* TPM2_PolicyAuthorizeNV_REQUEST::Clone() const
{
    return new TPM2_PolicyAuthorizeNV_REQUEST(*this);
}

void* TPM2_PolicyAuthorizeNV_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_CreatePrimary_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
}

TPM2_CreatePrimary_REQUEST::TPM2_CreatePrimary_REQUEST(
    const TPM_HANDLE& _primaryHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const TPMT_PUBLIC& _inPublic,
    const ByteVec& _outsideInfo,
    const vector<TPMS_PCR_SELECTION>& _creationPCR
)
{
    primaryHandle = _primaryHandle;
    inSensitive = _inSensitive;
    inPublic = _inPublic;
    outsideInfo = _outsideInfo;
    creationPCR = _creationPCR;
}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
TPM2_CreatePrimary_REQUEST::~TPM2_CreatePrimary_REQUEST() {}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
TpmStructureBase* TPM2_CreatePrimary_REQUEST::Clone() const
{
    return new TPM2_CreatePrimary_REQUEST(*this);
}

void* TPM2_CreatePrimary_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&primaryHandle); return &primaryHandle;
            case 1: return &inSensitiveSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return &inSensitive;
            case 3: return &inPublicSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            case 5: return &outsideInfoSize;
            case 6: { if (newArraySize != -1) outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return &outsideInfo; }
            case 7: return &creationPCRCount;
            case 8: { if (newArraySize != -1) creationPCR.resize(newArraySize); arraySize = (int)creationPCR.size(); return &creationPCR; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &outsideInfo[arrayIndex];
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationPCR[arrayIndex]); return &creationPCR[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CreatePrimaryResponse::GetTypeId() const
{
    return TpmTypeId::CreatePrimaryResponse_ID;
}

CreatePrimaryResponse::CreatePrimaryResponse(
    const TPM_HANDLE& _handle,
    const TPMT_PUBLIC& _outPublic,
    const TPMS_CREATION_DATA& _creationData,
    const ByteVec& _creationHash,
    const TPMT_TK_CREATION& _creationTicket,
    const ByteVec& _name
)
{
    handle = _handle;
    outPublic = _outPublic;
    creationData = _creationData;
    creationHash = _creationHash;
    creationTicket = _creationTicket;
    name = _name;
}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
CreatePrimaryResponse::~CreatePrimaryResponse() {}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
TpmStructureBase* CreatePrimaryResponse::Clone() const
{
    return new CreatePrimaryResponse(*this);
}

void* CreatePrimaryResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &outPublicSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 3: return &creationDataSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return &creationData;
            case 5: return &creationHashSize;
            case 6: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return &creationTicket;
            case 8: return &nameSize;
            case 9: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &creationHash[arrayIndex];
            case 9: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_HierarchyControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
}

TPM2_HierarchyControl_REQUEST::TPM2_HierarchyControl_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _enable,
    BYTE _state
)
{
    authHandle = _authHandle;
    enable = _enable;
    state = _state;
}

/// <summary> This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided. </summary>
TPM2_HierarchyControl_REQUEST::~TPM2_HierarchyControl_REQUEST() {}

/// <summary> This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided. </summary>
TpmStructureBase* TPM2_HierarchyControl_REQUEST::Clone() const
{
    return new TPM2_HierarchyControl_REQUEST(*this);
}

void* TPM2_HierarchyControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&enable); return &enable;
            case 2: return &state;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_SetPrimaryPolicy_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
}

TPM2_SetPrimaryPolicy_REQUEST::TPM2_SetPrimaryPolicy_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _authPolicy,
    TPM_ALG_ID _hashAlg
)
{
    authHandle = _authHandle;
    authPolicy = _authPolicy;
    hashAlg = _hashAlg;
}

/// <summary> This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown Timers (ACT), this command may also be used to set the authorization policy for an ACT. </summary>
TPM2_SetPrimaryPolicy_REQUEST::~TPM2_SetPrimaryPolicy_REQUEST() {}

/// <summary> This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown Timers (ACT), this command may also be used to set the authorization policy for an ACT. </summary>
TpmStructureBase* TPM2_SetPrimaryPolicy_REQUEST::Clone() const
{
    return new TPM2_SetPrimaryPolicy_REQUEST(*this);
}

void* TPM2_SetPrimaryPolicy_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &authPolicySize;
            case 2: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 3: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ChangePPS_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ChangePPS_REQUEST_ID;
}

TPM2_ChangePPS_REQUEST::TPM2_ChangePPS_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer). </summary>
TPM2_ChangePPS_REQUEST::~TPM2_ChangePPS_REQUEST() {}

/// <summary> This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer). </summary>
TpmStructureBase* TPM2_ChangePPS_REQUEST::Clone() const
{
    return new TPM2_ChangePPS_REQUEST(*this);
}

void* TPM2_ChangePPS_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ChangeEPS_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ChangeEPS_REQUEST_ID;
}

TPM2_ChangeEPS_REQUEST::TPM2_ChangeEPS_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded. </summary>
TPM2_ChangeEPS_REQUEST::~TPM2_ChangeEPS_REQUEST() {}

/// <summary> This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded. </summary>
TpmStructureBase* TPM2_ChangeEPS_REQUEST::Clone() const
{
    return new TPM2_ChangeEPS_REQUEST(*this);
}

void* TPM2_ChangeEPS_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Clear_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Clear_REQUEST_ID;
}

TPM2_Clear_REQUEST::TPM2_Clear_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> This command removes all TPM context associated with a specific Owner. </summary>
TPM2_Clear_REQUEST::~TPM2_Clear_REQUEST() {}

/// <summary> This command removes all TPM context associated with a specific Owner. </summary>
TpmStructureBase* TPM2_Clear_REQUEST::Clone() const
{
    return new TPM2_Clear_REQUEST(*this);
}

void* TPM2_Clear_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ClearControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClearControl_REQUEST_ID;
}

TPM2_ClearControl_REQUEST::TPM2_ClearControl_REQUEST(
    const TPM_HANDLE& _auth,
    BYTE _disable
)
{
    auth = _auth;
    disable = _disable;
}

/// <summary> TPM2_ClearControl() disables and enables the execution of TPM2_Clear(). </summary>
TPM2_ClearControl_REQUEST::~TPM2_ClearControl_REQUEST() {}

/// <summary> TPM2_ClearControl() disables and enables the execution of TPM2_Clear(). </summary>
TpmStructureBase* TPM2_ClearControl_REQUEST::Clone() const
{
    return new TPM2_ClearControl_REQUEST(*this);
}

void* TPM2_ClearControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &disable;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_HierarchyChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
}

TPM2_HierarchyChangeAuth_REQUEST::TPM2_HierarchyChangeAuth_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _newAuth
)
{
    authHandle = _authHandle;
    newAuth = _newAuth;
}

/// <summary> This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization. </summary>
TPM2_HierarchyChangeAuth_REQUEST::~TPM2_HierarchyChangeAuth_REQUEST() {}

/// <summary> This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization. </summary>
TpmStructureBase* TPM2_HierarchyChangeAuth_REQUEST::Clone() const
{
    return new TPM2_HierarchyChangeAuth_REQUEST(*this);
}

void* TPM2_HierarchyChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &newAuthSize;
            case 2: { if (newArraySize != -1) newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return &newAuth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &newAuth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_DictionaryAttackLockReset_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID;
}

TPM2_DictionaryAttackLockReset_REQUEST::TPM2_DictionaryAttackLockReset_REQUEST(const TPM_HANDLE& _lockHandle)
{
    lockHandle = _lockHandle;
}

/// <summary> This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero. </summary>
TPM2_DictionaryAttackLockReset_REQUEST::~TPM2_DictionaryAttackLockReset_REQUEST() {}

/// <summary> This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero. </summary>
TpmStructureBase* TPM2_DictionaryAttackLockReset_REQUEST::Clone() const
{
    return new TPM2_DictionaryAttackLockReset_REQUEST(*this);
}

void* TPM2_DictionaryAttackLockReset_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&lockHandle); return &lockHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_DictionaryAttackParameters_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
}

TPM2_DictionaryAttackParameters_REQUEST::TPM2_DictionaryAttackParameters_REQUEST(
    const TPM_HANDLE& _lockHandle,
    UINT32 _newMaxTries,
    UINT32 _newRecoveryTime,
    UINT32 _lockoutRecovery
)
{
    lockHandle = _lockHandle;
    newMaxTries = _newMaxTries;
    newRecoveryTime = _newRecoveryTime;
    lockoutRecovery = _lockoutRecovery;
}

/// <summary> This command changes the lockout parameters. </summary>
TPM2_DictionaryAttackParameters_REQUEST::~TPM2_DictionaryAttackParameters_REQUEST() {}

/// <summary> This command changes the lockout parameters. </summary>
TpmStructureBase* TPM2_DictionaryAttackParameters_REQUEST::Clone() const
{
    return new TPM2_DictionaryAttackParameters_REQUEST(*this);
}

void* TPM2_DictionaryAttackParameters_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&lockHandle); return &lockHandle;
            case 1: return &newMaxTries;
            case 2: return &newRecoveryTime;
            case 3: return &lockoutRecovery;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PP_Commands_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
}

TPM2_PP_Commands_REQUEST::TPM2_PP_Commands_REQUEST(
    const TPM_HANDLE& _auth,
    const vector<TPM_CC>& _setList,
    const vector<TPM_CC>& _clearList
)
{
    auth = _auth;
    setList = _setList;
    clearList = _clearList;
}

/// <summary> This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy. </summary>
TPM2_PP_Commands_REQUEST::~TPM2_PP_Commands_REQUEST() {}

/// <summary> This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy. </summary>
TpmStructureBase* TPM2_PP_Commands_REQUEST::Clone() const
{
    return new TPM2_PP_Commands_REQUEST(*this);
}

void* TPM2_PP_Commands_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &setListCount;
            case 2: { if (newArraySize != -1) setList.resize(newArraySize); arraySize = (int)setList.size(); return &setList; }
            case 3: return &clearListCount;
            case 4: { if (newArraySize != -1) clearList.resize(newArraySize); arraySize = (int)clearList.size(); return &clearList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &setList[arrayIndex];
            case 4: return &clearList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_SetAlgorithmSet_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
}

TPM2_SetAlgorithmSet_REQUEST::TPM2_SetAlgorithmSet_REQUEST(
    const TPM_HANDLE& _authHandle,
    UINT32 _algorithmSet
)
{
    authHandle = _authHandle;
    algorithmSet = _algorithmSet;
}

/// <summary> This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value. </summary>
TPM2_SetAlgorithmSet_REQUEST::~TPM2_SetAlgorithmSet_REQUEST() {}

/// <summary> This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value. </summary>
TpmStructureBase* TPM2_SetAlgorithmSet_REQUEST::Clone() const
{
    return new TPM2_SetAlgorithmSet_REQUEST(*this);
}

void* TPM2_SetAlgorithmSet_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &algorithmSet;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_FieldUpgradeStart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
}

TPM2_FieldUpgradeStart_REQUEST::TPM2_FieldUpgradeStart_REQUEST(
    const TPM_HANDLE& _authorization,
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _fuDigest,
    const TPMU_SIGNATURE& _manifestSignature
)
{
    authorization = _authorization;
    keyHandle = _keyHandle;
    fuDigest = _fuDigest;
    manifestSignature.reset(dynamic_cast<TPMU_SIGNATURE*>(_manifestSignature.Clone()));
}

/// <summary> This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest. </summary>
TPM2_FieldUpgradeStart_REQUEST::~TPM2_FieldUpgradeStart_REQUEST() {}

/// <summary> This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest. </summary>
TpmStructureBase* TPM2_FieldUpgradeStart_REQUEST::Clone() const
{
    return new TPM2_FieldUpgradeStart_REQUEST(*this);
}

void* TPM2_FieldUpgradeStart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authorization); return &authorization;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 2: return &fuDigestSize;
            case 3: { if (newArraySize != -1) fuDigest.resize(newArraySize); arraySize = (int)fuDigest.size(); return &fuDigest; }
            case 4: return &manifestSignatureSigAlg;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*manifestSignature); return &manifestSignature;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &fuDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_FieldUpgradeData_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
}

TPM2_FieldUpgradeData_REQUEST::TPM2_FieldUpgradeData_REQUEST(
    const ByteVec& _fuData
)
{
    fuData = _fuData;
}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
TPM2_FieldUpgradeData_REQUEST::~TPM2_FieldUpgradeData_REQUEST() {}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
TpmStructureBase* TPM2_FieldUpgradeData_REQUEST::Clone() const
{
    return new TPM2_FieldUpgradeData_REQUEST(*this);
}

void* TPM2_FieldUpgradeData_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &fuDataSize;
            case 1: { if (newArraySize != -1) fuData.resize(newArraySize); arraySize = (int)fuData.size(); return &fuData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &fuData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId FieldUpgradeDataResponse::GetTypeId() const
{
    return TpmTypeId::FieldUpgradeDataResponse_ID;
}

FieldUpgradeDataResponse::FieldUpgradeDataResponse(
    const TPMT_HA& _nextDigest,
    const TPMT_HA& _firstDigest
)
{
    nextDigest = _nextDigest;
    firstDigest = _firstDigest;
}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
FieldUpgradeDataResponse::~FieldUpgradeDataResponse() {}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
TpmStructureBase* FieldUpgradeDataResponse::Clone() const
{
    return new FieldUpgradeDataResponse(*this);
}

void* FieldUpgradeDataResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nextDigest); return &nextDigest;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&firstDigest); return &firstDigest;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_FirmwareRead_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FirmwareRead_REQUEST_ID;
}

TPM2_FirmwareRead_REQUEST::TPM2_FirmwareRead_REQUEST(UINT32 _sequenceNumber)
{
    sequenceNumber = _sequenceNumber;
}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
TPM2_FirmwareRead_REQUEST::~TPM2_FirmwareRead_REQUEST() {}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
TpmStructureBase* TPM2_FirmwareRead_REQUEST::Clone() const
{
    return new TPM2_FirmwareRead_REQUEST(*this);
}

void* TPM2_FirmwareRead_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sequenceNumber;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId FirmwareReadResponse::GetTypeId() const
{
    return TpmTypeId::FirmwareReadResponse_ID;
}

FirmwareReadResponse::FirmwareReadResponse(
    const ByteVec& _fuData
)
{
    fuData = _fuData;
}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
FirmwareReadResponse::~FirmwareReadResponse() {}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
TpmStructureBase* FirmwareReadResponse::Clone() const
{
    return new FirmwareReadResponse(*this);
}

void* FirmwareReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &fuDataSize;
            case 1: { if (newArraySize != -1) fuData.resize(newArraySize); arraySize = (int)fuData.size(); return &fuData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &fuData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ContextSave_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ContextSave_REQUEST_ID;
}

TPM2_ContextSave_REQUEST::TPM2_ContextSave_REQUEST(const TPM_HANDLE& _saveHandle)
{
    saveHandle = _saveHandle;
}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
TPM2_ContextSave_REQUEST::~TPM2_ContextSave_REQUEST() {}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
TpmStructureBase* TPM2_ContextSave_REQUEST::Clone() const
{
    return new TPM2_ContextSave_REQUEST(*this);
}

void* TPM2_ContextSave_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&saveHandle); return &saveHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ContextSaveResponse::GetTypeId() const
{
    return TpmTypeId::ContextSaveResponse_ID;
}

ContextSaveResponse::ContextSaveResponse(const TPMS_CONTEXT& _context)
{
    context = _context;
}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
ContextSaveResponse::~ContextSaveResponse() {}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
TpmStructureBase* ContextSaveResponse::Clone() const
{
    return new ContextSaveResponse(*this);
}

void* ContextSaveResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&context); return &context;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ContextLoad_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ContextLoad_REQUEST_ID;
}

TPM2_ContextLoad_REQUEST::TPM2_ContextLoad_REQUEST(const TPMS_CONTEXT& _context)
{
    context = _context;
}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
TPM2_ContextLoad_REQUEST::~TPM2_ContextLoad_REQUEST() {}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
TpmStructureBase* TPM2_ContextLoad_REQUEST::Clone() const
{
    return new TPM2_ContextLoad_REQUEST(*this);
}

void* TPM2_ContextLoad_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&context); return &context;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ContextLoadResponse::GetTypeId() const
{
    return TpmTypeId::ContextLoadResponse_ID;
}

ContextLoadResponse::ContextLoadResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
ContextLoadResponse::~ContextLoadResponse() {}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
TpmStructureBase* ContextLoadResponse::Clone() const
{
    return new ContextLoadResponse(*this);
}

void* ContextLoadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_FlushContext_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FlushContext_REQUEST_ID;
}

TPM2_FlushContext_REQUEST::TPM2_FlushContext_REQUEST(const TPM_HANDLE& _flushHandle)
{
    flushHandle = _flushHandle;
}

/// <summary> This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory. </summary>
TPM2_FlushContext_REQUEST::~TPM2_FlushContext_REQUEST() {}

/// <summary> This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory. </summary>
TpmStructureBase* TPM2_FlushContext_REQUEST::Clone() const
{
    return new TPM2_FlushContext_REQUEST(*this);
}

void* TPM2_FlushContext_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&flushHandle); return &flushHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_EvictControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EvictControl_REQUEST_ID;
}

TPM2_EvictControl_REQUEST::TPM2_EvictControl_REQUEST(
    const TPM_HANDLE& _auth,
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _persistentHandle
)
{
    auth = _auth;
    objectHandle = _objectHandle;
    persistentHandle = _persistentHandle;
}

/// <summary> This command allows certain Transient Objects to be made persistent or a persistent object to be evicted. </summary>
TPM2_EvictControl_REQUEST::~TPM2_EvictControl_REQUEST() {}

/// <summary> This command allows certain Transient Objects to be made persistent or a persistent object to be evicted. </summary>
TpmStructureBase* TPM2_EvictControl_REQUEST::Clone() const
{
    return new TPM2_EvictControl_REQUEST(*this);
}

void* TPM2_EvictControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&persistentHandle); return &persistentHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ReadClock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ReadClock_REQUEST_ID;
}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
TPM2_ReadClock_REQUEST::~TPM2_ReadClock_REQUEST() {}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
TpmStructureBase* TPM2_ReadClock_REQUEST::Clone() const
{
    return new TPM2_ReadClock_REQUEST(*this);
}

void* TPM2_ReadClock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId ReadClockResponse::GetTypeId() const
{
    return TpmTypeId::ReadClockResponse_ID;
}

ReadClockResponse::ReadClockResponse(const TPMS_TIME_INFO& _currentTime)
{
    currentTime = _currentTime;
}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
ReadClockResponse::~ReadClockResponse() {}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
TpmStructureBase* ReadClockResponse::Clone() const
{
    return new ReadClockResponse(*this);
}

void* ReadClockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&currentTime); return &currentTime;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ClockSet_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClockSet_REQUEST_ID;
}

TPM2_ClockSet_REQUEST::TPM2_ClockSet_REQUEST(
    const TPM_HANDLE& _auth,
    UINT64 _newTime
)
{
    auth = _auth;
    newTime = _newTime;
}

/// <summary> This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock. </summary>
TPM2_ClockSet_REQUEST::~TPM2_ClockSet_REQUEST() {}

/// <summary> This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock. </summary>
TpmStructureBase* TPM2_ClockSet_REQUEST::Clone() const
{
    return new TPM2_ClockSet_REQUEST(*this);
}

void* TPM2_ClockSet_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &newTime;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ClockRateAdjust_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
}

TPM2_ClockRateAdjust_REQUEST::TPM2_ClockRateAdjust_REQUEST(
    const TPM_HANDLE& _auth,
    TPM_CLOCK_ADJUST _rateAdjust
)
{
    auth = _auth;
    rateAdjust = _rateAdjust;
}

/// <summary> This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time. </summary>
TPM2_ClockRateAdjust_REQUEST::~TPM2_ClockRateAdjust_REQUEST() {}

/// <summary> This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time. </summary>
TpmStructureBase* TPM2_ClockRateAdjust_REQUEST::Clone() const
{
    return new TPM2_ClockRateAdjust_REQUEST(*this);
}

void* TPM2_ClockRateAdjust_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &rateAdjust;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_GetCapability_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetCapability_REQUEST_ID;
}

TPM2_GetCapability_REQUEST::TPM2_GetCapability_REQUEST(
    TPM_CAP _capability,
    UINT32 _property,
    UINT32 _propertyCount
)
{
    capability = _capability;
    property = _property;
    propertyCount = _propertyCount;
}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
TPM2_GetCapability_REQUEST::~TPM2_GetCapability_REQUEST() {}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
TpmStructureBase* TPM2_GetCapability_REQUEST::Clone() const
{
    return new TPM2_GetCapability_REQUEST(*this);
}

void* TPM2_GetCapability_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &capability;
            case 1: return &property;
            case 2: return &propertyCount;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId GetCapabilityResponse::GetTypeId() const
{
    return TpmTypeId::GetCapabilityResponse_ID;
}

GetCapabilityResponse::GetCapabilityResponse(
    BYTE _moreData,
    const TPMU_CAPABILITIES& _capabilityData
)
{
    moreData = _moreData;
    capabilityData.reset(dynamic_cast<TPMU_CAPABILITIES*>(_capabilityData.Clone()));
}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
GetCapabilityResponse::~GetCapabilityResponse() {}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
TpmStructureBase* GetCapabilityResponse::Clone() const
{
    return new GetCapabilityResponse(*this);
}

void* GetCapabilityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &moreData;
            case 1: return &capabilityDataCapability;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*capabilityData); return &capabilityData;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_TestParms_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_TestParms_REQUEST_ID;
}

TPM2_TestParms_REQUEST::TPM2_TestParms_REQUEST(
    const TPMU_PUBLIC_PARMS& _parameters
)
{
    parameters.reset(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()));
}

/// <summary> This command is used to check to see if specific combinations of algorithm parameters are supported. </summary>
TPM2_TestParms_REQUEST::~TPM2_TestParms_REQUEST() {}

/// <summary> This command is used to check to see if specific combinations of algorithm parameters are supported. </summary>
TpmStructureBase* TPM2_TestParms_REQUEST::Clone() const
{
    return new TPM2_TestParms_REQUEST(*this);
}

void* TPM2_TestParms_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &parametersType;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*parameters); return &parameters;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_DefineSpace_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
}

TPM2_NV_DefineSpace_REQUEST::TPM2_NV_DefineSpace_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _auth,
    const TPMS_NV_PUBLIC& _publicInfo
)
{
    authHandle = _authHandle;
    auth = _auth;
    publicInfo = _publicInfo;
}

/// <summary> This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED. </summary>
TPM2_NV_DefineSpace_REQUEST::~TPM2_NV_DefineSpace_REQUEST() {}

/// <summary> This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED. </summary>
TpmStructureBase* TPM2_NV_DefineSpace_REQUEST::Clone() const
{
    return new TPM2_NV_DefineSpace_REQUEST(*this);
}

void* TPM2_NV_DefineSpace_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 3: return &publicInfoSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&publicInfo); return &publicInfo;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_UndefineSpace_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
}

TPM2_NV_UndefineSpace_REQUEST::TPM2_NV_UndefineSpace_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> This command removes an Index from the TPM. </summary>
TPM2_NV_UndefineSpace_REQUEST::~TPM2_NV_UndefineSpace_REQUEST() {}

/// <summary> This command removes an Index from the TPM. </summary>
TpmStructureBase* TPM2_NV_UndefineSpace_REQUEST::Clone() const
{
    return new TPM2_NV_UndefineSpace_REQUEST(*this);
}

void* TPM2_NV_UndefineSpace_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_UndefineSpaceSpecial_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
}

TPM2_NV_UndefineSpaceSpecial_REQUEST::TPM2_NV_UndefineSpaceSpecial_REQUEST(
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _platform
)
{
    nvIndex = _nvIndex;
    platform = _platform;
}

/// <summary> This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET. </summary>
TPM2_NV_UndefineSpaceSpecial_REQUEST::~TPM2_NV_UndefineSpaceSpecial_REQUEST() {}

/// <summary> This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET. </summary>
TpmStructureBase* TPM2_NV_UndefineSpaceSpecial_REQUEST::Clone() const
{
    return new TPM2_NV_UndefineSpaceSpecial_REQUEST(*this);
}

void* TPM2_NV_UndefineSpaceSpecial_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&platform); return &platform;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_ReadPublic_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID;
}

TPM2_NV_ReadPublic_REQUEST::TPM2_NV_ReadPublic_REQUEST(const TPM_HANDLE& _nvIndex)
{
    nvIndex = _nvIndex;
}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
TPM2_NV_ReadPublic_REQUEST::~TPM2_NV_ReadPublic_REQUEST() {}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
TpmStructureBase* TPM2_NV_ReadPublic_REQUEST::Clone() const
{
    return new TPM2_NV_ReadPublic_REQUEST(*this);
}

void* TPM2_NV_ReadPublic_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_ReadPublicResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadPublicResponse_ID;
}

NV_ReadPublicResponse::NV_ReadPublicResponse(
    const TPMS_NV_PUBLIC& _nvPublic,
    const ByteVec& _nvName
)
{
    nvPublic = _nvPublic;
    nvName = _nvName;
}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
NV_ReadPublicResponse::~NV_ReadPublicResponse() {}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
TpmStructureBase* NV_ReadPublicResponse::Clone() const
{
    return new NV_ReadPublicResponse(*this);
}

void* NV_ReadPublicResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nvPublicSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvPublic); return &nvPublic;
            case 2: return &nvNameSize;
            case 3: { if (newArraySize != -1) nvName.resize(newArraySize); arraySize = (int)nvName.size(); return &nvName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nvName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_Write_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Write_REQUEST_ID;
}

TPM2_NV_Write_REQUEST::TPM2_NV_Write_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _data,
    UINT16 _offset
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    data = _data;
    offset = _offset;
}

/// <summary> This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace(). </summary>
TPM2_NV_Write_REQUEST::~TPM2_NV_Write_REQUEST() {}

/// <summary> This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace(). </summary>
TpmStructureBase* TPM2_NV_Write_REQUEST::Clone() const
{
    return new TPM2_NV_Write_REQUEST(*this);
}

void* TPM2_NV_Write_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &dataSize;
            case 3: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            case 4: return &offset;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_Increment_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
}

TPM2_NV_Increment_REQUEST::TPM2_NV_Increment_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one. </summary>
TPM2_NV_Increment_REQUEST::~TPM2_NV_Increment_REQUEST() {}

/// <summary> This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one. </summary>
TpmStructureBase* TPM2_NV_Increment_REQUEST::Clone() const
{
    return new TPM2_NV_Increment_REQUEST(*this);
}

void* TPM2_NV_Increment_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_Extend_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
}

TPM2_NV_Extend_REQUEST::TPM2_NV_Extend_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _data
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    data = _data;
}

/// <summary> This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace. </summary>
TPM2_NV_Extend_REQUEST::~TPM2_NV_Extend_REQUEST() {}

/// <summary> This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace. </summary>
TpmStructureBase* TPM2_NV_Extend_REQUEST::Clone() const
{
    return new TPM2_NV_Extend_REQUEST(*this);
}

void* TPM2_NV_Extend_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &dataSize;
            case 3: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_SetBits_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
}

TPM2_NV_SetBits_REQUEST::TPM2_NV_SetBits_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    UINT64 _bits
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    bits = _bits;
}

/// <summary> This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index. </summary>
TPM2_NV_SetBits_REQUEST::~TPM2_NV_SetBits_REQUEST() {}

/// <summary> This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index. </summary>
TpmStructureBase* TPM2_NV_SetBits_REQUEST::Clone() const
{
    return new TPM2_NV_SetBits_REQUEST(*this);
}

void* TPM2_NV_SetBits_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &bits;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_WriteLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
}

TPM2_NV_WriteLock_REQUEST::TPM2_NV_WriteLock_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index. </summary>
TPM2_NV_WriteLock_REQUEST::~TPM2_NV_WriteLock_REQUEST() {}

/// <summary> If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index. </summary>
TpmStructureBase* TPM2_NV_WriteLock_REQUEST::Clone() const
{
    return new TPM2_NV_WriteLock_REQUEST(*this);
}

void* TPM2_NV_WriteLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_GlobalWriteLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID;
}

TPM2_NV_GlobalWriteLock_REQUEST::TPM2_NV_GlobalWriteLock_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET. </summary>
TPM2_NV_GlobalWriteLock_REQUEST::~TPM2_NV_GlobalWriteLock_REQUEST() {}

/// <summary> The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET. </summary>
TpmStructureBase* TPM2_NV_GlobalWriteLock_REQUEST::Clone() const
{
    return new TPM2_NV_GlobalWriteLock_REQUEST(*this);
}

void* TPM2_NV_GlobalWriteLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_Read_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Read_REQUEST_ID;
}

TPM2_NV_Read_REQUEST::TPM2_NV_Read_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    UINT16 _size,
    UINT16 _offset
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    size = _size;
    offset = _offset;
}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
TPM2_NV_Read_REQUEST::~TPM2_NV_Read_REQUEST() {}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
TpmStructureBase* TPM2_NV_Read_REQUEST::Clone() const
{
    return new TPM2_NV_Read_REQUEST(*this);
}

void* TPM2_NV_Read_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &size;
            case 3: return &offset;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_ReadResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadResponse_ID;
}

NV_ReadResponse::NV_ReadResponse(
    const ByteVec& _data
)
{
    data = _data;
}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
NV_ReadResponse::~NV_ReadResponse() {}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
TpmStructureBase* NV_ReadResponse::Clone() const
{
    return new NV_ReadResponse(*this);
}

void* NV_ReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &dataSize;
            case 1: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_ReadLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
}

TPM2_NV_ReadLock_REQUEST::TPM2_NV_ReadLock_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR). </summary>
TPM2_NV_ReadLock_REQUEST::~TPM2_NV_ReadLock_REQUEST() {}

/// <summary> If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR). </summary>
TpmStructureBase* TPM2_NV_ReadLock_REQUEST::Clone() const
{
    return new TPM2_NV_ReadLock_REQUEST(*this);
}

void* TPM2_NV_ReadLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_NV_ChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
}

TPM2_NV_ChangeAuth_REQUEST::TPM2_NV_ChangeAuth_REQUEST(
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _newAuth
)
{
    nvIndex = _nvIndex;
    newAuth = _newAuth;
}

/// <summary> This command allows the authorization secret for an NV Index to be changed. </summary>
TPM2_NV_ChangeAuth_REQUEST::~TPM2_NV_ChangeAuth_REQUEST() {}

/// <summary> This command allows the authorization secret for an NV Index to be changed. </summary>
TpmStructureBase* TPM2_NV_ChangeAuth_REQUEST::Clone() const
{
    return new TPM2_NV_ChangeAuth_REQUEST(*this);
}

void* TPM2_NV_ChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 1: return &newAuthSize;
            case 2: { if (newArraySize != -1) newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return &newAuth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &newAuth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_Certify_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
}

TPM2_NV_Certify_REQUEST::TPM2_NV_Certify_REQUEST(
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme,
    UINT16 _size,
    UINT16 _offset
)
{
    signHandle = _signHandle;
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    size = _size;
    offset = _offset;
}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
TPM2_NV_Certify_REQUEST::~TPM2_NV_Certify_REQUEST() {}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
TpmStructureBase* TPM2_NV_Certify_REQUEST::Clone() const
{
    return new TPM2_NV_Certify_REQUEST(*this);
}

void* TPM2_NV_Certify_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 3: return &qualifyingDataSize;
            case 4: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 5: return &inSchemeScheme;
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 7: return &size;
            case 8: return &offset;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId NV_CertifyResponse::GetTypeId() const
{
    return TpmTypeId::NV_CertifyResponse_ID;
}

NV_CertifyResponse::NV_CertifyResponse(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo = _certifyInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
NV_CertifyResponse::~NV_CertifyResponse() {}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
TpmStructureBase* NV_CertifyResponse::Clone() const
{
    return new NV_CertifyResponse(*this);
}

void* NV_CertifyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certifyInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return &certifyInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_AC_GetCapability_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
}

TPM2_AC_GetCapability_REQUEST::TPM2_AC_GetCapability_REQUEST(
    const TPM_HANDLE& _ac,
    TPM_AT _capability,
    UINT32 _count
)
{
    ac = _ac;
    capability = _capability;
    count = _count;
}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
TPM2_AC_GetCapability_REQUEST::~TPM2_AC_GetCapability_REQUEST() {}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
TpmStructureBase* TPM2_AC_GetCapability_REQUEST::Clone() const
{
    return new TPM2_AC_GetCapability_REQUEST(*this);
}

void* TPM2_AC_GetCapability_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&ac); return &ac;
            case 1: return &capability;
            case 2: return &count;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId AC_GetCapabilityResponse::GetTypeId() const
{
    return TpmTypeId::AC_GetCapabilityResponse_ID;
}

AC_GetCapabilityResponse::AC_GetCapabilityResponse(
    BYTE _moreData,
    const vector<TPMS_AC_OUTPUT>& _capabilitiesData
)
{
    moreData = _moreData;
    capabilitiesData = _capabilitiesData;
}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
AC_GetCapabilityResponse::~AC_GetCapabilityResponse() {}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
TpmStructureBase* AC_GetCapabilityResponse::Clone() const
{
    return new AC_GetCapabilityResponse(*this);
}

void* AC_GetCapabilityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &moreData;
            case 1: return &capabilitiesDataCount;
            case 2: { if (newArraySize != -1) capabilitiesData.resize(newArraySize); arraySize = (int)capabilitiesData.size(); return &capabilitiesData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&capabilitiesData[arrayIndex]); return &capabilitiesData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_AC_Send_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_AC_Send_REQUEST_ID;
}

TPM2_AC_Send_REQUEST::TPM2_AC_Send_REQUEST(
    const TPM_HANDLE& _sendObject,
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _ac,
    const ByteVec& _acDataIn
)
{
    sendObject = _sendObject;
    authHandle = _authHandle;
    ac = _ac;
    acDataIn = _acDataIn;
}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
TPM2_AC_Send_REQUEST::~TPM2_AC_Send_REQUEST() {}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
TpmStructureBase* TPM2_AC_Send_REQUEST::Clone() const
{
    return new TPM2_AC_Send_REQUEST(*this);
}

void* TPM2_AC_Send_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sendObject); return &sendObject;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&ac); return &ac;
            case 3: return &acDataInSize;
            case 4: { if (newArraySize != -1) acDataIn.resize(newArraySize); arraySize = (int)acDataIn.size(); return &acDataIn; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &acDataIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId AC_SendResponse::GetTypeId() const
{
    return TpmTypeId::AC_SendResponse_ID;
}

AC_SendResponse::AC_SendResponse(const TPMS_AC_OUTPUT& _acDataOut)
{
    acDataOut = _acDataOut;
}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
AC_SendResponse::~AC_SendResponse() {}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
TpmStructureBase* AC_SendResponse::Clone() const
{
    return new AC_SendResponse(*this);
}

void* AC_SendResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&acDataOut); return &acDataOut;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Policy_AC_SendSelect_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
}

TPM2_Policy_AC_SendSelect_REQUEST::TPM2_Policy_AC_SendSelect_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _objectName,
    const ByteVec& _authHandleName,
    const ByteVec& _acName,
    BYTE _includeObject
)
{
    policySession = _policySession;
    objectName = _objectName;
    authHandleName = _authHandleName;
    acName = _acName;
    includeObject = _includeObject;
}

/// <summary> This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified. </summary>
TPM2_Policy_AC_SendSelect_REQUEST::~TPM2_Policy_AC_SendSelect_REQUEST() {}

/// <summary> This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified. </summary>
TpmStructureBase* TPM2_Policy_AC_SendSelect_REQUEST::Clone() const
{
    return new TPM2_Policy_AC_SendSelect_REQUEST(*this);
}

void* TPM2_Policy_AC_SendSelect_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &objectNameSize;
            case 2: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            case 3: return &authHandleNameSize;
            case 4: { if (newArraySize != -1) authHandleName.resize(newArraySize); arraySize = (int)authHandleName.size(); return &authHandleName; }
            case 5: return &acNameSize;
            case 6: { if (newArraySize != -1) acName.resize(newArraySize); arraySize = (int)acName.size(); return &acName; }
            case 7: return &includeObject;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &objectName[arrayIndex];
            case 4: return &authHandleName[arrayIndex];
            case 6: return &acName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ACT_SetTimeout_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID;
}

TPM2_ACT_SetTimeout_REQUEST::TPM2_ACT_SetTimeout_REQUEST(
    const TPM_HANDLE& _actHandle,
    UINT32 _startTimeout
)
{
    actHandle = _actHandle;
    startTimeout = _startTimeout;
}

/// <summary> This command is used to set the time remaining before an Authenticated Countdown Timer (ACT) expires. </summary>
TPM2_ACT_SetTimeout_REQUEST::~TPM2_ACT_SetTimeout_REQUEST() {}

/// <summary> This command is used to set the time remaining before an Authenticated Countdown Timer (ACT) expires. </summary>
TpmStructureBase* TPM2_ACT_SetTimeout_REQUEST::Clone() const
{
    return new TPM2_ACT_SetTimeout_REQUEST(*this);
}

void* TPM2_ACT_SetTimeout_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&actHandle); return &actHandle;
            case 1: return &startTimeout;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Vendor_TCG_Test_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
}

TPM2_Vendor_TCG_Test_REQUEST::TPM2_Vendor_TCG_Test_REQUEST(
    const ByteVec& _inputData
)
{
    inputData = _inputData;
}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
TPM2_Vendor_TCG_Test_REQUEST::~TPM2_Vendor_TCG_Test_REQUEST() {}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
TpmStructureBase* TPM2_Vendor_TCG_Test_REQUEST::Clone() const
{
    return new TPM2_Vendor_TCG_Test_REQUEST(*this);
}

void* TPM2_Vendor_TCG_Test_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &inputDataSize;
            case 1: { if (newArraySize != -1) inputData.resize(newArraySize); arraySize = (int)inputData.size(); return &inputData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &inputData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId Vendor_TCG_TestResponse::GetTypeId() const
{
    return TpmTypeId::Vendor_TCG_TestResponse_ID;
}

Vendor_TCG_TestResponse::Vendor_TCG_TestResponse(
    const ByteVec& _outputData
)
{
    outputData = _outputData;
}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
Vendor_TCG_TestResponse::~Vendor_TCG_TestResponse() {}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
TpmStructureBase* Vendor_TCG_TestResponse::Clone() const
{
    return new Vendor_TCG_TestResponse(*this);
}

void* Vendor_TCG_TestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outputDataSize;
            case 1: { if (newArraySize != -1) outputData.resize(newArraySize); arraySize = (int)outputData.size(); return &outputData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outputData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TssObject::GetTypeId() const
{
    return TpmTypeId::TssObject_ID;
}

TssObject::TssObject(
    const TPMT_PUBLIC& _Public,
    const TPMT_SENSITIVE& _Sensitive,
    const TPM2B_PRIVATE& _Private
)
{
    Public = _Public;
    Sensitive = _Sensitive;
    Private = _Private;
}

/// <summary> Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object) </summary>
TssObject::~TssObject() {}

/// <summary> Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object) </summary>
TpmStructureBase* TssObject::Clone() const
{
    return new TssObject(*this);
}

void* TssObject::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&Public); return &Public;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&Sensitive); return &Sensitive;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&Private); return &Private;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PcrValue::GetTypeId() const
{
    return TpmTypeId::PcrValue_ID;
}

PcrValue::PcrValue(
    UINT32 _index,
    const TPMT_HA& _value
)
{
    index = _index;
    value = _value;
}

/// <summary> Contains a PCR index and associated hash(pcr-value) [TSS] </summary>
PcrValue::~PcrValue() {}

/// <summary> Contains a PCR index and associated hash(pcr-value) [TSS] </summary>
TpmStructureBase* PcrValue::Clone() const
{
    return new PcrValue(*this);
}

void* PcrValue::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &index;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&value); return &value;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId SessionIn::GetTypeId() const
{
    return TpmTypeId::SessionIn_ID;
}

SessionIn::SessionIn(
    const TPM_HANDLE& _handle,
    const ByteVec& _nonceCaller,
    TPMA_SESSION _attributes,
    const ByteVec& _auth
)
{
    handle = _handle;
    nonceCaller = _nonceCaller;
    attributes = _attributes;
    auth = _auth;
}

/// <summary> Structure representing a session block in a command buffer [TSS] </summary>
SessionIn::~SessionIn() {}

/// <summary> Structure representing a session block in a command buffer [TSS] </summary>
TpmStructureBase* SessionIn::Clone() const
{
    return new SessionIn(*this);
}

void* SessionIn::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nonceCallerSize;
            case 2: { if (newArraySize != -1) nonceCaller.resize(newArraySize); arraySize = (int)nonceCaller.size(); return &nonceCaller; }
            case 3: return &attributes;
            case 4: return &authSize;
            case 5: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nonceCaller[arrayIndex];
            case 5: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SessionOut::GetTypeId() const
{
    return TpmTypeId::SessionOut_ID;
}

SessionOut::SessionOut(
    const ByteVec& _nonceTpm,
    TPMA_SESSION _attributes,
    const ByteVec& _auth
)
{
    nonceTpm = _nonceTpm;
    attributes = _attributes;
    auth = _auth;
}

/// <summary> Structure representing a session block in a response buffer [TSS] </summary>
SessionOut::~SessionOut() {}

/// <summary> Structure representing a session block in a response buffer [TSS] </summary>
TpmStructureBase* SessionOut::Clone() const
{
    return new SessionOut(*this);
}

void* SessionOut::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nonceTpmSize;
            case 1: { if (newArraySize != -1) nonceTpm.resize(newArraySize); arraySize = (int)nonceTpm.size(); return &nonceTpm; }
            case 2: return &attributes;
            case 3: return &authSize;
            case 4: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &nonceTpm[arrayIndex];
            case 4: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CommandHeader::GetTypeId() const
{
    return TpmTypeId::CommandHeader_ID;
}

CommandHeader::CommandHeader(
    TPM_ST _Tag,
    UINT32 _CommandSize,
    TPM_CC _CommandCode
)
{
    Tag = _Tag;
    CommandSize = _CommandSize;
    CommandCode = _CommandCode;
}

/// <summary> Command header [TSS] </summary>
CommandHeader::~CommandHeader() {}

/// <summary> Command header [TSS] </summary>
TpmStructureBase* CommandHeader::Clone() const
{
    return new CommandHeader(*this);
}

void* CommandHeader::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &Tag;
            case 1: return &CommandSize;
            case 2: return &CommandCode;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _TSS_KEY::GetTypeId() const
{
    return TpmTypeId::TSS_KEY_ID;
}

_TSS_KEY::_TSS_KEY(
    const TPMT_PUBLIC& _publicPart,
    const ByteVec& _privatePart
)
{
    publicPart = _publicPart;
    privatePart = _privatePart;
}

/// <summary> Contains the public and private part of a TPM key </summary>
_TSS_KEY::~_TSS_KEY() {}

/// <summary> Contains the public and private part of a TPM key </summary>
TpmStructureBase* _TSS_KEY::Clone() const
{
    return new TSS_KEY(dynamic_cast<const TSS_KEY&>(*this));
}

void* _TSS_KEY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&publicPart); return &publicPart;
            case 1: return &privatePartSize;
            case 2: { if (newArraySize != -1) privatePart.resize(newArraySize); arraySize = (int)privatePart.size(); return &privatePart; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &privatePart[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DIGEST_Symcipher::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
}

TPM2B_DIGEST_Symcipher::TPM2B_DIGEST_Symcipher(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation </summary>
TPM2B_DIGEST_Symcipher::~TPM2B_DIGEST_Symcipher() {}

/// <summary> Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation </summary>
TpmStructureBase* TPM2B_DIGEST_Symcipher::Clone() const
{
    return new TPM2B_DIGEST_Symcipher(*this);
}

void* TPM2B_DIGEST_Symcipher::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DIGEST_Keyedhash::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
}

TPM2B_DIGEST_Keyedhash::TPM2B_DIGEST_Keyedhash(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> Auto-derived from TPM2B_DIGEST </summary>
TPM2B_DIGEST_Keyedhash::~TPM2B_DIGEST_Keyedhash() {}

/// <summary> Auto-derived from TPM2B_DIGEST </summary>
TpmStructureBase* TPM2B_DIGEST_Keyedhash::Clone() const
{
    return new TPM2B_DIGEST_Keyedhash(*this);
}

void* TPM2B_DIGEST_Keyedhash::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmStructureBase* TpmStructureBase::UnionFactory(TpmTypeId objTypeID, TpmTypeId unionTypeID, void* pUnion)
{
    _ASSERT(pUnion && objTypeID != TpmTypeId::None && unionTypeID != TpmTypeId::None);
    
    TpmStructureBase* obj = GetTypeInfo<TpmEntity::Struct>(objTypeID).Factory();
    switch (unionTypeID)
    {
    case TpmTypeId::TPMU_CAPABILITIES_ID: new (pUnion) shared_ptr<TPMU_CAPABILITIES>(dynamic_cast<TPMU_CAPABILITIES*>(obj)); break;
    case TpmTypeId::TPMU_ATTEST_ID: new (pUnion) shared_ptr<TPMU_ATTEST>(dynamic_cast<TPMU_ATTEST*>(obj)); break;
    case TpmTypeId::TPMU_SYM_KEY_BITS_ID: new (pUnion) shared_ptr<TPMU_SYM_KEY_BITS>(dynamic_cast<TPMU_SYM_KEY_BITS*>(obj)); break;
    case TpmTypeId::TPMU_SYM_MODE_ID: new (pUnion) shared_ptr<TPMU_SYM_MODE>(dynamic_cast<TPMU_SYM_MODE*>(obj)); break;
    case TpmTypeId::TPMU_SYM_DETAILS_ID: new (pUnion) shared_ptr<TPMU_SYM_DETAILS>(dynamic_cast<TPMU_SYM_DETAILS*>(obj)); break;
    case TpmTypeId::TPMU_SENSITIVE_CREATE_ID: new (pUnion) shared_ptr<TPMU_SENSITIVE_CREATE>(dynamic_cast<TPMU_SENSITIVE_CREATE*>(obj)); break;
    case TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID: new (pUnion) shared_ptr<TPMU_SCHEME_KEYEDHASH>(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(obj)); break;
    case TpmTypeId::TPMU_SIG_SCHEME_ID: new (pUnion) shared_ptr<TPMU_SIG_SCHEME>(dynamic_cast<TPMU_SIG_SCHEME*>(obj)); break;
    case TpmTypeId::TPMU_KDF_SCHEME_ID: new (pUnion) shared_ptr<TPMU_KDF_SCHEME>(dynamic_cast<TPMU_KDF_SCHEME*>(obj)); break;
    case TpmTypeId::TPMU_ASYM_SCHEME_ID: new (pUnion) shared_ptr<TPMU_ASYM_SCHEME>(dynamic_cast<TPMU_ASYM_SCHEME*>(obj)); break;
    case TpmTypeId::TPMU_SIGNATURE_ID: new (pUnion) shared_ptr<TPMU_SIGNATURE>(dynamic_cast<TPMU_SIGNATURE*>(obj)); break;
    case TpmTypeId::TPMU_ENCRYPTED_SECRET_ID: new (pUnion) shared_ptr<TPMU_ENCRYPTED_SECRET>(dynamic_cast<TPMU_ENCRYPTED_SECRET*>(obj)); break;
    case TpmTypeId::TPMU_PUBLIC_ID_ID: new (pUnion) shared_ptr<TPMU_PUBLIC_ID>(dynamic_cast<TPMU_PUBLIC_ID*>(obj)); break;
    case TpmTypeId::TPMU_PUBLIC_PARMS_ID: new (pUnion) shared_ptr<TPMU_PUBLIC_PARMS>(dynamic_cast<TPMU_PUBLIC_PARMS*>(obj)); break;
    case TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID: new (pUnion) shared_ptr<TPMU_SENSITIVE_COMPOSITE>(dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(obj)); break;
    default: throw new runtime_error("Factory only casts to TPM unions");
    }
    return obj;
}

void TpmTypeInfo::Init()
{
    
    TpmStructInfo* psi;
    
    
    // ======== TPM_HANDLE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM_HANDLE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM_HANDLE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM_HANDLE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM_HANDLE_ID;
    
    // ======== TPMS_NULL_UNION ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_UNION_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_UNION";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_UNION()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_EMPTY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_EMPTY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_EMPTY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_EMPTY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_ALGORITHM_DESCRIPTION ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ALGORITHM_DESCRIPTION";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ALGORITHM_DESCRIPTION()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //alg
    psi->Fields[0].Name = "alg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
    //attributes
    psi->Fields[1].Name = "attributes";
    psi->Fields[1].TypeId = TpmTypeId::TPMA_ALGORITHM_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
    
    // ======== TPMT_HA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_HA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_HA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_HA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_HA_ID;
    //digest
    psi->Fields[1].Name = "digest";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::SpecialVariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_HA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_DIGEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_DIGEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_DIGEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DIGEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_DATA_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_DATA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_EVENT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_EVENT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_EVENT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_EVENT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_EVENT_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_EVENT_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_MAX_BUFFER ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_MAX_BUFFER_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_MAX_BUFFER";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_MAX_BUFFER()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_MAX_BUFFER_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_MAX_BUFFER_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_MAX_NV_BUFFER ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_MAX_NV_BUFFER_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_MAX_NV_BUFFER";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_MAX_NV_BUFFER()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_TIMEOUT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_TIMEOUT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_TIMEOUT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_TIMEOUT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_TIMEOUT_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_TIMEOUT_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_IV ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_IV_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_IV";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_IV()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_IV_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_IV_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_NAME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_NAME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_NAME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_NAME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_NAME_ID;
    //name
    psi->Fields[1].Name = "name";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_NAME_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_PCR_SELECT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_PCR_SELECT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_PCR_SELECT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_PCR_SELECT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //sizeofSelect
    psi->Fields[0].Name = "sizeofSelect";
    psi->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_PCR_SELECT_ID;
    //pcrSelect
    psi->Fields[1].Name = "pcrSelect";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_PCR_SELECT_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_PCR_SELECTION ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_PCR_SELECTION_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_PCR_SELECTION";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_PCR_SELECTION()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    //sizeofSelect
    psi->Fields[1].Name = "sizeofSelect";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    //pcrSelect
    psi->Fields[2].Name = "pcrSelect";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPMT_TK_CREATION ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_TK_CREATION_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_TK_CREATION";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_CREATION()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //tag
    psi->Fields[0].Name = "tag";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    psi->Fields[0].MarshalType = MarshalType::ConstantValue;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    //hierarchy
    psi->Fields[1].Name = "hierarchy";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    //digestSize
    psi->Fields[2].Name = "digestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    //digest
    psi->Fields[3].Name = "digest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMT_TK_VERIFIED ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_TK_VERIFIED_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_TK_VERIFIED";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_VERIFIED()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //tag
    psi->Fields[0].Name = "tag";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    psi->Fields[0].MarshalType = MarshalType::ConstantValue;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    //hierarchy
    psi->Fields[1].Name = "hierarchy";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    //digestSize
    psi->Fields[2].Name = "digestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    //digest
    psi->Fields[3].Name = "digest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMT_TK_AUTH ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_TK_AUTH_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_TK_AUTH";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_AUTH()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //tag
    psi->Fields[0].Name = "tag";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    //hierarchy
    psi->Fields[1].Name = "hierarchy";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    //digestSize
    psi->Fields[2].Name = "digestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    //digest
    psi->Fields[3].Name = "digest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMT_TK_HASHCHECK ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_TK_HASHCHECK_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_TK_HASHCHECK";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_HASHCHECK()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //tag
    psi->Fields[0].Name = "tag";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    psi->Fields[0].MarshalType = MarshalType::ConstantValue;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    //hierarchy
    psi->Fields[1].Name = "hierarchy";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    //digestSize
    psi->Fields[2].Name = "digestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    //digest
    psi->Fields[3].Name = "digest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_ALG_PROPERTY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ALG_PROPERTY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ALG_PROPERTY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ALG_PROPERTY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //alg
    psi->Fields[0].Name = "alg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    //algProperties
    psi->Fields[1].Name = "algProperties";
    psi->Fields[1].TypeId = TpmTypeId::TPMA_ALGORITHM_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    
    // ======== TPMS_TAGGED_PROPERTY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_TAGGED_PROPERTY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_TAGGED_PROPERTY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TAGGED_PROPERTY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //property
    psi->Fields[0].Name = "property";
    psi->Fields[0].TypeId = TpmTypeId::TPM_PT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    //value
    psi->Fields[1].Name = "value";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    
    // ======== TPMS_TAGGED_PCR_SELECT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_TAGGED_PCR_SELECT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TAGGED_PCR_SELECT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //tag
    psi->Fields[0].Name = "tag";
    psi->Fields[0].TypeId = TpmTypeId::TPM_PT_PCR_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    //sizeofSelect
    psi->Fields[1].Name = "sizeofSelect";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    //pcrSelect
    psi->Fields[2].Name = "pcrSelect";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_TAGGED_POLICY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_TAGGED_POLICY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_TAGGED_POLICY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TAGGED_POLICY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    //policyHash
    psi->Fields[1].Name = "policyHash";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    
    // ======== TPMS_ACT_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ACT_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ACT_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ACT_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ACT_DATA_ID;
    //timeout
    psi->Fields[1].Name = "timeout";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ACT_DATA_ID;
    //attributes
    psi->Fields[2].Name = "attributes";
    psi->Fields[2].TypeId = TpmTypeId::TPMA_ACT_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_ACT_DATA_ID;
    
    // ======== TPML_CC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_CC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_CC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_CC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_CC_ID;
    //commandCodes
    psi->Fields[1].Name = "commandCodes";
    psi->Fields[1].TypeId = TpmTypeId::TPM_CC_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_CC_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_CCA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_CCA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_CCA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_CCA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_CCA_ID;
    //commandAttributes
    psi->Fields[1].Name = "commandAttributes";
    psi->Fields[1].TypeId = TpmTypeId::TPMA_CC_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_CCA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ALG ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_ALG_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_ALG";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ALG()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_ALG_ID;
    //algorithms
    psi->Fields[1].Name = "algorithms";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_ALG_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_HANDLE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_HANDLE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_HANDLE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_HANDLE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_HANDLE_ID;
    //handle
    psi->Fields[1].Name = "handle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_HANDLE_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_DIGEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_DIGEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_DIGEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_DIGEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_DIGEST_ID;
    //digests
    psi->Fields[1].Name = "digests";
    psi->Fields[1].TypeId = TpmTypeId::TPM2B_DIGEST_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_DIGEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_DIGEST_VALUES ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_DIGEST_VALUES_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_DIGEST_VALUES";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_DIGEST_VALUES()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_DIGEST_VALUES_ID;
    //digests
    psi->Fields[1].Name = "digests";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_DIGEST_VALUES_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_PCR_SELECTION ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_PCR_SELECTION_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_PCR_SELECTION";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_PCR_SELECTION()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_PCR_SELECTION_ID;
    //pcrSelections
    psi->Fields[1].Name = "pcrSelections";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_PCR_SELECTION_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ALG_PROPERTY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_ALG_PROPERTY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_ALG_PROPERTY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ALG_PROPERTY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_ALG_PROPERTY_ID;
    //algProperties
    psi->Fields[1].Name = "algProperties";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_ALG_PROPERTY_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_TAGGED_TPM_PROPERTY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_TAGGED_TPM_PROPERTY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_TAGGED_TPM_PROPERTY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    //tpmProperty
    psi->Fields[1].Name = "tpmProperty";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_TAGGED_PCR_PROPERTY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_TAGGED_PCR_PROPERTY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_TAGGED_PCR_PROPERTY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    //pcrProperty
    psi->Fields[1].Name = "pcrProperty";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ECC_CURVE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_ECC_CURVE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_ECC_CURVE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ECC_CURVE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_ECC_CURVE_ID;
    //eccCurves
    psi->Fields[1].Name = "eccCurves";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_ECC_CURVE_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_TAGGED_POLICY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_TAGGED_POLICY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_TAGGED_POLICY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_TAGGED_POLICY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_POLICY_ID;
    //policies
    psi->Fields[1].Name = "policies";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_POLICY_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ACT_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_ACT_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_ACT_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ACT_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_ACT_DATA_ID;
    //actData
    psi->Fields[1].Name = "actData";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ACT_DATA_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_ACT_DATA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_CAPABILITY_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CAPABILITY_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CAPABILITY_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CAPABILITY_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //capability
    psi->Fields[0].Name = "capability";
    psi->Fields[0].TypeId = TpmTypeId::TPM_CAP_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_CAPABILITY_DATA_ID;
    psi->Fields[0].AssociatedField = 1;
    //data
    psi->Fields[1].Name = "data";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_CAPABILITIES_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_CAPABILITY_DATA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_CLOCK_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CLOCK_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CLOCK_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CLOCK_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //clock
    psi->Fields[0].Name = "clock";
    psi->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    //resetCount
    psi->Fields[1].Name = "resetCount";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    //restartCount
    psi->Fields[2].Name = "restartCount";
    psi->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    //safe
    psi->Fields[3].Name = "safe";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    
    // ======== TPMS_TIME_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_TIME_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_TIME_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TIME_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //time
    psi->Fields[0].Name = "time";
    psi->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_TIME_INFO_ID;
    //clockInfo
    psi->Fields[1].Name = "clockInfo";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_CLOCK_INFO_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_TIME_INFO_ID;
    
    // ======== TPMS_TIME_ATTEST_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_TIME_ATTEST_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_TIME_ATTEST_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TIME_ATTEST_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //time
    psi->Fields[0].Name = "time";
    psi->Fields[0].TypeId = TpmTypeId::TPMS_TIME_INFO_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    //firmwareVersion
    psi->Fields[1].Name = "firmwareVersion";
    psi->Fields[1].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    
    // ======== TPMS_CERTIFY_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CERTIFY_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CERTIFY_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CERTIFY_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //nameSize
    psi->Fields[0].Name = "nameSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    //name
    psi->Fields[1].Name = "name";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    psi->Fields[1].AssociatedField = 0;
    //qualifiedNameSize
    psi->Fields[2].Name = "qualifiedNameSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    //qualifiedName
    psi->Fields[3].Name = "qualifiedName";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_QUOTE_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_QUOTE_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_QUOTE_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_QUOTE_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //pcrSelectCount
    psi->Fields[0].Name = "pcrSelectCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    //pcrSelect
    psi->Fields[1].Name = "pcrSelect";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    psi->Fields[1].AssociatedField = 0;
    //pcrDigestSize
    psi->Fields[2].Name = "pcrDigestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    //pcrDigest
    psi->Fields[3].Name = "pcrDigest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_COMMAND_AUDIT_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_COMMAND_AUDIT_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_COMMAND_AUDIT_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //auditCounter
    psi->Fields[0].Name = "auditCounter";
    psi->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //digestAlg
    psi->Fields[1].Name = "digestAlg";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //auditDigestSize
    psi->Fields[2].Name = "auditDigestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //auditDigest
    psi->Fields[3].Name = "auditDigest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    psi->Fields[3].AssociatedField = 2;
    //commandDigestSize
    psi->Fields[4].Name = "commandDigestSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //commandDigest
    psi->Fields[5].Name = "commandDigest";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPMS_SESSION_AUDIT_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SESSION_AUDIT_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SESSION_AUDIT_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //exclusiveSession
    psi->Fields[0].Name = "exclusiveSession";
    psi->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    //sessionDigestSize
    psi->Fields[1].Name = "sessionDigestSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    //sessionDigest
    psi->Fields[2].Name = "sessionDigest";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_CREATION_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CREATION_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CREATION_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CREATION_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //objectNameSize
    psi->Fields[0].Name = "objectNameSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    //objectName
    psi->Fields[1].Name = "objectName";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    psi->Fields[1].AssociatedField = 0;
    //creationHashSize
    psi->Fields[2].Name = "creationHashSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    //creationHash
    psi->Fields[3].Name = "creationHash";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_NV_CERTIFY_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NV_CERTIFY_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NV_CERTIFY_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_CERTIFY_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //indexNameSize
    psi->Fields[0].Name = "indexNameSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    //indexName
    psi->Fields[1].Name = "indexName";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    psi->Fields[1].AssociatedField = 0;
    //offset
    psi->Fields[2].Name = "offset";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    //nvContentsSize
    psi->Fields[3].Name = "nvContentsSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    //nvContents
    psi->Fields[4].Name = "nvContents";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_NV_DIGEST_CERTIFY_INFO ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NV_DIGEST_CERTIFY_INFO";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_DIGEST_CERTIFY_INFO()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //indexNameSize
    psi->Fields[0].Name = "indexNameSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    //indexName
    psi->Fields[1].Name = "indexName";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    psi->Fields[1].AssociatedField = 0;
    //nvDigestSize
    psi->Fields[2].Name = "nvDigestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    //nvDigest
    psi->Fields[3].Name = "nvDigest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_ATTEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ATTEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ATTEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ATTEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(9);
    //magic
    psi->Fields[0].Name = "magic";
    psi->Fields[0].TypeId = TpmTypeId::TPM_GENERATED_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //type
    psi->Fields[1].Name = "type";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ST_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionSelector;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].AssociatedField = 8;
    //qualifiedSignerSize
    psi->Fields[2].Name = "qualifiedSignerSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //qualifiedSigner
    psi->Fields[3].Name = "qualifiedSigner";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //extraDataSize
    psi->Fields[4].Name = "extraDataSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //extraData
    psi->Fields[5].Name = "extraData";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[5].AssociatedField = 4;
    //clockInfo
    psi->Fields[6].Name = "clockInfo";
    psi->Fields[6].TypeId = TpmTypeId::TPMS_CLOCK_INFO_ID;
    psi->Fields[6].MarshalType = MarshalType::Normal;
    psi->Fields[6].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //firmwareVersion
    psi->Fields[7].Name = "firmwareVersion";
    psi->Fields[7].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[7].MarshalType = MarshalType::Normal;
    psi->Fields[7].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //attested
    psi->Fields[8].Name = "attested";
    psi->Fields[8].TypeId = TpmTypeId::TPMU_ATTEST_ID;
    psi->Fields[8].MarshalType = MarshalType::UnionObject;
    psi->Fields[8].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[8].AssociatedField = 1;
    
    // ======== TPM2B_ATTEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_ATTEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_ATTEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ATTEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_ATTEST_ID;
    //attestationData
    psi->Fields[1].Name = "attestationData";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_ATTEST_ID;
    
    // ======== TPMS_AUTH_COMMAND ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_AUTH_COMMAND_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_AUTH_COMMAND";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_AUTH_COMMAND()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //sessionHandle
    psi->Fields[0].Name = "sessionHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //nonceSize
    psi->Fields[1].Name = "nonceSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //nonce
    psi->Fields[2].Name = "nonce";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    psi->Fields[2].AssociatedField = 1;
    //sessionAttributes
    psi->Fields[3].Name = "sessionAttributes";
    psi->Fields[3].TypeId = TpmTypeId::TPMA_SESSION_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //hmacSize
    psi->Fields[4].Name = "hmacSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //hmac
    psi->Fields[5].Name = "hmac";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== AUTHResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::AUTHResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "AUTHResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new AUTHResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //nonceSize
    psi->Fields[0].Name = "nonceSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::AUTHResponse_ID;
    //nonce
    psi->Fields[1].Name = "nonce";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::AUTHResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //sessionAttributes
    psi->Fields[2].Name = "sessionAttributes";
    psi->Fields[2].TypeId = TpmTypeId::TPMA_SESSION_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::AUTHResponse_ID;
    //hmacSize
    psi->Fields[3].Name = "hmacSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::AUTHResponse_ID;
    //hmac
    psi->Fields[4].Name = "hmac";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::AUTHResponse_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_NULL_SYM_KEY_BITS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_SYM_KEY_BITS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SYM_KEY_BITS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_XOR_SYM_MODE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_XOR_SYM_MODE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_XOR_SYM_MODE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_XOR_SYM_MODE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_NULL_SYM_MODE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SYM_MODE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_SYM_MODE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SYM_MODE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_TDES_SYM_DETAILS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_TDES_SYM_DETAILS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_TDES_SYM_DETAILS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TDES_SYM_DETAILS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_AES_SYM_DETAILS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_AES_SYM_DETAILS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_AES_SYM_DETAILS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_AES_SYM_DETAILS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_SM4_SYM_DETAILS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SM4_SYM_DETAILS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SM4_SYM_DETAILS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SM4_SYM_DETAILS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_CAMELLIA_SYM_DETAILS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CAMELLIA_SYM_DETAILS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CAMELLIA_SYM_DETAILS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_ANY_SYM_DETAILS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ANY_SYM_DETAILS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ANY_SYM_DETAILS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ANY_SYM_DETAILS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_XOR_SYM_DETAILS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_XOR_SYM_DETAILS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_XOR_SYM_DETAILS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_XOR_SYM_DETAILS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_NULL_SYM_DETAILS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SYM_DETAILS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_SYM_DETAILS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SYM_DETAILS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMT_SYM_DEF ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_SYM_DEF_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_SYM_DEF";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SYM_DEF()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //algorithm
    psi->Fields[0].Name = "algorithm";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    //keyBits
    psi->Fields[1].Name = "keyBits";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    //mode
    psi->Fields[2].Name = "mode";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    
    // ======== TPMT_SYM_DEF_OBJECT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_SYM_DEF_OBJECT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_SYM_DEF_OBJECT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SYM_DEF_OBJECT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //algorithm
    psi->Fields[0].Name = "algorithm";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    //keyBits
    psi->Fields[1].Name = "keyBits";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    //mode
    psi->Fields[2].Name = "mode";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    
    // ======== TPM2B_SYM_KEY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_SYM_KEY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_SYM_KEY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SYM_KEY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_SYM_KEY_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_SYM_KEY_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_SYMCIPHER_PARMS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SYMCIPHER_PARMS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SYMCIPHER_PARMS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SYMCIPHER_PARMS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //sym
    psi->Fields[0].Name = "sym";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
    
    // ======== TPM2B_LABEL ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_LABEL_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_LABEL";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_LABEL()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_LABEL_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_LABEL_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_DERIVE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_DERIVE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_DERIVE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_DERIVE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //labelSize
    psi->Fields[0].Name = "labelSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    //label
    psi->Fields[1].Name = "label";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    psi->Fields[1].AssociatedField = 0;
    //contextSize
    psi->Fields[2].Name = "contextSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    //context
    psi->Fields[3].Name = "context";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2B_DERIVE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_DERIVE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_DERIVE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DERIVE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_DERIVE_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_DERIVE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_DERIVE_ID;
    
    // ======== TPM2B_SENSITIVE_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_SENSITIVE_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SENSITIVE_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_SENSITIVE_CREATE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SENSITIVE_CREATE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SENSITIVE_CREATE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SENSITIVE_CREATE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //userAuthSize
    psi->Fields[0].Name = "userAuthSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    //userAuth
    psi->Fields[1].Name = "userAuth";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    psi->Fields[1].AssociatedField = 0;
    //dataSize
    psi->Fields[2].Name = "dataSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    //data
    psi->Fields[3].Name = "data";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2B_SENSITIVE_CREATE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_CREATE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_SENSITIVE_CREATE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SENSITIVE_CREATE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
    //sensitive
    psi->Fields[1].Name = "sensitive";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
    
    // ======== TPMS_SCHEME_HASH ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_HASH_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SCHEME_HASH";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_HASH()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_HASH_ID;
    
    // ======== TPMS_SCHEME_ECDAA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_ECDAA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SCHEME_ECDAA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_ECDAA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_ECDAA_ID;
    //count
    psi->Fields[1].Name = "count";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SCHEME_ECDAA_ID;
    
    // ======== TPMS_SCHEME_HMAC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_HMAC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SCHEME_HMAC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_HMAC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    
    // ======== TPMS_SCHEME_XOR ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_XOR_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SCHEME_XOR";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_XOR()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_XOR_ID;
    //kdf
    psi->Fields[1].Name = "kdf";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SCHEME_XOR_ID;
    
    // ======== TPMS_NULL_SCHEME_KEYEDHASH ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_SCHEME_KEYEDHASH";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SCHEME_KEYEDHASH()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMT_KEYEDHASH_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_KEYEDHASH_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_KEYEDHASH_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //scheme
    psi->Fields[0].Name = "scheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
    psi->Fields[0].AssociatedField = 1;
    //details
    psi->Fields[1].Name = "details";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_SIG_SCHEME_RSASSA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIG_SCHEME_RSASSA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_RSASSA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    
    // ======== TPMS_SIG_SCHEME_RSAPSS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIG_SCHEME_RSAPSS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_RSAPSS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    
    // ======== TPMS_SIG_SCHEME_ECDSA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIG_SCHEME_ECDSA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_ECDSA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    
    // ======== TPMS_SIG_SCHEME_SM2 ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_SM2_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIG_SCHEME_SM2";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_SM2()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    
    // ======== TPMS_SIG_SCHEME_ECSCHNORR ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIG_SCHEME_ECSCHNORR";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_ECSCHNORR()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    
    // ======== TPMS_SIG_SCHEME_ECDAA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIG_SCHEME_ECDAA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_ECDAA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    //count
    psi->Fields[1].Name = "count";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    
    // ======== TPMS_NULL_SIG_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SIG_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_SIG_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SIG_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMT_SIG_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_SIG_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_SIG_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SIG_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //scheme
    psi->Fields[0].Name = "scheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_SIG_SCHEME_ID;
    psi->Fields[0].AssociatedField = 1;
    //details
    psi->Fields[1].Name = "details";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_SIG_SCHEME_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ENC_SCHEME_OAEP ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ENC_SCHEME_OAEP";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ENC_SCHEME_OAEP()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
    
    // ======== TPMS_ENC_SCHEME_RSAES ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ENC_SCHEME_RSAES";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ENC_SCHEME_RSAES()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMS_KEY_SCHEME_ECDH ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_KEY_SCHEME_ECDH";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KEY_SCHEME_ECDH()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
    
    // ======== TPMS_KEY_SCHEME_ECMQV ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_KEY_SCHEME_ECMQV";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KEY_SCHEME_ECMQV()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
    
    // ======== TPMS_KDF_SCHEME_MGF1 ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_KDF_SCHEME_MGF1";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_MGF1()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID;
    
    // ======== TPMS_KDF_SCHEME_KDF1_SP800_56A ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_KDF_SCHEME_KDF1_SP800_56A";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_KDF1_SP800_56A()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID;
    
    // ======== TPMS_KDF_SCHEME_KDF2 ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_KDF_SCHEME_KDF2";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_KDF2()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID;
    
    // ======== TPMS_KDF_SCHEME_KDF1_SP800_108 ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_KDF_SCHEME_KDF1_SP800_108";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_KDF1_SP800_108()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //hashAlg
    psi->Fields[0].Name = "hashAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID;
    
    // ======== TPMS_NULL_KDF_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_KDF_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_KDF_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_KDF_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMT_KDF_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_KDF_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_KDF_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_KDF_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //scheme
    psi->Fields[0].Name = "scheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_KDF_SCHEME_ID;
    psi->Fields[0].AssociatedField = 1;
    //details
    psi->Fields[1].Name = "details";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_KDF_SCHEME_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_NULL_ASYM_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_ASYM_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_ASYM_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMT_ASYM_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_ASYM_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_ASYM_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_ASYM_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //scheme
    psi->Fields[0].Name = "scheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_ASYM_SCHEME_ID;
    psi->Fields[0].AssociatedField = 1;
    //details
    psi->Fields[1].Name = "details";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_ASYM_SCHEME_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_RSA_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_RSA_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_RSA_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_RSA_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //scheme
    psi->Fields[0].Name = "scheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_RSA_SCHEME_ID;
    psi->Fields[0].AssociatedField = 1;
    //details
    psi->Fields[1].Name = "details";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_RSA_SCHEME_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_RSA_DECRYPT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_RSA_DECRYPT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_RSA_DECRYPT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_RSA_DECRYPT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //scheme
    psi->Fields[0].Name = "scheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_RSA_DECRYPT_ID;
    psi->Fields[0].AssociatedField = 1;
    //details
    psi->Fields[1].Name = "details";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_RSA_DECRYPT_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_PUBLIC_KEY_RSA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_PUBLIC_KEY_RSA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PUBLIC_KEY_RSA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_PRIVATE_KEY_RSA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_PRIVATE_KEY_RSA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PRIVATE_KEY_RSA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_ECC_PARAMETER ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_ECC_PARAMETER_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_ECC_PARAMETER";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ECC_PARAMETER()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ECC_POINT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ECC_POINT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ECC_POINT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ECC_POINT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //xSize
    psi->Fields[0].Name = "xSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    //x
    psi->Fields[1].Name = "x";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].AssociatedField = 0;
    //ySize
    psi->Fields[2].Name = "ySize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    //y
    psi->Fields[3].Name = "y";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2B_ECC_POINT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_ECC_POINT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_ECC_POINT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ECC_POINT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_ECC_POINT_ID;
    //point
    psi->Fields[1].Name = "point";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_ECC_POINT_ID;
    
    // ======== TPMT_ECC_SCHEME ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_ECC_SCHEME_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_ECC_SCHEME";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_ECC_SCHEME()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //scheme
    psi->Fields[0].Name = "scheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_ECC_SCHEME_ID;
    psi->Fields[0].AssociatedField = 1;
    //details
    psi->Fields[1].Name = "details";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_ECC_SCHEME_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ALGORITHM_DETAIL_ECC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ALGORITHM_DETAIL_ECC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ALGORITHM_DETAIL_ECC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(20);
    //curveID
    psi->Fields[0].Name = "curveID";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //keySize
    psi->Fields[1].Name = "keySize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //kdfScheme
    psi->Fields[2].Name = "kdfScheme";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[2].AssociatedField = 3;
    //kdf
    psi->Fields[3].Name = "kdf";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[3].AssociatedField = 2;
    //signScheme
    psi->Fields[4].Name = "signScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[4].AssociatedField = 5;
    //sign
    psi->Fields[5].Name = "sign";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[5].AssociatedField = 4;
    //pSize
    psi->Fields[6].Name = "pSize";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::ArrayCount;
    psi->Fields[6].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //p
    psi->Fields[7].Name = "p";
    psi->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[7].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[7].AssociatedField = 6;
    //aSize
    psi->Fields[8].Name = "aSize";
    psi->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[8].MarshalType = MarshalType::ArrayCount;
    psi->Fields[8].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //a
    psi->Fields[9].Name = "a";
    psi->Fields[9].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[9].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[9].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[9].AssociatedField = 8;
    //bSize
    psi->Fields[10].Name = "bSize";
    psi->Fields[10].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[10].MarshalType = MarshalType::ArrayCount;
    psi->Fields[10].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //b
    psi->Fields[11].Name = "b";
    psi->Fields[11].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[11].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[11].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[11].AssociatedField = 10;
    //gXSize
    psi->Fields[12].Name = "gXSize";
    psi->Fields[12].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[12].MarshalType = MarshalType::ArrayCount;
    psi->Fields[12].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //gX
    psi->Fields[13].Name = "gX";
    psi->Fields[13].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[13].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[13].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[13].AssociatedField = 12;
    //gYSize
    psi->Fields[14].Name = "gYSize";
    psi->Fields[14].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[14].MarshalType = MarshalType::ArrayCount;
    psi->Fields[14].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //gY
    psi->Fields[15].Name = "gY";
    psi->Fields[15].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[15].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[15].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[15].AssociatedField = 14;
    //nSize
    psi->Fields[16].Name = "nSize";
    psi->Fields[16].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[16].MarshalType = MarshalType::ArrayCount;
    psi->Fields[16].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //n
    psi->Fields[17].Name = "n";
    psi->Fields[17].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[17].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[17].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[17].AssociatedField = 16;
    //hSize
    psi->Fields[18].Name = "hSize";
    psi->Fields[18].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[18].MarshalType = MarshalType::ArrayCount;
    psi->Fields[18].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //h
    psi->Fields[19].Name = "h";
    psi->Fields[19].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[19].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[19].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[19].AssociatedField = 18;
    
    // ======== TPMS_SIGNATURE_RSA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_RSA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_RSA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    //sigSize
    psi->Fields[1].Name = "sigSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    //sig
    psi->Fields[2].Name = "sig";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_SIGNATURE_RSASSA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSASSA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_RSASSA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_RSASSA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    //sigSize
    psi->Fields[1].Name = "sigSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    //sig
    psi->Fields[2].Name = "sig";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_SIGNATURE_RSAPSS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_RSAPSS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_RSAPSS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    //sigSize
    psi->Fields[1].Name = "sigSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    //sig
    psi->Fields[2].Name = "sig";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_SIGNATURE_ECC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_ECC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    //signatureRSize
    psi->Fields[1].Name = "signatureRSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    //signatureR
    psi->Fields[2].Name = "signatureR";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    psi->Fields[2].AssociatedField = 1;
    //signatureSSize
    psi->Fields[3].Name = "signatureSSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    //signatureS
    psi->Fields[4].Name = "signatureS";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_ECDSA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECDSA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_ECDSA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECDSA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    //signatureRSize
    psi->Fields[1].Name = "signatureRSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    //signatureR
    psi->Fields[2].Name = "signatureR";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    psi->Fields[2].AssociatedField = 1;
    //signatureSSize
    psi->Fields[3].Name = "signatureSSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    //signatureS
    psi->Fields[4].Name = "signatureS";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_ECDAA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECDAA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_ECDAA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECDAA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    //signatureRSize
    psi->Fields[1].Name = "signatureRSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    //signatureR
    psi->Fields[2].Name = "signatureR";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    psi->Fields[2].AssociatedField = 1;
    //signatureSSize
    psi->Fields[3].Name = "signatureSSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    //signatureS
    psi->Fields[4].Name = "signatureS";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_SM2 ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_SM2_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_SM2";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_SM2()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    //signatureRSize
    psi->Fields[1].Name = "signatureRSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    //signatureR
    psi->Fields[2].Name = "signatureR";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    psi->Fields[2].AssociatedField = 1;
    //signatureSSize
    psi->Fields[3].Name = "signatureSSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    //signatureS
    psi->Fields[4].Name = "signatureS";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_ECSCHNORR ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_SIGNATURE_ECSCHNORR";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECSCHNORR()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //hash
    psi->Fields[0].Name = "hash";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    //signatureRSize
    psi->Fields[1].Name = "signatureRSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    //signatureR
    psi->Fields[2].Name = "signatureR";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    psi->Fields[2].AssociatedField = 1;
    //signatureSSize
    psi->Fields[3].Name = "signatureSSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    //signatureS
    psi->Fields[4].Name = "signatureS";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_NULL_SIGNATURE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SIGNATURE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NULL_SIGNATURE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SIGNATURE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== TPMT_SIGNATURE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_SIGNATURE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_SIGNATURE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SIGNATURE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //sigAlg
    psi->Fields[0].Name = "sigAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_SIGNATURE_ID;
    psi->Fields[0].AssociatedField = 1;
    //signature
    psi->Fields[1].Name = "signature";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_SIGNATURE_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_ENCRYPTED_SECRET ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_ENCRYPTED_SECRET";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ENCRYPTED_SECRET()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
    //secret
    psi->Fields[1].Name = "secret";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_KEYEDHASH_PARMS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_KEYEDHASH_PARMS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_KEYEDHASH_PARMS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KEYEDHASH_PARMS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //schemeScheme
    psi->Fields[0].Name = "schemeScheme";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    psi->Fields[0].AssociatedField = 1;
    //scheme
    psi->Fields[1].Name = "scheme";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ASYM_PARMS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ASYM_PARMS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ASYM_PARMS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ASYM_PARMS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //symmetric
    psi->Fields[0].Name = "symmetric";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    //schemeScheme
    psi->Fields[1].Name = "schemeScheme";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionSelector;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    psi->Fields[1].AssociatedField = 2;
    //scheme
    psi->Fields[2].Name = "scheme";
    psi->Fields[2].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionObject;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_RSA_PARMS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_RSA_PARMS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_RSA_PARMS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_RSA_PARMS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //symmetric
    psi->Fields[0].Name = "symmetric";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    //schemeScheme
    psi->Fields[1].Name = "schemeScheme";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionSelector;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    psi->Fields[1].AssociatedField = 2;
    //scheme
    psi->Fields[2].Name = "scheme";
    psi->Fields[2].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionObject;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    psi->Fields[2].AssociatedField = 1;
    //keyBits
    psi->Fields[3].Name = "keyBits";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    //exponent
    psi->Fields[4].Name = "exponent";
    psi->Fields[4].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    
    // ======== TPMS_ECC_PARMS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ECC_PARMS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ECC_PARMS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ECC_PARMS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //symmetric
    psi->Fields[0].Name = "symmetric";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    //schemeScheme
    psi->Fields[1].Name = "schemeScheme";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionSelector;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    psi->Fields[1].AssociatedField = 2;
    //scheme
    psi->Fields[2].Name = "scheme";
    psi->Fields[2].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionObject;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    psi->Fields[2].AssociatedField = 1;
    //curveID
    psi->Fields[3].Name = "curveID";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    //kdfScheme
    psi->Fields[4].Name = "kdfScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    psi->Fields[4].AssociatedField = 5;
    //kdf
    psi->Fields[5].Name = "kdf";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPMT_PUBLIC_PARMS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_PUBLIC_PARMS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_PUBLIC_PARMS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_PUBLIC_PARMS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //type
    psi->Fields[0].Name = "type";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_PUBLIC_PARMS_ID;
    psi->Fields[0].AssociatedField = 1;
    //parameters
    psi->Fields[1].Name = "parameters";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_PUBLIC_PARMS_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_PUBLIC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_PUBLIC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_PUBLIC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_PUBLIC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(7);
    //type
    psi->Fields[0].Name = "type";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[0].AssociatedField = 5;
    //nameAlg
    psi->Fields[1].Name = "nameAlg";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    //objectAttributes
    psi->Fields[2].Name = "objectAttributes";
    psi->Fields[2].TypeId = TpmTypeId::TPMA_OBJECT_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    //authPolicySize
    psi->Fields[3].Name = "authPolicySize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    //authPolicy
    psi->Fields[4].Name = "authPolicy";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[4].AssociatedField = 3;
    //parameters
    psi->Fields[5].Name = "parameters";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[5].AssociatedField = 0;
    //unique
    psi->Fields[6].Name = "unique";
    psi->Fields[6].TypeId = TpmTypeId::TPMU_PUBLIC_ID_ID;
    psi->Fields[6].MarshalType = MarshalType::UnionObject;
    psi->Fields[6].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[6].AssociatedField = 0;
    
    // ======== TPM2B_PUBLIC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_PUBLIC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_PUBLIC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PUBLIC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_PUBLIC_ID;
    //publicArea
    psi->Fields[1].Name = "publicArea";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_PUBLIC_ID;
    
    // ======== TPM2B_TEMPLATE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_TEMPLATE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_TEMPLATE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_TEMPLATE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_TEMPLATE_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_TEMPLATE_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_PRIVATE_VENDOR_SPECIFIC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_PRIVATE_VENDOR_SPECIFIC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PRIVATE_VENDOR_SPECIFIC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_SENSITIVE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMT_SENSITIVE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMT_SENSITIVE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SENSITIVE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //sensitiveType
    psi->Fields[0].Name = "sensitiveType";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[0].AssociatedField = 5;
    //authValueSize
    psi->Fields[1].Name = "authValueSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    //authValue
    psi->Fields[2].Name = "authValue";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[2].AssociatedField = 1;
    //seedValueSize
    psi->Fields[3].Name = "seedValueSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    //seedValue
    psi->Fields[4].Name = "seedValue";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[4].AssociatedField = 3;
    //sensitive
    psi->Fields[5].Name = "sensitive";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[5].AssociatedField = 0;
    
    // ======== TPM2B_SENSITIVE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_SENSITIVE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SENSITIVE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_ID;
    //sensitiveArea
    psi->Fields[1].Name = "sensitiveArea";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_ID;
    
    // ======== _PRIVATE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::_PRIVATE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "_PRIVATE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new _PRIVATE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //integrityOuterSize
    psi->Fields[0].Name = "integrityOuterSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::_PRIVATE_ID;
    //integrityOuter
    psi->Fields[1].Name = "integrityOuter";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::_PRIVATE_ID;
    psi->Fields[1].AssociatedField = 0;
    //integrityInnerSize
    psi->Fields[2].Name = "integrityInnerSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::_PRIVATE_ID;
    //integrityInner
    psi->Fields[3].Name = "integrityInner";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::_PRIVATE_ID;
    psi->Fields[3].AssociatedField = 2;
    //sensitiveSize
    psi->Fields[4].Name = "sensitiveSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[4].ParentType = TpmTypeId::_PRIVATE_ID;
    //sensitive
    psi->Fields[5].Name = "sensitive";
    psi->Fields[5].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::_PRIVATE_ID;
    
    // ======== TPM2B_PRIVATE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_PRIVATE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_PRIVATE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PRIVATE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ID_OBJECT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_ID_OBJECT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_ID_OBJECT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ID_OBJECT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //integrityHMACSize
    psi->Fields[0].Name = "integrityHMACSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    //integrityHMAC
    psi->Fields[1].Name = "integrityHMAC";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    psi->Fields[1].AssociatedField = 0;
    //encIdentity
    psi->Fields[2].Name = "encIdentity";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::EncryptedVariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    
    // ======== TPM2B_ID_OBJECT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_ID_OBJECT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_ID_OBJECT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ID_OBJECT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_ID_OBJECT_ID;
    //credential
    psi->Fields[1].Name = "credential";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ID_OBJECT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_ID_OBJECT_ID;
    
    // ======== TPMS_NV_PIN_COUNTER_PARAMETERS ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NV_PIN_COUNTER_PARAMETERS";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_PIN_COUNTER_PARAMETERS()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //pinCount
    psi->Fields[0].Name = "pinCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
    //pinLimit
    psi->Fields[1].Name = "pinLimit";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
    
    // ======== TPMS_NV_PUBLIC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_NV_PUBLIC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_NV_PUBLIC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_PUBLIC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //nvIndex
    psi->Fields[0].Name = "nvIndex";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //nameAlg
    psi->Fields[1].Name = "nameAlg";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //attributes
    psi->Fields[2].Name = "attributes";
    psi->Fields[2].TypeId = TpmTypeId::TPMA_NV_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //authPolicySize
    psi->Fields[3].Name = "authPolicySize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //authPolicy
    psi->Fields[4].Name = "authPolicy";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    psi->Fields[4].AssociatedField = 3;
    //dataSize
    psi->Fields[5].Name = "dataSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    
    // ======== TPM2B_NV_PUBLIC ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_NV_PUBLIC_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_NV_PUBLIC";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_NV_PUBLIC()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_NV_PUBLIC_ID;
    //nvPublic
    psi->Fields[1].Name = "nvPublic";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_NV_PUBLIC_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_NV_PUBLIC_ID;
    
    // ======== TPM2B_CONTEXT_SENSITIVE ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_CONTEXT_SENSITIVE";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_CONTEXT_SENSITIVE()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_CONTEXT_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CONTEXT_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CONTEXT_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CONTEXT_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //integritySize
    psi->Fields[0].Name = "integritySize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    //integrity
    psi->Fields[1].Name = "integrity";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    psi->Fields[1].AssociatedField = 0;
    //encrypted
    psi->Fields[2].Name = "encrypted";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::EncryptedVariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    
    // ======== TPM2B_CONTEXT_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_CONTEXT_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_CONTEXT_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_CONTEXT_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_CONTEXT_DATA_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_CONTEXT_DATA_ID;
    
    // ======== TPMS_CONTEXT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CONTEXT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CONTEXT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CONTEXT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //sequence
    psi->Fields[0].Name = "sequence";
    psi->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //savedHandle
    psi->Fields[1].Name = "savedHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //hierarchy
    psi->Fields[2].Name = "hierarchy";
    psi->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //contextBlobSize
    psi->Fields[3].Name = "contextBlobSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //contextBlob
    psi->Fields[4].Name = "contextBlob";
    psi->Fields[4].TypeId = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    
    // ======== TPMS_CREATION_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_CREATION_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_CREATION_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CREATION_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(12);
    //pcrSelectCount
    psi->Fields[0].Name = "pcrSelectCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //pcrSelect
    psi->Fields[1].Name = "pcrSelect";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[1].AssociatedField = 0;
    //pcrDigestSize
    psi->Fields[2].Name = "pcrDigestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //pcrDigest
    psi->Fields[3].Name = "pcrDigest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[3].AssociatedField = 2;
    //locality
    psi->Fields[4].Name = "locality";
    psi->Fields[4].TypeId = TpmTypeId::TPMA_LOCALITY_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentNameAlg
    psi->Fields[5].Name = "parentNameAlg";
    psi->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentNameSize
    psi->Fields[6].Name = "parentNameSize";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::ArrayCount;
    psi->Fields[6].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentName
    psi->Fields[7].Name = "parentName";
    psi->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[7].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[7].AssociatedField = 6;
    //parentQualifiedNameSize
    psi->Fields[8].Name = "parentQualifiedNameSize";
    psi->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[8].MarshalType = MarshalType::ArrayCount;
    psi->Fields[8].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentQualifiedName
    psi->Fields[9].Name = "parentQualifiedName";
    psi->Fields[9].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[9].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[9].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[9].AssociatedField = 8;
    //outsideInfoSize
    psi->Fields[10].Name = "outsideInfoSize";
    psi->Fields[10].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[10].MarshalType = MarshalType::ArrayCount;
    psi->Fields[10].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //outsideInfo
    psi->Fields[11].Name = "outsideInfo";
    psi->Fields[11].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[11].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[11].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[11].AssociatedField = 10;
    
    // ======== TPM2B_CREATION_DATA ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_CREATION_DATA_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_CREATION_DATA";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_CREATION_DATA()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_CREATION_DATA_ID;
    //creationData
    psi->Fields[1].Name = "creationData";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_CREATION_DATA_ID;
    
    // ======== TPMS_AC_OUTPUT ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPMS_AC_OUTPUT_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPMS_AC_OUTPUT";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_AC_OUTPUT()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //tag
    psi->Fields[0].Name = "tag";
    psi->Fields[0].TypeId = TpmTypeId::TPM_AT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    //data
    psi->Fields[1].Name = "data";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    
    // ======== TPML_AC_CAPABILITIES ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPML_AC_CAPABILITIES_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPML_AC_CAPABILITIES";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_AC_CAPABILITIES()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //count
    psi->Fields[0].Name = "count";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPML_AC_CAPABILITIES_ID;
    //acCapabilities
    psi->Fields[1].Name = "acCapabilities";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_AC_OUTPUT_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPML_AC_CAPABILITIES_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_Startup_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Startup_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Startup_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Startup_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //startupType
    psi->Fields[0].Name = "startupType";
    psi->Fields[0].TypeId = TpmTypeId::TPM_SU_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Startup_REQUEST_ID;
    
    // ======== TPM2_Shutdown_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Shutdown_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Shutdown_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Shutdown_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //shutdownType
    psi->Fields[0].Name = "shutdownType";
    psi->Fields[0].TypeId = TpmTypeId::TPM_SU_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Shutdown_REQUEST_ID;
    
    // ======== TPM2_SelfTest_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_SelfTest_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_SelfTest_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SelfTest_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //fullTest
    psi->Fields[0].Name = "fullTest";
    psi->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_SelfTest_REQUEST_ID;
    
    // ======== TPM2_IncrementalSelfTest_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_IncrementalSelfTest_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_IncrementalSelfTest_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //toTestCount
    psi->Fields[0].Name = "toTestCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
    //toTest
    psi->Fields[1].Name = "toTest";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== IncrementalSelfTestResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::IncrementalSelfTestResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "IncrementalSelfTestResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new IncrementalSelfTestResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //toDoListCount
    psi->Fields[0].Name = "toDoListCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::IncrementalSelfTestResponse_ID;
    //toDoList
    psi->Fields[1].Name = "toDoList";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::IncrementalSelfTestResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_GetTestResult_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_GetTestResult_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_GetTestResult_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetTestResult_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== GetTestResultResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::GetTestResultResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "GetTestResultResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetTestResultResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //outDataSize
    psi->Fields[0].Name = "outDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::GetTestResultResponse_ID;
    //outData
    psi->Fields[1].Name = "outData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::GetTestResultResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //testResult
    psi->Fields[2].Name = "testResult";
    psi->Fields[2].TypeId = TpmTypeId::TPM_RC_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::GetTestResultResponse_ID;
    
    // ======== TPM2_StartAuthSession_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_StartAuthSession_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_StartAuthSession_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_StartAuthSession_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(9);
    //tpmKey
    psi->Fields[0].Name = "tpmKey";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //bind
    psi->Fields[1].Name = "bind";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //nonceCallerSize
    psi->Fields[2].Name = "nonceCallerSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //nonceCaller
    psi->Fields[3].Name = "nonceCaller";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //encryptedSaltSize
    psi->Fields[4].Name = "encryptedSaltSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //encryptedSalt
    psi->Fields[5].Name = "encryptedSalt";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    //sessionType
    psi->Fields[6].Name = "sessionType";
    psi->Fields[6].TypeId = TpmTypeId::TPM_SE_ID;
    psi->Fields[6].MarshalType = MarshalType::Normal;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //symmetric
    psi->Fields[7].Name = "symmetric";
    psi->Fields[7].TypeId = TpmTypeId::TPMT_SYM_DEF_ID;
    psi->Fields[7].MarshalType = MarshalType::Normal;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //authHash
    psi->Fields[8].Name = "authHash";
    psi->Fields[8].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[8].MarshalType = MarshalType::Normal;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    
    // ======== StartAuthSessionResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::StartAuthSessionResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "StartAuthSessionResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new StartAuthSessionResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    //nonceTPMSize
    psi->Fields[1].Name = "nonceTPMSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    //nonceTPM
    psi->Fields[2].Name = "nonceTPM";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PolicyRestart_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyRestart_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyRestart_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyRestart_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //sessionHandle
    psi->Fields[0].Name = "sessionHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyRestart_REQUEST_ID;
    
    // ======== TPM2_Create_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Create_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Create_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Create_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(9);
    //parentHandle
    psi->Fields[0].Name = "parentHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inSensitiveSize
    psi->Fields[1].Name = "inSensitiveSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inSensitive
    psi->Fields[2].Name = "inSensitive";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inPublicSize
    psi->Fields[3].Name = "inPublicSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inPublic
    psi->Fields[4].Name = "inPublic";
    psi->Fields[4].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //outsideInfoSize
    psi->Fields[5].Name = "outsideInfoSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //outsideInfo
    psi->Fields[6].Name = "outsideInfo";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    //creationPCRCount
    psi->Fields[7].Name = "creationPCRCount";
    psi->Fields[7].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[7].MarshalType = MarshalType::ArrayCount;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //creationPCR
    psi->Fields[8].Name = "creationPCR";
    psi->Fields[8].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[8].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    psi->Fields[8].AssociatedField = 7;
    
    // ======== CreateResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CreateResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CreateResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CreateResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(8);
    //outPrivate
    psi->Fields[0].Name = "outPrivate";
    psi->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::CreateResponse_ID;
    //outPublicSize
    psi->Fields[1].Name = "outPublicSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::CreateResponse_ID;
    //outPublic
    psi->Fields[2].Name = "outPublic";
    psi->Fields[2].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::CreateResponse_ID;
    //creationDataSize
    psi->Fields[3].Name = "creationDataSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::CreateResponse_ID;
    //creationData
    psi->Fields[4].Name = "creationData";
    psi->Fields[4].TypeId = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::CreateResponse_ID;
    //creationHashSize
    psi->Fields[5].Name = "creationHashSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::CreateResponse_ID;
    //creationHash
    psi->Fields[6].Name = "creationHash";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::CreateResponse_ID;
    psi->Fields[6].AssociatedField = 5;
    //creationTicket
    psi->Fields[7].Name = "creationTicket";
    psi->Fields[7].TypeId = TpmTypeId::TPMT_TK_CREATION_ID;
    psi->Fields[7].MarshalType = MarshalType::Normal;
    psi->Fields[7].ParentType = TpmTypeId::CreateResponse_ID;
    
    // ======== TPM2_Load_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Load_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Load_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Load_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //parentHandle
    psi->Fields[0].Name = "parentHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    //inPrivate
    psi->Fields[1].Name = "inPrivate";
    psi->Fields[1].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    //inPublicSize
    psi->Fields[2].Name = "inPublicSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    //inPublic
    psi->Fields[3].Name = "inPublic";
    psi->Fields[3].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    
    // ======== LoadResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::LoadResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "LoadResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new LoadResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::LoadResponse_ID;
    //nameSize
    psi->Fields[1].Name = "nameSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::LoadResponse_ID;
    //name
    psi->Fields[2].Name = "name";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::LoadResponse_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_LoadExternal_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_LoadExternal_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_LoadExternal_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_LoadExternal_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //inPrivateSize
    psi->Fields[0].Name = "inPrivateSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //inPrivate
    psi->Fields[1].Name = "inPrivate";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //inPublicSize
    psi->Fields[2].Name = "inPublicSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //inPublic
    psi->Fields[3].Name = "inPublic";
    psi->Fields[3].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //hierarchy
    psi->Fields[4].Name = "hierarchy";
    psi->Fields[4].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    
    // ======== LoadExternalResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::LoadExternalResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "LoadExternalResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new LoadExternalResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::LoadExternalResponse_ID;
    //nameSize
    psi->Fields[1].Name = "nameSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::LoadExternalResponse_ID;
    //name
    psi->Fields[2].Name = "name";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::LoadExternalResponse_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_ReadPublic_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ReadPublic_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ReadPublic_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ReadPublic_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //objectHandle
    psi->Fields[0].Name = "objectHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ReadPublic_REQUEST_ID;
    
    // ======== ReadPublicResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ReadPublicResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ReadPublicResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ReadPublicResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //outPublicSize
    psi->Fields[0].Name = "outPublicSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //outPublic
    psi->Fields[1].Name = "outPublic";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //nameSize
    psi->Fields[2].Name = "nameSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //name
    psi->Fields[3].Name = "name";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::ReadPublicResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    //qualifiedNameSize
    psi->Fields[4].Name = "qualifiedNameSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //qualifiedName
    psi->Fields[5].Name = "qualifiedName";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::ReadPublicResponse_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_ActivateCredential_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ActivateCredential_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ActivateCredential_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ActivateCredential_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(6);
    //activateHandle
    psi->Fields[0].Name = "activateHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //keyHandle
    psi->Fields[1].Name = "keyHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //credentialBlobSize
    psi->Fields[2].Name = "credentialBlobSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //credentialBlob
    psi->Fields[3].Name = "credentialBlob";
    psi->Fields[3].TypeId = TpmTypeId::TPMS_ID_OBJECT_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //secretSize
    psi->Fields[4].Name = "secretSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //secret
    psi->Fields[5].Name = "secret";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== ActivateCredentialResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ActivateCredentialResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ActivateCredentialResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ActivateCredentialResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //certInfoSize
    psi->Fields[0].Name = "certInfoSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::ActivateCredentialResponse_ID;
    //certInfo
    psi->Fields[1].Name = "certInfo";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::ActivateCredentialResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_MakeCredential_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_MakeCredential_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_MakeCredential_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_MakeCredential_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    //credentialSize
    psi->Fields[1].Name = "credentialSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    //credential
    psi->Fields[2].Name = "credential";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //objectNameSize
    psi->Fields[3].Name = "objectNameSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    //objectName
    psi->Fields[4].Name = "objectName";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== MakeCredentialResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::MakeCredentialResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "MakeCredentialResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new MakeCredentialResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //credentialBlobSize
    psi->Fields[0].Name = "credentialBlobSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    //credentialBlob
    psi->Fields[1].Name = "credentialBlob";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ID_OBJECT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    //secretSize
    psi->Fields[2].Name = "secretSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    //secret
    psi->Fields[3].Name = "secret";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_Unseal_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Unseal_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Unseal_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Unseal_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(1);
    //itemHandle
    psi->Fields[0].Name = "itemHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Unseal_REQUEST_ID;
    
    // ======== UnsealResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::UnsealResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "UnsealResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new UnsealResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //outDataSize
    psi->Fields[0].Name = "outDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::UnsealResponse_ID;
    //outData
    psi->Fields[1].Name = "outData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::UnsealResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_ObjectChangeAuth_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ObjectChangeAuth_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ObjectChangeAuth_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //objectHandle
    psi->Fields[0].Name = "objectHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    //parentHandle
    psi->Fields[1].Name = "parentHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    //newAuthSize
    psi->Fields[2].Name = "newAuthSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    //newAuth
    psi->Fields[3].Name = "newAuth";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== ObjectChangeAuthResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ObjectChangeAuthResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ObjectChangeAuthResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ObjectChangeAuthResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //outPrivate
    psi->Fields[0].Name = "outPrivate";
    psi->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::ObjectChangeAuthResponse_ID;
    
    // ======== TPM2_CreateLoaded_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_CreateLoaded_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_CreateLoaded_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CreateLoaded_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(5);
    //parentHandle
    psi->Fields[0].Name = "parentHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inSensitiveSize
    psi->Fields[1].Name = "inSensitiveSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inSensitive
    psi->Fields[2].Name = "inSensitive";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inPublicSize
    psi->Fields[3].Name = "inPublicSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inPublic
    psi->Fields[4].Name = "inPublic";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== CreateLoadedResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CreateLoadedResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CreateLoadedResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CreateLoadedResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //outPrivate
    psi->Fields[1].Name = "outPrivate";
    psi->Fields[1].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //outPublicSize
    psi->Fields[2].Name = "outPublicSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[2].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //outPublic
    psi->Fields[3].Name = "outPublic";
    psi->Fields[3].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //nameSize
    psi->Fields[4].Name = "nameSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //name
    psi->Fields[5].Name = "name";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_Duplicate_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Duplicate_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Duplicate_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Duplicate_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(5);
    //objectHandle
    psi->Fields[0].Name = "objectHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    //newParentHandle
    psi->Fields[1].Name = "newParentHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    //encryptionKeyInSize
    psi->Fields[2].Name = "encryptionKeyInSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    //encryptionKeyIn
    psi->Fields[3].Name = "encryptionKeyIn";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //symmetricAlg
    psi->Fields[4].Name = "symmetricAlg";
    psi->Fields[4].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    
    // ======== DuplicateResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::DuplicateResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "DuplicateResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new DuplicateResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //encryptionKeyOutSize
    psi->Fields[0].Name = "encryptionKeyOutSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::DuplicateResponse_ID;
    //encryptionKeyOut
    psi->Fields[1].Name = "encryptionKeyOut";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::DuplicateResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //duplicate
    psi->Fields[2].Name = "duplicate";
    psi->Fields[2].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::DuplicateResponse_ID;
    //outSymSeedSize
    psi->Fields[3].Name = "outSymSeedSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::DuplicateResponse_ID;
    //outSymSeed
    psi->Fields[4].Name = "outSymSeed";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::DuplicateResponse_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPM2_Rewrap_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Rewrap_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Rewrap_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Rewrap_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //oldParent
    psi->Fields[0].Name = "oldParent";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //newParent
    psi->Fields[1].Name = "newParent";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //inDuplicate
    psi->Fields[2].Name = "inDuplicate";
    psi->Fields[2].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //nameSize
    psi->Fields[3].Name = "nameSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //name
    psi->Fields[4].Name = "name";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //inSymSeedSize
    psi->Fields[5].Name = "inSymSeedSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //inSymSeed
    psi->Fields[6].Name = "inSymSeed";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== RewrapResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::RewrapResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "RewrapResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new RewrapResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //outDuplicate
    psi->Fields[0].Name = "outDuplicate";
    psi->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::RewrapResponse_ID;
    //outSymSeedSize
    psi->Fields[1].Name = "outSymSeedSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::RewrapResponse_ID;
    //outSymSeed
    psi->Fields[2].Name = "outSymSeed";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::RewrapResponse_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_Import_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Import_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Import_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Import_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(9);
    //parentHandle
    psi->Fields[0].Name = "parentHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //encryptionKeySize
    psi->Fields[1].Name = "encryptionKeySize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //encryptionKey
    psi->Fields[2].Name = "encryptionKey";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //objectPublicSize
    psi->Fields[3].Name = "objectPublicSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //objectPublic
    psi->Fields[4].Name = "objectPublic";
    psi->Fields[4].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //duplicate
    psi->Fields[5].Name = "duplicate";
    psi->Fields[5].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //inSymSeedSize
    psi->Fields[6].Name = "inSymSeedSize";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::ArrayCount;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //inSymSeed
    psi->Fields[7].Name = "inSymSeed";
    psi->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    psi->Fields[7].AssociatedField = 6;
    //symmetricAlg
    psi->Fields[8].Name = "symmetricAlg";
    psi->Fields[8].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    psi->Fields[8].MarshalType = MarshalType::Normal;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    
    // ======== ImportResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ImportResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ImportResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ImportResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //outPrivate
    psi->Fields[0].Name = "outPrivate";
    psi->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::ImportResponse_ID;
    
    // ======== TPM2_RSA_Encrypt_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_RSA_Encrypt_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_RSA_Encrypt_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(7);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    //messageSize
    psi->Fields[1].Name = "messageSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    //message
    psi->Fields[2].Name = "message";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    psi->Fields[3].Name = "inSchemeScheme";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionSelector;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    psi->Fields[3].AssociatedField = 4;
    //inScheme
    psi->Fields[4].Name = "inScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionObject;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //labelSize
    psi->Fields[5].Name = "labelSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    //label
    psi->Fields[6].Name = "label";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== RSA_EncryptResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::RSA_EncryptResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "RSA_EncryptResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new RSA_EncryptResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //outDataSize
    psi->Fields[0].Name = "outDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::RSA_EncryptResponse_ID;
    //outData
    psi->Fields[1].Name = "outData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::RSA_EncryptResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_RSA_Decrypt_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_RSA_Decrypt_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_RSA_Decrypt_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    //cipherTextSize
    psi->Fields[1].Name = "cipherTextSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    //cipherText
    psi->Fields[2].Name = "cipherText";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    psi->Fields[3].Name = "inSchemeScheme";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionSelector;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    psi->Fields[3].AssociatedField = 4;
    //inScheme
    psi->Fields[4].Name = "inScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionObject;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //labelSize
    psi->Fields[5].Name = "labelSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    //label
    psi->Fields[6].Name = "label";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== RSA_DecryptResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::RSA_DecryptResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "RSA_DecryptResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new RSA_DecryptResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //messageSize
    psi->Fields[0].Name = "messageSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::RSA_DecryptResponse_ID;
    //message
    psi->Fields[1].Name = "message";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::RSA_DecryptResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_ECDH_KeyGen_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ECDH_KeyGen_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECDH_KeyGen_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID;
    
    // ======== ECDH_KeyGenResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ECDH_KeyGenResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ECDH_KeyGenResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECDH_KeyGenResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //zPointSize
    psi->Fields[0].Name = "zPointSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    //zPoint
    psi->Fields[1].Name = "zPoint";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    //pubPointSize
    psi->Fields[2].Name = "pubPointSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[2].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    //pubPoint
    psi->Fields[3].Name = "pubPoint";
    psi->Fields[3].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    
    // ======== TPM2_ECDH_ZGen_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ECDH_ZGen_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECDH_ZGen_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    //inPointSize
    psi->Fields[1].Name = "inPointSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    //inPoint
    psi->Fields[2].Name = "inPoint";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    
    // ======== ECDH_ZGenResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ECDH_ZGenResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ECDH_ZGenResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECDH_ZGenResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //outPointSize
    psi->Fields[0].Name = "outPointSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::ECDH_ZGenResponse_ID;
    //outPoint
    psi->Fields[1].Name = "outPoint";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::ECDH_ZGenResponse_ID;
    
    // ======== TPM2_ECC_Parameters_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ECC_Parameters_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECC_Parameters_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //curveID
    psi->Fields[0].Name = "curveID";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID;
    
    // ======== ECC_ParametersResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ECC_ParametersResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ECC_ParametersResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECC_ParametersResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //parameters
    psi->Fields[0].Name = "parameters";
    psi->Fields[0].TypeId = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::ECC_ParametersResponse_ID;
    
    // ======== TPM2_ZGen_2Phase_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ZGen_2Phase_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ZGen_2Phase_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //keyA
    psi->Fields[0].Name = "keyA";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQsBSize
    psi->Fields[1].Name = "inQsBSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQsB
    psi->Fields[2].Name = "inQsB";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQeBSize
    psi->Fields[3].Name = "inQeBSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQeB
    psi->Fields[4].Name = "inQeB";
    psi->Fields[4].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inScheme
    psi->Fields[5].Name = "inScheme";
    psi->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //counter
    psi->Fields[6].Name = "counter";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::Normal;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    
    // ======== ZGen_2PhaseResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ZGen_2PhaseResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ZGen_2PhaseResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ZGen_2PhaseResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //outZ1Size
    psi->Fields[0].Name = "outZ1Size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    //outZ1
    psi->Fields[1].Name = "outZ1";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    //outZ2Size
    psi->Fields[2].Name = "outZ2Size";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[2].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    //outZ2
    psi->Fields[3].Name = "outZ2";
    psi->Fields[3].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    
    // ======== TPM2_ECC_Encrypt_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ECC_Encrypt_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECC_Encrypt_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    //plainTextSize
    psi->Fields[1].Name = "plainTextSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    //plainText
    psi->Fields[2].Name = "plainText";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    psi->Fields[3].Name = "inSchemeScheme";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionSelector;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    psi->Fields[3].AssociatedField = 4;
    //inScheme
    psi->Fields[4].Name = "inScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionObject;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== ECC_EncryptResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ECC_EncryptResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ECC_EncryptResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECC_EncryptResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //C1Size
    psi->Fields[0].Name = "C1Size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C1
    psi->Fields[1].Name = "C1";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C2Size
    psi->Fields[2].Name = "C2Size";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C2
    psi->Fields[3].Name = "C2";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    //C3Size
    psi->Fields[4].Name = "C3Size";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C3
    psi->Fields[5].Name = "C3";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_ECC_Decrypt_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ECC_Decrypt_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECC_Decrypt_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(9);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C1Size
    psi->Fields[1].Name = "C1Size";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C1
    psi->Fields[2].Name = "C1";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C2Size
    psi->Fields[3].Name = "C2Size";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C2
    psi->Fields[4].Name = "C2";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //C3Size
    psi->Fields[5].Name = "C3Size";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C3
    psi->Fields[6].Name = "C3";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    //inSchemeScheme
    psi->Fields[7].Name = "inSchemeScheme";
    psi->Fields[7].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[7].MarshalType = MarshalType::UnionSelector;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    psi->Fields[7].AssociatedField = 8;
    //inScheme
    psi->Fields[8].Name = "inScheme";
    psi->Fields[8].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    psi->Fields[8].MarshalType = MarshalType::UnionObject;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    psi->Fields[8].AssociatedField = 7;
    
    // ======== ECC_DecryptResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ECC_DecryptResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ECC_DecryptResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECC_DecryptResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //plainTextSize
    psi->Fields[0].Name = "plainTextSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::ECC_DecryptResponse_ID;
    //plainText
    psi->Fields[1].Name = "plainText";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::ECC_DecryptResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_EncryptDecrypt_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_EncryptDecrypt_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EncryptDecrypt_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //decrypt
    psi->Fields[1].Name = "decrypt";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //mode
    psi->Fields[2].Name = "mode";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //ivInSize
    psi->Fields[3].Name = "ivInSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //ivIn
    psi->Fields[4].Name = "ivIn";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //inDataSize
    psi->Fields[5].Name = "inDataSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //inData
    psi->Fields[6].Name = "inData";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== EncryptDecryptResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::EncryptDecryptResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "EncryptDecryptResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EncryptDecryptResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //outDataSize
    psi->Fields[0].Name = "outDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    //outData
    psi->Fields[1].Name = "outData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //ivOutSize
    psi->Fields[2].Name = "ivOutSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    //ivOut
    psi->Fields[3].Name = "ivOut";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_EncryptDecrypt2_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_EncryptDecrypt2_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EncryptDecrypt2_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //inDataSize
    psi->Fields[1].Name = "inDataSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //inData
    psi->Fields[2].Name = "inData";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //decrypt
    psi->Fields[3].Name = "decrypt";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //mode
    psi->Fields[4].Name = "mode";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //ivInSize
    psi->Fields[5].Name = "ivInSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //ivIn
    psi->Fields[6].Name = "ivIn";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== EncryptDecrypt2Response ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::EncryptDecrypt2Response_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "EncryptDecrypt2Response";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EncryptDecrypt2Response()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //outDataSize
    psi->Fields[0].Name = "outDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    //outData
    psi->Fields[1].Name = "outData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    psi->Fields[1].AssociatedField = 0;
    //ivOutSize
    psi->Fields[2].Name = "ivOutSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    //ivOut
    psi->Fields[3].Name = "ivOut";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_Hash_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Hash_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Hash_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Hash_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //dataSize
    psi->Fields[0].Name = "dataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    //data
    psi->Fields[1].Name = "data";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    //hashAlg
    psi->Fields[2].Name = "hashAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    //hierarchy
    psi->Fields[3].Name = "hierarchy";
    psi->Fields[3].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    
    // ======== HashResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::HashResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "HashResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HashResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //outHashSize
    psi->Fields[0].Name = "outHashSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::HashResponse_ID;
    //outHash
    psi->Fields[1].Name = "outHash";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::HashResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //validation
    psi->Fields[2].Name = "validation";
    psi->Fields[2].TypeId = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::HashResponse_ID;
    
    // ======== TPM2_HMAC_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_HMAC_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_HMAC_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HMAC_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    //bufferSize
    psi->Fields[1].Name = "bufferSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    //buffer
    psi->Fields[2].Name = "buffer";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //hashAlg
    psi->Fields[3].Name = "hashAlg";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    
    // ======== HMACResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::HMACResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "HMACResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HMACResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //outHMACSize
    psi->Fields[0].Name = "outHMACSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::HMACResponse_ID;
    //outHMAC
    psi->Fields[1].Name = "outHMAC";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::HMACResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_MAC_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_MAC_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_MAC_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_MAC_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    //bufferSize
    psi->Fields[1].Name = "bufferSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    //buffer
    psi->Fields[2].Name = "buffer";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //inScheme
    psi->Fields[3].Name = "inScheme";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    
    // ======== MACResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::MACResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "MACResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new MACResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //outMACSize
    psi->Fields[0].Name = "outMACSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::MACResponse_ID;
    //outMAC
    psi->Fields[1].Name = "outMAC";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::MACResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_GetRandom_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_GetRandom_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_GetRandom_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetRandom_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //bytesRequested
    psi->Fields[0].Name = "bytesRequested";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_GetRandom_REQUEST_ID;
    
    // ======== GetRandomResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::GetRandomResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "GetRandomResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetRandomResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //randomBytesSize
    psi->Fields[0].Name = "randomBytesSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::GetRandomResponse_ID;
    //randomBytes
    psi->Fields[1].Name = "randomBytes";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::GetRandomResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_StirRandom_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_StirRandom_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_StirRandom_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_StirRandom_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //inDataSize
    psi->Fields[0].Name = "inDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_StirRandom_REQUEST_ID;
    //inData
    psi->Fields[1].Name = "inData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_StirRandom_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_HMAC_Start_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_HMAC_Start_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_HMAC_Start_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HMAC_Start_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    //authSize
    psi->Fields[1].Name = "authSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    //auth
    psi->Fields[2].Name = "auth";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //hashAlg
    psi->Fields[3].Name = "hashAlg";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    
    // ======== HMAC_StartResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::HMAC_StartResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "HMAC_StartResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HMAC_StartResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::HMAC_StartResponse_ID;
    
    // ======== TPM2_MAC_Start_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_MAC_Start_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_MAC_Start_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_MAC_Start_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    //authSize
    psi->Fields[1].Name = "authSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    //auth
    psi->Fields[2].Name = "auth";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //inScheme
    psi->Fields[3].Name = "inScheme";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    
    // ======== MAC_StartResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::MAC_StartResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "MAC_StartResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new MAC_StartResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::MAC_StartResponse_ID;
    
    // ======== TPM2_HashSequenceStart_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_HashSequenceStart_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HashSequenceStart_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //authSize
    psi->Fields[0].Name = "authSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    //auth
    psi->Fields[1].Name = "auth";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    //hashAlg
    psi->Fields[2].Name = "hashAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    
    // ======== HashSequenceStartResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::HashSequenceStartResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "HashSequenceStartResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HashSequenceStartResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::HashSequenceStartResponse_ID;
    
    // ======== TPM2_SequenceUpdate_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_SequenceUpdate_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SequenceUpdate_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //sequenceHandle
    psi->Fields[0].Name = "sequenceHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    //bufferSize
    psi->Fields[1].Name = "bufferSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    //buffer
    psi->Fields[2].Name = "buffer";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_SequenceComplete_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_SequenceComplete_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_SequenceComplete_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SequenceComplete_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //sequenceHandle
    psi->Fields[0].Name = "sequenceHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    //bufferSize
    psi->Fields[1].Name = "bufferSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    //buffer
    psi->Fields[2].Name = "buffer";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //hierarchy
    psi->Fields[3].Name = "hierarchy";
    psi->Fields[3].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    
    // ======== SequenceCompleteResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::SequenceCompleteResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "SequenceCompleteResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SequenceCompleteResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //resultSize
    psi->Fields[0].Name = "resultSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    //result
    psi->Fields[1].Name = "result";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //validation
    psi->Fields[2].Name = "validation";
    psi->Fields[2].TypeId = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    
    // ======== TPM2_EventSequenceComplete_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_EventSequenceComplete_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EventSequenceComplete_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(4);
    //pcrHandle
    psi->Fields[0].Name = "pcrHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    //sequenceHandle
    psi->Fields[1].Name = "sequenceHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    //bufferSize
    psi->Fields[2].Name = "bufferSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    //buffer
    psi->Fields[3].Name = "buffer";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== EventSequenceCompleteResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::EventSequenceCompleteResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "EventSequenceCompleteResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EventSequenceCompleteResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //resultsCount
    psi->Fields[0].Name = "resultsCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::EventSequenceCompleteResponse_ID;
    //results
    psi->Fields[1].Name = "results";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::EventSequenceCompleteResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_Certify_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Certify_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Certify_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Certify_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(6);
    //objectHandle
    psi->Fields[0].Name = "objectHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    //signHandle
    psi->Fields[1].Name = "signHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    //qualifyingDataSize
    psi->Fields[2].Name = "qualifyingDataSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    //qualifyingData
    psi->Fields[3].Name = "qualifyingData";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    psi->Fields[4].Name = "inSchemeScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    psi->Fields[4].AssociatedField = 5;
    //inScheme
    psi->Fields[5].Name = "inScheme";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== CertifyResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CertifyResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CertifyResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CertifyResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //certifyInfoSize
    psi->Fields[0].Name = "certifyInfoSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::CertifyResponse_ID;
    //certifyInfo
    psi->Fields[1].Name = "certifyInfo";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::CertifyResponse_ID;
    //signatureSigAlg
    psi->Fields[2].Name = "signatureSigAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::CertifyResponse_ID;
    psi->Fields[2].AssociatedField = 3;
    //signature
    psi->Fields[3].Name = "signature";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::CertifyResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_CertifyCreation_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_CertifyCreation_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_CertifyCreation_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CertifyCreation_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(9);
    //signHandle
    psi->Fields[0].Name = "signHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //objectHandle
    psi->Fields[1].Name = "objectHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //qualifyingDataSize
    psi->Fields[2].Name = "qualifyingDataSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //qualifyingData
    psi->Fields[3].Name = "qualifyingData";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //creationHashSize
    psi->Fields[4].Name = "creationHashSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //creationHash
    psi->Fields[5].Name = "creationHash";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    //inSchemeScheme
    psi->Fields[6].Name = "inSchemeScheme";
    psi->Fields[6].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[6].MarshalType = MarshalType::UnionSelector;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    psi->Fields[6].AssociatedField = 7;
    //inScheme
    psi->Fields[7].Name = "inScheme";
    psi->Fields[7].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[7].MarshalType = MarshalType::UnionObject;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    psi->Fields[7].AssociatedField = 6;
    //creationTicket
    psi->Fields[8].Name = "creationTicket";
    psi->Fields[8].TypeId = TpmTypeId::TPMT_TK_CREATION_ID;
    psi->Fields[8].MarshalType = MarshalType::Normal;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    
    // ======== CertifyCreationResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CertifyCreationResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CertifyCreationResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CertifyCreationResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //certifyInfoSize
    psi->Fields[0].Name = "certifyInfoSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    //certifyInfo
    psi->Fields[1].Name = "certifyInfo";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    //signatureSigAlg
    psi->Fields[2].Name = "signatureSigAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    psi->Fields[2].AssociatedField = 3;
    //signature
    psi->Fields[3].Name = "signature";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_Quote_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Quote_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Quote_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Quote_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //signHandle
    psi->Fields[0].Name = "signHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    //qualifyingDataSize
    psi->Fields[1].Name = "qualifyingDataSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    //qualifyingData
    psi->Fields[2].Name = "qualifyingData";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    psi->Fields[3].Name = "inSchemeScheme";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionSelector;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    psi->Fields[3].AssociatedField = 4;
    //inScheme
    psi->Fields[4].Name = "inScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionObject;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //PCRselectCount
    psi->Fields[5].Name = "PCRselectCount";
    psi->Fields[5].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    //PCRselect
    psi->Fields[6].Name = "PCRselect";
    psi->Fields[6].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== QuoteResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::QuoteResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "QuoteResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new QuoteResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //quotedSize
    psi->Fields[0].Name = "quotedSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::QuoteResponse_ID;
    //quoted
    psi->Fields[1].Name = "quoted";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::QuoteResponse_ID;
    //signatureSigAlg
    psi->Fields[2].Name = "signatureSigAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::QuoteResponse_ID;
    psi->Fields[2].AssociatedField = 3;
    //signature
    psi->Fields[3].Name = "signature";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::QuoteResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_GetSessionAuditDigest_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_GetSessionAuditDigest_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetSessionAuditDigest_REQUEST()); };
    psi->HandleCount = 3;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(7);
    //privacyAdminHandle
    psi->Fields[0].Name = "privacyAdminHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //signHandle
    psi->Fields[1].Name = "signHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //sessionHandle
    psi->Fields[2].Name = "sessionHandle";
    psi->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //qualifyingDataSize
    psi->Fields[3].Name = "qualifyingDataSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //qualifyingData
    psi->Fields[4].Name = "qualifyingData";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //inSchemeScheme
    psi->Fields[5].Name = "inSchemeScheme";
    psi->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionSelector;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    psi->Fields[5].AssociatedField = 6;
    //inScheme
    psi->Fields[6].Name = "inScheme";
    psi->Fields[6].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[6].MarshalType = MarshalType::UnionObject;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== GetSessionAuditDigestResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::GetSessionAuditDigestResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "GetSessionAuditDigestResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetSessionAuditDigestResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //auditInfoSize
    psi->Fields[0].Name = "auditInfoSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    //auditInfo
    psi->Fields[1].Name = "auditInfo";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    //signatureSigAlg
    psi->Fields[2].Name = "signatureSigAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    psi->Fields[2].AssociatedField = 3;
    //signature
    psi->Fields[3].Name = "signature";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_GetCommandAuditDigest_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_GetCommandAuditDigest_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetCommandAuditDigest_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(6);
    //privacyHandle
    psi->Fields[0].Name = "privacyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    //signHandle
    psi->Fields[1].Name = "signHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    //qualifyingDataSize
    psi->Fields[2].Name = "qualifyingDataSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    //qualifyingData
    psi->Fields[3].Name = "qualifyingData";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    psi->Fields[4].Name = "inSchemeScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    psi->Fields[4].AssociatedField = 5;
    //inScheme
    psi->Fields[5].Name = "inScheme";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== GetCommandAuditDigestResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::GetCommandAuditDigestResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "GetCommandAuditDigestResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetCommandAuditDigestResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //auditInfoSize
    psi->Fields[0].Name = "auditInfoSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    //auditInfo
    psi->Fields[1].Name = "auditInfo";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    //signatureSigAlg
    psi->Fields[2].Name = "signatureSigAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    psi->Fields[2].AssociatedField = 3;
    //signature
    psi->Fields[3].Name = "signature";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_GetTime_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_GetTime_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_GetTime_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetTime_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(6);
    //privacyAdminHandle
    psi->Fields[0].Name = "privacyAdminHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    //signHandle
    psi->Fields[1].Name = "signHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    //qualifyingDataSize
    psi->Fields[2].Name = "qualifyingDataSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    //qualifyingData
    psi->Fields[3].Name = "qualifyingData";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    psi->Fields[4].Name = "inSchemeScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    psi->Fields[4].AssociatedField = 5;
    //inScheme
    psi->Fields[5].Name = "inScheme";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== GetTimeResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::GetTimeResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "GetTimeResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetTimeResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //timeInfoSize
    psi->Fields[0].Name = "timeInfoSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::GetTimeResponse_ID;
    //timeInfo
    psi->Fields[1].Name = "timeInfo";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::GetTimeResponse_ID;
    //signatureSigAlg
    psi->Fields[2].Name = "signatureSigAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::GetTimeResponse_ID;
    psi->Fields[2].AssociatedField = 3;
    //signature
    psi->Fields[3].Name = "signature";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::GetTimeResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_CertifyX509_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_CertifyX509_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_CertifyX509_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CertifyX509_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(8);
    //objectHandle
    psi->Fields[0].Name = "objectHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //signHandle
    psi->Fields[1].Name = "signHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //reservedSize
    psi->Fields[2].Name = "reservedSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //reserved
    psi->Fields[3].Name = "reserved";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    psi->Fields[4].Name = "inSchemeScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    psi->Fields[4].AssociatedField = 5;
    //inScheme
    psi->Fields[5].Name = "inScheme";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    //partialCertificateSize
    psi->Fields[6].Name = "partialCertificateSize";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::ArrayCount;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //partialCertificate
    psi->Fields[7].Name = "partialCertificate";
    psi->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    psi->Fields[7].AssociatedField = 6;
    
    // ======== CertifyX509Response ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CertifyX509Response_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CertifyX509Response";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CertifyX509Response()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //addedToCertificateSize
    psi->Fields[0].Name = "addedToCertificateSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::CertifyX509Response_ID;
    //addedToCertificate
    psi->Fields[1].Name = "addedToCertificate";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::CertifyX509Response_ID;
    psi->Fields[1].AssociatedField = 0;
    //tbsDigestSize
    psi->Fields[2].Name = "tbsDigestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::CertifyX509Response_ID;
    //tbsDigest
    psi->Fields[3].Name = "tbsDigest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::CertifyX509Response_ID;
    psi->Fields[3].AssociatedField = 2;
    //signatureSigAlg
    psi->Fields[4].Name = "signatureSigAlg";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::CertifyX509Response_ID;
    psi->Fields[4].AssociatedField = 5;
    //signature
    psi->Fields[5].Name = "signature";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::CertifyX509Response_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_Commit_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Commit_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Commit_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Commit_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //signHandle
    psi->Fields[0].Name = "signHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //P1Size
    psi->Fields[1].Name = "P1Size";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //P1
    psi->Fields[2].Name = "P1";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //s2Size
    psi->Fields[3].Name = "s2Size";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //s2
    psi->Fields[4].Name = "s2";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //y2Size
    psi->Fields[5].Name = "y2Size";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //y2
    psi->Fields[6].Name = "y2";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    
    // ======== CommitResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CommitResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CommitResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CommitResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(7);
    //KSize
    psi->Fields[0].Name = "KSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::CommitResponse_ID;
    //K
    psi->Fields[1].Name = "K";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::CommitResponse_ID;
    //LSize
    psi->Fields[2].Name = "LSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[2].ParentType = TpmTypeId::CommitResponse_ID;
    //L
    psi->Fields[3].Name = "L";
    psi->Fields[3].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::CommitResponse_ID;
    //ESize
    psi->Fields[4].Name = "ESize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[4].ParentType = TpmTypeId::CommitResponse_ID;
    //E
    psi->Fields[5].Name = "E";
    psi->Fields[5].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::CommitResponse_ID;
    //counter
    psi->Fields[6].Name = "counter";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::Normal;
    psi->Fields[6].ParentType = TpmTypeId::CommitResponse_ID;
    
    // ======== TPM2_EC_Ephemeral_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_EC_Ephemeral_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EC_Ephemeral_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //curveID
    psi->Fields[0].Name = "curveID";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID;
    
    // ======== EC_EphemeralResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::EC_EphemeralResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "EC_EphemeralResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EC_EphemeralResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //QSize
    psi->Fields[0].Name = "QSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    //Q
    psi->Fields[1].Name = "Q";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    //counter
    psi->Fields[2].Name = "counter";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    
    // ======== TPM2_VerifySignature_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_VerifySignature_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_VerifySignature_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_VerifySignature_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    //digestSize
    psi->Fields[1].Name = "digestSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    //digest
    psi->Fields[2].Name = "digest";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //signatureSigAlg
    psi->Fields[3].Name = "signatureSigAlg";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionSelector;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    psi->Fields[3].AssociatedField = 4;
    //signature
    psi->Fields[4].Name = "signature";
    psi->Fields[4].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionObject;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== VerifySignatureResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::VerifySignatureResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "VerifySignatureResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new VerifySignatureResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //validation
    psi->Fields[0].Name = "validation";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_TK_VERIFIED_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::VerifySignatureResponse_ID;
    
    // ======== TPM2_Sign_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Sign_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Sign_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Sign_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(6);
    //keyHandle
    psi->Fields[0].Name = "keyHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    //digestSize
    psi->Fields[1].Name = "digestSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    //digest
    psi->Fields[2].Name = "digest";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    psi->Fields[3].Name = "inSchemeScheme";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionSelector;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    psi->Fields[3].AssociatedField = 4;
    //inScheme
    psi->Fields[4].Name = "inScheme";
    psi->Fields[4].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionObject;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //validation
    psi->Fields[5].Name = "validation";
    psi->Fields[5].TypeId = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    
    // ======== SignResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::SignResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "SignResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SignResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //signatureSigAlg
    psi->Fields[0].Name = "signatureSigAlg";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::SignResponse_ID;
    psi->Fields[0].AssociatedField = 1;
    //signature
    psi->Fields[1].Name = "signature";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::SignResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_SetCommandCodeAuditStatus_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SetCommandCodeAuditStatus_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(6);
    //auth
    psi->Fields[0].Name = "auth";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //auditAlg
    psi->Fields[1].Name = "auditAlg";
    psi->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //setListCount
    psi->Fields[2].Name = "setListCount";
    psi->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //setList
    psi->Fields[3].Name = "setList";
    psi->Fields[3].TypeId = TpmTypeId::TPM_CC_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //clearListCount
    psi->Fields[4].Name = "clearListCount";
    psi->Fields[4].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //clearList
    psi->Fields[5].Name = "clearList";
    psi->Fields[5].TypeId = TpmTypeId::TPM_CC_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_PCR_Extend_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Extend_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PCR_Extend_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Extend_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //pcrHandle
    psi->Fields[0].Name = "pcrHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    //digestsCount
    psi->Fields[1].Name = "digestsCount";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    //digests
    psi->Fields[2].Name = "digests";
    psi->Fields[2].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PCR_Event_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Event_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PCR_Event_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Event_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //pcrHandle
    psi->Fields[0].Name = "pcrHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    //eventDataSize
    psi->Fields[1].Name = "eventDataSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    //eventData
    psi->Fields[2].Name = "eventData";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== PCR_EventResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::PCR_EventResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "PCR_EventResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_EventResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //digestsCount
    psi->Fields[0].Name = "digestsCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::PCR_EventResponse_ID;
    //digests
    psi->Fields[1].Name = "digests";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::PCR_EventResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_PCR_Read_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Read_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PCR_Read_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Read_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //pcrSelectionInCount
    psi->Fields[0].Name = "pcrSelectionInCount";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
    //pcrSelectionIn
    psi->Fields[1].Name = "pcrSelectionIn";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== PCR_ReadResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::PCR_ReadResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "PCR_ReadResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_ReadResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //pcrUpdateCounter
    psi->Fields[0].Name = "pcrUpdateCounter";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    //pcrSelectionOutCount
    psi->Fields[1].Name = "pcrSelectionOutCount";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    //pcrSelectionOut
    psi->Fields[2].Name = "pcrSelectionOut";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    psi->Fields[2].AssociatedField = 1;
    //pcrValuesCount
    psi->Fields[3].Name = "pcrValuesCount";
    psi->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    //pcrValues
    psi->Fields[4].Name = "pcrValues";
    psi->Fields[4].TypeId = TpmTypeId::TPM2B_DIGEST_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPM2_PCR_Allocate_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PCR_Allocate_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Allocate_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    //pcrAllocationCount
    psi->Fields[1].Name = "pcrAllocationCount";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    //pcrAllocation
    psi->Fields[2].Name = "pcrAllocation";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== PCR_AllocateResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::PCR_AllocateResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "PCR_AllocateResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_AllocateResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //allocationSuccess
    psi->Fields[0].Name = "allocationSuccess";
    psi->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    //maxPCR
    psi->Fields[1].Name = "maxPCR";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    //sizeNeeded
    psi->Fields[2].Name = "sizeNeeded";
    psi->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    //sizeAvailable
    psi->Fields[3].Name = "sizeAvailable";
    psi->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    
    // ======== TPM2_PCR_SetAuthPolicy_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PCR_SetAuthPolicy_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_SetAuthPolicy_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(5);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    //authPolicySize
    psi->Fields[1].Name = "authPolicySize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    //authPolicy
    psi->Fields[2].Name = "authPolicy";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //hashAlg
    psi->Fields[3].Name = "hashAlg";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    //pcrNum
    psi->Fields[4].Name = "pcrNum";
    psi->Fields[4].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    
    // ======== TPM2_PCR_SetAuthValue_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PCR_SetAuthValue_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_SetAuthValue_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //pcrHandle
    psi->Fields[0].Name = "pcrHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    //authSize
    psi->Fields[1].Name = "authSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    //auth
    psi->Fields[2].Name = "auth";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PCR_Reset_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Reset_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PCR_Reset_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Reset_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(1);
    //pcrHandle
    psi->Fields[0].Name = "pcrHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Reset_REQUEST_ID;
    
    // ======== TPM2_PolicySigned_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicySigned_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicySigned_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicySigned_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(11);
    //authObject
    psi->Fields[0].Name = "authObject";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //policySession
    psi->Fields[1].Name = "policySession";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //nonceTPMSize
    psi->Fields[2].Name = "nonceTPMSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //nonceTPM
    psi->Fields[3].Name = "nonceTPM";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //cpHashASize
    psi->Fields[4].Name = "cpHashASize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //cpHashA
    psi->Fields[5].Name = "cpHashA";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    //policyRefSize
    psi->Fields[6].Name = "policyRefSize";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::ArrayCount;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //policyRef
    psi->Fields[7].Name = "policyRef";
    psi->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    psi->Fields[7].AssociatedField = 6;
    //expiration
    psi->Fields[8].Name = "expiration";
    psi->Fields[8].TypeId = TpmTypeId::INT32_ID;
    psi->Fields[8].MarshalType = MarshalType::Normal;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //authSigAlg
    psi->Fields[9].Name = "authSigAlg";
    psi->Fields[9].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[9].MarshalType = MarshalType::UnionSelector;
    psi->Fields[9].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    psi->Fields[9].AssociatedField = 10;
    //auth
    psi->Fields[10].Name = "auth";
    psi->Fields[10].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[10].MarshalType = MarshalType::UnionObject;
    psi->Fields[10].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    psi->Fields[10].AssociatedField = 9;
    
    // ======== PolicySignedResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::PolicySignedResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "PolicySignedResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicySignedResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //timeoutSize
    psi->Fields[0].Name = "timeoutSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::PolicySignedResponse_ID;
    //timeout
    psi->Fields[1].Name = "timeout";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::PolicySignedResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //policyTicket
    psi->Fields[2].Name = "policyTicket";
    psi->Fields[2].TypeId = TpmTypeId::TPMT_TK_AUTH_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::PolicySignedResponse_ID;
    
    // ======== TPM2_PolicySecret_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicySecret_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicySecret_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicySecret_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(9);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //policySession
    psi->Fields[1].Name = "policySession";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //nonceTPMSize
    psi->Fields[2].Name = "nonceTPMSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //nonceTPM
    psi->Fields[3].Name = "nonceTPM";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //cpHashASize
    psi->Fields[4].Name = "cpHashASize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //cpHashA
    psi->Fields[5].Name = "cpHashA";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    //policyRefSize
    psi->Fields[6].Name = "policyRefSize";
    psi->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[6].MarshalType = MarshalType::ArrayCount;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //policyRef
    psi->Fields[7].Name = "policyRef";
    psi->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    psi->Fields[7].AssociatedField = 6;
    //expiration
    psi->Fields[8].Name = "expiration";
    psi->Fields[8].TypeId = TpmTypeId::INT32_ID;
    psi->Fields[8].MarshalType = MarshalType::Normal;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    
    // ======== PolicySecretResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::PolicySecretResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "PolicySecretResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicySecretResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //timeoutSize
    psi->Fields[0].Name = "timeoutSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::PolicySecretResponse_ID;
    //timeout
    psi->Fields[1].Name = "timeout";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::PolicySecretResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    //policyTicket
    psi->Fields[2].Name = "policyTicket";
    psi->Fields[2].TypeId = TpmTypeId::TPMT_TK_AUTH_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::PolicySecretResponse_ID;
    
    // ======== TPM2_PolicyTicket_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyTicket_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyTicket_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyTicket_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(10);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //timeoutSize
    psi->Fields[1].Name = "timeoutSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //timeout
    psi->Fields[2].Name = "timeout";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //cpHashASize
    psi->Fields[3].Name = "cpHashASize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //cpHashA
    psi->Fields[4].Name = "cpHashA";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //policyRefSize
    psi->Fields[5].Name = "policyRefSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //policyRef
    psi->Fields[6].Name = "policyRef";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    //authNameSize
    psi->Fields[7].Name = "authNameSize";
    psi->Fields[7].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[7].MarshalType = MarshalType::ArrayCount;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //authName
    psi->Fields[8].Name = "authName";
    psi->Fields[8].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[8].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    psi->Fields[8].AssociatedField = 7;
    //ticket
    psi->Fields[9].Name = "ticket";
    psi->Fields[9].TypeId = TpmTypeId::TPMT_TK_AUTH_ID;
    psi->Fields[9].MarshalType = MarshalType::Normal;
    psi->Fields[9].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    
    // ======== TPM2_PolicyOR_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyOR_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyOR_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyOR_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    //pHashListCount
    psi->Fields[1].Name = "pHashListCount";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    //pHashList
    psi->Fields[2].Name = "pHashList";
    psi->Fields[2].TypeId = TpmTypeId::TPM2B_DIGEST_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PolicyPCR_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyPCR_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyPCR_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyPCR_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    //pcrDigestSize
    psi->Fields[1].Name = "pcrDigestSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    //pcrDigest
    psi->Fields[2].Name = "pcrDigest";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //pcrsCount
    psi->Fields[3].Name = "pcrsCount";
    psi->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    //pcrs
    psi->Fields[4].Name = "pcrs";
    psi->Fields[4].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPM2_PolicyLocality_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyLocality_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyLocality_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyLocality_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
    //locality
    psi->Fields[1].Name = "locality";
    psi->Fields[1].TypeId = TpmTypeId::TPMA_LOCALITY_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
    
    // ======== TPM2_PolicyNV_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyNV_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyNV_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyNV_REQUEST()); };
    psi->HandleCount = 3;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(7);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //policySession
    psi->Fields[2].Name = "policySession";
    psi->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //operandBSize
    psi->Fields[3].Name = "operandBSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //operandB
    psi->Fields[4].Name = "operandB";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //offset
    psi->Fields[5].Name = "offset";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //operation
    psi->Fields[6].Name = "operation";
    psi->Fields[6].TypeId = TpmTypeId::TPM_EO_ID;
    psi->Fields[6].MarshalType = MarshalType::Normal;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    
    // ======== TPM2_PolicyCounterTimer_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyCounterTimer_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyCounterTimer_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    //operandBSize
    psi->Fields[1].Name = "operandBSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    //operandB
    psi->Fields[2].Name = "operandB";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //offset
    psi->Fields[3].Name = "offset";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    //operation
    psi->Fields[4].Name = "operation";
    psi->Fields[4].TypeId = TpmTypeId::TPM_EO_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    
    // ======== TPM2_PolicyCommandCode_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyCommandCode_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyCommandCode_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
    //code
    psi->Fields[1].Name = "code";
    psi->Fields[1].TypeId = TpmTypeId::TPM_CC_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
    
    // ======== TPM2_PolicyPhysicalPresence_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyPhysicalPresence_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyPhysicalPresence_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID;
    
    // ======== TPM2_PolicyCpHash_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyCpHash_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyCpHash_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    //cpHashASize
    psi->Fields[1].Name = "cpHashASize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    //cpHashA
    psi->Fields[2].Name = "cpHashA";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PolicyNameHash_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyNameHash_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyNameHash_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    //nameHashSize
    psi->Fields[1].Name = "nameHashSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    //nameHash
    psi->Fields[2].Name = "nameHash";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PolicyDuplicationSelect_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyDuplicationSelect_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyDuplicationSelect_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    //objectNameSize
    psi->Fields[1].Name = "objectNameSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    //objectName
    psi->Fields[2].Name = "objectName";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //newParentNameSize
    psi->Fields[3].Name = "newParentNameSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    //newParentName
    psi->Fields[4].Name = "newParentName";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //includeObject
    psi->Fields[5].Name = "includeObject";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::Normal;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    
    // ======== TPM2_PolicyAuthorize_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyAuthorize_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyAuthorize_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(8);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //approvedPolicySize
    psi->Fields[1].Name = "approvedPolicySize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //approvedPolicy
    psi->Fields[2].Name = "approvedPolicy";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //policyRefSize
    psi->Fields[3].Name = "policyRefSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //policyRef
    psi->Fields[4].Name = "policyRef";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //keySignSize
    psi->Fields[5].Name = "keySignSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //keySign
    psi->Fields[6].Name = "keySign";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    //checkTicket
    psi->Fields[7].Name = "checkTicket";
    psi->Fields[7].TypeId = TpmTypeId::TPMT_TK_VERIFIED_ID;
    psi->Fields[7].MarshalType = MarshalType::Normal;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    
    // ======== TPM2_PolicyAuthValue_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyAuthValue_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyAuthValue_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID;
    
    // ======== TPM2_PolicyPassword_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyPassword_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyPassword_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyPassword_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPassword_REQUEST_ID;
    
    // ======== TPM2_PolicyGetDigest_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyGetDigest_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyGetDigest_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID;
    
    // ======== PolicyGetDigestResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::PolicyGetDigestResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "PolicyGetDigestResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyGetDigestResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //policyDigestSize
    psi->Fields[0].Name = "policyDigestSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::PolicyGetDigestResponse_ID;
    //policyDigest
    psi->Fields[1].Name = "policyDigest";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::PolicyGetDigestResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_PolicyNvWritten_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyNvWritten_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyNvWritten_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
    //writtenSet
    psi->Fields[1].Name = "writtenSet";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
    
    // ======== TPM2_PolicyTemplate_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyTemplate_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyTemplate_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    //templateHashSize
    psi->Fields[1].Name = "templateHashSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    //templateHash
    psi->Fields[2].Name = "templateHash";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PolicyAuthorizeNV_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PolicyAuthorizeNV_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyAuthorizeNV_REQUEST()); };
    psi->HandleCount = 3;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    //policySession
    psi->Fields[2].Name = "policySession";
    psi->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    
    // ======== TPM2_CreatePrimary_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_CreatePrimary_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_CreatePrimary_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CreatePrimary_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(9);
    //primaryHandle
    psi->Fields[0].Name = "primaryHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inSensitiveSize
    psi->Fields[1].Name = "inSensitiveSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inSensitive
    psi->Fields[2].Name = "inSensitive";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inPublicSize
    psi->Fields[3].Name = "inPublicSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inPublic
    psi->Fields[4].Name = "inPublic";
    psi->Fields[4].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //outsideInfoSize
    psi->Fields[5].Name = "outsideInfoSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //outsideInfo
    psi->Fields[6].Name = "outsideInfo";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    //creationPCRCount
    psi->Fields[7].Name = "creationPCRCount";
    psi->Fields[7].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[7].MarshalType = MarshalType::ArrayCount;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //creationPCR
    psi->Fields[8].Name = "creationPCR";
    psi->Fields[8].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    psi->Fields[8].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    psi->Fields[8].AssociatedField = 7;
    
    // ======== CreatePrimaryResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CreatePrimaryResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CreatePrimaryResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CreatePrimaryResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(10);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //outPublicSize
    psi->Fields[1].Name = "outPublicSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[1].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //outPublic
    psi->Fields[2].Name = "outPublic";
    psi->Fields[2].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationDataSize
    psi->Fields[3].Name = "creationDataSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationData
    psi->Fields[4].Name = "creationData";
    psi->Fields[4].TypeId = TpmTypeId::TPMS_CREATION_DATA_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationHashSize
    psi->Fields[5].Name = "creationHashSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationHash
    psi->Fields[6].Name = "creationHash";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    psi->Fields[6].AssociatedField = 5;
    //creationTicket
    psi->Fields[7].Name = "creationTicket";
    psi->Fields[7].TypeId = TpmTypeId::TPMT_TK_CREATION_ID;
    psi->Fields[7].MarshalType = MarshalType::Normal;
    psi->Fields[7].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //nameSize
    psi->Fields[8].Name = "nameSize";
    psi->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[8].MarshalType = MarshalType::ArrayCount;
    psi->Fields[8].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //name
    psi->Fields[9].Name = "name";
    psi->Fields[9].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[9].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[9].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    psi->Fields[9].AssociatedField = 8;
    
    // ======== TPM2_HierarchyControl_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_HierarchyControl_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_HierarchyControl_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HierarchyControl_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    //enable
    psi->Fields[1].Name = "enable";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    //state
    psi->Fields[2].Name = "state";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    
    // ======== TPM2_SetPrimaryPolicy_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_SetPrimaryPolicy_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SetPrimaryPolicy_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    //authPolicySize
    psi->Fields[1].Name = "authPolicySize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    //authPolicy
    psi->Fields[2].Name = "authPolicy";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //hashAlg
    psi->Fields[3].Name = "hashAlg";
    psi->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    
    // ======== TPM2_ChangePPS_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ChangePPS_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ChangePPS_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ChangePPS_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(1);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ChangePPS_REQUEST_ID;
    
    // ======== TPM2_ChangeEPS_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ChangeEPS_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ChangeEPS_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ChangeEPS_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(1);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ChangeEPS_REQUEST_ID;
    
    // ======== TPM2_Clear_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Clear_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Clear_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Clear_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(1);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Clear_REQUEST_ID;
    
    // ======== TPM2_ClearControl_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ClearControl_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ClearControl_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ClearControl_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //auth
    psi->Fields[0].Name = "auth";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ClearControl_REQUEST_ID;
    //disable
    psi->Fields[1].Name = "disable";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ClearControl_REQUEST_ID;
    
    // ======== TPM2_HierarchyChangeAuth_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_HierarchyChangeAuth_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HierarchyChangeAuth_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    //newAuthSize
    psi->Fields[1].Name = "newAuthSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    //newAuth
    psi->Fields[2].Name = "newAuth";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_DictionaryAttackLockReset_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_DictionaryAttackLockReset_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_DictionaryAttackLockReset_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(1);
    //lockHandle
    psi->Fields[0].Name = "lockHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID;
    
    // ======== TPM2_DictionaryAttackParameters_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_DictionaryAttackParameters_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_DictionaryAttackParameters_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //lockHandle
    psi->Fields[0].Name = "lockHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    //newMaxTries
    psi->Fields[1].Name = "newMaxTries";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    //newRecoveryTime
    psi->Fields[2].Name = "newRecoveryTime";
    psi->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    //lockoutRecovery
    psi->Fields[3].Name = "lockoutRecovery";
    psi->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    
    // ======== TPM2_PP_Commands_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_PP_Commands_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_PP_Commands_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PP_Commands_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(5);
    //auth
    psi->Fields[0].Name = "auth";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    //setListCount
    psi->Fields[1].Name = "setListCount";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    //setList
    psi->Fields[2].Name = "setList";
    psi->Fields[2].TypeId = TpmTypeId::TPM_CC_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //clearListCount
    psi->Fields[3].Name = "clearListCount";
    psi->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    //clearList
    psi->Fields[4].Name = "clearList";
    psi->Fields[4].TypeId = TpmTypeId::TPM_CC_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== TPM2_SetAlgorithmSet_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_SetAlgorithmSet_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SetAlgorithmSet_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
    //algorithmSet
    psi->Fields[1].Name = "algorithmSet";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
    
    // ======== TPM2_FieldUpgradeStart_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_FieldUpgradeStart_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FieldUpgradeStart_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(6);
    //authorization
    psi->Fields[0].Name = "authorization";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    //keyHandle
    psi->Fields[1].Name = "keyHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    //fuDigestSize
    psi->Fields[2].Name = "fuDigestSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    //fuDigest
    psi->Fields[3].Name = "fuDigest";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //manifestSignatureSigAlg
    psi->Fields[4].Name = "manifestSignatureSigAlg";
    psi->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[4].MarshalType = MarshalType::UnionSelector;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    psi->Fields[4].AssociatedField = 5;
    //manifestSignature
    psi->Fields[5].Name = "manifestSignature";
    psi->Fields[5].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionObject;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_FieldUpgradeData_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_FieldUpgradeData_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FieldUpgradeData_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //fuDataSize
    psi->Fields[0].Name = "fuDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
    //fuData
    psi->Fields[1].Name = "fuData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== FieldUpgradeDataResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::FieldUpgradeDataResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "FieldUpgradeDataResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new FieldUpgradeDataResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //nextDigest
    psi->Fields[0].Name = "nextDigest";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::FieldUpgradeDataResponse_ID;
    //firstDigest
    psi->Fields[1].Name = "firstDigest";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::FieldUpgradeDataResponse_ID;
    
    // ======== TPM2_FirmwareRead_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_FirmwareRead_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_FirmwareRead_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FirmwareRead_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //sequenceNumber
    psi->Fields[0].Name = "sequenceNumber";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_FirmwareRead_REQUEST_ID;
    
    // ======== FirmwareReadResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::FirmwareReadResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "FirmwareReadResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new FirmwareReadResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //fuDataSize
    psi->Fields[0].Name = "fuDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::FirmwareReadResponse_ID;
    //fuData
    psi->Fields[1].Name = "fuData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::FirmwareReadResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_ContextSave_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ContextSave_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ContextSave_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ContextSave_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //saveHandle
    psi->Fields[0].Name = "saveHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ContextSave_REQUEST_ID;
    
    // ======== ContextSaveResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ContextSaveResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ContextSaveResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ContextSaveResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //context
    psi->Fields[0].Name = "context";
    psi->Fields[0].TypeId = TpmTypeId::TPMS_CONTEXT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::ContextSaveResponse_ID;
    
    // ======== TPM2_ContextLoad_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ContextLoad_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ContextLoad_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ContextLoad_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //context
    psi->Fields[0].Name = "context";
    psi->Fields[0].TypeId = TpmTypeId::TPMS_CONTEXT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ContextLoad_REQUEST_ID;
    
    // ======== ContextLoadResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ContextLoadResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ContextLoadResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ContextLoadResponse()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::ContextLoadResponse_ID;
    
    // ======== TPM2_FlushContext_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_FlushContext_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_FlushContext_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FlushContext_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //flushHandle
    psi->Fields[0].Name = "flushHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_FlushContext_REQUEST_ID;
    
    // ======== TPM2_EvictControl_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_EvictControl_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_EvictControl_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EvictControl_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //auth
    psi->Fields[0].Name = "auth";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    //objectHandle
    psi->Fields[1].Name = "objectHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    //persistentHandle
    psi->Fields[2].Name = "persistentHandle";
    psi->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    
    // ======== TPM2_ReadClock_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ReadClock_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ReadClock_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ReadClock_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(0);
    
    // ======== ReadClockResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::ReadClockResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "ReadClockResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ReadClockResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //currentTime
    psi->Fields[0].Name = "currentTime";
    psi->Fields[0].TypeId = TpmTypeId::TPMS_TIME_INFO_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::ReadClockResponse_ID;
    
    // ======== TPM2_ClockSet_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ClockSet_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ClockSet_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ClockSet_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //auth
    psi->Fields[0].Name = "auth";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ClockSet_REQUEST_ID;
    //newTime
    psi->Fields[1].Name = "newTime";
    psi->Fields[1].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ClockSet_REQUEST_ID;
    
    // ======== TPM2_ClockRateAdjust_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ClockRateAdjust_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ClockRateAdjust_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //auth
    psi->Fields[0].Name = "auth";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
    //rateAdjust
    psi->Fields[1].Name = "rateAdjust";
    psi->Fields[1].TypeId = TpmTypeId::TPM_CLOCK_ADJUST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
    
    // ======== TPM2_GetCapability_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_GetCapability_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_GetCapability_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetCapability_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //capability
    psi->Fields[0].Name = "capability";
    psi->Fields[0].TypeId = TpmTypeId::TPM_CAP_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    //property
    psi->Fields[1].Name = "property";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    //propertyCount
    psi->Fields[2].Name = "propertyCount";
    psi->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    
    // ======== GetCapabilityResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::GetCapabilityResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "GetCapabilityResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetCapabilityResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //moreData
    psi->Fields[0].Name = "moreData";
    psi->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    //capabilityDataCapability
    psi->Fields[1].Name = "capabilityDataCapability";
    psi->Fields[1].TypeId = TpmTypeId::TPM_CAP_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionSelector;
    psi->Fields[1].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    psi->Fields[1].AssociatedField = 2;
    //capabilityData
    psi->Fields[2].Name = "capabilityData";
    psi->Fields[2].TypeId = TpmTypeId::TPMU_CAPABILITIES_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionObject;
    psi->Fields[2].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_TestParms_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_TestParms_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_TestParms_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_TestParms_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //parametersType
    psi->Fields[0].Name = "parametersType";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[0].MarshalType = MarshalType::UnionSelector;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_TestParms_REQUEST_ID;
    psi->Fields[0].AssociatedField = 1;
    //parameters
    psi->Fields[1].Name = "parameters";
    psi->Fields[1].TypeId = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    psi->Fields[1].MarshalType = MarshalType::UnionObject;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_TestParms_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_NV_DefineSpace_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_DefineSpace_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_DefineSpace_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(5);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    //authSize
    psi->Fields[1].Name = "authSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    //auth
    psi->Fields[2].Name = "auth";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //publicInfoSize
    psi->Fields[3].Name = "publicInfoSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    //publicInfo
    psi->Fields[4].Name = "publicInfo";
    psi->Fields[4].TypeId = TpmTypeId::TPMS_NV_PUBLIC_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    
    // ======== TPM2_NV_UndefineSpace_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_UndefineSpace_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_UndefineSpace_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
    
    // ======== TPM2_NV_UndefineSpaceSpecial_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_UndefineSpaceSpecial_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_UndefineSpaceSpecial_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(2);
    //nvIndex
    psi->Fields[0].Name = "nvIndex";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
    //platform
    psi->Fields[1].Name = "platform";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
    
    // ======== TPM2_NV_ReadPublic_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_ReadPublic_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_ReadPublic_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //nvIndex
    psi->Fields[0].Name = "nvIndex";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID;
    
    // ======== NV_ReadPublicResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::NV_ReadPublicResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "NV_ReadPublicResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_ReadPublicResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //nvPublicSize
    psi->Fields[0].Name = "nvPublicSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    //nvPublic
    psi->Fields[1].Name = "nvPublic";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_NV_PUBLIC_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    //nvNameSize
    psi->Fields[2].Name = "nvNameSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    //nvName
    psi->Fields[3].Name = "nvName";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_NV_Write_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_Write_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_Write_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Write_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(5);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    //dataSize
    psi->Fields[2].Name = "dataSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    //data
    psi->Fields[3].Name = "data";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    //offset
    psi->Fields[4].Name = "offset";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::Normal;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    
    // ======== TPM2_NV_Increment_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_Increment_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_Increment_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Increment_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
    
    // ======== TPM2_NV_Extend_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_Extend_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_Extend_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Extend_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    //dataSize
    psi->Fields[2].Name = "dataSize";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::ArrayCount;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    //data
    psi->Fields[3].Name = "data";
    psi->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_NV_SetBits_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_SetBits_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_SetBits_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_SetBits_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    //bits
    psi->Fields[2].Name = "bits";
    psi->Fields[2].TypeId = TpmTypeId::UINT64_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    
    // ======== TPM2_NV_WriteLock_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_WriteLock_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_WriteLock_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
    
    // ======== TPM2_NV_GlobalWriteLock_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_GlobalWriteLock_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_GlobalWriteLock_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(1);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID;
    
    // ======== TPM2_NV_Read_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_Read_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_Read_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Read_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(4);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    //size
    psi->Fields[2].Name = "size";
    psi->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    //offset
    psi->Fields[3].Name = "offset";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    
    // ======== NV_ReadResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::NV_ReadResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "NV_ReadResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_ReadResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //dataSize
    psi->Fields[0].Name = "dataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::NV_ReadResponse_ID;
    //data
    psi->Fields[1].Name = "data";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::NV_ReadResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_NV_ReadLock_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_ReadLock_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_ReadLock_REQUEST()); };
    psi->HandleCount = 2;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //authHandle
    psi->Fields[0].Name = "authHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
    //nvIndex
    psi->Fields[1].Name = "nvIndex";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
    
    // ======== TPM2_NV_ChangeAuth_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_ChangeAuth_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_ChangeAuth_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(3);
    //nvIndex
    psi->Fields[0].Name = "nvIndex";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    //newAuthSize
    psi->Fields[1].Name = "newAuthSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    //newAuth
    psi->Fields[2].Name = "newAuth";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_NV_Certify_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_NV_Certify_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_NV_Certify_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Certify_REQUEST()); };
    psi->HandleCount = 3;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(9);
    //signHandle
    psi->Fields[0].Name = "signHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //authHandle
    psi->Fields[1].Name = "authHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //nvIndex
    psi->Fields[2].Name = "nvIndex";
    psi->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //qualifyingDataSize
    psi->Fields[3].Name = "qualifyingDataSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //qualifyingData
    psi->Fields[4].Name = "qualifyingData";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //inSchemeScheme
    psi->Fields[5].Name = "inSchemeScheme";
    psi->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[5].MarshalType = MarshalType::UnionSelector;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    psi->Fields[5].AssociatedField = 6;
    //inScheme
    psi->Fields[6].Name = "inScheme";
    psi->Fields[6].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    psi->Fields[6].MarshalType = MarshalType::UnionObject;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    //size
    psi->Fields[7].Name = "size";
    psi->Fields[7].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[7].MarshalType = MarshalType::Normal;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //offset
    psi->Fields[8].Name = "offset";
    psi->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[8].MarshalType = MarshalType::Normal;
    psi->Fields[8].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    
    // ======== NV_CertifyResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::NV_CertifyResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "NV_CertifyResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_CertifyResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(4);
    //certifyInfoSize
    psi->Fields[0].Name = "certifyInfoSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    psi->Fields[0].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    //certifyInfo
    psi->Fields[1].Name = "certifyInfo";
    psi->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    //signatureSigAlg
    psi->Fields[2].Name = "signatureSigAlg";
    psi->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    psi->Fields[2].MarshalType = MarshalType::UnionSelector;
    psi->Fields[2].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    psi->Fields[2].AssociatedField = 3;
    //signature
    psi->Fields[3].Name = "signature";
    psi->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    psi->Fields[3].MarshalType = MarshalType::UnionObject;
    psi->Fields[3].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    psi->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_AC_GetCapability_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_AC_GetCapability_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_AC_GetCapability_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //ac
    psi->Fields[0].Name = "ac";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    //capability
    psi->Fields[1].Name = "capability";
    psi->Fields[1].TypeId = TpmTypeId::TPM_AT_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    //count
    psi->Fields[2].Name = "count";
    psi->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    
    // ======== AC_GetCapabilityResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::AC_GetCapabilityResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "AC_GetCapabilityResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new AC_GetCapabilityResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //moreData
    psi->Fields[0].Name = "moreData";
    psi->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    //capabilitiesDataCount
    psi->Fields[1].Name = "capabilitiesDataCount";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    //capabilitiesData
    psi->Fields[2].Name = "capabilitiesData";
    psi->Fields[2].TypeId = TpmTypeId::TPMS_AC_OUTPUT_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_AC_Send_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_AC_Send_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_AC_Send_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_AC_Send_REQUEST()); };
    psi->HandleCount = 3;
    psi->AuthHandleCount = 2;
    psi->Fields.resize(5);
    //sendObject
    psi->Fields[0].Name = "sendObject";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //authHandle
    psi->Fields[1].Name = "authHandle";
    psi->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //ac
    psi->Fields[2].Name = "ac";
    psi->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //acDataInSize
    psi->Fields[3].Name = "acDataInSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //acDataIn
    psi->Fields[4].Name = "acDataIn";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== AC_SendResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::AC_SendResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "AC_SendResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new AC_SendResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(1);
    //acDataOut
    psi->Fields[0].Name = "acDataOut";
    psi->Fields[0].TypeId = TpmTypeId::TPMS_AC_OUTPUT_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::AC_SendResponse_ID;
    
    // ======== TPM2_Policy_AC_SendSelect_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Policy_AC_SendSelect_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Policy_AC_SendSelect_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(8);
    //policySession
    psi->Fields[0].Name = "policySession";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //objectNameSize
    psi->Fields[1].Name = "objectNameSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //objectName
    psi->Fields[2].Name = "objectName";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    psi->Fields[2].AssociatedField = 1;
    //authHandleNameSize
    psi->Fields[3].Name = "authHandleNameSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //authHandleName
    psi->Fields[4].Name = "authHandleName";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    psi->Fields[4].AssociatedField = 3;
    //acNameSize
    psi->Fields[5].Name = "acNameSize";
    psi->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[5].MarshalType = MarshalType::ArrayCount;
    psi->Fields[5].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //acName
    psi->Fields[6].Name = "acName";
    psi->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[6].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    psi->Fields[6].AssociatedField = 5;
    //includeObject
    psi->Fields[7].Name = "includeObject";
    psi->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[7].MarshalType = MarshalType::Normal;
    psi->Fields[7].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    
    // ======== TPM2_ACT_SetTimeout_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_ACT_SetTimeout_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ACT_SetTimeout_REQUEST()); };
    psi->HandleCount = 1;
    psi->AuthHandleCount = 1;
    psi->Fields.resize(2);
    //actHandle
    psi->Fields[0].Name = "actHandle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID;
    //startTimeout
    psi->Fields[1].Name = "startTimeout";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID;
    
    // ======== TPM2_Vendor_TCG_Test_REQUEST ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2_Vendor_TCG_Test_REQUEST";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Vendor_TCG_Test_REQUEST()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //inputDataSize
    psi->Fields[0].Name = "inputDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
    //inputData
    psi->Fields[1].Name = "inputData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== Vendor_TCG_TestResponse ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::Vendor_TCG_TestResponse_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "Vendor_TCG_TestResponse";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new Vendor_TCG_TestResponse()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //outputDataSize
    psi->Fields[0].Name = "outputDataSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::Vendor_TCG_TestResponse_ID;
    //outputData
    psi->Fields[1].Name = "outputData";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::Vendor_TCG_TestResponse_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TssObject ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TssObject_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TssObject";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TssObject()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //Public
    psi->Fields[0].Name = "Public";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TssObject_ID;
    //Sensitive
    psi->Fields[1].Name = "Sensitive";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::TssObject_ID;
    //Private
    psi->Fields[2].Name = "Private";
    psi->Fields[2].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::TssObject_ID;
    
    // ======== PcrValue ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::PcrValue_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "PcrValue";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PcrValue()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //index
    psi->Fields[0].Name = "index";
    psi->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::PcrValue_ID;
    //value
    psi->Fields[1].Name = "value";
    psi->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::PcrValue_ID;
    
    // ======== SessionIn ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::SessionIn_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "SessionIn";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SessionIn()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(6);
    //handle
    psi->Fields[0].Name = "handle";
    psi->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::SessionIn_ID;
    //nonceCallerSize
    psi->Fields[1].Name = "nonceCallerSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::SessionIn_ID;
    //nonceCaller
    psi->Fields[2].Name = "nonceCaller";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::SessionIn_ID;
    psi->Fields[2].AssociatedField = 1;
    //attributes
    psi->Fields[3].Name = "attributes";
    psi->Fields[3].TypeId = TpmTypeId::TPMA_SESSION_ID;
    psi->Fields[3].MarshalType = MarshalType::Normal;
    psi->Fields[3].ParentType = TpmTypeId::SessionIn_ID;
    //authSize
    psi->Fields[4].Name = "authSize";
    psi->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[4].MarshalType = MarshalType::ArrayCount;
    psi->Fields[4].ParentType = TpmTypeId::SessionIn_ID;
    //auth
    psi->Fields[5].Name = "auth";
    psi->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[5].ParentType = TpmTypeId::SessionIn_ID;
    psi->Fields[5].AssociatedField = 4;
    
    // ======== SessionOut ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::SessionOut_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "SessionOut";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SessionOut()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(5);
    //nonceTpmSize
    psi->Fields[0].Name = "nonceTpmSize";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::SessionOut_ID;
    //nonceTpm
    psi->Fields[1].Name = "nonceTpm";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::SessionOut_ID;
    psi->Fields[1].AssociatedField = 0;
    //attributes
    psi->Fields[2].Name = "attributes";
    psi->Fields[2].TypeId = TpmTypeId::TPMA_SESSION_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::SessionOut_ID;
    //authSize
    psi->Fields[3].Name = "authSize";
    psi->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[3].MarshalType = MarshalType::ArrayCount;
    psi->Fields[3].ParentType = TpmTypeId::SessionOut_ID;
    //auth
    psi->Fields[4].Name = "auth";
    psi->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[4].ParentType = TpmTypeId::SessionOut_ID;
    psi->Fields[4].AssociatedField = 3;
    
    // ======== CommandHeader ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::CommandHeader_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "CommandHeader";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CommandHeader()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //Tag
    psi->Fields[0].Name = "Tag";
    psi->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::CommandHeader_ID;
    //CommandSize
    psi->Fields[1].Name = "CommandSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    psi->Fields[1].MarshalType = MarshalType::Normal;
    psi->Fields[1].ParentType = TpmTypeId::CommandHeader_ID;
    //CommandCode
    psi->Fields[2].Name = "CommandCode";
    psi->Fields[2].TypeId = TpmTypeId::TPM_CC_ID;
    psi->Fields[2].MarshalType = MarshalType::Normal;
    psi->Fields[2].ParentType = TpmTypeId::CommandHeader_ID;
    
    // ======== TSS_KEY ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TSS_KEY_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TSS_KEY";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TSS_KEY()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(3);
    //publicPart
    psi->Fields[0].Name = "publicPart";
    psi->Fields[0].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    psi->Fields[0].MarshalType = MarshalType::Normal;
    psi->Fields[0].ParentType = TpmTypeId::TSS_KEY_ID;
    //privatePartSize
    psi->Fields[1].Name = "privatePartSize";
    psi->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[1].MarshalType = MarshalType::ArrayCount;
    psi->Fields[1].ParentType = TpmTypeId::TSS_KEY_ID;
    //privatePart
    psi->Fields[2].Name = "privatePart";
    psi->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[2].ParentType = TpmTypeId::TSS_KEY_ID;
    psi->Fields[2].AssociatedField = 1;
    
    // ======== TPM2B_DIGEST_Symcipher ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_DIGEST_Symcipher_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_DIGEST_Symcipher";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DIGEST_Symcipher()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    psi->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_DIGEST_Keyedhash ========
    psi = new TpmStructInfo();
    TypeMap[TpmTypeId::TPM2B_DIGEST_Keyedhash_ID] = psi;
    psi->Kind = TpmEntity::Struct;
    psi->Name = "TPM2B_DIGEST_Keyedhash";
    psi->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DIGEST_Keyedhash()); };
    psi->HandleCount = 0;
    psi->AuthHandleCount = 0;
    psi->Fields.resize(2);
    //size
    psi->Fields[0].Name = "size";
    psi->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    psi->Fields[0].MarshalType = MarshalType::ArrayCount;
    psi->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    //buffer
    psi->Fields[1].Name = "buffer";
    psi->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    psi->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    psi->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    psi->Fields[1].AssociatedField = 0;
    
    TpmUnionInfo* pui;
    
    
    // ======== TPMU_HA ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_HA_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_HA";
    pui->UnionSelector.resize(0);
    pui->UnionType.resize(0);
    
    // ======== TPMU_NAME ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_NAME_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_NAME";
    pui->UnionSelector.resize(0);
    pui->UnionType.resize(0);
    
    // ======== TPMU_CAPABILITIES ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_CAPABILITIES_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_CAPABILITIES";
    pui->UnionSelector.resize(11);
    pui->UnionType.resize(11);
    pui->UnionSelector[0] = TPM_CAP::ALGS;
    pui->UnionType[0] = TpmTypeId::TPML_ALG_PROPERTY_ID;
    pui->UnionSelector[1] = TPM_CAP::HANDLES;
    pui->UnionType[1] = TpmTypeId::TPML_HANDLE_ID;
    pui->UnionSelector[2] = TPM_CAP::COMMANDS;
    pui->UnionType[2] = TpmTypeId::TPML_CCA_ID;
    pui->UnionSelector[3] = TPM_CAP::PP_COMMANDS;
    pui->UnionType[3] = TpmTypeId::TPML_CC_ID;
    pui->UnionSelector[4] = TPM_CAP::AUDIT_COMMANDS;
    pui->UnionType[4] = TpmTypeId::TPML_CC_ID;
    pui->UnionSelector[5] = TPM_CAP::PCRS;
    pui->UnionType[5] = TpmTypeId::TPML_PCR_SELECTION_ID;
    pui->UnionSelector[6] = TPM_CAP::TPM_PROPERTIES;
    pui->UnionType[6] = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    pui->UnionSelector[7] = TPM_CAP::PCR_PROPERTIES;
    pui->UnionType[7] = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    pui->UnionSelector[8] = TPM_CAP::ECC_CURVES;
    pui->UnionType[8] = TpmTypeId::TPML_ECC_CURVE_ID;
    pui->UnionSelector[9] = TPM_CAP::AUTH_POLICIES;
    pui->UnionType[9] = TpmTypeId::TPML_TAGGED_POLICY_ID;
    pui->UnionSelector[10] = TPM_CAP::ACT;
    pui->UnionType[10] = TpmTypeId::TPML_ACT_DATA_ID;
    
    // ======== TPMU_ATTEST ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_ATTEST_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_ATTEST";
    pui->UnionSelector.resize(8);
    pui->UnionType.resize(8);
    pui->UnionSelector[0] = TPM_ST::ATTEST_CERTIFY;
    pui->UnionType[0] = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    pui->UnionSelector[1] = TPM_ST::ATTEST_CREATION;
    pui->UnionType[1] = TpmTypeId::TPMS_CREATION_INFO_ID;
    pui->UnionSelector[2] = TPM_ST::ATTEST_QUOTE;
    pui->UnionType[2] = TpmTypeId::TPMS_QUOTE_INFO_ID;
    pui->UnionSelector[3] = TPM_ST::ATTEST_COMMAND_AUDIT;
    pui->UnionType[3] = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    pui->UnionSelector[4] = TPM_ST::ATTEST_SESSION_AUDIT;
    pui->UnionType[4] = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    pui->UnionSelector[5] = TPM_ST::ATTEST_TIME;
    pui->UnionType[5] = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    pui->UnionSelector[6] = TPM_ST::ATTEST_NV;
    pui->UnionType[6] = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    pui->UnionSelector[7] = TPM_ST::ATTEST_NV_DIGEST;
    pui->UnionType[7] = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    
    // ======== TPMU_SYM_KEY_BITS ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SYM_KEY_BITS_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SYM_KEY_BITS";
    pui->UnionSelector.resize(7);
    pui->UnionType.resize(7);
    pui->UnionSelector[0] = TPM_ALG_ID::TDES;
    pui->UnionType[0] = TpmTypeId::TPMI_TDES_KEY_BITS_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::AES;
    pui->UnionType[1] = TpmTypeId::TPMI_AES_KEY_BITS_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::SM4;
    pui->UnionType[2] = TpmTypeId::TPMI_SM4_KEY_BITS_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::CAMELLIA;
    pui->UnionType[3] = TpmTypeId::TPMI_CAMELLIA_KEY_BITS_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ANY;
    pui->UnionType[4] = TpmTypeId::TPM_KEY_BITS_ID;
    pui->UnionSelector[5] = TPM_ALG_ID::XOR;
    pui->UnionType[5] = TpmTypeId::TPMI_ALG_HASH_ID;
    pui->UnionSelector[6] = TPM_ALG_ID::_NULL;
    pui->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID;
    
    // ======== TPMU_SYM_MODE ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SYM_MODE_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SYM_MODE";
    pui->UnionSelector.resize(7);
    pui->UnionType.resize(7);
    pui->UnionSelector[0] = TPM_ALG_ID::TDES;
    pui->UnionType[0] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::AES;
    pui->UnionType[1] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::SM4;
    pui->UnionType[2] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::CAMELLIA;
    pui->UnionType[3] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ANY;
    pui->UnionType[4] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    pui->UnionSelector[5] = TPM_ALG_ID::XOR;
    pui->UnionType[5] = TpmTypeId::TPMS_XOR_SYM_MODE_ID;
    pui->UnionSelector[6] = TPM_ALG_ID::_NULL;
    pui->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_MODE_ID;
    
    // ======== TPMU_SYM_DETAILS ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SYM_DETAILS_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SYM_DETAILS";
    pui->UnionSelector.resize(7);
    pui->UnionType.resize(7);
    pui->UnionSelector[0] = TPM_ALG_ID::TDES;
    pui->UnionType[0] = TpmTypeId::TPMS_TDES_SYM_DETAILS_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::AES;
    pui->UnionType[1] = TpmTypeId::TPMS_AES_SYM_DETAILS_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::SM4;
    pui->UnionType[2] = TpmTypeId::TPMS_SM4_SYM_DETAILS_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::CAMELLIA;
    pui->UnionType[3] = TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ANY;
    pui->UnionType[4] = TpmTypeId::TPMS_ANY_SYM_DETAILS_ID;
    pui->UnionSelector[5] = TPM_ALG_ID::XOR;
    pui->UnionType[5] = TpmTypeId::TPMS_XOR_SYM_DETAILS_ID;
    pui->UnionSelector[6] = TPM_ALG_ID::_NULL;
    pui->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_DETAILS_ID;
    
    // ======== TPMU_SENSITIVE_CREATE ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SENSITIVE_CREATE_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SENSITIVE_CREATE";
    pui->UnionSelector.resize(2);
    pui->UnionType.resize(2);
    pui->UnionSelector[0] = TPM_ALG_ID::ANY;
    pui->UnionType[0] = TpmTypeId::BYTE_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::ANY2;
    pui->UnionType[1] = TpmTypeId::TPMS_DERIVE_ID;
    
    // ======== TPMU_SCHEME_KEYEDHASH ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SCHEME_KEYEDHASH";
    pui->UnionSelector.resize(3);
    pui->UnionType.resize(3);
    pui->UnionSelector[0] = TPM_ALG_ID::HMAC;
    pui->UnionType[0] = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::XOR;
    pui->UnionType[1] = TpmTypeId::TPMS_SCHEME_XOR_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::_NULL;
    pui->UnionType[2] = TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID;
    
    // ======== TPMU_SIG_SCHEME ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SIG_SCHEME_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SIG_SCHEME";
    pui->UnionSelector.resize(9);
    pui->UnionType.resize(9);
    pui->UnionSelector[0] = TPM_ALG_ID::RSASSA;
    pui->UnionType[0] = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::RSAPSS;
    pui->UnionType[1] = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::ECDSA;
    pui->UnionType[2] = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::ECDAA;
    pui->UnionType[3] = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::SM2;
    pui->UnionType[4] = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    pui->UnionSelector[5] = TPM_ALG_ID::ECSCHNORR;
    pui->UnionType[5] = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    pui->UnionSelector[6] = TPM_ALG_ID::HMAC;
    pui->UnionType[6] = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    pui->UnionSelector[7] = TPM_ALG_ID::ANY;
    pui->UnionType[7] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    pui->UnionSelector[8] = TPM_ALG_ID::_NULL;
    pui->UnionType[8] = TpmTypeId::TPMS_NULL_SIG_SCHEME_ID;
    
    // ======== TPMU_KDF_SCHEME ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_KDF_SCHEME_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_KDF_SCHEME";
    pui->UnionSelector.resize(6);
    pui->UnionType.resize(6);
    pui->UnionSelector[0] = TPM_ALG_ID::MGF1;
    pui->UnionType[0] = TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::KDF1_SP800_56A;
    pui->UnionType[1] = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::KDF2;
    pui->UnionType[2] = TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::KDF1_SP800_108;
    pui->UnionType[3] = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ANY;
    pui->UnionType[4] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    pui->UnionSelector[5] = TPM_ALG_ID::_NULL;
    pui->UnionType[5] = TpmTypeId::TPMS_NULL_KDF_SCHEME_ID;
    
    // ======== TPMU_ASYM_SCHEME ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_ASYM_SCHEME_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_ASYM_SCHEME";
    pui->UnionSelector.resize(12);
    pui->UnionType.resize(12);
    pui->UnionSelector[0] = TPM_ALG_ID::ECDH;
    pui->UnionType[0] = TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::ECMQV;
    pui->UnionType[1] = TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::RSASSA;
    pui->UnionType[2] = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::RSAPSS;
    pui->UnionType[3] = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ECDSA;
    pui->UnionType[4] = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    pui->UnionSelector[5] = TPM_ALG_ID::ECDAA;
    pui->UnionType[5] = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    pui->UnionSelector[6] = TPM_ALG_ID::SM2;
    pui->UnionType[6] = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    pui->UnionSelector[7] = TPM_ALG_ID::ECSCHNORR;
    pui->UnionType[7] = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    pui->UnionSelector[8] = TPM_ALG_ID::RSAES;
    pui->UnionType[8] = TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID;
    pui->UnionSelector[9] = TPM_ALG_ID::OAEP;
    pui->UnionType[9] = TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
    pui->UnionSelector[10] = TPM_ALG_ID::ANY;
    pui->UnionType[10] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    pui->UnionSelector[11] = TPM_ALG_ID::_NULL;
    pui->UnionType[11] = TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID;
    
    // ======== TPMU_SIGNATURE ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SIGNATURE_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SIGNATURE";
    pui->UnionSelector.resize(9);
    pui->UnionType.resize(9);
    pui->UnionSelector[0] = TPM_ALG_ID::RSASSA;
    pui->UnionType[0] = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::RSAPSS;
    pui->UnionType[1] = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::ECDSA;
    pui->UnionType[2] = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::ECDAA;
    pui->UnionType[3] = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::SM2;
    pui->UnionType[4] = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    pui->UnionSelector[5] = TPM_ALG_ID::ECSCHNORR;
    pui->UnionType[5] = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    pui->UnionSelector[6] = TPM_ALG_ID::HMAC;
    pui->UnionType[6] = TpmTypeId::TPMT_HA_ID;
    pui->UnionSelector[7] = TPM_ALG_ID::ANY;
    pui->UnionType[7] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    pui->UnionSelector[8] = TPM_ALG_ID::_NULL;
    pui->UnionType[8] = TpmTypeId::TPMS_NULL_SIGNATURE_ID;
    
    // ======== TPMU_ENCRYPTED_SECRET ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_ENCRYPTED_SECRET_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_ENCRYPTED_SECRET";
    pui->UnionSelector.resize(4);
    pui->UnionType.resize(4);
    pui->UnionSelector[0] = TPM_ALG_ID::ECC;
    pui->UnionType[0] = TpmTypeId::BYTE_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::RSA;
    pui->UnionType[1] = TpmTypeId::BYTE_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::SYMCIPHER;
    pui->UnionType[2] = TpmTypeId::BYTE_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::KEYEDHASH;
    pui->UnionType[3] = TpmTypeId::BYTE_ID;
    
    // ======== TPMU_PUBLIC_ID ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_PUBLIC_ID_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_PUBLIC_ID";
    pui->UnionSelector.resize(5);
    pui->UnionType.resize(5);
    pui->UnionSelector[0] = TPM_ALG_ID::KEYEDHASH;
    pui->UnionType[0] = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::SYMCIPHER;
    pui->UnionType[1] = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::RSA;
    pui->UnionType[2] = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::ECC;
    pui->UnionType[3] = TpmTypeId::TPMS_ECC_POINT_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ANY;
    pui->UnionType[4] = TpmTypeId::TPMS_DERIVE_ID;
    
    // ======== TPMU_PUBLIC_PARMS ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_PUBLIC_PARMS_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_PUBLIC_PARMS";
    pui->UnionSelector.resize(5);
    pui->UnionType.resize(5);
    pui->UnionSelector[0] = TPM_ALG_ID::KEYEDHASH;
    pui->UnionType[0] = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::SYMCIPHER;
    pui->UnionType[1] = TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::RSA;
    pui->UnionType[2] = TpmTypeId::TPMS_RSA_PARMS_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::ECC;
    pui->UnionType[3] = TpmTypeId::TPMS_ECC_PARMS_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ANY;
    pui->UnionType[4] = TpmTypeId::TPMS_ASYM_PARMS_ID;
    
    // ======== TPMU_SENSITIVE_COMPOSITE ========
    pui = new TpmUnionInfo();
    TypeMap[TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID] = pui;
    pui->Kind = TpmEntity::Union;
    pui->Name = "TPMU_SENSITIVE_COMPOSITE";
    pui->UnionSelector.resize(5);
    pui->UnionType.resize(5);
    pui->UnionSelector[0] = TPM_ALG_ID::RSA;
    pui->UnionType[0] = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    pui->UnionSelector[1] = TPM_ALG_ID::ECC;
    pui->UnionType[1] = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    pui->UnionSelector[2] = TPM_ALG_ID::KEYEDHASH;
    pui->UnionType[2] = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    pui->UnionSelector[3] = TPM_ALG_ID::SYMCIPHER;
    pui->UnionType[3] = TpmTypeId::TPM2B_SYM_KEY_ID;
    pui->UnionSelector[4] = TPM_ALG_ID::ANY;
    pui->UnionType[4] = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    
    
    TpmBitfieldInfo* pbi;
    
    // ======== TPMA_ALGORITHM ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_ALGORITHM_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_ALGORITHM";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "asymmetric";
    pbi->ConstNames[1] = "symmetric";
    pbi->ConstNames[2] = "hash";
    pbi->ConstNames[3] = "object";
    pbi->ConstNames[8] = "signing";
    pbi->ConstNames[9] = "encrypting";
    pbi->ConstNames[10] = "method";
    
    // ======== TPMA_OBJECT ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_OBJECT_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_OBJECT";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "Reserved";
    pbi->ConstNames[1] = "fixedTPM";
    pbi->ConstNames[2] = "stClear";
    pbi->ConstNames[3] = "Reserved";
    pbi->ConstNames[4] = "fixedParent";
    pbi->ConstNames[5] = "sensitiveDataOrigin";
    pbi->ConstNames[6] = "userWithAuth";
    pbi->ConstNames[7] = "adminWithPolicy";
    pbi->ConstNames[10] = "noDA";
    pbi->ConstNames[11] = "encryptedDuplication";
    pbi->ConstNames[16] = "restricted";
    pbi->ConstNames[17] = "decrypt";
    pbi->ConstNames[18] = "sign";
    pbi->ConstNames[18] = "encrypt";
    pbi->ConstNames[19] = "x509sign";
    
    // ======== TPMA_SESSION ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_SESSION_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_SESSION";
    pbi->Size = sizeof(BYTE);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "continueSession";
    pbi->ConstNames[1] = "auditExclusive";
    pbi->ConstNames[2] = "auditReset";
    pbi->ConstNames[5] = "decrypt";
    pbi->ConstNames[6] = "encrypt";
    pbi->ConstNames[7] = "audit";
    
    // ======== TPMA_LOCALITY ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_LOCALITY_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_LOCALITY";
    pbi->Size = sizeof(BYTE);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "LOC_ZERO";
    pbi->ConstNames[1] = "LOC_ONE";
    pbi->ConstNames[2] = "LOC_TWO";
    pbi->ConstNames[3] = "LOC_THREE";
    pbi->ConstNames[4] = "LOC_FOUR";
    
    // ======== TPMA_PERMANENT ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_PERMANENT_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_PERMANENT";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "ownerAuthSet";
    pbi->ConstNames[1] = "endorsementAuthSet";
    pbi->ConstNames[2] = "lockoutAuthSet";
    pbi->ConstNames[8] = "disableClear";
    pbi->ConstNames[9] = "inLockout";
    pbi->ConstNames[10] = "tpmGeneratedEPS";
    
    // ======== TPMA_STARTUP_CLEAR ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_STARTUP_CLEAR_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_STARTUP_CLEAR";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "phEnable";
    pbi->ConstNames[1] = "shEnable";
    pbi->ConstNames[2] = "ehEnable";
    pbi->ConstNames[3] = "phEnableNV";
    pbi->ConstNames[31] = "orderly";
    
    // ======== TPMA_MEMORY ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_MEMORY_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_MEMORY";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "sharedRAM";
    pbi->ConstNames[1] = "sharedNV";
    pbi->ConstNames[2] = "objectCopiedToRam";
    
    // ======== TPMA_CC ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_CC_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_CC";
    pbi->Size = sizeof(TPM_CC);
    pbi->ConstNames.clear();
    pbi->ConstNames[22] = "nv";
    pbi->ConstNames[23] = "extensive";
    pbi->ConstNames[24] = "flushed";
    pbi->ConstNames[28] = "rHandle";
    pbi->ConstNames[29] = "V";
    
    // ======== TPMA_MODES ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_MODES_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_MODES";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "FIPS_140_2";
    
    // ======== TPMA_X509_KEY_USAGE ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_X509_KEY_USAGE_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_X509_KEY_USAGE";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[23] = "decipherOnly";
    pbi->ConstNames[24] = "encipherOnly";
    pbi->ConstNames[25] = "cRLSign";
    pbi->ConstNames[26] = "keyCertSign";
    pbi->ConstNames[27] = "keyAgreement";
    pbi->ConstNames[28] = "dataEncipherment";
    pbi->ConstNames[29] = "keyEncipherment";
    pbi->ConstNames[30] = "nonrepudiation";
    pbi->ConstNames[30] = "contentCommitment";
    pbi->ConstNames[31] = "digitalSignature";
    
    // ======== TPMA_ACT ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_ACT_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_ACT";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "signaled";
    pbi->ConstNames[1] = "preserveSignaled";
    
    // ======== TPM_NV_INDEX ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPM_NV_INDEX_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPM_NV_INDEX";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    
    // ======== TPMA_NV ========
    pbi = new TpmBitfieldInfo();
    TypeMap[TpmTypeId::TPMA_NV_ID] = pbi;
    pbi->Kind = TpmEntity::Bitfield;
    pbi->Name = "TPMA_NV";
    pbi->Size = sizeof(UINT32);
    pbi->ConstNames.clear();
    pbi->ConstNames[0] = "PPWRITE";
    pbi->ConstNames[1] = "OWNERWRITE";
    pbi->ConstNames[2] = "AUTHWRITE";
    pbi->ConstNames[3] = "POLICYWRITE";
    pbi->ConstNames[10] = "POLICY_DELETE";
    pbi->ConstNames[11] = "WRITELOCKED";
    pbi->ConstNames[12] = "WRITEALL";
    pbi->ConstNames[13] = "WRITEDEFINE";
    pbi->ConstNames[14] = "WRITE_STCLEAR";
    pbi->ConstNames[15] = "GLOBALLOCK";
    pbi->ConstNames[16] = "PPREAD";
    pbi->ConstNames[17] = "OWNERREAD";
    pbi->ConstNames[18] = "AUTHREAD";
    pbi->ConstNames[19] = "POLICYREAD";
    pbi->ConstNames[25] = "NO_DA";
    pbi->ConstNames[26] = "ORDERLY";
    pbi->ConstNames[27] = "CLEAR_STCLEAR";
    pbi->ConstNames[28] = "READLOCKED";
    pbi->ConstNames[29] = "WRITTEN";
    pbi->ConstNames[30] = "PLATFORMCREATE";
    pbi->ConstNames[31] = "READ_STCLEAR";
    
    TpmEnumInfo* pei;
    
    
    // ======== NameUnionTagValues ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::NameUnionTagValues_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "NameUnionTagValues";
    pei->Size = sizeof(BYTE);
    pei->ConstNames.clear();
    pei->ConstNames[0] = "TAG_TPMU_NAME_TPMT_HA";
    pei->ConstNames[1] = "TAG_TPMU_NAME_TPM_HANDLE";
    
    // ======== TPM_ALG_ID ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_ALG_ID_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_ALG_ID";
    pei->Size = sizeof(UINT16);
    pei->ConstNames.clear();
    pei->ConstNames[0x0000] = "_ERROR";
    pei->ConstNames[0x0001] = "FIRST";
    pei->ConstNames[0x0001] = "RSA";
    pei->ConstNames[0x0003] = "TDES";
    pei->ConstNames[0x0004] = "SHA";
    pei->ConstNames[0x0004] = "SHA1";
    pei->ConstNames[0x0005] = "HMAC";
    pei->ConstNames[0x0006] = "AES";
    pei->ConstNames[0x0007] = "MGF1";
    pei->ConstNames[0x0008] = "KEYEDHASH";
    pei->ConstNames[0x000A] = "XOR";
    pei->ConstNames[0x000B] = "SHA256";
    pei->ConstNames[0x000C] = "SHA384";
    pei->ConstNames[0x000D] = "SHA512";
    pei->ConstNames[0x0010] = "_NULL";
    pei->ConstNames[0x0012] = "SM3_256";
    pei->ConstNames[0x0013] = "SM4";
    pei->ConstNames[0x0014] = "RSASSA";
    pei->ConstNames[0x0015] = "RSAES";
    pei->ConstNames[0x0016] = "RSAPSS";
    pei->ConstNames[0x0017] = "OAEP";
    pei->ConstNames[0x0018] = "ECDSA";
    pei->ConstNames[0x0019] = "ECDH";
    pei->ConstNames[0x001A] = "ECDAA";
    pei->ConstNames[0x001B] = "SM2";
    pei->ConstNames[0x001C] = "ECSCHNORR";
    pei->ConstNames[0x001D] = "ECMQV";
    pei->ConstNames[0x0020] = "KDF1_SP800_56A";
    pei->ConstNames[0x0021] = "KDF2";
    pei->ConstNames[0x0022] = "KDF1_SP800_108";
    pei->ConstNames[0x0023] = "ECC";
    pei->ConstNames[0x0025] = "SYMCIPHER";
    pei->ConstNames[0x0026] = "CAMELLIA";
    pei->ConstNames[0x0027] = "SHA3_256";
    pei->ConstNames[0x0028] = "SHA3_384";
    pei->ConstNames[0x0029] = "SHA3_512";
    pei->ConstNames[0x003F] = "CMAC";
    pei->ConstNames[0x0040] = "CTR";
    pei->ConstNames[0x0041] = "OFB";
    pei->ConstNames[0x0042] = "CBC";
    pei->ConstNames[0x0043] = "CFB";
    pei->ConstNames[0x0044] = "ECB";
    pei->ConstNames[0x0044] = "LAST";
    pei->ConstNames[0x7FFF] = "ANY";
    pei->ConstNames[0x7FFE] = "ANY2";
    
    // ======== TPM_ECC_CURVE ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_ECC_CURVE_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_ECC_CURVE";
    pei->Size = sizeof(UINT16);
    pei->ConstNames.clear();
    pei->ConstNames[0x0000] = "NONE";
    pei->ConstNames[0x0001] = "NIST_P192";
    pei->ConstNames[0x0002] = "NIST_P224";
    pei->ConstNames[0x0003] = "NIST_P256";
    pei->ConstNames[0x0004] = "NIST_P384";
    pei->ConstNames[0x0005] = "NIST_P521";
    pei->ConstNames[0x0010] = "BN_P256";
    pei->ConstNames[0x0011] = "BN_P638";
    pei->ConstNames[0x0020] = "SM2_P256";
    pei->ConstNames[0x0021] = "TEST_P192";
    
    // ======== SHA1 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SHA1_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SHA1";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[20] = "DIGEST_SIZE";
    pei->ConstNames[64] = "BLOCK_SIZE";
    
    // ======== SHA256 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SHA256_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SHA256";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[32] = "DIGEST_SIZE";
    pei->ConstNames[64] = "BLOCK_SIZE";
    
    // ======== SHA384 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SHA384_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SHA384";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[48] = "DIGEST_SIZE";
    pei->ConstNames[128] = "BLOCK_SIZE";
    
    // ======== SHA512 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SHA512_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SHA512";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[64] = "DIGEST_SIZE";
    pei->ConstNames[128] = "BLOCK_SIZE";
    
    // ======== SM3_256 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SM3_256_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SM3_256";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[32] = "DIGEST_SIZE";
    pei->ConstNames[64] = "BLOCK_SIZE";
    
    // ======== SHA3_256 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SHA3_256_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SHA3_256";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[32] = "DIGEST_SIZE";
    pei->ConstNames[136] = "BLOCK_SIZE";
    
    // ======== SHA3_384 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SHA3_384_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SHA3_384";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[48] = "DIGEST_SIZE";
    pei->ConstNames[104] = "BLOCK_SIZE";
    
    // ======== SHA3_512 ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::SHA3_512_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "SHA3_512";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[64] = "DIGEST_SIZE";
    pei->ConstNames[72] = "BLOCK_SIZE";
    
    // ======== ImplementationConstants ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::ImplementationConstants_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "ImplementationConstants";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[1] = "Ossl";
    pei->ConstNames[2] = "Ltc";
    pei->ConstNames[3] = "Msbn";
    pei->ConstNames[4] = "Symcrypt";
    pei->ConstNames[3] = "HASH_COUNT";
    pei->ConstNames[256] = "MAX_SYM_KEY_BITS";
    pei->ConstNames[((ImplementationConstants::MAX_SYM_KEY_BITS + 7) / 8)] = "MAX_SYM_KEY_BYTES";
    pei->ConstNames[16] = "MAX_SYM_BLOCK_SIZE";
    pei->ConstNames[TPM_CC::LAST] = "MAX_CAP_CC";
    pei->ConstNames[256] = "MAX_RSA_KEY_BYTES";
    pei->ConstNames[32] = "MAX_AES_KEY_BYTES";
    pei->ConstNames[48] = "MAX_ECC_KEY_BYTES";
    pei->ConstNames[32] = "LABEL_MAX_BUFFER";
    pei->ConstNames[sizeof(UINT32)] = "_TPM_CAP_SIZE";
    pei->ConstNames[(Implementation::MAX_CAP_BUFFER-ImplementationConstants::_TPM_CAP_SIZE-sizeof(UINT32))] = "MAX_CAP_DATA";
    pei->ConstNames[(ImplementationConstants::MAX_CAP_DATA / 0x6 /*sizeof(TPMS_ALG_PROPERTY)*/)] = "MAX_CAP_ALGS";
    pei->ConstNames[(ImplementationConstants::MAX_CAP_DATA / 0x4 /*sizeof(TPM_HANDLE)*/)] = "MAX_CAP_HANDLES";
    pei->ConstNames[(ImplementationConstants::MAX_CAP_DATA / 0x8 /*sizeof(TPMS_TAGGED_PROPERTY)*/)] = "MAX_TPM_PROPERTIES";
    pei->ConstNames[(ImplementationConstants::MAX_CAP_DATA / 0x5 /*sizeof(TPMS_TAGGED_PCR_SELECT)*/)] = "MAX_PCR_PROPERTIES";
    pei->ConstNames[(ImplementationConstants::MAX_CAP_DATA / sizeof(TPM_ECC_CURVE))] = "MAX_ECC_CURVES";
    pei->ConstNames[(ImplementationConstants::MAX_CAP_DATA / 0x46 /*sizeof(TPMS_TAGGED_POLICY)*/)] = "MAX_TAGGED_POLICIES";
    pei->ConstNames[(ImplementationConstants::MAX_CAP_DATA / 0x8 /*sizeof(TPMS_AC_OUTPUT)*/)] = "MAX_AC_CAPABILITIES";
    pei->ConstNames[ImplementationConstants::MAX_CAP_DATA / 0xC /*sizeof(TPMS_ACT_DATA)*/] = "MAX_ACT_DATA";
    
    // ======== Logic ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::Logic_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "Logic";
    pei->Size = sizeof(BYTE);
    pei->ConstNames.clear();
    pei->ConstNames[1] = "TRUE";
    pei->ConstNames[0] = "FALSE";
    pei->ConstNames[1] = "YES";
    pei->ConstNames[0] = "NO";
    pei->ConstNames[1] = "SET";
    pei->ConstNames[0] = "CLEAR";
    
    // ======== TPM_SPEC ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_SPEC_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_SPEC";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x322E3000] = "FAMILY";
    pei->ConstNames[00] = "LEVEL";
    pei->ConstNames[161] = "VERSION";
    pei->ConstNames[2019] = "YEAR";
    pei->ConstNames[360] = "DAY_OF_YEAR";
    
    // ======== TPM_GENERATED ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_GENERATED_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_GENERATED";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0xff544347] = "VALUE";
    
    // ======== TPM_CC ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_CC_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_CC";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x0000011F] = "FIRST";
    pei->ConstNames[0x0000011F] = "NV_UndefineSpaceSpecial";
    pei->ConstNames[0x00000120] = "EvictControl";
    pei->ConstNames[0x00000121] = "HierarchyControl";
    pei->ConstNames[0x00000122] = "NV_UndefineSpace";
    pei->ConstNames[0x00000124] = "ChangeEPS";
    pei->ConstNames[0x00000125] = "ChangePPS";
    pei->ConstNames[0x00000126] = "Clear";
    pei->ConstNames[0x00000127] = "ClearControl";
    pei->ConstNames[0x00000128] = "ClockSet";
    pei->ConstNames[0x00000129] = "HierarchyChangeAuth";
    pei->ConstNames[0x0000012A] = "NV_DefineSpace";
    pei->ConstNames[0x0000012B] = "PCR_Allocate";
    pei->ConstNames[0x0000012C] = "PCR_SetAuthPolicy";
    pei->ConstNames[0x0000012D] = "PP_Commands";
    pei->ConstNames[0x0000012E] = "SetPrimaryPolicy";
    pei->ConstNames[0x0000012F] = "FieldUpgradeStart";
    pei->ConstNames[0x00000130] = "ClockRateAdjust";
    pei->ConstNames[0x00000131] = "CreatePrimary";
    pei->ConstNames[0x00000132] = "NV_GlobalWriteLock";
    pei->ConstNames[0x00000133] = "GetCommandAuditDigest";
    pei->ConstNames[0x00000134] = "NV_Increment";
    pei->ConstNames[0x00000135] = "NV_SetBits";
    pei->ConstNames[0x00000136] = "NV_Extend";
    pei->ConstNames[0x00000137] = "NV_Write";
    pei->ConstNames[0x00000138] = "NV_WriteLock";
    pei->ConstNames[0x00000139] = "DictionaryAttackLockReset";
    pei->ConstNames[0x0000013A] = "DictionaryAttackParameters";
    pei->ConstNames[0x0000013B] = "NV_ChangeAuth";
    pei->ConstNames[0x0000013C] = "PCR_Event";
    pei->ConstNames[0x0000013D] = "PCR_Reset";
    pei->ConstNames[0x0000013E] = "SequenceComplete";
    pei->ConstNames[0x0000013F] = "SetAlgorithmSet";
    pei->ConstNames[0x00000140] = "SetCommandCodeAuditStatus";
    pei->ConstNames[0x00000141] = "FieldUpgradeData";
    pei->ConstNames[0x00000142] = "IncrementalSelfTest";
    pei->ConstNames[0x00000143] = "SelfTest";
    pei->ConstNames[0x00000144] = "Startup";
    pei->ConstNames[0x00000145] = "Shutdown";
    pei->ConstNames[0x00000146] = "StirRandom";
    pei->ConstNames[0x00000147] = "ActivateCredential";
    pei->ConstNames[0x00000148] = "Certify";
    pei->ConstNames[0x00000149] = "PolicyNV";
    pei->ConstNames[0x0000014A] = "CertifyCreation";
    pei->ConstNames[0x0000014B] = "Duplicate";
    pei->ConstNames[0x0000014C] = "GetTime";
    pei->ConstNames[0x0000014D] = "GetSessionAuditDigest";
    pei->ConstNames[0x0000014E] = "NV_Read";
    pei->ConstNames[0x0000014F] = "NV_ReadLock";
    pei->ConstNames[0x00000150] = "ObjectChangeAuth";
    pei->ConstNames[0x00000151] = "PolicySecret";
    pei->ConstNames[0x00000152] = "Rewrap";
    pei->ConstNames[0x00000153] = "Create";
    pei->ConstNames[0x00000154] = "ECDH_ZGen";
    pei->ConstNames[0x00000155] = "HMAC";
    pei->ConstNames[0x00000155] = "MAC";
    pei->ConstNames[0x00000156] = "Import";
    pei->ConstNames[0x00000157] = "Load";
    pei->ConstNames[0x00000158] = "Quote";
    pei->ConstNames[0x00000159] = "RSA_Decrypt";
    pei->ConstNames[0x0000015B] = "HMAC_Start";
    pei->ConstNames[0x0000015B] = "MAC_Start";
    pei->ConstNames[0x0000015C] = "SequenceUpdate";
    pei->ConstNames[0x0000015D] = "Sign";
    pei->ConstNames[0x0000015E] = "Unseal";
    pei->ConstNames[0x00000160] = "PolicySigned";
    pei->ConstNames[0x00000161] = "ContextLoad";
    pei->ConstNames[0x00000162] = "ContextSave";
    pei->ConstNames[0x00000163] = "ECDH_KeyGen";
    pei->ConstNames[0x00000164] = "EncryptDecrypt";
    pei->ConstNames[0x00000165] = "FlushContext";
    pei->ConstNames[0x00000167] = "LoadExternal";
    pei->ConstNames[0x00000168] = "MakeCredential";
    pei->ConstNames[0x00000169] = "NV_ReadPublic";
    pei->ConstNames[0x0000016A] = "PolicyAuthorize";
    pei->ConstNames[0x0000016B] = "PolicyAuthValue";
    pei->ConstNames[0x0000016C] = "PolicyCommandCode";
    pei->ConstNames[0x0000016D] = "PolicyCounterTimer";
    pei->ConstNames[0x0000016E] = "PolicyCpHash";
    pei->ConstNames[0x0000016F] = "PolicyLocality";
    pei->ConstNames[0x00000170] = "PolicyNameHash";
    pei->ConstNames[0x00000171] = "PolicyOR";
    pei->ConstNames[0x00000172] = "PolicyTicket";
    pei->ConstNames[0x00000173] = "ReadPublic";
    pei->ConstNames[0x00000174] = "RSA_Encrypt";
    pei->ConstNames[0x00000176] = "StartAuthSession";
    pei->ConstNames[0x00000177] = "VerifySignature";
    pei->ConstNames[0x00000178] = "ECC_Parameters";
    pei->ConstNames[0x00000179] = "FirmwareRead";
    pei->ConstNames[0x0000017A] = "GetCapability";
    pei->ConstNames[0x0000017B] = "GetRandom";
    pei->ConstNames[0x0000017C] = "GetTestResult";
    pei->ConstNames[0x0000017D] = "Hash";
    pei->ConstNames[0x0000017E] = "PCR_Read";
    pei->ConstNames[0x0000017F] = "PolicyPCR";
    pei->ConstNames[0x00000180] = "PolicyRestart";
    pei->ConstNames[0x00000181] = "ReadClock";
    pei->ConstNames[0x00000182] = "PCR_Extend";
    pei->ConstNames[0x00000183] = "PCR_SetAuthValue";
    pei->ConstNames[0x00000184] = "NV_Certify";
    pei->ConstNames[0x00000185] = "EventSequenceComplete";
    pei->ConstNames[0x00000186] = "HashSequenceStart";
    pei->ConstNames[0x00000187] = "PolicyPhysicalPresence";
    pei->ConstNames[0x00000188] = "PolicyDuplicationSelect";
    pei->ConstNames[0x00000189] = "PolicyGetDigest";
    pei->ConstNames[0x0000018A] = "TestParms";
    pei->ConstNames[0x0000018B] = "Commit";
    pei->ConstNames[0x0000018C] = "PolicyPassword";
    pei->ConstNames[0x0000018D] = "ZGen_2Phase";
    pei->ConstNames[0x0000018E] = "EC_Ephemeral";
    pei->ConstNames[0x0000018F] = "PolicyNvWritten";
    pei->ConstNames[0x00000190] = "PolicyTemplate";
    pei->ConstNames[0x00000191] = "CreateLoaded";
    pei->ConstNames[0x00000192] = "PolicyAuthorizeNV";
    pei->ConstNames[0x00000193] = "EncryptDecrypt2";
    pei->ConstNames[0x00000194] = "AC_GetCapability";
    pei->ConstNames[0x00000195] = "AC_Send";
    pei->ConstNames[0x00000196] = "Policy_AC_SendSelect";
    pei->ConstNames[0x00000197] = "CertifyX509";
    pei->ConstNames[0x00000198] = "ACT_SetTimeout";
    pei->ConstNames[0x00000199] = "ECC_Encrypt";
    pei->ConstNames[0x0000019A] = "ECC_Decrypt";
    pei->ConstNames[0x0000019A] = "LAST";
    pei->ConstNames[0x20000000] = "CC_VEND";
    pei->ConstNames[TPM_CC::CC_VEND+0x0000] = "Vendor_TCG_Test";
    
    // ======== TPM_RC ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_RC_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_RC";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x000] = "SUCCESS";
    pei->ConstNames[0x01E] = "BAD_TAG";
    pei->ConstNames[0x100] = "RC_VER1";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x000] = "INITIALIZE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x001] = "FAILURE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x003] = "SEQUENCE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x00B] = "PRIVATE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x019] = "HMAC";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x020] = "DISABLED";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x021] = "EXCLUSIVE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x024] = "AUTH_TYPE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x025] = "AUTH_MISSING";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x026] = "POLICY";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x027] = "PCR";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x028] = "PCR_CHANGED";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x02D] = "UPGRADE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x02E] = "TOO_MANY_CONTEXTS";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x02F] = "AUTH_UNAVAILABLE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x030] = "REBOOT";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x031] = "UNBALANCED";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x042] = "COMMAND_SIZE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x043] = "COMMAND_CODE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x044] = "AUTHSIZE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x045] = "AUTH_CONTEXT";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x046] = "NV_RANGE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x047] = "NV_SIZE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x048] = "NV_LOCKED";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x049] = "NV_AUTHORIZATION";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x04A] = "NV_UNINITIALIZED";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x04B] = "NV_SPACE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x04C] = "NV_DEFINED";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x050] = "BAD_CONTEXT";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x051] = "CPHASH";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x052] = "PARENT";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x053] = "NEEDS_TEST";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x054] = "NO_RESULT";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x055] = "SENSITIVE";
    pei->ConstNames[TPM_RC::RC_VER1 + 0x07F] = "RC_MAX_FM0";
    pei->ConstNames[0x080] = "RC_FMT1";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x001] = "ASYMMETRIC";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x002] = "ATTRIBUTES";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x003] = "HASH";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x004] = "VALUE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x005] = "HIERARCHY";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x007] = "KEY_SIZE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x008] = "MGF";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x009] = "MODE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x00A] = "TYPE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x00B] = "HANDLE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x00C] = "KDF";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x00D] = "RANGE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x00E] = "AUTH_FAIL";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x00F] = "NONCE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x010] = "PP";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x012] = "SCHEME";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x015] = "SIZE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x016] = "SYMMETRIC";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x017] = "TAG";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x018] = "SELECTOR";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x01A] = "INSUFFICIENT";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x01B] = "SIGNATURE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x01C] = "KEY";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x01D] = "POLICY_FAIL";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x01F] = "INTEGRITY";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x020] = "TICKET";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x021] = "RESERVED_BITS";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x022] = "BAD_AUTH";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x023] = "EXPIRED";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x024] = "POLICY_CC";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x025] = "BINDING";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x026] = "CURVE";
    pei->ConstNames[TPM_RC::RC_FMT1 + 0x027] = "ECC_POINT";
    pei->ConstNames[0x900] = "RC_WARN";
    pei->ConstNames[TPM_RC::RC_WARN + 0x001] = "CONTEXT_GAP";
    pei->ConstNames[TPM_RC::RC_WARN + 0x002] = "OBJECT_MEMORY";
    pei->ConstNames[TPM_RC::RC_WARN + 0x003] = "SESSION_MEMORY";
    pei->ConstNames[TPM_RC::RC_WARN + 0x004] = "MEMORY";
    pei->ConstNames[TPM_RC::RC_WARN + 0x005] = "SESSION_HANDLES";
    pei->ConstNames[TPM_RC::RC_WARN + 0x006] = "OBJECT_HANDLES";
    pei->ConstNames[TPM_RC::RC_WARN + 0x007] = "LOCALITY";
    pei->ConstNames[TPM_RC::RC_WARN + 0x008] = "YIELDED";
    pei->ConstNames[TPM_RC::RC_WARN + 0x009] = "CANCELED";
    pei->ConstNames[TPM_RC::RC_WARN + 0x00A] = "TESTING";
    pei->ConstNames[TPM_RC::RC_WARN + 0x010] = "REFERENCE_H0";
    pei->ConstNames[TPM_RC::RC_WARN + 0x011] = "REFERENCE_H1";
    pei->ConstNames[TPM_RC::RC_WARN + 0x012] = "REFERENCE_H2";
    pei->ConstNames[TPM_RC::RC_WARN + 0x013] = "REFERENCE_H3";
    pei->ConstNames[TPM_RC::RC_WARN + 0x014] = "REFERENCE_H4";
    pei->ConstNames[TPM_RC::RC_WARN + 0x015] = "REFERENCE_H5";
    pei->ConstNames[TPM_RC::RC_WARN + 0x016] = "REFERENCE_H6";
    pei->ConstNames[TPM_RC::RC_WARN + 0x018] = "REFERENCE_S0";
    pei->ConstNames[TPM_RC::RC_WARN + 0x019] = "REFERENCE_S1";
    pei->ConstNames[TPM_RC::RC_WARN + 0x01A] = "REFERENCE_S2";
    pei->ConstNames[TPM_RC::RC_WARN + 0x01B] = "REFERENCE_S3";
    pei->ConstNames[TPM_RC::RC_WARN + 0x01C] = "REFERENCE_S4";
    pei->ConstNames[TPM_RC::RC_WARN + 0x01D] = "REFERENCE_S5";
    pei->ConstNames[TPM_RC::RC_WARN + 0x01E] = "REFERENCE_S6";
    pei->ConstNames[TPM_RC::RC_WARN + 0x020] = "NV_RATE";
    pei->ConstNames[TPM_RC::RC_WARN + 0x021] = "LOCKOUT";
    pei->ConstNames[TPM_RC::RC_WARN + 0x022] = "RETRY";
    pei->ConstNames[TPM_RC::RC_WARN + 0x023] = "NV_UNAVAILABLE";
    pei->ConstNames[TPM_RC::RC_WARN + 0x7F] = "NOT_USED";
    pei->ConstNames[0x040] = "P";
    pei->ConstNames[0x800] = "S";
    pei->ConstNames[0x100] = "_1";
    pei->ConstNames[0x200] = "_2";
    pei->ConstNames[0x300] = "_3";
    pei->ConstNames[0x400] = "_4";
    pei->ConstNames[0x500] = "_5";
    pei->ConstNames[0x600] = "_6";
    pei->ConstNames[0x700] = "_7";
    pei->ConstNames[0x800] = "_8";
    pei->ConstNames[0x900] = "_9";
    pei->ConstNames[0xA00] = "A";
    pei->ConstNames[0xB00] = "B";
    pei->ConstNames[0xC00] = "C";
    pei->ConstNames[0xD00] = "D";
    pei->ConstNames[0xE00] = "E";
    pei->ConstNames[0xF00] = "F";
    pei->ConstNames[0xF00] = "N_MASK";
    pei->ConstNames[0x40280001] = "TSS_TCP_BAD_HANDSHAKE_RESP";
    pei->ConstNames[0x40280002] = "TSS_TCP_SERVER_TOO_OLD";
    pei->ConstNames[0x40280003] = "TSS_TCP_BAD_ACK";
    pei->ConstNames[0x40280004] = "TSS_TCP_BAD_RESP_LEN";
    pei->ConstNames[0x40280005] = "TSS_TCP_UNEXPECTED_STARTUP_RESP";
    pei->ConstNames[0x40280006] = "TSS_TCP_INVALID_SIZE_TAG";
    pei->ConstNames[0x40280007] = "TSS_TCP_DISCONNECTED";
    pei->ConstNames[0x40280010] = "TSS_DISPATCH_FAILED";
    pei->ConstNames[0x40280011] = "TSS_SEND_OP_FAILED";
    pei->ConstNames[0x40280021] = "TSS_RESP_BUF_TOO_SHORT";
    pei->ConstNames[0x40280022] = "TSS_RESP_BUF_INVALID_SESSION_TAG";
    pei->ConstNames[0x80280400] = "TBS_COMMAND_BLOCKED";
    pei->ConstNames[0x80280401] = "TBS_INVALID_HANDLE";
    pei->ConstNames[0x80280402] = "TBS_DUPLICATE_V_HANDLE";
    pei->ConstNames[0x80280403] = "TBS_EMBEDDED_COMMAND_BLOCKED";
    pei->ConstNames[0x80280404] = "TBS_EMBEDDED_COMMAND_UNSUPPORTED";
    pei->ConstNames[0x80284000] = "TBS_UNKNOWN_ERROR";
    pei->ConstNames[0x80284001] = "TBS_INTERNAL_ERROR";
    pei->ConstNames[0x80284002] = "TBS_BAD_PARAMETER";
    pei->ConstNames[0x80284003] = "TBS_INVALID_OUTPUT_POINTER";
    pei->ConstNames[0x80284004] = "TBS_INVALID_CONTEXT";
    pei->ConstNames[0x80284005] = "TBS_INSUFFICIENT_BUFFER";
    pei->ConstNames[0x80284006] = "TBS_IO_ERROR";
    pei->ConstNames[0x80284007] = "TBS_INVALID_CONTEXT_PARAM";
    pei->ConstNames[0x80284008] = "TBS_SERVICE_NOT_RUNNING";
    pei->ConstNames[0x80284009] = "TBS_TOO_MANY_CONTEXTS";
    pei->ConstNames[0x8028400A] = "TBS_TOO_MANY_RESOURCES";
    pei->ConstNames[0x8028400B] = "TBS_SERVICE_START_PENDING";
    pei->ConstNames[0x8028400C] = "TBS_PPI_NOT_SUPPORTED";
    pei->ConstNames[0x8028400D] = "TBS_COMMAND_CANCELED";
    pei->ConstNames[0x8028400E] = "TBS_BUFFER_TOO_LARGE";
    pei->ConstNames[0x8028400F] = "TBS_NOT_FOUND";
    pei->ConstNames[0x80284010] = "TBS_SERVICE_DISABLED";
    pei->ConstNames[0x80284012] = "TBS_ACCESS_DENIED";
    pei->ConstNames[0x80284014] = "TBS_PPI_FUNCTION_NOT_SUPPORTED";
    pei->ConstNames[0x80284015] = "TBS_OWNER_AUTH_NOT_FOUND";
    
    // ======== TPM_CLOCK_ADJUST ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_CLOCK_ADJUST_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_CLOCK_ADJUST";
    pei->Size = sizeof(char);
    pei->ConstNames.clear();
    pei->ConstNames[-3] = "COARSE_SLOWER";
    pei->ConstNames[-2] = "MEDIUM_SLOWER";
    pei->ConstNames[-1] = "FINE_SLOWER";
    pei->ConstNames[0] = "NO_CHANGE";
    pei->ConstNames[1] = "FINE_FASTER";
    pei->ConstNames[2] = "MEDIUM_FASTER";
    pei->ConstNames[3] = "COARSE_FASTER";
    
    // ======== TPM_EO ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_EO_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_EO";
    pei->Size = sizeof(UINT16);
    pei->ConstNames.clear();
    pei->ConstNames[0x0000] = "EQ";
    pei->ConstNames[0x0001] = "NEQ";
    pei->ConstNames[0x0002] = "SIGNED_GT";
    pei->ConstNames[0x0003] = "UNSIGNED_GT";
    pei->ConstNames[0x0004] = "SIGNED_LT";
    pei->ConstNames[0x0005] = "UNSIGNED_LT";
    pei->ConstNames[0x0006] = "SIGNED_GE";
    pei->ConstNames[0x0007] = "UNSIGNED_GE";
    pei->ConstNames[0x0008] = "SIGNED_LE";
    pei->ConstNames[0x0009] = "UNSIGNED_LE";
    pei->ConstNames[0x000A] = "BITSET";
    pei->ConstNames[0x000B] = "BITCLEAR";
    
    // ======== TPM_ST ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_ST_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_ST";
    pei->Size = sizeof(UINT16);
    pei->ConstNames.clear();
    pei->ConstNames[0x00C4] = "RSP_COMMAND";
    pei->ConstNames[0X8000] = "_NULL";
    pei->ConstNames[0x8001] = "NO_SESSIONS";
    pei->ConstNames[0x8002] = "SESSIONS";
    pei->ConstNames[0x8014] = "ATTEST_NV";
    pei->ConstNames[0x8015] = "ATTEST_COMMAND_AUDIT";
    pei->ConstNames[0x8016] = "ATTEST_SESSION_AUDIT";
    pei->ConstNames[0x8017] = "ATTEST_CERTIFY";
    pei->ConstNames[0x8018] = "ATTEST_QUOTE";
    pei->ConstNames[0x8019] = "ATTEST_TIME";
    pei->ConstNames[0x801A] = "ATTEST_CREATION";
    pei->ConstNames[0x801C] = "ATTEST_NV_DIGEST";
    pei->ConstNames[0x8021] = "CREATION";
    pei->ConstNames[0x8022] = "VERIFIED";
    pei->ConstNames[0x8023] = "AUTH_SECRET";
    pei->ConstNames[0x8024] = "HASHCHECK";
    pei->ConstNames[0x8025] = "AUTH_SIGNED";
    pei->ConstNames[0x8029] = "FU_MANIFEST";
    
    // ======== TPM_SU ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_SU_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_SU";
    pei->Size = sizeof(UINT16);
    pei->ConstNames.clear();
    pei->ConstNames[0x0000] = "CLEAR";
    pei->ConstNames[0x0001] = "STATE";
    
    // ======== TPM_SE ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_SE_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_SE";
    pei->Size = sizeof(BYTE);
    pei->ConstNames.clear();
    pei->ConstNames[0x00] = "HMAC";
    pei->ConstNames[0x01] = "POLICY";
    pei->ConstNames[0x03] = "TRIAL";
    
    // ======== TPM_CAP ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_CAP_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_CAP";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x00000000] = "FIRST";
    pei->ConstNames[0x00000000] = "ALGS";
    pei->ConstNames[0x00000001] = "HANDLES";
    pei->ConstNames[0x00000002] = "COMMANDS";
    pei->ConstNames[0x00000003] = "PP_COMMANDS";
    pei->ConstNames[0x00000004] = "AUDIT_COMMANDS";
    pei->ConstNames[0x00000005] = "PCRS";
    pei->ConstNames[0x00000006] = "TPM_PROPERTIES";
    pei->ConstNames[0x00000007] = "PCR_PROPERTIES";
    pei->ConstNames[0x00000008] = "ECC_CURVES";
    pei->ConstNames[0x00000009] = "AUTH_POLICIES";
    pei->ConstNames[0x0000000A] = "ACT";
    pei->ConstNames[0x0000000A] = "LAST";
    pei->ConstNames[0x00000100] = "VENDOR_PROPERTY";
    
    // ======== TPM_PT ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_PT_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_PT";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x00000000] = "NONE";
    pei->ConstNames[0x00000100] = "PT_GROUP";
    pei->ConstNames[TPM_PT::PT_GROUP * 1] = "PT_FIXED";
    pei->ConstNames[TPM_PT::PT_FIXED + 0] = "FAMILY_INDICATOR";
    pei->ConstNames[TPM_PT::PT_FIXED + 1] = "LEVEL";
    pei->ConstNames[TPM_PT::PT_FIXED + 2] = "REVISION";
    pei->ConstNames[TPM_PT::PT_FIXED + 3] = "DAY_OF_YEAR";
    pei->ConstNames[TPM_PT::PT_FIXED + 4] = "YEAR";
    pei->ConstNames[TPM_PT::PT_FIXED + 5] = "MANUFACTURER";
    pei->ConstNames[TPM_PT::PT_FIXED + 6] = "VENDOR_STRING_1";
    pei->ConstNames[TPM_PT::PT_FIXED + 7] = "VENDOR_STRING_2";
    pei->ConstNames[TPM_PT::PT_FIXED + 8] = "VENDOR_STRING_3";
    pei->ConstNames[TPM_PT::PT_FIXED + 9] = "VENDOR_STRING_4";
    pei->ConstNames[TPM_PT::PT_FIXED + 10] = "VENDOR_TPM_TYPE";
    pei->ConstNames[TPM_PT::PT_FIXED + 11] = "FIRMWARE_VERSION_1";
    pei->ConstNames[TPM_PT::PT_FIXED + 12] = "FIRMWARE_VERSION_2";
    pei->ConstNames[TPM_PT::PT_FIXED + 13] = "INPUT_BUFFER";
    pei->ConstNames[TPM_PT::PT_FIXED + 14] = "HR_TRANSIENT_MIN";
    pei->ConstNames[TPM_PT::PT_FIXED + 15] = "HR_PERSISTENT_MIN";
    pei->ConstNames[TPM_PT::PT_FIXED + 16] = "HR_LOADED_MIN";
    pei->ConstNames[TPM_PT::PT_FIXED + 17] = "ACTIVE_SESSIONS_MAX";
    pei->ConstNames[TPM_PT::PT_FIXED + 18] = "PCR_COUNT";
    pei->ConstNames[TPM_PT::PT_FIXED + 19] = "PCR_SELECT_MIN";
    pei->ConstNames[TPM_PT::PT_FIXED + 20] = "CONTEXT_GAP_MAX";
    pei->ConstNames[TPM_PT::PT_FIXED + 22] = "NV_COUNTERS_MAX";
    pei->ConstNames[TPM_PT::PT_FIXED + 23] = "NV_INDEX_MAX";
    pei->ConstNames[TPM_PT::PT_FIXED + 24] = "MEMORY";
    pei->ConstNames[TPM_PT::PT_FIXED + 25] = "CLOCK_UPDATE";
    pei->ConstNames[TPM_PT::PT_FIXED + 26] = "CONTEXT_HASH";
    pei->ConstNames[TPM_PT::PT_FIXED + 27] = "CONTEXT_SYM";
    pei->ConstNames[TPM_PT::PT_FIXED + 28] = "CONTEXT_SYM_SIZE";
    pei->ConstNames[TPM_PT::PT_FIXED + 29] = "ORDERLY_COUNT";
    pei->ConstNames[TPM_PT::PT_FIXED + 30] = "MAX_COMMAND_SIZE";
    pei->ConstNames[TPM_PT::PT_FIXED + 31] = "MAX_RESPONSE_SIZE";
    pei->ConstNames[TPM_PT::PT_FIXED + 32] = "MAX_DIGEST";
    pei->ConstNames[TPM_PT::PT_FIXED + 33] = "MAX_OBJECT_CONTEXT";
    pei->ConstNames[TPM_PT::PT_FIXED + 34] = "MAX_SESSION_CONTEXT";
    pei->ConstNames[TPM_PT::PT_FIXED + 35] = "PS_FAMILY_INDICATOR";
    pei->ConstNames[TPM_PT::PT_FIXED + 36] = "PS_LEVEL";
    pei->ConstNames[TPM_PT::PT_FIXED + 37] = "PS_REVISION";
    pei->ConstNames[TPM_PT::PT_FIXED + 38] = "PS_DAY_OF_YEAR";
    pei->ConstNames[TPM_PT::PT_FIXED + 39] = "PS_YEAR";
    pei->ConstNames[TPM_PT::PT_FIXED + 40] = "SPLIT_MAX";
    pei->ConstNames[TPM_PT::PT_FIXED + 41] = "TOTAL_COMMANDS";
    pei->ConstNames[TPM_PT::PT_FIXED + 42] = "LIBRARY_COMMANDS";
    pei->ConstNames[TPM_PT::PT_FIXED + 43] = "VENDOR_COMMANDS";
    pei->ConstNames[TPM_PT::PT_FIXED + 44] = "NV_BUFFER_MAX";
    pei->ConstNames[TPM_PT::PT_FIXED + 45] = "MODES";
    pei->ConstNames[TPM_PT::PT_FIXED + 46] = "MAX_CAP_BUFFER";
    pei->ConstNames[TPM_PT::PT_GROUP * 2] = "PT_VAR";
    pei->ConstNames[TPM_PT::PT_VAR + 0] = "PERMANENT";
    pei->ConstNames[TPM_PT::PT_VAR + 1] = "STARTUP_CLEAR";
    pei->ConstNames[TPM_PT::PT_VAR + 2] = "HR_NV_INDEX";
    pei->ConstNames[TPM_PT::PT_VAR + 3] = "HR_LOADED";
    pei->ConstNames[TPM_PT::PT_VAR + 4] = "HR_LOADED_AVAIL";
    pei->ConstNames[TPM_PT::PT_VAR + 5] = "HR_ACTIVE";
    pei->ConstNames[TPM_PT::PT_VAR + 6] = "HR_ACTIVE_AVAIL";
    pei->ConstNames[TPM_PT::PT_VAR + 7] = "HR_TRANSIENT_AVAIL";
    pei->ConstNames[TPM_PT::PT_VAR + 8] = "HR_PERSISTENT";
    pei->ConstNames[TPM_PT::PT_VAR + 9] = "HR_PERSISTENT_AVAIL";
    pei->ConstNames[TPM_PT::PT_VAR + 10] = "NV_COUNTERS";
    pei->ConstNames[TPM_PT::PT_VAR + 11] = "NV_COUNTERS_AVAIL";
    pei->ConstNames[TPM_PT::PT_VAR + 12] = "ALGORITHM_SET";
    pei->ConstNames[TPM_PT::PT_VAR + 13] = "LOADED_CURVES";
    pei->ConstNames[TPM_PT::PT_VAR + 14] = "LOCKOUT_COUNTER";
    pei->ConstNames[TPM_PT::PT_VAR + 15] = "MAX_AUTH_FAIL";
    pei->ConstNames[TPM_PT::PT_VAR + 16] = "LOCKOUT_INTERVAL";
    pei->ConstNames[TPM_PT::PT_VAR + 17] = "LOCKOUT_RECOVERY";
    pei->ConstNames[TPM_PT::PT_VAR + 18] = "NV_WRITE_RECOVERY";
    pei->ConstNames[TPM_PT::PT_VAR + 19] = "AUDIT_COUNTER_0";
    pei->ConstNames[TPM_PT::PT_VAR + 20] = "AUDIT_COUNTER_1";
    
    // ======== TPM_PT_PCR ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_PT_PCR_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_PT_PCR";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x00000000] = "FIRST";
    pei->ConstNames[0x00000000] = "SAVE";
    pei->ConstNames[0x00000001] = "EXTEND_L0";
    pei->ConstNames[0x00000002] = "RESET_L0";
    pei->ConstNames[0x00000003] = "EXTEND_L1";
    pei->ConstNames[0x00000004] = "RESET_L1";
    pei->ConstNames[0x00000005] = "EXTEND_L2";
    pei->ConstNames[0x00000006] = "RESET_L2";
    pei->ConstNames[0x00000007] = "EXTEND_L3";
    pei->ConstNames[0x00000008] = "RESET_L3";
    pei->ConstNames[0x00000009] = "EXTEND_L4";
    pei->ConstNames[0x0000000A] = "RESET_L4";
    pei->ConstNames[0x00000011] = "NO_INCREMENT";
    pei->ConstNames[0x00000012] = "DRTM_RESET";
    pei->ConstNames[0x00000013] = "POLICY";
    pei->ConstNames[0x00000014] = "AUTH";
    pei->ConstNames[0x00000014] = "LAST";
    
    // ======== TPM_PS ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_PS_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_PS";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x00000000] = "MAIN";
    pei->ConstNames[0x00000001] = "PC";
    pei->ConstNames[0x00000002] = "PDA";
    pei->ConstNames[0x00000003] = "CELL_PHONE";
    pei->ConstNames[0x00000004] = "SERVER";
    pei->ConstNames[0x00000005] = "PERIPHERAL";
    pei->ConstNames[0x00000006] = "TSS";
    pei->ConstNames[0x00000007] = "STORAGE";
    pei->ConstNames[0x00000008] = "AUTHENTICATION";
    pei->ConstNames[0x00000009] = "EMBEDDED";
    pei->ConstNames[0x0000000A] = "HARDCOPY";
    pei->ConstNames[0x0000000B] = "INFRASTRUCTURE";
    pei->ConstNames[0x0000000C] = "VIRTUALIZATION";
    pei->ConstNames[0x0000000D] = "TNC";
    pei->ConstNames[0x0000000E] = "MULTI_TENANT";
    pei->ConstNames[0x0000000F] = "TC";
    
    // ======== TPM_HT ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_HT_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_HT";
    pei->Size = sizeof(BYTE);
    pei->ConstNames.clear();
    pei->ConstNames[0x00] = "PCR";
    pei->ConstNames[0x01] = "NV_INDEX";
    pei->ConstNames[0x02] = "HMAC_SESSION";
    pei->ConstNames[0x02] = "LOADED_SESSION";
    pei->ConstNames[0x03] = "POLICY_SESSION";
    pei->ConstNames[0x03] = "SAVED_SESSION";
    pei->ConstNames[0x40] = "PERMANENT";
    pei->ConstNames[0x80] = "TRANSIENT";
    pei->ConstNames[0x81] = "PERSISTENT";
    pei->ConstNames[0x90] = "AC";
    
    // ======== TPM_RH ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_RH_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_RH";
    pei->Size = sizeof(TPM_HANDLE);
    pei->ConstNames.clear();
    pei->ConstNames[0x40000000] = "FIRST";
    pei->ConstNames[0x40000000] = "SRK";
    pei->ConstNames[0x40000001] = "OWNER";
    pei->ConstNames[0x40000002] = "REVOKE";
    pei->ConstNames[0x40000003] = "TRANSPORT";
    pei->ConstNames[0x40000004] = "OPERATOR";
    pei->ConstNames[0x40000005] = "ADMIN";
    pei->ConstNames[0x40000006] = "EK";
    pei->ConstNames[0x40000007] = "_NULL";
    pei->ConstNames[0x40000008] = "UNASSIGNED";
    pei->ConstNames[0x40000009] = "RS_PW";
    pei->ConstNames[0x4000000A] = "LOCKOUT";
    pei->ConstNames[0x4000000B] = "ENDORSEMENT";
    pei->ConstNames[0x4000000C] = "PLATFORM";
    pei->ConstNames[0x4000000D] = "PLATFORM_NV";
    pei->ConstNames[0x40000010] = "AUTH_00";
    pei->ConstNames[0x4000010F] = "AUTH_FF";
    pei->ConstNames[0x40000110] = "ACT_0";
    pei->ConstNames[0x4000011F] = "ACT_F";
    pei->ConstNames[0x4000011F] = "LAST";
    
    // ======== TPM_NT ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_NT_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_NT";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x0] = "ORDINARY";
    pei->ConstNames[0x1] = "COUNTER";
    pei->ConstNames[0x2] = "BITS";
    pei->ConstNames[0x4] = "EXTEND";
    pei->ConstNames[0x8] = "PIN_FAIL";
    pei->ConstNames[0x9] = "PIN_PASS";
    
    // ======== TPM_AT ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_AT_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_AT";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x00000000] = "ANY";
    pei->ConstNames[0x00000001] = "_ERROR";
    pei->ConstNames[0x00000002] = "PV1";
    pei->ConstNames[0x80000000] = "VEND";
    
    // ======== TPM_AE ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_AE_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_AE";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[0x00000000] = "NONE";
    
    // ======== PLATFORM ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::PLATFORM_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "PLATFORM";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[TPM_SPEC::FAMILY] = "FAMILY";
    pei->ConstNames[TPM_SPEC::LEVEL] = "LEVEL";
    pei->ConstNames[TPM_SPEC::VERSION] = "VERSION";
    pei->ConstNames[TPM_SPEC::YEAR] = "YEAR";
    pei->ConstNames[TPM_SPEC::DAY_OF_YEAR] = "DAY_OF_YEAR";
    
    // ======== Implementation ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::Implementation_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "Implementation";
    pei->Size = sizeof(UINT32);
    pei->ConstNames.clear();
    pei->ConstNames[Logic::NO] = "FIELD_UPGRADE_IMPLEMENTED";
    pei->ConstNames[ImplementationConstants::Ossl] = "HASH_LIB";
    pei->ConstNames[ImplementationConstants::Ossl] = "SYM_LIB";
    pei->ConstNames[ImplementationConstants::Ossl] = "MATH_LIB";
    pei->ConstNames[24] = "IMPLEMENTATION_PCR";
    pei->ConstNames[((Implementation::IMPLEMENTATION_PCR+7)/8)] = "PCR_SELECT_MAX";
    pei->ConstNames[24] = "PLATFORM_PCR";
    pei->ConstNames[((Implementation::PLATFORM_PCR + 7) / 8)] = "PCR_SELECT_MIN";
    pei->ConstNames[17] = "DRTM_PCR";
    pei->ConstNames[0] = "HCRTM_PCR";
    pei->ConstNames[5] = "NUM_LOCALITIES";
    pei->ConstNames[3] = "MAX_HANDLE_NUM";
    pei->ConstNames[64] = "MAX_ACTIVE_SESSIONS";
    pei->ConstNames[3] = "MAX_LOADED_SESSIONS";
    pei->ConstNames[3] = "MAX_SESSION_NUM";
    pei->ConstNames[3] = "MAX_LOADED_OBJECTS";
    pei->ConstNames[2] = "MIN_EVICT_OBJECTS";
    pei->ConstNames[1] = "NUM_POLICY_PCR_GROUP";
    pei->ConstNames[1] = "NUM_AUTHVALUE_PCR_GROUP";
    pei->ConstNames[1264] = "MAX_CONTEXT_SIZE";
    pei->ConstNames[1024] = "MAX_DIGEST_BUFFER";
    pei->ConstNames[2048] = "MAX_NV_INDEX_SIZE";
    pei->ConstNames[1024] = "MAX_NV_BUFFER_SIZE";
    pei->ConstNames[1024] = "MAX_CAP_BUFFER";
    pei->ConstNames[16384] = "NV_MEMORY_SIZE";
    pei->ConstNames[8] = "MIN_COUNTER_INDICES";
    pei->ConstNames[16] = "NUM_STATIC_PCR";
    pei->ConstNames[64] = "MAX_ALG_LIST_SIZE";
    pei->ConstNames[32] = "PRIMARY_SEED_SIZE";
    pei->ConstNames[ALG_ID_VALUE::AES_VALUE] = "CONTEXT_ENCRYPT_ALGORITHM";
    pei->ConstNames[12] = "NV_CLOCK_UPDATE_INTERVAL";
    pei->ConstNames[1] = "NUM_POLICY_PCR";
    pei->ConstNames[4096] = "MAX_COMMAND_SIZE";
    pei->ConstNames[4096] = "MAX_RESPONSE_SIZE";
    pei->ConstNames[8] = "ORDERLY_BITS";
    pei->ConstNames[128] = "MAX_SYM_DATA";
    pei->ConstNames[64] = "MAX_RNG_ENTROPY_SIZE";
    pei->ConstNames[512] = "RAM_INDEX_SPACE";
    pei->ConstNames[0x00010001] = "RSA_DEFAULT_PUBLIC_EXPONENT";
    pei->ConstNames[Logic::YES] = "ENABLE_PCR_NO_INCREMENT";
    pei->ConstNames[Logic::YES] = "CRT_FORMAT_RSA";
    pei->ConstNames[0] = "VENDOR_COMMAND_COUNT";
    pei->ConstNames[1024] = "MAX_VENDOR_BUFFER_SIZE";
    pei->ConstNames[8192] = "MAX_DERIVATION_BITS";
    pei->ConstNames[(ImplementationConstants::MAX_RSA_KEY_BYTES/2)] = "RSA_MAX_PRIME";
    pei->ConstNames[(Implementation::RSA_MAX_PRIME * 5)] = "RSA_PRIVATE_SIZE";
    pei->ConstNames[20] = "SIZE_OF_X509_SERIAL_NUMBER";
    pei->ConstNames[Implementation::RSA_PRIVATE_SIZE] = "PRIVATE_VENDOR_SPECIFIC_BYTES";
    
    // ======== TPM_HC ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::TPM_HC_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "TPM_HC";
    pei->Size = sizeof(TPM_HANDLE);
    pei->ConstNames.clear();
    pei->ConstNames[0x00FFFFFF] = "HR_HANDLE_MASK";
    pei->ConstNames[0xFF000000] = "HR_RANGE_MASK";
    pei->ConstNames[24] = "HR_SHIFT";
    pei->ConstNames[(TPM_HT::PCR << TPM_HC::HR_SHIFT)] = "HR_PCR";
    pei->ConstNames[(TPM_HT::HMAC_SESSION << TPM_HC::HR_SHIFT)] = "HR_HMAC_SESSION";
    pei->ConstNames[(TPM_HT::POLICY_SESSION << TPM_HC::HR_SHIFT)] = "HR_POLICY_SESSION";
    pei->ConstNames[(TPM_HT::TRANSIENT << TPM_HC::HR_SHIFT)] = "HR_TRANSIENT";
    pei->ConstNames[(TPM_HT::PERSISTENT << TPM_HC::HR_SHIFT)] = "HR_PERSISTENT";
    pei->ConstNames[(TPM_HT::NV_INDEX << TPM_HC::HR_SHIFT)] = "HR_NV_INDEX";
    pei->ConstNames[(TPM_HT::PERMANENT << TPM_HC::HR_SHIFT)] = "HR_PERMANENT";
    pei->ConstNames[(TPM_HC::HR_PCR + 0)] = "PCR_FIRST";
    pei->ConstNames[(TPM_HC::PCR_FIRST + Implementation::IMPLEMENTATION_PCR-1)] = "PCR_LAST";
    pei->ConstNames[(TPM_HC::HR_HMAC_SESSION + 0)] = "HMAC_SESSION_FIRST";
    pei->ConstNames[(TPM_HC::HMAC_SESSION_FIRST+Implementation::MAX_ACTIVE_SESSIONS-1)] = "HMAC_SESSION_LAST";
    pei->ConstNames[TPM_HC::HMAC_SESSION_FIRST] = "LOADED_SESSION_FIRST";
    pei->ConstNames[TPM_HC::HMAC_SESSION_LAST] = "LOADED_SESSION_LAST";
    pei->ConstNames[(TPM_HC::HR_POLICY_SESSION + 0)] = "POLICY_SESSION_FIRST";
    pei->ConstNames[(TPM_HC::POLICY_SESSION_FIRST + Implementation::MAX_ACTIVE_SESSIONS-1)] = "POLICY_SESSION_LAST";
    pei->ConstNames[(TPM_HC::HR_TRANSIENT + 0)] = "TRANSIENT_FIRST";
    pei->ConstNames[TPM_HC::POLICY_SESSION_FIRST] = "ACTIVE_SESSION_FIRST";
    pei->ConstNames[TPM_HC::POLICY_SESSION_LAST] = "ACTIVE_SESSION_LAST";
    pei->ConstNames[(TPM_HC::TRANSIENT_FIRST+Implementation::MAX_LOADED_OBJECTS-1)] = "TRANSIENT_LAST";
    pei->ConstNames[(TPM_HC::HR_PERSISTENT + 0)] = "PERSISTENT_FIRST";
    pei->ConstNames[(TPM_HC::PERSISTENT_FIRST + 0x00FFFFFF)] = "PERSISTENT_LAST";
    pei->ConstNames[(TPM_HC::PERSISTENT_FIRST + 0x00800000)] = "PLATFORM_PERSISTENT";
    pei->ConstNames[(TPM_HC::HR_NV_INDEX + 0)] = "NV_INDEX_FIRST";
    pei->ConstNames[(TPM_HC::NV_INDEX_FIRST + 0x00FFFFFF)] = "NV_INDEX_LAST";
    pei->ConstNames[TPM_RH::FIRST] = "PERMANENT_FIRST";
    pei->ConstNames[TPM_RH::LAST] = "PERMANENT_LAST";
    pei->ConstNames[((TPM_HT::NV_INDEX << TPM_HC::HR_SHIFT) + 0xD00000)] = "HR_NV_AC";
    pei->ConstNames[(TPM_HC::HR_NV_AC + 0)] = "NV_AC_FIRST";
    pei->ConstNames[(TPM_HC::HR_NV_AC + 0x0000FFFF)] = "NV_AC_LAST";
    pei->ConstNames[(TPM_HT::AC << TPM_HC::HR_SHIFT)] = "HR_AC";
    pei->ConstNames[(TPM_HC::HR_AC + 0)] = "AC_FIRST";
    pei->ConstNames[(TPM_HC::HR_AC + 0x0000FFFF)] = "AC_LAST";
    
    // ======== ALG_ID_VALUE ========
    pei = new TpmEnumInfo();
    TypeMap[TpmTypeId::ALG_ID_VALUE_ID] = pei;
    pei->Kind = TpmEntity::Enum;
    pei->Name = "ALG_ID_VALUE";
    pei->Size = sizeof(UINT16);
    pei->ConstNames.clear();
    pei->ConstNames[0x0000] = "ERROR_VALUE";
    pei->ConstNames[0x0001] = "FIRST_VALUE";
    pei->ConstNames[0x0001] = "RSA_VALUE";
    pei->ConstNames[0x0003] = "TDES_VALUE";
    pei->ConstNames[0x0004] = "SHA_VALUE";
    pei->ConstNames[0x0004] = "SHA1_VALUE";
    pei->ConstNames[0x0005] = "HMAC_VALUE";
    pei->ConstNames[0x0006] = "AES_VALUE";
    pei->ConstNames[0x0007] = "MGF1_VALUE";
    pei->ConstNames[0x0008] = "KEYEDHASH_VALUE";
    pei->ConstNames[0x000A] = "XOR_VALUE";
    pei->ConstNames[0x000B] = "SHA256_VALUE";
    pei->ConstNames[0x000C] = "SHA384_VALUE";
    pei->ConstNames[0x000D] = "SHA512_VALUE";
    pei->ConstNames[0x0010] = "NULL_VALUE";
    pei->ConstNames[0x0012] = "SM3_256_VALUE";
    pei->ConstNames[0x0013] = "SM4_VALUE";
    pei->ConstNames[0x0014] = "RSASSA_VALUE";
    pei->ConstNames[0x0015] = "RSAES_VALUE";
    pei->ConstNames[0x0016] = "RSAPSS_VALUE";
    pei->ConstNames[0x0017] = "OAEP_VALUE";
    pei->ConstNames[0x0018] = "ECDSA_VALUE";
    pei->ConstNames[0x0019] = "ECDH_VALUE";
    pei->ConstNames[0x001A] = "ECDAA_VALUE";
    pei->ConstNames[0x001B] = "SM2_VALUE";
    pei->ConstNames[0x001C] = "ECSCHNORR_VALUE";
    pei->ConstNames[0x001D] = "ECMQV_VALUE";
    pei->ConstNames[0x0020] = "KDF1_SP800_56A_VALUE";
    pei->ConstNames[0x0021] = "KDF2_VALUE";
    pei->ConstNames[0x0022] = "KDF1_SP800_108_VALUE";
    pei->ConstNames[0x0023] = "ECC_VALUE";
    pei->ConstNames[0x0025] = "SYMCIPHER_VALUE";
    pei->ConstNames[0x0026] = "CAMELLIA_VALUE";
    pei->ConstNames[0x0027] = "SHA3_256_VALUE";
    pei->ConstNames[0x0028] = "SHA3_384_VALUE";
    pei->ConstNames[0x0029] = "SHA3_512_VALUE";
    pei->ConstNames[0x003F] = "CMAC_VALUE";
    pei->ConstNames[0x0040] = "CTR_VALUE";
    pei->ConstNames[0x0041] = "OFB_VALUE";
    pei->ConstNames[0x0042] = "CBC_VALUE";
    pei->ConstNames[0x0043] = "CFB_VALUE";
    pei->ConstNames[0x0044] = "ECB_VALUE";
    pei->ConstNames[0x0044] = "LAST_VALUE";
    pei->ConstNames[0x7FFF] = "ANY_VALUE";
    pei->ConstNames[0x7FFE] = "ANY2_VALUE";
    
    TpmTypedefInfo* pti;
    
    
    // ======== INT8 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::INT8_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "INT8";
    pti->Size = sizeof(char);
    
    // ======== UINT8 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::UINT8_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "UINT8";
    pti->Size = sizeof(BYTE);
    
    // ======== BYTE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::BYTE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "BYTE";
    pti->Size = sizeof(BYTE);
    
    // ======== UINT16 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::UINT16_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "UINT16";
    pti->Size = sizeof(UINT16);
    
    // ======== INT16 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::INT16_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "INT16";
    pti->Size = sizeof(INT16);
    
    // ======== UINT32 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::UINT32_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "UINT32";
    pti->Size = sizeof(UINT32);
    
    // ======== INT32 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::INT32_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "INT32";
    pti->Size = sizeof(INT32);
    
    // ======== UINT64 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::UINT64_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "UINT64";
    pti->Size = sizeof(UINT64);
    
    // ======== INT64 ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::INT64_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "INT64";
    pti->Size = sizeof(INT64);
    
    // ======== BOOL ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::BOOL_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "BOOL";
    pti->Size = sizeof(bool);
    
    // ======== TPM_ALGORITHM_ID ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPM_ALGORITHM_ID_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPM_ALGORITHM_ID";
    pti->Size = sizeof(UINT32);
    
    // ======== TPM_MODIFIER_INDICATOR ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPM_MODIFIER_INDICATOR_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPM_MODIFIER_INDICATOR";
    pti->Size = sizeof(UINT32);
    
    // ======== TPM_AUTHORIZATION_SIZE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPM_AUTHORIZATION_SIZE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPM_AUTHORIZATION_SIZE";
    pti->Size = sizeof(UINT32);
    
    // ======== TPM_PARAMETER_SIZE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPM_PARAMETER_SIZE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPM_PARAMETER_SIZE";
    pti->Size = sizeof(UINT32);
    
    // ======== TPM_KEY_SIZE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPM_KEY_SIZE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPM_KEY_SIZE";
    pti->Size = sizeof(UINT16);
    
    // ======== TPM_KEY_BITS ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPM_KEY_BITS_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPM_KEY_BITS";
    pti->Size = sizeof(UINT16);
    
    // ======== TPMI_YES_NO ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_YES_NO_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_YES_NO";
    pti->Size = sizeof(BYTE);
    
    // ======== TPMI_DH_OBJECT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_DH_OBJECT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_DH_OBJECT";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_PARENT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_DH_PARENT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_DH_PARENT";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_PERSISTENT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_DH_PERSISTENT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_DH_PERSISTENT";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_ENTITY ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_DH_ENTITY_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_DH_ENTITY";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_PCR ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_DH_PCR_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_DH_PCR";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_SH_AUTH_SESSION ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_SH_AUTH_SESSION_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_SH_AUTH_SESSION";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_SH_HMAC ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_SH_HMAC_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_SH_HMAC";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_SH_POLICY ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_SH_POLICY_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_SH_POLICY";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_CONTEXT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_DH_CONTEXT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_DH_CONTEXT";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_SAVED ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_DH_SAVED_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_DH_SAVED";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_HIERARCHY ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_HIERARCHY_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_HIERARCHY";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_ENABLES ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_ENABLES_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_ENABLES";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_HIERARCHY_AUTH ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_HIERARCHY_AUTH_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_HIERARCHY_AUTH";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_HIERARCHY_POLICY ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_HIERARCHY_POLICY_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_HIERARCHY_POLICY";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_PLATFORM ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_PLATFORM_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_PLATFORM";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_OWNER ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_OWNER_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_OWNER";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_ENDORSEMENT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_ENDORSEMENT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_ENDORSEMENT";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_PROVISION ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_PROVISION_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_PROVISION";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_CLEAR ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_CLEAR_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_CLEAR";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_NV_AUTH ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_NV_AUTH_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_NV_AUTH";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_LOCKOUT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_LOCKOUT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_LOCKOUT";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_NV_INDEX ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_NV_INDEX_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_NV_INDEX";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_AC ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_AC_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_AC";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_ACT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RH_ACT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RH_ACT";
    pti->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_ALG_HASH ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_HASH_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_HASH";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_ASYM ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_ASYM_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_ASYM";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SYM ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SYM_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_SYM";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SYM_OBJECT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SYM_OBJECT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_SYM_OBJECT";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SYM_MODE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SYM_MODE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_SYM_MODE";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_KDF ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_KDF_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_KDF";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SIG_SCHEME ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SIG_SCHEME_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_SIG_SCHEME";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ECC_KEY_EXCHANGE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ECC_KEY_EXCHANGE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ECC_KEY_EXCHANGE";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ST_COMMAND_TAG ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ST_COMMAND_TAG_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ST_COMMAND_TAG";
    pti->Size = sizeof(TPM_ST);
    
    // ======== TPMI_ALG_MAC_SCHEME ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_MAC_SCHEME_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_MAC_SCHEME";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_CIPHER_MODE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_CIPHER_MODE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_CIPHER_MODE";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ST_ATTEST ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ST_ATTEST_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ST_ATTEST";
    pti->Size = sizeof(TPM_ST);
    
    // ======== TPMI_TDES_KEY_BITS ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_TDES_KEY_BITS_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_TDES_KEY_BITS";
    pti->Size = sizeof(UINT16);
    
    // ======== TPMI_AES_KEY_BITS ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_AES_KEY_BITS_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_AES_KEY_BITS";
    pti->Size = sizeof(UINT16);
    
    // ======== TPMI_SM4_KEY_BITS ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_SM4_KEY_BITS_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_SM4_KEY_BITS";
    pti->Size = sizeof(UINT16);
    
    // ======== TPMI_CAMELLIA_KEY_BITS ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_CAMELLIA_KEY_BITS_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_CAMELLIA_KEY_BITS";
    pti->Size = sizeof(UINT16);
    
    // ======== TPMI_ALG_KEYEDHASH_SCHEME ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_KEYEDHASH_SCHEME_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_KEYEDHASH_SCHEME";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_ASYM_SCHEME ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_ASYM_SCHEME_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_ASYM_SCHEME";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_RSA_SCHEME ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_RSA_SCHEME_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_RSA_SCHEME";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_RSA_DECRYPT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_RSA_DECRYPT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_RSA_DECRYPT";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_RSA_KEY_BITS ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_RSA_KEY_BITS_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_RSA_KEY_BITS";
    pti->Size = sizeof(UINT16);
    
    // ======== TPMI_ALG_ECC_SCHEME ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_ECC_SCHEME_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_ECC_SCHEME";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ECC_CURVE ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ECC_CURVE_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ECC_CURVE";
    pti->Size = sizeof(TPM_ECC_CURVE);
    
    // ======== TPMI_ALG_PUBLIC ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::TPMI_ALG_PUBLIC_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "TPMI_ALG_PUBLIC";
    pti->Size = sizeof(TPM_ALG_ID);
    
    // ======== CONTEXT_SLOT ========
    pti = new TpmTypedefInfo();
    TypeMap[TpmTypeId::CONTEXT_SLOT_ID] = pti;
    pti->Kind = TpmEntity::Typedef;
    pti->Name = "CONTEXT_SLOT";
    pti->Size = sizeof(UINT16);
}

