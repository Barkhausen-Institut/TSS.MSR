/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

/*
 * NOTE: this file is partially auto generated!
 *
 * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
 * is autogenerated from the TPM 2.0 Specification docs.
 *
 * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
 */

#include "stdafx.h"
#include "MarshalInternal.h"

_TPMCPP_USING

// Windows SDK headers may define this symbol
#ifdef _C2
#undef _C2
#endif

using namespace std;

// <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

void Tpm2::Startup(TPM_SU startupType)
{
    TPM2_Startup_REQUEST _req(startupType);
    StartupResponse _resp;
    Dispatch(TPM_CC::Startup, TpmTypeId::StartupResponse_ID, &_req, &_resp);
}

void Tpm2::Shutdown(TPM_SU shutdownType)
{
    TPM2_Shutdown_REQUEST _req(shutdownType);
    ShutdownResponse _resp;
    Dispatch(TPM_CC::Shutdown, TpmTypeId::ShutdownResponse_ID, &_req, &_resp);
}

void Tpm2::SelfTest(BYTE fullTest)
{
    TPM2_SelfTest_REQUEST _req(fullTest);
    SelfTestResponse _resp;
    Dispatch(TPM_CC::SelfTest, TpmTypeId::SelfTestResponse_ID, &_req, &_resp);
}

vector<TPM_ALG_ID> Tpm2::IncrementalSelfTest(const vector<TPM_ALG_ID>& toTest)
{
    TPM2_IncrementalSelfTest_REQUEST _req(toTest);
    IncrementalSelfTestResponse _resp;
    Dispatch(TPM_CC::IncrementalSelfTest, TpmTypeId::IncrementalSelfTestResponse_ID, &_req, &_resp);
    return _resp.toDoList;
}

GetTestResultResponse Tpm2::GetTestResult()
{
    GetTestResultResponse _resp;
    Dispatch(TPM_CC::GetTestResult, TpmTypeId::GetTestResultResponse_ID, NULL, &_resp);
    return _resp;
}

StartAuthSessionResponse Tpm2::StartAuthSession
(
    const TPM_HANDLE& tpmKey, 
    const TPM_HANDLE& bind, 
    const ByteVec& nonceCaller, 
    const ByteVec& encryptedSalt, 
    TPM_SE sessionType, 
    const TPMT_SYM_DEF& symmetric, 
    TPM_ALG_ID authHash
)
{
    TPM2_StartAuthSession_REQUEST _req(tpmKey,bind,nonceCaller,encryptedSalt,sessionType,symmetric,authHash);
    StartAuthSessionResponse _resp;
    Dispatch(TPM_CC::StartAuthSession, TpmTypeId::StartAuthSessionResponse_ID, &_req, &_resp);
    return _resp;
}

void Tpm2::PolicyRestart(const TPM_HANDLE& sessionHandle)
{
    TPM2_PolicyRestart_REQUEST _req(sessionHandle);
    PolicyRestartResponse _resp;
    Dispatch(TPM_CC::PolicyRestart, TpmTypeId::PolicyRestartResponse_ID, &_req, &_resp);
}

CreateResponse Tpm2::Create
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_Create_REQUEST _req(parentHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    CreateResponse _resp;
    Dispatch(TPM_CC::Create, TpmTypeId::CreateResponse_ID, &_req, &_resp);
    return _resp;
}

TPM_HANDLE Tpm2::Load
(
    const TPM_HANDLE& parentHandle, 
    const TPM2B_PRIVATE& inPrivate, 
    const TPMT_PUBLIC& inPublic
)
{
    TPM2_Load_REQUEST _req(parentHandle,inPrivate,inPublic);
    LoadResponse _resp;
    Dispatch(TPM_CC::Load, TpmTypeId::LoadResponse_ID, &_req, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::LoadExternal
(
    const TPMT_SENSITIVE& inPrivate, 
    const TPMT_PUBLIC& inPublic, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_LoadExternal_REQUEST _req(inPrivate,inPublic,hierarchy);
    LoadExternalResponse _resp;
    Dispatch(TPM_CC::LoadExternal, TpmTypeId::LoadExternalResponse_ID, &_req, &_resp);
    return _resp.handle;
}

ReadPublicResponse Tpm2::ReadPublic(const TPM_HANDLE& objectHandle)
{
    TPM2_ReadPublic_REQUEST _req(objectHandle);
    ReadPublicResponse _resp;
    Dispatch(TPM_CC::ReadPublic, TpmTypeId::ReadPublicResponse_ID, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::ActivateCredential
(
    const TPM_HANDLE& activateHandle, 
    const TPM_HANDLE& keyHandle, 
    const TPMS_ID_OBJECT& credentialBlob, 
    const ByteVec& secret
)
{
    TPM2_ActivateCredential_REQUEST _req(activateHandle,keyHandle,credentialBlob,secret);
    ActivateCredentialResponse _resp;
    Dispatch(TPM_CC::ActivateCredential, TpmTypeId::ActivateCredentialResponse_ID, &_req, &_resp);
    return _resp.certInfo;
}

MakeCredentialResponse Tpm2::MakeCredential
(
    const TPM_HANDLE& handle, 
    const ByteVec& credential, 
    const ByteVec& objectName
)
{
    TPM2_MakeCredential_REQUEST _req(handle,credential,objectName);
    MakeCredentialResponse _resp;
    Dispatch(TPM_CC::MakeCredential, TpmTypeId::MakeCredentialResponse_ID, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::Unseal(const TPM_HANDLE& itemHandle)
{
    TPM2_Unseal_REQUEST _req(itemHandle);
    UnsealResponse _resp;
    Dispatch(TPM_CC::Unseal, TpmTypeId::UnsealResponse_ID, &_req, &_resp);
    return _resp.outData;
}

TPM2B_PRIVATE Tpm2::ObjectChangeAuth
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& parentHandle, 
    const ByteVec& newAuth
)
{
    TPM2_ObjectChangeAuth_REQUEST _req(objectHandle,parentHandle,newAuth);
    ObjectChangeAuthResponse _resp;
    Dispatch(TPM_CC::ObjectChangeAuth, TpmTypeId::ObjectChangeAuthResponse_ID, &_req, &_resp);
    return _resp.outPrivate;
}

CreateLoadedResponse Tpm2::CreateLoaded
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const ByteVec& inPublic
)
{
    TPM2_CreateLoaded_REQUEST _req(parentHandle,inSensitive,inPublic);
    CreateLoadedResponse _resp;
    Dispatch(TPM_CC::CreateLoaded, TpmTypeId::CreateLoadedResponse_ID, &_req, &_resp);
    return _resp;
}

DuplicateResponse Tpm2::Duplicate
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& newParentHandle, 
    const ByteVec& encryptionKeyIn, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Duplicate_REQUEST _req(objectHandle,newParentHandle,encryptionKeyIn,symmetricAlg);
    DuplicateResponse _resp;
    Dispatch(TPM_CC::Duplicate, TpmTypeId::DuplicateResponse_ID, &_req, &_resp);
    return _resp;
}

RewrapResponse Tpm2::Rewrap
(
    const TPM_HANDLE& oldParent, 
    const TPM_HANDLE& newParent, 
    const TPM2B_PRIVATE& inDuplicate, 
    const ByteVec& name, 
    const ByteVec& inSymSeed
)
{
    TPM2_Rewrap_REQUEST _req(oldParent,newParent,inDuplicate,name,inSymSeed);
    RewrapResponse _resp;
    Dispatch(TPM_CC::Rewrap, TpmTypeId::RewrapResponse_ID, &_req, &_resp);
    return _resp;
}

TPM2B_PRIVATE Tpm2::Import
(
    const TPM_HANDLE& parentHandle, 
    const ByteVec& encryptionKey, 
    const TPMT_PUBLIC& objectPublic, 
    const TPM2B_PRIVATE& duplicate, 
    const ByteVec& inSymSeed, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Import_REQUEST _req(parentHandle,encryptionKey,objectPublic,duplicate,inSymSeed,symmetricAlg);
    ImportResponse _resp;
    Dispatch(TPM_CC::Import, TpmTypeId::ImportResponse_ID, &_req, &_resp);
    return _resp.outPrivate;
}

ByteVec Tpm2::RSA_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& message, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Encrypt_REQUEST _req(keyHandle,message,inScheme,label);
    RSA_EncryptResponse _resp;
    Dispatch(TPM_CC::RSA_Encrypt, TpmTypeId::RSA_EncryptResponse_ID, &_req, &_resp);
    return _resp.outData;
}

ByteVec Tpm2::RSA_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& cipherText, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Decrypt_REQUEST _req(keyHandle,cipherText,inScheme,label);
    RSA_DecryptResponse _resp;
    Dispatch(TPM_CC::RSA_Decrypt, TpmTypeId::RSA_DecryptResponse_ID, &_req, &_resp);
    return _resp.message;
}

ECDH_KeyGenResponse Tpm2::ECDH_KeyGen(const TPM_HANDLE& keyHandle)
{
    TPM2_ECDH_KeyGen_REQUEST _req(keyHandle);
    ECDH_KeyGenResponse _resp;
    Dispatch(TPM_CC::ECDH_KeyGen, TpmTypeId::ECDH_KeyGenResponse_ID, &_req, &_resp);
    return _resp;
}

TPMS_ECC_POINT Tpm2::ECDH_ZGen
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& inPoint
)
{
    TPM2_ECDH_ZGen_REQUEST _req(keyHandle,inPoint);
    ECDH_ZGenResponse _resp;
    Dispatch(TPM_CC::ECDH_ZGen, TpmTypeId::ECDH_ZGenResponse_ID, &_req, &_resp);
    return _resp.outPoint;
}

TPMS_ALGORITHM_DETAIL_ECC Tpm2::ECC_Parameters(TPM_ECC_CURVE curveID)
{
    TPM2_ECC_Parameters_REQUEST _req(curveID);
    ECC_ParametersResponse _resp;
    Dispatch(TPM_CC::ECC_Parameters, TpmTypeId::ECC_ParametersResponse_ID, &_req, &_resp);
    return _resp.parameters;
}

ZGen_2PhaseResponse Tpm2::ZGen_2Phase
(
    const TPM_HANDLE& keyA, 
    const TPMS_ECC_POINT& inQsB, 
    const TPMS_ECC_POINT& inQeB, 
    TPM_ALG_ID inScheme, 
    UINT16 counter
)
{
    TPM2_ZGen_2Phase_REQUEST _req(keyA,inQsB,inQeB,inScheme,counter);
    ZGen_2PhaseResponse _resp;
    Dispatch(TPM_CC::ZGen_2Phase, TpmTypeId::ZGen_2PhaseResponse_ID, &_req, &_resp);
    return _resp;
}

ECC_EncryptResponse Tpm2::ECC_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& plainText, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Encrypt_REQUEST _req(keyHandle,plainText,inScheme);
    ECC_EncryptResponse _resp;
    Dispatch(TPM_CC::ECC_Encrypt, TpmTypeId::ECC_EncryptResponse_ID, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::ECC_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& C1, 
    const ByteVec& C2, 
    const ByteVec& C3, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Decrypt_REQUEST _req(keyHandle,C1,C2,C3,inScheme);
    ECC_DecryptResponse _resp;
    Dispatch(TPM_CC::ECC_Decrypt, TpmTypeId::ECC_DecryptResponse_ID, &_req, &_resp);
    return _resp.plainText;
}

EncryptDecryptResponse Tpm2::EncryptDecrypt
(
    const TPM_HANDLE& keyHandle, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn, 
    const ByteVec& inData
)
{
    TPM2_EncryptDecrypt_REQUEST _req(keyHandle,decrypt,mode,ivIn,inData);
    EncryptDecryptResponse _resp;
    Dispatch(TPM_CC::EncryptDecrypt, TpmTypeId::EncryptDecryptResponse_ID, &_req, &_resp);
    return _resp;
}

EncryptDecrypt2Response Tpm2::EncryptDecrypt2
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& inData, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn
)
{
    TPM2_EncryptDecrypt2_REQUEST _req(keyHandle,inData,decrypt,mode,ivIn);
    EncryptDecrypt2Response _resp;
    Dispatch(TPM_CC::EncryptDecrypt2, TpmTypeId::EncryptDecrypt2Response_ID, &_req, &_resp);
    return _resp;
}

HashResponse Tpm2::Hash
(
    const ByteVec& data, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_Hash_REQUEST _req(data,hashAlg,hierarchy);
    HashResponse _resp;
    Dispatch(TPM_CC::Hash, TpmTypeId::HashResponse_ID, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::HMAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_REQUEST _req(handle,buffer,hashAlg);
    HMACResponse _resp;
    Dispatch(TPM_CC::HMAC, TpmTypeId::HMACResponse_ID, &_req, &_resp);
    return _resp.outHMAC;
}

ByteVec Tpm2::MAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_REQUEST _req(handle,buffer,inScheme);
    MACResponse _resp;
    Dispatch(TPM_CC::MAC, TpmTypeId::MACResponse_ID, &_req, &_resp);
    return _resp.outMAC;
}

ByteVec Tpm2::GetRandom(UINT16 bytesRequested)
{
    TPM2_GetRandom_REQUEST _req(bytesRequested);
    GetRandomResponse _resp;
    Dispatch(TPM_CC::GetRandom, TpmTypeId::GetRandomResponse_ID, &_req, &_resp);
    return _resp.randomBytes;
}

void Tpm2::StirRandom(const ByteVec& inData)
{
    TPM2_StirRandom_REQUEST _req(inData);
    StirRandomResponse _resp;
    Dispatch(TPM_CC::StirRandom, TpmTypeId::StirRandomResponse_ID, &_req, &_resp);
}

TPM_HANDLE Tpm2::HMAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_Start_REQUEST _req(handle,auth,hashAlg);
    HMAC_StartResponse _resp;
    Dispatch(TPM_CC::HMAC_Start, TpmTypeId::HMAC_StartResponse_ID, &_req, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::MAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_Start_REQUEST _req(handle,auth,inScheme);
    MAC_StartResponse _resp;
    Dispatch(TPM_CC::MAC_Start, TpmTypeId::MAC_StartResponse_ID, &_req, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::HashSequenceStart
(
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HashSequenceStart_REQUEST _req(auth,hashAlg);
    HashSequenceStartResponse _resp;
    Dispatch(TPM_CC::HashSequenceStart, TpmTypeId::HashSequenceStartResponse_ID, &_req, &_resp);
    return _resp.handle;
}

void Tpm2::SequenceUpdate
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_SequenceUpdate_REQUEST _req(sequenceHandle,buffer);
    SequenceUpdateResponse _resp;
    Dispatch(TPM_CC::SequenceUpdate, TpmTypeId::SequenceUpdateResponse_ID, &_req, &_resp);
}

SequenceCompleteResponse Tpm2::SequenceComplete
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_SequenceComplete_REQUEST _req(sequenceHandle,buffer,hierarchy);
    SequenceCompleteResponse _resp;
    Dispatch(TPM_CC::SequenceComplete, TpmTypeId::SequenceCompleteResponse_ID, &_req, &_resp);
    return _resp;
}

vector<TPMT_HA> Tpm2::EventSequenceComplete
(
    const TPM_HANDLE& pcrHandle, 
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_EventSequenceComplete_REQUEST _req(pcrHandle,sequenceHandle,buffer);
    EventSequenceCompleteResponse _resp;
    Dispatch(TPM_CC::EventSequenceComplete, TpmTypeId::EventSequenceCompleteResponse_ID, &_req, &_resp);
    return _resp.results;
}

CertifyResponse Tpm2::Certify
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_Certify_REQUEST _req(objectHandle,signHandle,qualifyingData,inScheme);
    CertifyResponse _resp;
    Dispatch(TPM_CC::Certify, TpmTypeId::CertifyResponse_ID, &_req, &_resp);
    return _resp;
}

CertifyCreationResponse Tpm2::CertifyCreation
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& objectHandle, 
    const ByteVec& qualifyingData, 
    const ByteVec& creationHash, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_CREATION& creationTicket
)
{
    TPM2_CertifyCreation_REQUEST _req(signHandle,objectHandle,qualifyingData,creationHash,inScheme,creationTicket);
    CertifyCreationResponse _resp;
    Dispatch(TPM_CC::CertifyCreation, TpmTypeId::CertifyCreationResponse_ID, &_req, &_resp);
    return _resp;
}

QuoteResponse Tpm2::Quote
(
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    const vector<TPMS_PCR_SELECTION>& PCRselect
)
{
    TPM2_Quote_REQUEST _req(signHandle,qualifyingData,inScheme,PCRselect);
    QuoteResponse _resp;
    Dispatch(TPM_CC::Quote, TpmTypeId::QuoteResponse_ID, &_req, &_resp);
    return _resp;
}

GetSessionAuditDigestResponse Tpm2::GetSessionAuditDigest
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& sessionHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetSessionAuditDigest_REQUEST _req(privacyAdminHandle,signHandle,sessionHandle,qualifyingData,inScheme);
    GetSessionAuditDigestResponse _resp;
    Dispatch(TPM_CC::GetSessionAuditDigest, TpmTypeId::GetSessionAuditDigestResponse_ID, &_req, &_resp);
    return _resp;
}

GetCommandAuditDigestResponse Tpm2::GetCommandAuditDigest
(
    const TPM_HANDLE& privacyHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetCommandAuditDigest_REQUEST _req(privacyHandle,signHandle,qualifyingData,inScheme);
    GetCommandAuditDigestResponse _resp;
    Dispatch(TPM_CC::GetCommandAuditDigest, TpmTypeId::GetCommandAuditDigestResponse_ID, &_req, &_resp);
    return _resp;
}

GetTimeResponse Tpm2::GetTime
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetTime_REQUEST _req(privacyAdminHandle,signHandle,qualifyingData,inScheme);
    GetTimeResponse _resp;
    Dispatch(TPM_CC::GetTime, TpmTypeId::GetTimeResponse_ID, &_req, &_resp);
    return _resp;
}

CertifyX509Response Tpm2::CertifyX509
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& reserved, 
    const TPMU_SIG_SCHEME& inScheme, 
    const ByteVec& partialCertificate
)
{
    TPM2_CertifyX509_REQUEST _req(objectHandle,signHandle,reserved,inScheme,partialCertificate);
    CertifyX509Response _resp;
    Dispatch(TPM_CC::CertifyX509, TpmTypeId::CertifyX509Response_ID, &_req, &_resp);
    return _resp;
}

CommitResponse Tpm2::Commit
(
    const TPM_HANDLE& signHandle, 
    const TPMS_ECC_POINT& P1, 
    const ByteVec& s2, 
    const ByteVec& y2
)
{
    TPM2_Commit_REQUEST _req(signHandle,P1,s2,y2);
    CommitResponse _resp;
    Dispatch(TPM_CC::Commit, TpmTypeId::CommitResponse_ID, &_req, &_resp);
    return _resp;
}

EC_EphemeralResponse Tpm2::EC_Ephemeral(TPM_ECC_CURVE curveID)
{
    TPM2_EC_Ephemeral_REQUEST _req(curveID);
    EC_EphemeralResponse _resp;
    Dispatch(TPM_CC::EC_Ephemeral, TpmTypeId::EC_EphemeralResponse_ID, &_req, &_resp);
    return _resp;
}

VerifySignatureResponse Tpm2::VerifySignature
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIGNATURE& signature
)
{
    TPM2_VerifySignature_REQUEST _req(keyHandle,digest,signature);
    VerifySignatureResponse _resp;
    Dispatch(TPM_CC::VerifySignature, TpmTypeId::VerifySignatureResponse_ID, &_req, &_resp);
    return _resp.validation;
}

SignResponse Tpm2::Sign
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_HASHCHECK& validation
)
{
    TPM2_Sign_REQUEST _req(keyHandle,digest,inScheme,validation);
    SignResponse _resp;
    Dispatch(TPM_CC::Sign, TpmTypeId::SignResponse_ID, &_req, &_resp);
    return _resp;
}

void Tpm2::SetCommandCodeAuditStatus
(
    const TPM_HANDLE& auth, 
    TPM_ALG_ID auditAlg, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_SetCommandCodeAuditStatus_REQUEST _req(auth,auditAlg,setList,clearList);
    SetCommandCodeAuditStatusResponse _resp;
    Dispatch(TPM_CC::SetCommandCodeAuditStatus, TpmTypeId::SetCommandCodeAuditStatusResponse_ID, &_req, &_resp);
}

void Tpm2::PCR_Extend
(
    const TPM_HANDLE& pcrHandle, 
    const vector<TPMT_HA>& digests
)
{
    TPM2_PCR_Extend_REQUEST _req(pcrHandle,digests);
    PCR_ExtendResponse _resp;
    Dispatch(TPM_CC::PCR_Extend, TpmTypeId::PCR_ExtendResponse_ID, &_req, &_resp);
}

vector<TPMT_HA> Tpm2::PCR_Event
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& eventData
)
{
    TPM2_PCR_Event_REQUEST _req(pcrHandle,eventData);
    PCR_EventResponse _resp;
    Dispatch(TPM_CC::PCR_Event, TpmTypeId::PCR_EventResponse_ID, &_req, &_resp);
    return _resp.digests;
}

PCR_ReadResponse Tpm2::PCR_Read(const vector<TPMS_PCR_SELECTION>& pcrSelectionIn)
{
    TPM2_PCR_Read_REQUEST _req(pcrSelectionIn);
    PCR_ReadResponse _resp;
    Dispatch(TPM_CC::PCR_Read, TpmTypeId::PCR_ReadResponse_ID, &_req, &_resp);
    return _resp;
}

PCR_AllocateResponse Tpm2::PCR_Allocate
(
    const TPM_HANDLE& authHandle, 
    const vector<TPMS_PCR_SELECTION>& pcrAllocation
)
{
    TPM2_PCR_Allocate_REQUEST _req(authHandle,pcrAllocation);
    PCR_AllocateResponse _resp;
    Dispatch(TPM_CC::PCR_Allocate, TpmTypeId::PCR_AllocateResponse_ID, &_req, &_resp);
    return _resp;
}

void Tpm2::PCR_SetAuthPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& pcrNum
)
{
    TPM2_PCR_SetAuthPolicy_REQUEST _req(authHandle,authPolicy,hashAlg,pcrNum);
    PCR_SetAuthPolicyResponse _resp;
    Dispatch(TPM_CC::PCR_SetAuthPolicy, TpmTypeId::PCR_SetAuthPolicyResponse_ID, &_req, &_resp);
}

void Tpm2::PCR_SetAuthValue
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& auth
)
{
    TPM2_PCR_SetAuthValue_REQUEST _req(pcrHandle,auth);
    PCR_SetAuthValueResponse _resp;
    Dispatch(TPM_CC::PCR_SetAuthValue, TpmTypeId::PCR_SetAuthValueResponse_ID, &_req, &_resp);
}

void Tpm2::PCR_Reset(const TPM_HANDLE& pcrHandle)
{
    TPM2_PCR_Reset_REQUEST _req(pcrHandle);
    PCR_ResetResponse _resp;
    Dispatch(TPM_CC::PCR_Reset, TpmTypeId::PCR_ResetResponse_ID, &_req, &_resp);
}

PolicySignedResponse Tpm2::PolicySigned
(
    const TPM_HANDLE& authObject, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration, 
    const TPMU_SIGNATURE& auth
)
{
    TPM2_PolicySigned_REQUEST _req(authObject,policySession,nonceTPM,cpHashA,policyRef,expiration,auth);
    PolicySignedResponse _resp;
    Dispatch(TPM_CC::PolicySigned, TpmTypeId::PolicySignedResponse_ID, &_req, &_resp);
    return _resp;
}

PolicySecretResponse Tpm2::PolicySecret
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration
)
{
    TPM2_PolicySecret_REQUEST _req(authHandle,policySession,nonceTPM,cpHashA,policyRef,expiration);
    PolicySecretResponse _resp;
    Dispatch(TPM_CC::PolicySecret, TpmTypeId::PolicySecretResponse_ID, &_req, &_resp);
    return _resp;
}

void Tpm2::PolicyTicket
(
    const TPM_HANDLE& policySession, 
    const ByteVec& timeout, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    const ByteVec& authName, 
    const TPMT_TK_AUTH& ticket
)
{
    TPM2_PolicyTicket_REQUEST _req(policySession,timeout,cpHashA,policyRef,authName,ticket);
    PolicyTicketResponse _resp;
    Dispatch(TPM_CC::PolicyTicket, TpmTypeId::PolicyTicketResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyOR
(
    const TPM_HANDLE& policySession, 
    const vector<TPM2B_DIGEST>& pHashList
)
{
    TPM2_PolicyOR_REQUEST _req(policySession,pHashList);
    PolicyORResponse _resp;
    Dispatch(TPM_CC::PolicyOR, TpmTypeId::PolicyORResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyPCR
(
    const TPM_HANDLE& policySession, 
    const ByteVec& pcrDigest, 
    const vector<TPMS_PCR_SELECTION>& pcrs
)
{
    TPM2_PolicyPCR_REQUEST _req(policySession,pcrDigest,pcrs);
    PolicyPCRResponse _resp;
    Dispatch(TPM_CC::PolicyPCR, TpmTypeId::PolicyPCRResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyLocality
(
    const TPM_HANDLE& policySession, 
    TPMA_LOCALITY locality
)
{
    TPM2_PolicyLocality_REQUEST _req(policySession,locality);
    PolicyLocalityResponse _resp;
    Dispatch(TPM_CC::PolicyLocality, TpmTypeId::PolicyLocalityResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyNV_REQUEST _req(authHandle,nvIndex,policySession,operandB,offset,operation);
    PolicyNVResponse _resp;
    Dispatch(TPM_CC::PolicyNV, TpmTypeId::PolicyNVResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyCounterTimer
(
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyCounterTimer_REQUEST _req(policySession,operandB,offset,operation);
    PolicyCounterTimerResponse _resp;
    Dispatch(TPM_CC::PolicyCounterTimer, TpmTypeId::PolicyCounterTimerResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyCommandCode
(
    const TPM_HANDLE& policySession, 
    TPM_CC code
)
{
    TPM2_PolicyCommandCode_REQUEST _req(policySession,code);
    PolicyCommandCodeResponse _resp;
    Dispatch(TPM_CC::PolicyCommandCode, TpmTypeId::PolicyCommandCodeResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyPhysicalPresence(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPhysicalPresence_REQUEST _req(policySession);
    PolicyPhysicalPresenceResponse _resp;
    Dispatch(TPM_CC::PolicyPhysicalPresence, TpmTypeId::PolicyPhysicalPresenceResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyCpHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& cpHashA
)
{
    TPM2_PolicyCpHash_REQUEST _req(policySession,cpHashA);
    PolicyCpHashResponse _resp;
    Dispatch(TPM_CC::PolicyCpHash, TpmTypeId::PolicyCpHashResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyNameHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& nameHash
)
{
    TPM2_PolicyNameHash_REQUEST _req(policySession,nameHash);
    PolicyNameHashResponse _resp;
    Dispatch(TPM_CC::PolicyNameHash, TpmTypeId::PolicyNameHashResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyDuplicationSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& newParentName, 
    BYTE includeObject
)
{
    TPM2_PolicyDuplicationSelect_REQUEST _req(policySession,objectName,newParentName,includeObject);
    PolicyDuplicationSelectResponse _resp;
    Dispatch(TPM_CC::PolicyDuplicationSelect, TpmTypeId::PolicyDuplicationSelectResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyAuthorize
(
    const TPM_HANDLE& policySession, 
    const ByteVec& approvedPolicy, 
    const ByteVec& policyRef, 
    const ByteVec& keySign, 
    const TPMT_TK_VERIFIED& checkTicket
)
{
    TPM2_PolicyAuthorize_REQUEST _req(policySession,approvedPolicy,policyRef,keySign,checkTicket);
    PolicyAuthorizeResponse _resp;
    Dispatch(TPM_CC::PolicyAuthorize, TpmTypeId::PolicyAuthorizeResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyAuthValue(const TPM_HANDLE& policySession)
{
    TPM2_PolicyAuthValue_REQUEST _req(policySession);
    PolicyAuthValueResponse _resp;
    Dispatch(TPM_CC::PolicyAuthValue, TpmTypeId::PolicyAuthValueResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyPassword(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPassword_REQUEST _req(policySession);
    PolicyPasswordResponse _resp;
    Dispatch(TPM_CC::PolicyPassword, TpmTypeId::PolicyPasswordResponse_ID, &_req, &_resp);
}

ByteVec Tpm2::PolicyGetDigest(const TPM_HANDLE& policySession)
{
    TPM2_PolicyGetDigest_REQUEST _req(policySession);
    PolicyGetDigestResponse _resp;
    Dispatch(TPM_CC::PolicyGetDigest, TpmTypeId::PolicyGetDigestResponse_ID, &_req, &_resp);
    return _resp.policyDigest;
}

void Tpm2::PolicyNvWritten
(
    const TPM_HANDLE& policySession, 
    BYTE writtenSet
)
{
    TPM2_PolicyNvWritten_REQUEST _req(policySession,writtenSet);
    PolicyNvWrittenResponse _resp;
    Dispatch(TPM_CC::PolicyNvWritten, TpmTypeId::PolicyNvWrittenResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyTemplate
(
    const TPM_HANDLE& policySession, 
    const ByteVec& templateHash
)
{
    TPM2_PolicyTemplate_REQUEST _req(policySession,templateHash);
    PolicyTemplateResponse _resp;
    Dispatch(TPM_CC::PolicyTemplate, TpmTypeId::PolicyTemplateResponse_ID, &_req, &_resp);
}

void Tpm2::PolicyAuthorizeNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthorizeNV_REQUEST _req(authHandle,nvIndex,policySession);
    PolicyAuthorizeNVResponse _resp;
    Dispatch(TPM_CC::PolicyAuthorizeNV, TpmTypeId::PolicyAuthorizeNVResponse_ID, &_req, &_resp);
}

CreatePrimaryResponse Tpm2::CreatePrimary
(
    const TPM_HANDLE& primaryHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_CreatePrimary_REQUEST _req(primaryHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    CreatePrimaryResponse _resp;
    Dispatch(TPM_CC::CreatePrimary, TpmTypeId::CreatePrimaryResponse_ID, &_req, &_resp);
    return _resp;
}

void Tpm2::HierarchyControl
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& enable, 
    BYTE state
)
{
    TPM2_HierarchyControl_REQUEST _req(authHandle,enable,state);
    HierarchyControlResponse _resp;
    Dispatch(TPM_CC::HierarchyControl, TpmTypeId::HierarchyControlResponse_ID, &_req, &_resp);
}

void Tpm2::SetPrimaryPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_SetPrimaryPolicy_REQUEST _req(authHandle,authPolicy,hashAlg);
    SetPrimaryPolicyResponse _resp;
    Dispatch(TPM_CC::SetPrimaryPolicy, TpmTypeId::SetPrimaryPolicyResponse_ID, &_req, &_resp);
}

void Tpm2::ChangePPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangePPS_REQUEST _req(authHandle);
    ChangePPSResponse _resp;
    Dispatch(TPM_CC::ChangePPS, TpmTypeId::ChangePPSResponse_ID, &_req, &_resp);
}

void Tpm2::ChangeEPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangeEPS_REQUEST _req(authHandle);
    ChangeEPSResponse _resp;
    Dispatch(TPM_CC::ChangeEPS, TpmTypeId::ChangeEPSResponse_ID, &_req, &_resp);
}

void Tpm2::Clear(const TPM_HANDLE& authHandle)
{
    TPM2_Clear_REQUEST _req(authHandle);
    ClearResponse _resp;
    Dispatch(TPM_CC::Clear, TpmTypeId::ClearResponse_ID, &_req, &_resp);
}

void Tpm2::ClearControl
(
    const TPM_HANDLE& auth, 
    BYTE disable
)
{
    TPM2_ClearControl_REQUEST _req(auth,disable);
    ClearControlResponse _resp;
    Dispatch(TPM_CC::ClearControl, TpmTypeId::ClearControlResponse_ID, &_req, &_resp);
}

void Tpm2::HierarchyChangeAuth
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& newAuth
)
{
    TPM2_HierarchyChangeAuth_REQUEST _req(authHandle,newAuth);
    HierarchyChangeAuthResponse _resp;
    Dispatch(TPM_CC::HierarchyChangeAuth, TpmTypeId::HierarchyChangeAuthResponse_ID, &_req, &_resp);
}

void Tpm2::DictionaryAttackLockReset(const TPM_HANDLE& lockHandle)
{
    TPM2_DictionaryAttackLockReset_REQUEST _req(lockHandle);
    DictionaryAttackLockResetResponse _resp;
    Dispatch(TPM_CC::DictionaryAttackLockReset, TpmTypeId::DictionaryAttackLockResetResponse_ID, &_req, &_resp);
}

void Tpm2::DictionaryAttackParameters
(
    const TPM_HANDLE& lockHandle, 
    UINT32 newMaxTries, 
    UINT32 newRecoveryTime, 
    UINT32 lockoutRecovery
)
{
    TPM2_DictionaryAttackParameters_REQUEST _req(lockHandle,newMaxTries,newRecoveryTime,lockoutRecovery);
    DictionaryAttackParametersResponse _resp;
    Dispatch(TPM_CC::DictionaryAttackParameters, TpmTypeId::DictionaryAttackParametersResponse_ID, &_req, &_resp);
}

void Tpm2::PP_Commands
(
    const TPM_HANDLE& auth, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_PP_Commands_REQUEST _req(auth,setList,clearList);
    PP_CommandsResponse _resp;
    Dispatch(TPM_CC::PP_Commands, TpmTypeId::PP_CommandsResponse_ID, &_req, &_resp);
}

void Tpm2::SetAlgorithmSet
(
    const TPM_HANDLE& authHandle, 
    UINT32 algorithmSet
)
{
    TPM2_SetAlgorithmSet_REQUEST _req(authHandle,algorithmSet);
    SetAlgorithmSetResponse _resp;
    Dispatch(TPM_CC::SetAlgorithmSet, TpmTypeId::SetAlgorithmSetResponse_ID, &_req, &_resp);
}

void Tpm2::FieldUpgradeStart
(
    const TPM_HANDLE& authorization, 
    const TPM_HANDLE& keyHandle, 
    const ByteVec& fuDigest, 
    const TPMU_SIGNATURE& manifestSignature
)
{
    TPM2_FieldUpgradeStart_REQUEST _req(authorization,keyHandle,fuDigest,manifestSignature);
    FieldUpgradeStartResponse _resp;
    Dispatch(TPM_CC::FieldUpgradeStart, TpmTypeId::FieldUpgradeStartResponse_ID, &_req, &_resp);
}

FieldUpgradeDataResponse Tpm2::FieldUpgradeData(const ByteVec& fuData)
{
    TPM2_FieldUpgradeData_REQUEST _req(fuData);
    FieldUpgradeDataResponse _resp;
    Dispatch(TPM_CC::FieldUpgradeData, TpmTypeId::FieldUpgradeDataResponse_ID, &_req, &_resp);
    return _resp;
}

ByteVec Tpm2::FirmwareRead(UINT32 sequenceNumber)
{
    TPM2_FirmwareRead_REQUEST _req(sequenceNumber);
    FirmwareReadResponse _resp;
    Dispatch(TPM_CC::FirmwareRead, TpmTypeId::FirmwareReadResponse_ID, &_req, &_resp);
    return _resp.fuData;
}

TPMS_CONTEXT Tpm2::ContextSave(const TPM_HANDLE& saveHandle)
{
    TPM2_ContextSave_REQUEST _req(saveHandle);
    ContextSaveResponse _resp;
    Dispatch(TPM_CC::ContextSave, TpmTypeId::ContextSaveResponse_ID, &_req, &_resp);
    return _resp.context;
}

TPM_HANDLE Tpm2::ContextLoad(const TPMS_CONTEXT& context)
{
    TPM2_ContextLoad_REQUEST _req(context);
    ContextLoadResponse _resp;
    Dispatch(TPM_CC::ContextLoad, TpmTypeId::ContextLoadResponse_ID, &_req, &_resp);
    return _resp.handle;
}

void Tpm2::FlushContext(const TPM_HANDLE& flushHandle)
{
    TPM2_FlushContext_REQUEST _req(flushHandle);
    FlushContextResponse _resp;
    Dispatch(TPM_CC::FlushContext, TpmTypeId::FlushContextResponse_ID, &_req, &_resp);
}

void Tpm2::EvictControl
(
    const TPM_HANDLE& auth, 
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& persistentHandle
)
{
    TPM2_EvictControl_REQUEST _req(auth,objectHandle,persistentHandle);
    EvictControlResponse _resp;
    Dispatch(TPM_CC::EvictControl, TpmTypeId::EvictControlResponse_ID, &_req, &_resp);
}

TPMS_TIME_INFO Tpm2::ReadClock()
{
    ReadClockResponse _resp;
    Dispatch(TPM_CC::ReadClock, TpmTypeId::ReadClockResponse_ID, NULL, &_resp);
    return _resp.currentTime;
}

void Tpm2::ClockSet
(
    const TPM_HANDLE& auth, 
    UINT64 newTime
)
{
    TPM2_ClockSet_REQUEST _req(auth,newTime);
    ClockSetResponse _resp;
    Dispatch(TPM_CC::ClockSet, TpmTypeId::ClockSetResponse_ID, &_req, &_resp);
}

void Tpm2::ClockRateAdjust
(
    const TPM_HANDLE& auth, 
    TPM_CLOCK_ADJUST rateAdjust
)
{
    TPM2_ClockRateAdjust_REQUEST _req(auth,rateAdjust);
    ClockRateAdjustResponse _resp;
    Dispatch(TPM_CC::ClockRateAdjust, TpmTypeId::ClockRateAdjustResponse_ID, &_req, &_resp);
}

GetCapabilityResponse Tpm2::GetCapability
(
    TPM_CAP capability, 
    UINT32 property, 
    UINT32 propertyCount
)
{
    TPM2_GetCapability_REQUEST _req(capability,property,propertyCount);
    GetCapabilityResponse _resp;
    Dispatch(TPM_CC::GetCapability, TpmTypeId::GetCapabilityResponse_ID, &_req, &_resp);
    return _resp;
}

void Tpm2::TestParms(const TPMU_PUBLIC_PARMS& parameters)
{
    TPM2_TestParms_REQUEST _req(parameters);
    TestParmsResponse _resp;
    Dispatch(TPM_CC::TestParms, TpmTypeId::TestParmsResponse_ID, &_req, &_resp);
}

void Tpm2::NV_DefineSpace
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& auth, 
    const TPMS_NV_PUBLIC& publicInfo
)
{
    TPM2_NV_DefineSpace_REQUEST _req(authHandle,auth,publicInfo);
    NV_DefineSpaceResponse _resp;
    Dispatch(TPM_CC::NV_DefineSpace, TpmTypeId::NV_DefineSpaceResponse_ID, &_req, &_resp);
}

void Tpm2::NV_UndefineSpace
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_UndefineSpace_REQUEST _req(authHandle,nvIndex);
    NV_UndefineSpaceResponse _resp;
    Dispatch(TPM_CC::NV_UndefineSpace, TpmTypeId::NV_UndefineSpaceResponse_ID, &_req, &_resp);
}

void Tpm2::NV_UndefineSpaceSpecial
(
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& platform
)
{
    TPM2_NV_UndefineSpaceSpecial_REQUEST _req(nvIndex,platform);
    NV_UndefineSpaceSpecialResponse _resp;
    Dispatch(TPM_CC::NV_UndefineSpaceSpecial, TpmTypeId::NV_UndefineSpaceSpecialResponse_ID, &_req, &_resp);
}

NV_ReadPublicResponse Tpm2::NV_ReadPublic(const TPM_HANDLE& nvIndex)
{
    TPM2_NV_ReadPublic_REQUEST _req(nvIndex);
    NV_ReadPublicResponse _resp;
    Dispatch(TPM_CC::NV_ReadPublic, TpmTypeId::NV_ReadPublicResponse_ID, &_req, &_resp);
    return _resp;
}

void Tpm2::NV_Write
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data, 
    UINT16 offset
)
{
    TPM2_NV_Write_REQUEST _req(authHandle,nvIndex,data,offset);
    NV_WriteResponse _resp;
    Dispatch(TPM_CC::NV_Write, TpmTypeId::NV_WriteResponse_ID, &_req, &_resp);
}

void Tpm2::NV_Increment
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_Increment_REQUEST _req(authHandle,nvIndex);
    NV_IncrementResponse _resp;
    Dispatch(TPM_CC::NV_Increment, TpmTypeId::NV_IncrementResponse_ID, &_req, &_resp);
}

void Tpm2::NV_Extend
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data
)
{
    TPM2_NV_Extend_REQUEST _req(authHandle,nvIndex,data);
    NV_ExtendResponse _resp;
    Dispatch(TPM_CC::NV_Extend, TpmTypeId::NV_ExtendResponse_ID, &_req, &_resp);
}

void Tpm2::NV_SetBits
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT64 bits
)
{
    TPM2_NV_SetBits_REQUEST _req(authHandle,nvIndex,bits);
    NV_SetBitsResponse _resp;
    Dispatch(TPM_CC::NV_SetBits, TpmTypeId::NV_SetBitsResponse_ID, &_req, &_resp);
}

void Tpm2::NV_WriteLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_WriteLock_REQUEST _req(authHandle,nvIndex);
    NV_WriteLockResponse _resp;
    Dispatch(TPM_CC::NV_WriteLock, TpmTypeId::NV_WriteLockResponse_ID, &_req, &_resp);
}

void Tpm2::NV_GlobalWriteLock(const TPM_HANDLE& authHandle)
{
    TPM2_NV_GlobalWriteLock_REQUEST _req(authHandle);
    NV_GlobalWriteLockResponse _resp;
    Dispatch(TPM_CC::NV_GlobalWriteLock, TpmTypeId::NV_GlobalWriteLockResponse_ID, &_req, &_resp);
}

ByteVec Tpm2::NV_Read
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Read_REQUEST _req(authHandle,nvIndex,size,offset);
    NV_ReadResponse _resp;
    Dispatch(TPM_CC::NV_Read, TpmTypeId::NV_ReadResponse_ID, &_req, &_resp);
    return _resp.data;
}

void Tpm2::NV_ReadLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadLock_REQUEST _req(authHandle,nvIndex);
    NV_ReadLockResponse _resp;
    Dispatch(TPM_CC::NV_ReadLock, TpmTypeId::NV_ReadLockResponse_ID, &_req, &_resp);
}

void Tpm2::NV_ChangeAuth
(
    const TPM_HANDLE& nvIndex, 
    const ByteVec& newAuth
)
{
    TPM2_NV_ChangeAuth_REQUEST _req(nvIndex,newAuth);
    NV_ChangeAuthResponse _resp;
    Dispatch(TPM_CC::NV_ChangeAuth, TpmTypeId::NV_ChangeAuthResponse_ID, &_req, &_resp);
}

NV_CertifyResponse Tpm2::NV_Certify
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Certify_REQUEST _req(signHandle,authHandle,nvIndex,qualifyingData,inScheme,size,offset);
    NV_CertifyResponse _resp;
    Dispatch(TPM_CC::NV_Certify, TpmTypeId::NV_CertifyResponse_ID, &_req, &_resp);
    return _resp;
}

AC_GetCapabilityResponse Tpm2::AC_GetCapability
(
    const TPM_HANDLE& ac, 
    TPM_AT capability, 
    UINT32 count
)
{
    TPM2_AC_GetCapability_REQUEST _req(ac,capability,count);
    AC_GetCapabilityResponse _resp;
    Dispatch(TPM_CC::AC_GetCapability, TpmTypeId::AC_GetCapabilityResponse_ID, &_req, &_resp);
    return _resp;
}

TPMS_AC_OUTPUT Tpm2::AC_Send
(
    const TPM_HANDLE& sendObject, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& ac, 
    const ByteVec& acDataIn
)
{
    TPM2_AC_Send_REQUEST _req(sendObject,authHandle,ac,acDataIn);
    AC_SendResponse _resp;
    Dispatch(TPM_CC::AC_Send, TpmTypeId::AC_SendResponse_ID, &_req, &_resp);
    return _resp.acDataOut;
}

void Tpm2::Policy_AC_SendSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& authHandleName, 
    const ByteVec& acName, 
    BYTE includeObject
)
{
    TPM2_Policy_AC_SendSelect_REQUEST _req(policySession,objectName,authHandleName,acName,includeObject);
    Policy_AC_SendSelectResponse _resp;
    Dispatch(TPM_CC::Policy_AC_SendSelect, TpmTypeId::Policy_AC_SendSelectResponse_ID, &_req, &_resp);
}

void Tpm2::ACT_SetTimeout
(
    const TPM_HANDLE& actHandle, 
    UINT32 startTimeout
)
{
    TPM2_ACT_SetTimeout_REQUEST _req(actHandle,startTimeout);
    ACT_SetTimeoutResponse _resp;
    Dispatch(TPM_CC::ACT_SetTimeout, TpmTypeId::ACT_SetTimeoutResponse_ID, &_req, &_resp);
}

ByteVec Tpm2::Vendor_TCG_Test(const ByteVec& inputData)
{
    TPM2_Vendor_TCG_Test_REQUEST _req(inputData);
    Vendor_TCG_TestResponse _resp;
    Dispatch(TPM_CC::Vendor_TCG_Test, TpmTypeId::Vendor_TCG_TestResponse_ID, &_req, &_resp);
    return _resp.outputData;
}

void Tpm2::AsyncMethods::Startup(TPM_SU startupType)
{
    TPM2_Startup_REQUEST _req(startupType);
    StartupResponse _resp;
    theTpm.DispatchOut(TPM_CC::Startup, &_req);
}

void Tpm2::AsyncMethods::Shutdown(TPM_SU shutdownType)
{
    TPM2_Shutdown_REQUEST _req(shutdownType);
    ShutdownResponse _resp;
    theTpm.DispatchOut(TPM_CC::Shutdown, &_req);
}

void Tpm2::AsyncMethods::SelfTest(BYTE fullTest)
{
    TPM2_SelfTest_REQUEST _req(fullTest);
    SelfTestResponse _resp;
    theTpm.DispatchOut(TPM_CC::SelfTest, &_req);
}

void Tpm2::AsyncMethods::IncrementalSelfTest(const vector<TPM_ALG_ID>& toTest)
{
    TPM2_IncrementalSelfTest_REQUEST _req(toTest);
    IncrementalSelfTestResponse _resp;
    theTpm.DispatchOut(TPM_CC::IncrementalSelfTest, &_req);
}

void Tpm2::AsyncMethods::GetTestResult()
{
    GetTestResultResponse _resp;
    theTpm.DispatchOut(TPM_CC::GetTestResult, NULL);
}

void Tpm2::AsyncMethods::StartAuthSession
(
    const TPM_HANDLE& tpmKey, 
    const TPM_HANDLE& bind, 
    const ByteVec& nonceCaller, 
    const ByteVec& encryptedSalt, 
    TPM_SE sessionType, 
    const TPMT_SYM_DEF& symmetric, 
    TPM_ALG_ID authHash
)
{
    TPM2_StartAuthSession_REQUEST _req(tpmKey,bind,nonceCaller,encryptedSalt,sessionType,symmetric,authHash);
    StartAuthSessionResponse _resp;
    theTpm.DispatchOut(TPM_CC::StartAuthSession, &_req);
}

void Tpm2::AsyncMethods::PolicyRestart(const TPM_HANDLE& sessionHandle)
{
    TPM2_PolicyRestart_REQUEST _req(sessionHandle);
    PolicyRestartResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyRestart, &_req);
}

void Tpm2::AsyncMethods::Create
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_Create_REQUEST _req(parentHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    CreateResponse _resp;
    theTpm.DispatchOut(TPM_CC::Create, &_req);
}

void Tpm2::AsyncMethods::Load
(
    const TPM_HANDLE& parentHandle, 
    const TPM2B_PRIVATE& inPrivate, 
    const TPMT_PUBLIC& inPublic
)
{
    TPM2_Load_REQUEST _req(parentHandle,inPrivate,inPublic);
    LoadResponse _resp;
    theTpm.DispatchOut(TPM_CC::Load, &_req);
}

void Tpm2::AsyncMethods::LoadExternal
(
    const TPMT_SENSITIVE& inPrivate, 
    const TPMT_PUBLIC& inPublic, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_LoadExternal_REQUEST _req(inPrivate,inPublic,hierarchy);
    LoadExternalResponse _resp;
    theTpm.DispatchOut(TPM_CC::LoadExternal, &_req);
}

void Tpm2::AsyncMethods::ReadPublic(const TPM_HANDLE& objectHandle)
{
    TPM2_ReadPublic_REQUEST _req(objectHandle);
    ReadPublicResponse _resp;
    theTpm.DispatchOut(TPM_CC::ReadPublic, &_req);
}

void Tpm2::AsyncMethods::ActivateCredential
(
    const TPM_HANDLE& activateHandle, 
    const TPM_HANDLE& keyHandle, 
    const TPMS_ID_OBJECT& credentialBlob, 
    const ByteVec& secret
)
{
    TPM2_ActivateCredential_REQUEST _req(activateHandle,keyHandle,credentialBlob,secret);
    ActivateCredentialResponse _resp;
    theTpm.DispatchOut(TPM_CC::ActivateCredential, &_req);
}

void Tpm2::AsyncMethods::MakeCredential
(
    const TPM_HANDLE& handle, 
    const ByteVec& credential, 
    const ByteVec& objectName
)
{
    TPM2_MakeCredential_REQUEST _req(handle,credential,objectName);
    MakeCredentialResponse _resp;
    theTpm.DispatchOut(TPM_CC::MakeCredential, &_req);
}

void Tpm2::AsyncMethods::Unseal(const TPM_HANDLE& itemHandle)
{
    TPM2_Unseal_REQUEST _req(itemHandle);
    UnsealResponse _resp;
    theTpm.DispatchOut(TPM_CC::Unseal, &_req);
}

void Tpm2::AsyncMethods::ObjectChangeAuth
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& parentHandle, 
    const ByteVec& newAuth
)
{
    TPM2_ObjectChangeAuth_REQUEST _req(objectHandle,parentHandle,newAuth);
    ObjectChangeAuthResponse _resp;
    theTpm.DispatchOut(TPM_CC::ObjectChangeAuth, &_req);
}

void Tpm2::AsyncMethods::CreateLoaded
(
    const TPM_HANDLE& parentHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const ByteVec& inPublic
)
{
    TPM2_CreateLoaded_REQUEST _req(parentHandle,inSensitive,inPublic);
    CreateLoadedResponse _resp;
    theTpm.DispatchOut(TPM_CC::CreateLoaded, &_req);
}

void Tpm2::AsyncMethods::Duplicate
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& newParentHandle, 
    const ByteVec& encryptionKeyIn, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Duplicate_REQUEST _req(objectHandle,newParentHandle,encryptionKeyIn,symmetricAlg);
    DuplicateResponse _resp;
    theTpm.DispatchOut(TPM_CC::Duplicate, &_req);
}

void Tpm2::AsyncMethods::Rewrap
(
    const TPM_HANDLE& oldParent, 
    const TPM_HANDLE& newParent, 
    const TPM2B_PRIVATE& inDuplicate, 
    const ByteVec& name, 
    const ByteVec& inSymSeed
)
{
    TPM2_Rewrap_REQUEST _req(oldParent,newParent,inDuplicate,name,inSymSeed);
    RewrapResponse _resp;
    theTpm.DispatchOut(TPM_CC::Rewrap, &_req);
}

void Tpm2::AsyncMethods::Import
(
    const TPM_HANDLE& parentHandle, 
    const ByteVec& encryptionKey, 
    const TPMT_PUBLIC& objectPublic, 
    const TPM2B_PRIVATE& duplicate, 
    const ByteVec& inSymSeed, 
    const TPMT_SYM_DEF_OBJECT& symmetricAlg
)
{
    TPM2_Import_REQUEST _req(parentHandle,encryptionKey,objectPublic,duplicate,inSymSeed,symmetricAlg);
    ImportResponse _resp;
    theTpm.DispatchOut(TPM_CC::Import, &_req);
}

void Tpm2::AsyncMethods::RSA_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& message, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Encrypt_REQUEST _req(keyHandle,message,inScheme,label);
    RSA_EncryptResponse _resp;
    theTpm.DispatchOut(TPM_CC::RSA_Encrypt, &_req);
}

void Tpm2::AsyncMethods::RSA_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& cipherText, 
    const TPMU_ASYM_SCHEME& inScheme, 
    const ByteVec& label
)
{
    TPM2_RSA_Decrypt_REQUEST _req(keyHandle,cipherText,inScheme,label);
    RSA_DecryptResponse _resp;
    theTpm.DispatchOut(TPM_CC::RSA_Decrypt, &_req);
}

void Tpm2::AsyncMethods::ECDH_KeyGen(const TPM_HANDLE& keyHandle)
{
    TPM2_ECDH_KeyGen_REQUEST _req(keyHandle);
    ECDH_KeyGenResponse _resp;
    theTpm.DispatchOut(TPM_CC::ECDH_KeyGen, &_req);
}

void Tpm2::AsyncMethods::ECDH_ZGen
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& inPoint
)
{
    TPM2_ECDH_ZGen_REQUEST _req(keyHandle,inPoint);
    ECDH_ZGenResponse _resp;
    theTpm.DispatchOut(TPM_CC::ECDH_ZGen, &_req);
}

void Tpm2::AsyncMethods::ECC_Parameters(TPM_ECC_CURVE curveID)
{
    TPM2_ECC_Parameters_REQUEST _req(curveID);
    ECC_ParametersResponse _resp;
    theTpm.DispatchOut(TPM_CC::ECC_Parameters, &_req);
}

void Tpm2::AsyncMethods::ZGen_2Phase
(
    const TPM_HANDLE& keyA, 
    const TPMS_ECC_POINT& inQsB, 
    const TPMS_ECC_POINT& inQeB, 
    TPM_ALG_ID inScheme, 
    UINT16 counter
)
{
    TPM2_ZGen_2Phase_REQUEST _req(keyA,inQsB,inQeB,inScheme,counter);
    ZGen_2PhaseResponse _resp;
    theTpm.DispatchOut(TPM_CC::ZGen_2Phase, &_req);
}

void Tpm2::AsyncMethods::ECC_Encrypt
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& plainText, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Encrypt_REQUEST _req(keyHandle,plainText,inScheme);
    ECC_EncryptResponse _resp;
    theTpm.DispatchOut(TPM_CC::ECC_Encrypt, &_req);
}

void Tpm2::AsyncMethods::ECC_Decrypt
(
    const TPM_HANDLE& keyHandle, 
    const TPMS_ECC_POINT& C1, 
    const ByteVec& C2, 
    const ByteVec& C3, 
    const TPMU_KDF_SCHEME& inScheme
)
{
    TPM2_ECC_Decrypt_REQUEST _req(keyHandle,C1,C2,C3,inScheme);
    ECC_DecryptResponse _resp;
    theTpm.DispatchOut(TPM_CC::ECC_Decrypt, &_req);
}

void Tpm2::AsyncMethods::EncryptDecrypt
(
    const TPM_HANDLE& keyHandle, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn, 
    const ByteVec& inData
)
{
    TPM2_EncryptDecrypt_REQUEST _req(keyHandle,decrypt,mode,ivIn,inData);
    EncryptDecryptResponse _resp;
    theTpm.DispatchOut(TPM_CC::EncryptDecrypt, &_req);
}

void Tpm2::AsyncMethods::EncryptDecrypt2
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& inData, 
    BYTE decrypt, 
    TPM_ALG_ID mode, 
    const ByteVec& ivIn
)
{
    TPM2_EncryptDecrypt2_REQUEST _req(keyHandle,inData,decrypt,mode,ivIn);
    EncryptDecrypt2Response _resp;
    theTpm.DispatchOut(TPM_CC::EncryptDecrypt2, &_req);
}

void Tpm2::AsyncMethods::Hash
(
    const ByteVec& data, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_Hash_REQUEST _req(data,hashAlg,hierarchy);
    HashResponse _resp;
    theTpm.DispatchOut(TPM_CC::Hash, &_req);
}

void Tpm2::AsyncMethods::HMAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_REQUEST _req(handle,buffer,hashAlg);
    HMACResponse _resp;
    theTpm.DispatchOut(TPM_CC::HMAC, &_req);
}

void Tpm2::AsyncMethods::MAC
(
    const TPM_HANDLE& handle, 
    const ByteVec& buffer, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_REQUEST _req(handle,buffer,inScheme);
    MACResponse _resp;
    theTpm.DispatchOut(TPM_CC::MAC, &_req);
}

void Tpm2::AsyncMethods::GetRandom(UINT16 bytesRequested)
{
    TPM2_GetRandom_REQUEST _req(bytesRequested);
    GetRandomResponse _resp;
    theTpm.DispatchOut(TPM_CC::GetRandom, &_req);
}

void Tpm2::AsyncMethods::StirRandom(const ByteVec& inData)
{
    TPM2_StirRandom_REQUEST _req(inData);
    StirRandomResponse _resp;
    theTpm.DispatchOut(TPM_CC::StirRandom, &_req);
}

void Tpm2::AsyncMethods::HMAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HMAC_Start_REQUEST _req(handle,auth,hashAlg);
    HMAC_StartResponse _resp;
    theTpm.DispatchOut(TPM_CC::HMAC_Start, &_req);
}

void Tpm2::AsyncMethods::MAC_Start
(
    const TPM_HANDLE& handle, 
    const ByteVec& auth, 
    TPM_ALG_ID inScheme
)
{
    TPM2_MAC_Start_REQUEST _req(handle,auth,inScheme);
    MAC_StartResponse _resp;
    theTpm.DispatchOut(TPM_CC::MAC_Start, &_req);
}

void Tpm2::AsyncMethods::HashSequenceStart
(
    const ByteVec& auth, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_HashSequenceStart_REQUEST _req(auth,hashAlg);
    HashSequenceStartResponse _resp;
    theTpm.DispatchOut(TPM_CC::HashSequenceStart, &_req);
}

void Tpm2::AsyncMethods::SequenceUpdate
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_SequenceUpdate_REQUEST _req(sequenceHandle,buffer);
    SequenceUpdateResponse _resp;
    theTpm.DispatchOut(TPM_CC::SequenceUpdate, &_req);
}

void Tpm2::AsyncMethods::SequenceComplete
(
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer, 
    const TPM_HANDLE& hierarchy
)
{
    TPM2_SequenceComplete_REQUEST _req(sequenceHandle,buffer,hierarchy);
    SequenceCompleteResponse _resp;
    theTpm.DispatchOut(TPM_CC::SequenceComplete, &_req);
}

void Tpm2::AsyncMethods::EventSequenceComplete
(
    const TPM_HANDLE& pcrHandle, 
    const TPM_HANDLE& sequenceHandle, 
    const ByteVec& buffer
)
{
    TPM2_EventSequenceComplete_REQUEST _req(pcrHandle,sequenceHandle,buffer);
    EventSequenceCompleteResponse _resp;
    theTpm.DispatchOut(TPM_CC::EventSequenceComplete, &_req);
}

void Tpm2::AsyncMethods::Certify
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_Certify_REQUEST _req(objectHandle,signHandle,qualifyingData,inScheme);
    CertifyResponse _resp;
    theTpm.DispatchOut(TPM_CC::Certify, &_req);
}

void Tpm2::AsyncMethods::CertifyCreation
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& objectHandle, 
    const ByteVec& qualifyingData, 
    const ByteVec& creationHash, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_CREATION& creationTicket
)
{
    TPM2_CertifyCreation_REQUEST _req(signHandle,objectHandle,qualifyingData,creationHash,inScheme,creationTicket);
    CertifyCreationResponse _resp;
    theTpm.DispatchOut(TPM_CC::CertifyCreation, &_req);
}

void Tpm2::AsyncMethods::Quote
(
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    const vector<TPMS_PCR_SELECTION>& PCRselect
)
{
    TPM2_Quote_REQUEST _req(signHandle,qualifyingData,inScheme,PCRselect);
    QuoteResponse _resp;
    theTpm.DispatchOut(TPM_CC::Quote, &_req);
}

void Tpm2::AsyncMethods::GetSessionAuditDigest
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& sessionHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetSessionAuditDigest_REQUEST _req(privacyAdminHandle,signHandle,sessionHandle,qualifyingData,inScheme);
    GetSessionAuditDigestResponse _resp;
    theTpm.DispatchOut(TPM_CC::GetSessionAuditDigest, &_req);
}

void Tpm2::AsyncMethods::GetCommandAuditDigest
(
    const TPM_HANDLE& privacyHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetCommandAuditDigest_REQUEST _req(privacyHandle,signHandle,qualifyingData,inScheme);
    GetCommandAuditDigestResponse _resp;
    theTpm.DispatchOut(TPM_CC::GetCommandAuditDigest, &_req);
}

void Tpm2::AsyncMethods::GetTime
(
    const TPM_HANDLE& privacyAdminHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme
)
{
    TPM2_GetTime_REQUEST _req(privacyAdminHandle,signHandle,qualifyingData,inScheme);
    GetTimeResponse _resp;
    theTpm.DispatchOut(TPM_CC::GetTime, &_req);
}

void Tpm2::AsyncMethods::CertifyX509
(
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& signHandle, 
    const ByteVec& reserved, 
    const TPMU_SIG_SCHEME& inScheme, 
    const ByteVec& partialCertificate
)
{
    TPM2_CertifyX509_REQUEST _req(objectHandle,signHandle,reserved,inScheme,partialCertificate);
    CertifyX509Response _resp;
    theTpm.DispatchOut(TPM_CC::CertifyX509, &_req);
}

void Tpm2::AsyncMethods::Commit
(
    const TPM_HANDLE& signHandle, 
    const TPMS_ECC_POINT& P1, 
    const ByteVec& s2, 
    const ByteVec& y2
)
{
    TPM2_Commit_REQUEST _req(signHandle,P1,s2,y2);
    CommitResponse _resp;
    theTpm.DispatchOut(TPM_CC::Commit, &_req);
}

void Tpm2::AsyncMethods::EC_Ephemeral(TPM_ECC_CURVE curveID)
{
    TPM2_EC_Ephemeral_REQUEST _req(curveID);
    EC_EphemeralResponse _resp;
    theTpm.DispatchOut(TPM_CC::EC_Ephemeral, &_req);
}

void Tpm2::AsyncMethods::VerifySignature
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIGNATURE& signature
)
{
    TPM2_VerifySignature_REQUEST _req(keyHandle,digest,signature);
    VerifySignatureResponse _resp;
    theTpm.DispatchOut(TPM_CC::VerifySignature, &_req);
}

void Tpm2::AsyncMethods::Sign
(
    const TPM_HANDLE& keyHandle, 
    const ByteVec& digest, 
    const TPMU_SIG_SCHEME& inScheme, 
    const TPMT_TK_HASHCHECK& validation
)
{
    TPM2_Sign_REQUEST _req(keyHandle,digest,inScheme,validation);
    SignResponse _resp;
    theTpm.DispatchOut(TPM_CC::Sign, &_req);
}

void Tpm2::AsyncMethods::SetCommandCodeAuditStatus
(
    const TPM_HANDLE& auth, 
    TPM_ALG_ID auditAlg, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_SetCommandCodeAuditStatus_REQUEST _req(auth,auditAlg,setList,clearList);
    SetCommandCodeAuditStatusResponse _resp;
    theTpm.DispatchOut(TPM_CC::SetCommandCodeAuditStatus, &_req);
}

void Tpm2::AsyncMethods::PCR_Extend
(
    const TPM_HANDLE& pcrHandle, 
    const vector<TPMT_HA>& digests
)
{
    TPM2_PCR_Extend_REQUEST _req(pcrHandle,digests);
    PCR_ExtendResponse _resp;
    theTpm.DispatchOut(TPM_CC::PCR_Extend, &_req);
}

void Tpm2::AsyncMethods::PCR_Event
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& eventData
)
{
    TPM2_PCR_Event_REQUEST _req(pcrHandle,eventData);
    PCR_EventResponse _resp;
    theTpm.DispatchOut(TPM_CC::PCR_Event, &_req);
}

void Tpm2::AsyncMethods::PCR_Read(const vector<TPMS_PCR_SELECTION>& pcrSelectionIn)
{
    TPM2_PCR_Read_REQUEST _req(pcrSelectionIn);
    PCR_ReadResponse _resp;
    theTpm.DispatchOut(TPM_CC::PCR_Read, &_req);
}

void Tpm2::AsyncMethods::PCR_Allocate
(
    const TPM_HANDLE& authHandle, 
    const vector<TPMS_PCR_SELECTION>& pcrAllocation
)
{
    TPM2_PCR_Allocate_REQUEST _req(authHandle,pcrAllocation);
    PCR_AllocateResponse _resp;
    theTpm.DispatchOut(TPM_CC::PCR_Allocate, &_req);
}

void Tpm2::AsyncMethods::PCR_SetAuthPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg, 
    const TPM_HANDLE& pcrNum
)
{
    TPM2_PCR_SetAuthPolicy_REQUEST _req(authHandle,authPolicy,hashAlg,pcrNum);
    PCR_SetAuthPolicyResponse _resp;
    theTpm.DispatchOut(TPM_CC::PCR_SetAuthPolicy, &_req);
}

void Tpm2::AsyncMethods::PCR_SetAuthValue
(
    const TPM_HANDLE& pcrHandle, 
    const ByteVec& auth
)
{
    TPM2_PCR_SetAuthValue_REQUEST _req(pcrHandle,auth);
    PCR_SetAuthValueResponse _resp;
    theTpm.DispatchOut(TPM_CC::PCR_SetAuthValue, &_req);
}

void Tpm2::AsyncMethods::PCR_Reset(const TPM_HANDLE& pcrHandle)
{
    TPM2_PCR_Reset_REQUEST _req(pcrHandle);
    PCR_ResetResponse _resp;
    theTpm.DispatchOut(TPM_CC::PCR_Reset, &_req);
}

void Tpm2::AsyncMethods::PolicySigned
(
    const TPM_HANDLE& authObject, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration, 
    const TPMU_SIGNATURE& auth
)
{
    TPM2_PolicySigned_REQUEST _req(authObject,policySession,nonceTPM,cpHashA,policyRef,expiration,auth);
    PolicySignedResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicySigned, &_req);
}

void Tpm2::AsyncMethods::PolicySecret
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& policySession, 
    const ByteVec& nonceTPM, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    INT32 expiration
)
{
    TPM2_PolicySecret_REQUEST _req(authHandle,policySession,nonceTPM,cpHashA,policyRef,expiration);
    PolicySecretResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicySecret, &_req);
}

void Tpm2::AsyncMethods::PolicyTicket
(
    const TPM_HANDLE& policySession, 
    const ByteVec& timeout, 
    const ByteVec& cpHashA, 
    const ByteVec& policyRef, 
    const ByteVec& authName, 
    const TPMT_TK_AUTH& ticket
)
{
    TPM2_PolicyTicket_REQUEST _req(policySession,timeout,cpHashA,policyRef,authName,ticket);
    PolicyTicketResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyTicket, &_req);
}

void Tpm2::AsyncMethods::PolicyOR
(
    const TPM_HANDLE& policySession, 
    const vector<TPM2B_DIGEST>& pHashList
)
{
    TPM2_PolicyOR_REQUEST _req(policySession,pHashList);
    PolicyORResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyOR, &_req);
}

void Tpm2::AsyncMethods::PolicyPCR
(
    const TPM_HANDLE& policySession, 
    const ByteVec& pcrDigest, 
    const vector<TPMS_PCR_SELECTION>& pcrs
)
{
    TPM2_PolicyPCR_REQUEST _req(policySession,pcrDigest,pcrs);
    PolicyPCRResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyPCR, &_req);
}

void Tpm2::AsyncMethods::PolicyLocality
(
    const TPM_HANDLE& policySession, 
    TPMA_LOCALITY locality
)
{
    TPM2_PolicyLocality_REQUEST _req(policySession,locality);
    PolicyLocalityResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyLocality, &_req);
}

void Tpm2::AsyncMethods::PolicyNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyNV_REQUEST _req(authHandle,nvIndex,policySession,operandB,offset,operation);
    PolicyNVResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyNV, &_req);
}

void Tpm2::AsyncMethods::PolicyCounterTimer
(
    const TPM_HANDLE& policySession, 
    const ByteVec& operandB, 
    UINT16 offset, 
    TPM_EO operation
)
{
    TPM2_PolicyCounterTimer_REQUEST _req(policySession,operandB,offset,operation);
    PolicyCounterTimerResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyCounterTimer, &_req);
}

void Tpm2::AsyncMethods::PolicyCommandCode
(
    const TPM_HANDLE& policySession, 
    TPM_CC code
)
{
    TPM2_PolicyCommandCode_REQUEST _req(policySession,code);
    PolicyCommandCodeResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyCommandCode, &_req);
}

void Tpm2::AsyncMethods::PolicyPhysicalPresence(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPhysicalPresence_REQUEST _req(policySession);
    PolicyPhysicalPresenceResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyPhysicalPresence, &_req);
}

void Tpm2::AsyncMethods::PolicyCpHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& cpHashA
)
{
    TPM2_PolicyCpHash_REQUEST _req(policySession,cpHashA);
    PolicyCpHashResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyCpHash, &_req);
}

void Tpm2::AsyncMethods::PolicyNameHash
(
    const TPM_HANDLE& policySession, 
    const ByteVec& nameHash
)
{
    TPM2_PolicyNameHash_REQUEST _req(policySession,nameHash);
    PolicyNameHashResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyNameHash, &_req);
}

void Tpm2::AsyncMethods::PolicyDuplicationSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& newParentName, 
    BYTE includeObject
)
{
    TPM2_PolicyDuplicationSelect_REQUEST _req(policySession,objectName,newParentName,includeObject);
    PolicyDuplicationSelectResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyDuplicationSelect, &_req);
}

void Tpm2::AsyncMethods::PolicyAuthorize
(
    const TPM_HANDLE& policySession, 
    const ByteVec& approvedPolicy, 
    const ByteVec& policyRef, 
    const ByteVec& keySign, 
    const TPMT_TK_VERIFIED& checkTicket
)
{
    TPM2_PolicyAuthorize_REQUEST _req(policySession,approvedPolicy,policyRef,keySign,checkTicket);
    PolicyAuthorizeResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyAuthorize, &_req);
}

void Tpm2::AsyncMethods::PolicyAuthValue(const TPM_HANDLE& policySession)
{
    TPM2_PolicyAuthValue_REQUEST _req(policySession);
    PolicyAuthValueResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyAuthValue, &_req);
}

void Tpm2::AsyncMethods::PolicyPassword(const TPM_HANDLE& policySession)
{
    TPM2_PolicyPassword_REQUEST _req(policySession);
    PolicyPasswordResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyPassword, &_req);
}

void Tpm2::AsyncMethods::PolicyGetDigest(const TPM_HANDLE& policySession)
{
    TPM2_PolicyGetDigest_REQUEST _req(policySession);
    PolicyGetDigestResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyGetDigest, &_req);
}

void Tpm2::AsyncMethods::PolicyNvWritten
(
    const TPM_HANDLE& policySession, 
    BYTE writtenSet
)
{
    TPM2_PolicyNvWritten_REQUEST _req(policySession,writtenSet);
    PolicyNvWrittenResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyNvWritten, &_req);
}

void Tpm2::AsyncMethods::PolicyTemplate
(
    const TPM_HANDLE& policySession, 
    const ByteVec& templateHash
)
{
    TPM2_PolicyTemplate_REQUEST _req(policySession,templateHash);
    PolicyTemplateResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyTemplate, &_req);
}

void Tpm2::AsyncMethods::PolicyAuthorizeNV
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& policySession
)
{
    TPM2_PolicyAuthorizeNV_REQUEST _req(authHandle,nvIndex,policySession);
    PolicyAuthorizeNVResponse _resp;
    theTpm.DispatchOut(TPM_CC::PolicyAuthorizeNV, &_req);
}

void Tpm2::AsyncMethods::CreatePrimary
(
    const TPM_HANDLE& primaryHandle, 
    const TPMS_SENSITIVE_CREATE& inSensitive, 
    const TPMT_PUBLIC& inPublic, 
    const ByteVec& outsideInfo, 
    const vector<TPMS_PCR_SELECTION>& creationPCR
)
{
    TPM2_CreatePrimary_REQUEST _req(primaryHandle,inSensitive,inPublic,outsideInfo,creationPCR);
    CreatePrimaryResponse _resp;
    theTpm.DispatchOut(TPM_CC::CreatePrimary, &_req);
}

void Tpm2::AsyncMethods::HierarchyControl
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& enable, 
    BYTE state
)
{
    TPM2_HierarchyControl_REQUEST _req(authHandle,enable,state);
    HierarchyControlResponse _resp;
    theTpm.DispatchOut(TPM_CC::HierarchyControl, &_req);
}

void Tpm2::AsyncMethods::SetPrimaryPolicy
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& authPolicy, 
    TPM_ALG_ID hashAlg
)
{
    TPM2_SetPrimaryPolicy_REQUEST _req(authHandle,authPolicy,hashAlg);
    SetPrimaryPolicyResponse _resp;
    theTpm.DispatchOut(TPM_CC::SetPrimaryPolicy, &_req);
}

void Tpm2::AsyncMethods::ChangePPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangePPS_REQUEST _req(authHandle);
    ChangePPSResponse _resp;
    theTpm.DispatchOut(TPM_CC::ChangePPS, &_req);
}

void Tpm2::AsyncMethods::ChangeEPS(const TPM_HANDLE& authHandle)
{
    TPM2_ChangeEPS_REQUEST _req(authHandle);
    ChangeEPSResponse _resp;
    theTpm.DispatchOut(TPM_CC::ChangeEPS, &_req);
}

void Tpm2::AsyncMethods::Clear(const TPM_HANDLE& authHandle)
{
    TPM2_Clear_REQUEST _req(authHandle);
    ClearResponse _resp;
    theTpm.DispatchOut(TPM_CC::Clear, &_req);
}

void Tpm2::AsyncMethods::ClearControl
(
    const TPM_HANDLE& auth, 
    BYTE disable
)
{
    TPM2_ClearControl_REQUEST _req(auth,disable);
    ClearControlResponse _resp;
    theTpm.DispatchOut(TPM_CC::ClearControl, &_req);
}

void Tpm2::AsyncMethods::HierarchyChangeAuth
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& newAuth
)
{
    TPM2_HierarchyChangeAuth_REQUEST _req(authHandle,newAuth);
    HierarchyChangeAuthResponse _resp;
    theTpm.DispatchOut(TPM_CC::HierarchyChangeAuth, &_req);
}

void Tpm2::AsyncMethods::DictionaryAttackLockReset(const TPM_HANDLE& lockHandle)
{
    TPM2_DictionaryAttackLockReset_REQUEST _req(lockHandle);
    DictionaryAttackLockResetResponse _resp;
    theTpm.DispatchOut(TPM_CC::DictionaryAttackLockReset, &_req);
}

void Tpm2::AsyncMethods::DictionaryAttackParameters
(
    const TPM_HANDLE& lockHandle, 
    UINT32 newMaxTries, 
    UINT32 newRecoveryTime, 
    UINT32 lockoutRecovery
)
{
    TPM2_DictionaryAttackParameters_REQUEST _req(lockHandle,newMaxTries,newRecoveryTime,lockoutRecovery);
    DictionaryAttackParametersResponse _resp;
    theTpm.DispatchOut(TPM_CC::DictionaryAttackParameters, &_req);
}

void Tpm2::AsyncMethods::PP_Commands
(
    const TPM_HANDLE& auth, 
    const vector<TPM_CC>& setList, 
    const vector<TPM_CC>& clearList
)
{
    TPM2_PP_Commands_REQUEST _req(auth,setList,clearList);
    PP_CommandsResponse _resp;
    theTpm.DispatchOut(TPM_CC::PP_Commands, &_req);
}

void Tpm2::AsyncMethods::SetAlgorithmSet
(
    const TPM_HANDLE& authHandle, 
    UINT32 algorithmSet
)
{
    TPM2_SetAlgorithmSet_REQUEST _req(authHandle,algorithmSet);
    SetAlgorithmSetResponse _resp;
    theTpm.DispatchOut(TPM_CC::SetAlgorithmSet, &_req);
}

void Tpm2::AsyncMethods::FieldUpgradeStart
(
    const TPM_HANDLE& authorization, 
    const TPM_HANDLE& keyHandle, 
    const ByteVec& fuDigest, 
    const TPMU_SIGNATURE& manifestSignature
)
{
    TPM2_FieldUpgradeStart_REQUEST _req(authorization,keyHandle,fuDigest,manifestSignature);
    FieldUpgradeStartResponse _resp;
    theTpm.DispatchOut(TPM_CC::FieldUpgradeStart, &_req);
}

void Tpm2::AsyncMethods::FieldUpgradeData(const ByteVec& fuData)
{
    TPM2_FieldUpgradeData_REQUEST _req(fuData);
    FieldUpgradeDataResponse _resp;
    theTpm.DispatchOut(TPM_CC::FieldUpgradeData, &_req);
}

void Tpm2::AsyncMethods::FirmwareRead(UINT32 sequenceNumber)
{
    TPM2_FirmwareRead_REQUEST _req(sequenceNumber);
    FirmwareReadResponse _resp;
    theTpm.DispatchOut(TPM_CC::FirmwareRead, &_req);
}

void Tpm2::AsyncMethods::ContextSave(const TPM_HANDLE& saveHandle)
{
    TPM2_ContextSave_REQUEST _req(saveHandle);
    ContextSaveResponse _resp;
    theTpm.DispatchOut(TPM_CC::ContextSave, &_req);
}

void Tpm2::AsyncMethods::ContextLoad(const TPMS_CONTEXT& context)
{
    TPM2_ContextLoad_REQUEST _req(context);
    ContextLoadResponse _resp;
    theTpm.DispatchOut(TPM_CC::ContextLoad, &_req);
}

void Tpm2::AsyncMethods::FlushContext(const TPM_HANDLE& flushHandle)
{
    TPM2_FlushContext_REQUEST _req(flushHandle);
    FlushContextResponse _resp;
    theTpm.DispatchOut(TPM_CC::FlushContext, &_req);
}

void Tpm2::AsyncMethods::EvictControl
(
    const TPM_HANDLE& auth, 
    const TPM_HANDLE& objectHandle, 
    const TPM_HANDLE& persistentHandle
)
{
    TPM2_EvictControl_REQUEST _req(auth,objectHandle,persistentHandle);
    EvictControlResponse _resp;
    theTpm.DispatchOut(TPM_CC::EvictControl, &_req);
}

void Tpm2::AsyncMethods::ReadClock()
{
    ReadClockResponse _resp;
    theTpm.DispatchOut(TPM_CC::ReadClock, NULL);
}

void Tpm2::AsyncMethods::ClockSet
(
    const TPM_HANDLE& auth, 
    UINT64 newTime
)
{
    TPM2_ClockSet_REQUEST _req(auth,newTime);
    ClockSetResponse _resp;
    theTpm.DispatchOut(TPM_CC::ClockSet, &_req);
}

void Tpm2::AsyncMethods::ClockRateAdjust
(
    const TPM_HANDLE& auth, 
    TPM_CLOCK_ADJUST rateAdjust
)
{
    TPM2_ClockRateAdjust_REQUEST _req(auth,rateAdjust);
    ClockRateAdjustResponse _resp;
    theTpm.DispatchOut(TPM_CC::ClockRateAdjust, &_req);
}

void Tpm2::AsyncMethods::GetCapability
(
    TPM_CAP capability, 
    UINT32 property, 
    UINT32 propertyCount
)
{
    TPM2_GetCapability_REQUEST _req(capability,property,propertyCount);
    GetCapabilityResponse _resp;
    theTpm.DispatchOut(TPM_CC::GetCapability, &_req);
}

void Tpm2::AsyncMethods::TestParms(const TPMU_PUBLIC_PARMS& parameters)
{
    TPM2_TestParms_REQUEST _req(parameters);
    TestParmsResponse _resp;
    theTpm.DispatchOut(TPM_CC::TestParms, &_req);
}

void Tpm2::AsyncMethods::NV_DefineSpace
(
    const TPM_HANDLE& authHandle, 
    const ByteVec& auth, 
    const TPMS_NV_PUBLIC& publicInfo
)
{
    TPM2_NV_DefineSpace_REQUEST _req(authHandle,auth,publicInfo);
    NV_DefineSpaceResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_DefineSpace, &_req);
}

void Tpm2::AsyncMethods::NV_UndefineSpace
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_UndefineSpace_REQUEST _req(authHandle,nvIndex);
    NV_UndefineSpaceResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_UndefineSpace, &_req);
}

void Tpm2::AsyncMethods::NV_UndefineSpaceSpecial
(
    const TPM_HANDLE& nvIndex, 
    const TPM_HANDLE& platform
)
{
    TPM2_NV_UndefineSpaceSpecial_REQUEST _req(nvIndex,platform);
    NV_UndefineSpaceSpecialResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_UndefineSpaceSpecial, &_req);
}

void Tpm2::AsyncMethods::NV_ReadPublic(const TPM_HANDLE& nvIndex)
{
    TPM2_NV_ReadPublic_REQUEST _req(nvIndex);
    NV_ReadPublicResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_ReadPublic, &_req);
}

void Tpm2::AsyncMethods::NV_Write
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data, 
    UINT16 offset
)
{
    TPM2_NV_Write_REQUEST _req(authHandle,nvIndex,data,offset);
    NV_WriteResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_Write, &_req);
}

void Tpm2::AsyncMethods::NV_Increment
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_Increment_REQUEST _req(authHandle,nvIndex);
    NV_IncrementResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_Increment, &_req);
}

void Tpm2::AsyncMethods::NV_Extend
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& data
)
{
    TPM2_NV_Extend_REQUEST _req(authHandle,nvIndex,data);
    NV_ExtendResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_Extend, &_req);
}

void Tpm2::AsyncMethods::NV_SetBits
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT64 bits
)
{
    TPM2_NV_SetBits_REQUEST _req(authHandle,nvIndex,bits);
    NV_SetBitsResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_SetBits, &_req);
}

void Tpm2::AsyncMethods::NV_WriteLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_WriteLock_REQUEST _req(authHandle,nvIndex);
    NV_WriteLockResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_WriteLock, &_req);
}

void Tpm2::AsyncMethods::NV_GlobalWriteLock(const TPM_HANDLE& authHandle)
{
    TPM2_NV_GlobalWriteLock_REQUEST _req(authHandle);
    NV_GlobalWriteLockResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_GlobalWriteLock, &_req);
}

void Tpm2::AsyncMethods::NV_Read
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Read_REQUEST _req(authHandle,nvIndex,size,offset);
    NV_ReadResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_Read, &_req);
}

void Tpm2::AsyncMethods::NV_ReadLock
(
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex
)
{
    TPM2_NV_ReadLock_REQUEST _req(authHandle,nvIndex);
    NV_ReadLockResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_ReadLock, &_req);
}

void Tpm2::AsyncMethods::NV_ChangeAuth
(
    const TPM_HANDLE& nvIndex, 
    const ByteVec& newAuth
)
{
    TPM2_NV_ChangeAuth_REQUEST _req(nvIndex,newAuth);
    NV_ChangeAuthResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_ChangeAuth, &_req);
}

void Tpm2::AsyncMethods::NV_Certify
(
    const TPM_HANDLE& signHandle, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& nvIndex, 
    const ByteVec& qualifyingData, 
    const TPMU_SIG_SCHEME& inScheme, 
    UINT16 size, 
    UINT16 offset
)
{
    TPM2_NV_Certify_REQUEST _req(signHandle,authHandle,nvIndex,qualifyingData,inScheme,size,offset);
    NV_CertifyResponse _resp;
    theTpm.DispatchOut(TPM_CC::NV_Certify, &_req);
}

void Tpm2::AsyncMethods::AC_GetCapability
(
    const TPM_HANDLE& ac, 
    TPM_AT capability, 
    UINT32 count
)
{
    TPM2_AC_GetCapability_REQUEST _req(ac,capability,count);
    AC_GetCapabilityResponse _resp;
    theTpm.DispatchOut(TPM_CC::AC_GetCapability, &_req);
}

void Tpm2::AsyncMethods::AC_Send
(
    const TPM_HANDLE& sendObject, 
    const TPM_HANDLE& authHandle, 
    const TPM_HANDLE& ac, 
    const ByteVec& acDataIn
)
{
    TPM2_AC_Send_REQUEST _req(sendObject,authHandle,ac,acDataIn);
    AC_SendResponse _resp;
    theTpm.DispatchOut(TPM_CC::AC_Send, &_req);
}

void Tpm2::AsyncMethods::Policy_AC_SendSelect
(
    const TPM_HANDLE& policySession, 
    const ByteVec& objectName, 
    const ByteVec& authHandleName, 
    const ByteVec& acName, 
    BYTE includeObject
)
{
    TPM2_Policy_AC_SendSelect_REQUEST _req(policySession,objectName,authHandleName,acName,includeObject);
    Policy_AC_SendSelectResponse _resp;
    theTpm.DispatchOut(TPM_CC::Policy_AC_SendSelect, &_req);
}

void Tpm2::AsyncMethods::ACT_SetTimeout
(
    const TPM_HANDLE& actHandle, 
    UINT32 startTimeout
)
{
    TPM2_ACT_SetTimeout_REQUEST _req(actHandle,startTimeout);
    ACT_SetTimeoutResponse _resp;
    theTpm.DispatchOut(TPM_CC::ACT_SetTimeout, &_req);
}

void Tpm2::AsyncMethods::Vendor_TCG_Test(const ByteVec& inputData)
{
    TPM2_Vendor_TCG_Test_REQUEST _req(inputData);
    Vendor_TCG_TestResponse _resp;
    theTpm.DispatchOut(TPM_CC::Vendor_TCG_Test, &_req);
}

void Tpm2::AsyncMethods::StartupComplete()
{
    StartupResponse _resp;
    theTpm.DispatchIn(TPM_CC::Startup, TpmTypeId::StartupResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::ShutdownComplete()
{
    ShutdownResponse _resp;
    theTpm.DispatchIn(TPM_CC::Shutdown, TpmTypeId::ShutdownResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::SelfTestComplete()
{
    SelfTestResponse _resp;
    theTpm.DispatchIn(TPM_CC::SelfTest, TpmTypeId::SelfTestResponse_ID, &_resp);
}

vector<TPM_ALG_ID> Tpm2::AsyncMethods::IncrementalSelfTestComplete()
{
    IncrementalSelfTestResponse _resp;
    theTpm.DispatchIn(TPM_CC::IncrementalSelfTest, TpmTypeId::IncrementalSelfTestResponse_ID, &_resp);
    return _resp.toDoList;
}

GetTestResultResponse Tpm2::AsyncMethods::GetTestResultComplete()
{
    GetTestResultResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetTestResult, TpmTypeId::GetTestResultResponse_ID, &_resp);
    return _resp;
}

StartAuthSessionResponse Tpm2::AsyncMethods::StartAuthSessionComplete()
{
    StartAuthSessionResponse _resp;
    theTpm.DispatchIn(TPM_CC::StartAuthSession, TpmTypeId::StartAuthSessionResponse_ID, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::PolicyRestartComplete()
{
    PolicyRestartResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyRestart, TpmTypeId::PolicyRestartResponse_ID, &_resp);
}

CreateResponse Tpm2::AsyncMethods::CreateComplete()
{
    CreateResponse _resp;
    theTpm.DispatchIn(TPM_CC::Create, TpmTypeId::CreateResponse_ID, &_resp);
    return _resp;
}

LoadResponse Tpm2::AsyncMethods::LoadComplete()
{
    LoadResponse _resp;
    theTpm.DispatchIn(TPM_CC::Load, TpmTypeId::LoadResponse_ID, &_resp);
    return _resp;
}

LoadExternalResponse Tpm2::AsyncMethods::LoadExternalComplete()
{
    LoadExternalResponse _resp;
    theTpm.DispatchIn(TPM_CC::LoadExternal, TpmTypeId::LoadExternalResponse_ID, &_resp);
    return _resp;
}

ReadPublicResponse Tpm2::AsyncMethods::ReadPublicComplete()
{
    ReadPublicResponse _resp;
    theTpm.DispatchIn(TPM_CC::ReadPublic, TpmTypeId::ReadPublicResponse_ID, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::ActivateCredentialComplete()
{
    ActivateCredentialResponse _resp;
    theTpm.DispatchIn(TPM_CC::ActivateCredential, TpmTypeId::ActivateCredentialResponse_ID, &_resp);
    return _resp.certInfo;
}

MakeCredentialResponse Tpm2::AsyncMethods::MakeCredentialComplete()
{
    MakeCredentialResponse _resp;
    theTpm.DispatchIn(TPM_CC::MakeCredential, TpmTypeId::MakeCredentialResponse_ID, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::UnsealComplete()
{
    UnsealResponse _resp;
    theTpm.DispatchIn(TPM_CC::Unseal, TpmTypeId::UnsealResponse_ID, &_resp);
    return _resp.outData;
}

TPM2B_PRIVATE Tpm2::AsyncMethods::ObjectChangeAuthComplete()
{
    ObjectChangeAuthResponse _resp;
    theTpm.DispatchIn(TPM_CC::ObjectChangeAuth, TpmTypeId::ObjectChangeAuthResponse_ID, &_resp);
    return _resp.outPrivate;
}

CreateLoadedResponse Tpm2::AsyncMethods::CreateLoadedComplete()
{
    CreateLoadedResponse _resp;
    theTpm.DispatchIn(TPM_CC::CreateLoaded, TpmTypeId::CreateLoadedResponse_ID, &_resp);
    return _resp;
}

DuplicateResponse Tpm2::AsyncMethods::DuplicateComplete()
{
    DuplicateResponse _resp;
    theTpm.DispatchIn(TPM_CC::Duplicate, TpmTypeId::DuplicateResponse_ID, &_resp);
    return _resp;
}

RewrapResponse Tpm2::AsyncMethods::RewrapComplete()
{
    RewrapResponse _resp;
    theTpm.DispatchIn(TPM_CC::Rewrap, TpmTypeId::RewrapResponse_ID, &_resp);
    return _resp;
}

TPM2B_PRIVATE Tpm2::AsyncMethods::ImportComplete()
{
    ImportResponse _resp;
    theTpm.DispatchIn(TPM_CC::Import, TpmTypeId::ImportResponse_ID, &_resp);
    return _resp.outPrivate;
}

ByteVec Tpm2::AsyncMethods::RSA_EncryptComplete()
{
    RSA_EncryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::RSA_Encrypt, TpmTypeId::RSA_EncryptResponse_ID, &_resp);
    return _resp.outData;
}

ByteVec Tpm2::AsyncMethods::RSA_DecryptComplete()
{
    RSA_DecryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::RSA_Decrypt, TpmTypeId::RSA_DecryptResponse_ID, &_resp);
    return _resp.message;
}

ECDH_KeyGenResponse Tpm2::AsyncMethods::ECDH_KeyGenComplete()
{
    ECDH_KeyGenResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECDH_KeyGen, TpmTypeId::ECDH_KeyGenResponse_ID, &_resp);
    return _resp;
}

TPMS_ECC_POINT Tpm2::AsyncMethods::ECDH_ZGenComplete()
{
    ECDH_ZGenResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECDH_ZGen, TpmTypeId::ECDH_ZGenResponse_ID, &_resp);
    return _resp.outPoint;
}

TPMS_ALGORITHM_DETAIL_ECC Tpm2::AsyncMethods::ECC_ParametersComplete()
{
    ECC_ParametersResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECC_Parameters, TpmTypeId::ECC_ParametersResponse_ID, &_resp);
    return _resp.parameters;
}

ZGen_2PhaseResponse Tpm2::AsyncMethods::ZGen_2PhaseComplete()
{
    ZGen_2PhaseResponse _resp;
    theTpm.DispatchIn(TPM_CC::ZGen_2Phase, TpmTypeId::ZGen_2PhaseResponse_ID, &_resp);
    return _resp;
}

ECC_EncryptResponse Tpm2::AsyncMethods::ECC_EncryptComplete()
{
    ECC_EncryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECC_Encrypt, TpmTypeId::ECC_EncryptResponse_ID, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::ECC_DecryptComplete()
{
    ECC_DecryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::ECC_Decrypt, TpmTypeId::ECC_DecryptResponse_ID, &_resp);
    return _resp.plainText;
}

EncryptDecryptResponse Tpm2::AsyncMethods::EncryptDecryptComplete()
{
    EncryptDecryptResponse _resp;
    theTpm.DispatchIn(TPM_CC::EncryptDecrypt, TpmTypeId::EncryptDecryptResponse_ID, &_resp);
    return _resp;
}

EncryptDecrypt2Response Tpm2::AsyncMethods::EncryptDecrypt2Complete()
{
    EncryptDecrypt2Response _resp;
    theTpm.DispatchIn(TPM_CC::EncryptDecrypt2, TpmTypeId::EncryptDecrypt2Response_ID, &_resp);
    return _resp;
}

HashResponse Tpm2::AsyncMethods::HashComplete()
{
    HashResponse _resp;
    theTpm.DispatchIn(TPM_CC::Hash, TpmTypeId::HashResponse_ID, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::HMACComplete()
{
    HMACResponse _resp;
    theTpm.DispatchIn(TPM_CC::HMAC, TpmTypeId::HMACResponse_ID, &_resp);
    return _resp.outHMAC;
}

ByteVec Tpm2::AsyncMethods::MACComplete()
{
    MACResponse _resp;
    theTpm.DispatchIn(TPM_CC::MAC, TpmTypeId::MACResponse_ID, &_resp);
    return _resp.outMAC;
}

ByteVec Tpm2::AsyncMethods::GetRandomComplete()
{
    GetRandomResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetRandom, TpmTypeId::GetRandomResponse_ID, &_resp);
    return _resp.randomBytes;
}

void Tpm2::AsyncMethods::StirRandomComplete()
{
    StirRandomResponse _resp;
    theTpm.DispatchIn(TPM_CC::StirRandom, TpmTypeId::StirRandomResponse_ID, &_resp);
}

TPM_HANDLE Tpm2::AsyncMethods::HMAC_StartComplete()
{
    HMAC_StartResponse _resp;
    theTpm.DispatchIn(TPM_CC::HMAC_Start, TpmTypeId::HMAC_StartResponse_ID, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::AsyncMethods::MAC_StartComplete()
{
    MAC_StartResponse _resp;
    theTpm.DispatchIn(TPM_CC::MAC_Start, TpmTypeId::MAC_StartResponse_ID, &_resp);
    return _resp.handle;
}

TPM_HANDLE Tpm2::AsyncMethods::HashSequenceStartComplete()
{
    HashSequenceStartResponse _resp;
    theTpm.DispatchIn(TPM_CC::HashSequenceStart, TpmTypeId::HashSequenceStartResponse_ID, &_resp);
    return _resp.handle;
}

void Tpm2::AsyncMethods::SequenceUpdateComplete()
{
    SequenceUpdateResponse _resp;
    theTpm.DispatchIn(TPM_CC::SequenceUpdate, TpmTypeId::SequenceUpdateResponse_ID, &_resp);
}

SequenceCompleteResponse Tpm2::AsyncMethods::SequenceCompleteComplete()
{
    SequenceCompleteResponse _resp;
    theTpm.DispatchIn(TPM_CC::SequenceComplete, TpmTypeId::SequenceCompleteResponse_ID, &_resp);
    return _resp;
}

vector<TPMT_HA> Tpm2::AsyncMethods::EventSequenceCompleteComplete()
{
    EventSequenceCompleteResponse _resp;
    theTpm.DispatchIn(TPM_CC::EventSequenceComplete, TpmTypeId::EventSequenceCompleteResponse_ID, &_resp);
    return _resp.results;
}

CertifyResponse Tpm2::AsyncMethods::CertifyComplete()
{
    CertifyResponse _resp;
    theTpm.DispatchIn(TPM_CC::Certify, TpmTypeId::CertifyResponse_ID, &_resp);
    return _resp;
}

CertifyCreationResponse Tpm2::AsyncMethods::CertifyCreationComplete()
{
    CertifyCreationResponse _resp;
    theTpm.DispatchIn(TPM_CC::CertifyCreation, TpmTypeId::CertifyCreationResponse_ID, &_resp);
    return _resp;
}

QuoteResponse Tpm2::AsyncMethods::QuoteComplete()
{
    QuoteResponse _resp;
    theTpm.DispatchIn(TPM_CC::Quote, TpmTypeId::QuoteResponse_ID, &_resp);
    return _resp;
}

GetSessionAuditDigestResponse Tpm2::AsyncMethods::GetSessionAuditDigestComplete()
{
    GetSessionAuditDigestResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetSessionAuditDigest, TpmTypeId::GetSessionAuditDigestResponse_ID, &_resp);
    return _resp;
}

GetCommandAuditDigestResponse Tpm2::AsyncMethods::GetCommandAuditDigestComplete()
{
    GetCommandAuditDigestResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetCommandAuditDigest, TpmTypeId::GetCommandAuditDigestResponse_ID, &_resp);
    return _resp;
}

GetTimeResponse Tpm2::AsyncMethods::GetTimeComplete()
{
    GetTimeResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetTime, TpmTypeId::GetTimeResponse_ID, &_resp);
    return _resp;
}

CertifyX509Response Tpm2::AsyncMethods::CertifyX509Complete()
{
    CertifyX509Response _resp;
    theTpm.DispatchIn(TPM_CC::CertifyX509, TpmTypeId::CertifyX509Response_ID, &_resp);
    return _resp;
}

CommitResponse Tpm2::AsyncMethods::CommitComplete()
{
    CommitResponse _resp;
    theTpm.DispatchIn(TPM_CC::Commit, TpmTypeId::CommitResponse_ID, &_resp);
    return _resp;
}

EC_EphemeralResponse Tpm2::AsyncMethods::EC_EphemeralComplete()
{
    EC_EphemeralResponse _resp;
    theTpm.DispatchIn(TPM_CC::EC_Ephemeral, TpmTypeId::EC_EphemeralResponse_ID, &_resp);
    return _resp;
}

VerifySignatureResponse Tpm2::AsyncMethods::VerifySignatureComplete()
{
    VerifySignatureResponse _resp;
    theTpm.DispatchIn(TPM_CC::VerifySignature, TpmTypeId::VerifySignatureResponse_ID, &_resp);
    return _resp.validation;
}

SignResponse Tpm2::AsyncMethods::SignComplete()
{
    SignResponse _resp;
    theTpm.DispatchIn(TPM_CC::Sign, TpmTypeId::SignResponse_ID, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::SetCommandCodeAuditStatusComplete()
{
    SetCommandCodeAuditStatusResponse _resp;
    theTpm.DispatchIn(TPM_CC::SetCommandCodeAuditStatus, TpmTypeId::SetCommandCodeAuditStatusResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PCR_ExtendComplete()
{
    PCR_ExtendResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Extend, TpmTypeId::PCR_ExtendResponse_ID, &_resp);
}

vector<TPMT_HA> Tpm2::AsyncMethods::PCR_EventComplete()
{
    PCR_EventResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Event, TpmTypeId::PCR_EventResponse_ID, &_resp);
    return _resp.digests;
}

PCR_ReadResponse Tpm2::AsyncMethods::PCR_ReadComplete()
{
    PCR_ReadResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Read, TpmTypeId::PCR_ReadResponse_ID, &_resp);
    return _resp;
}

PCR_AllocateResponse Tpm2::AsyncMethods::PCR_AllocateComplete()
{
    PCR_AllocateResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Allocate, TpmTypeId::PCR_AllocateResponse_ID, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::PCR_SetAuthPolicyComplete()
{
    PCR_SetAuthPolicyResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_SetAuthPolicy, TpmTypeId::PCR_SetAuthPolicyResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PCR_SetAuthValueComplete()
{
    PCR_SetAuthValueResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_SetAuthValue, TpmTypeId::PCR_SetAuthValueResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PCR_ResetComplete()
{
    PCR_ResetResponse _resp;
    theTpm.DispatchIn(TPM_CC::PCR_Reset, TpmTypeId::PCR_ResetResponse_ID, &_resp);
}

PolicySignedResponse Tpm2::AsyncMethods::PolicySignedComplete()
{
    PolicySignedResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicySigned, TpmTypeId::PolicySignedResponse_ID, &_resp);
    return _resp;
}

PolicySecretResponse Tpm2::AsyncMethods::PolicySecretComplete()
{
    PolicySecretResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicySecret, TpmTypeId::PolicySecretResponse_ID, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::PolicyTicketComplete()
{
    PolicyTicketResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyTicket, TpmTypeId::PolicyTicketResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyORComplete()
{
    PolicyORResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyOR, TpmTypeId::PolicyORResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyPCRComplete()
{
    PolicyPCRResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyPCR, TpmTypeId::PolicyPCRResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyLocalityComplete()
{
    PolicyLocalityResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyLocality, TpmTypeId::PolicyLocalityResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyNVComplete()
{
    PolicyNVResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyNV, TpmTypeId::PolicyNVResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyCounterTimerComplete()
{
    PolicyCounterTimerResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyCounterTimer, TpmTypeId::PolicyCounterTimerResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyCommandCodeComplete()
{
    PolicyCommandCodeResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyCommandCode, TpmTypeId::PolicyCommandCodeResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyPhysicalPresenceComplete()
{
    PolicyPhysicalPresenceResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyPhysicalPresence, TpmTypeId::PolicyPhysicalPresenceResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyCpHashComplete()
{
    PolicyCpHashResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyCpHash, TpmTypeId::PolicyCpHashResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyNameHashComplete()
{
    PolicyNameHashResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyNameHash, TpmTypeId::PolicyNameHashResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyDuplicationSelectComplete()
{
    PolicyDuplicationSelectResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyDuplicationSelect, TpmTypeId::PolicyDuplicationSelectResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyAuthorizeComplete()
{
    PolicyAuthorizeResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyAuthorize, TpmTypeId::PolicyAuthorizeResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyAuthValueComplete()
{
    PolicyAuthValueResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyAuthValue, TpmTypeId::PolicyAuthValueResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyPasswordComplete()
{
    PolicyPasswordResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyPassword, TpmTypeId::PolicyPasswordResponse_ID, &_resp);
}

ByteVec Tpm2::AsyncMethods::PolicyGetDigestComplete()
{
    PolicyGetDigestResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyGetDigest, TpmTypeId::PolicyGetDigestResponse_ID, &_resp);
    return _resp.policyDigest;
}

void Tpm2::AsyncMethods::PolicyNvWrittenComplete()
{
    PolicyNvWrittenResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyNvWritten, TpmTypeId::PolicyNvWrittenResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyTemplateComplete()
{
    PolicyTemplateResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyTemplate, TpmTypeId::PolicyTemplateResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PolicyAuthorizeNVComplete()
{
    PolicyAuthorizeNVResponse _resp;
    theTpm.DispatchIn(TPM_CC::PolicyAuthorizeNV, TpmTypeId::PolicyAuthorizeNVResponse_ID, &_resp);
}

CreatePrimaryResponse Tpm2::AsyncMethods::CreatePrimaryComplete()
{
    CreatePrimaryResponse _resp;
    theTpm.DispatchIn(TPM_CC::CreatePrimary, TpmTypeId::CreatePrimaryResponse_ID, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::HierarchyControlComplete()
{
    HierarchyControlResponse _resp;
    theTpm.DispatchIn(TPM_CC::HierarchyControl, TpmTypeId::HierarchyControlResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::SetPrimaryPolicyComplete()
{
    SetPrimaryPolicyResponse _resp;
    theTpm.DispatchIn(TPM_CC::SetPrimaryPolicy, TpmTypeId::SetPrimaryPolicyResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::ChangePPSComplete()
{
    ChangePPSResponse _resp;
    theTpm.DispatchIn(TPM_CC::ChangePPS, TpmTypeId::ChangePPSResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::ChangeEPSComplete()
{
    ChangeEPSResponse _resp;
    theTpm.DispatchIn(TPM_CC::ChangeEPS, TpmTypeId::ChangeEPSResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::ClearComplete()
{
    ClearResponse _resp;
    theTpm.DispatchIn(TPM_CC::Clear, TpmTypeId::ClearResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::ClearControlComplete()
{
    ClearControlResponse _resp;
    theTpm.DispatchIn(TPM_CC::ClearControl, TpmTypeId::ClearControlResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::HierarchyChangeAuthComplete()
{
    HierarchyChangeAuthResponse _resp;
    theTpm.DispatchIn(TPM_CC::HierarchyChangeAuth, TpmTypeId::HierarchyChangeAuthResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::DictionaryAttackLockResetComplete()
{
    DictionaryAttackLockResetResponse _resp;
    theTpm.DispatchIn(TPM_CC::DictionaryAttackLockReset, TpmTypeId::DictionaryAttackLockResetResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::DictionaryAttackParametersComplete()
{
    DictionaryAttackParametersResponse _resp;
    theTpm.DispatchIn(TPM_CC::DictionaryAttackParameters, TpmTypeId::DictionaryAttackParametersResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::PP_CommandsComplete()
{
    PP_CommandsResponse _resp;
    theTpm.DispatchIn(TPM_CC::PP_Commands, TpmTypeId::PP_CommandsResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::SetAlgorithmSetComplete()
{
    SetAlgorithmSetResponse _resp;
    theTpm.DispatchIn(TPM_CC::SetAlgorithmSet, TpmTypeId::SetAlgorithmSetResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::FieldUpgradeStartComplete()
{
    FieldUpgradeStartResponse _resp;
    theTpm.DispatchIn(TPM_CC::FieldUpgradeStart, TpmTypeId::FieldUpgradeStartResponse_ID, &_resp);
}

FieldUpgradeDataResponse Tpm2::AsyncMethods::FieldUpgradeDataComplete()
{
    FieldUpgradeDataResponse _resp;
    theTpm.DispatchIn(TPM_CC::FieldUpgradeData, TpmTypeId::FieldUpgradeDataResponse_ID, &_resp);
    return _resp;
}

ByteVec Tpm2::AsyncMethods::FirmwareReadComplete()
{
    FirmwareReadResponse _resp;
    theTpm.DispatchIn(TPM_CC::FirmwareRead, TpmTypeId::FirmwareReadResponse_ID, &_resp);
    return _resp.fuData;
}

TPMS_CONTEXT Tpm2::AsyncMethods::ContextSaveComplete()
{
    ContextSaveResponse _resp;
    theTpm.DispatchIn(TPM_CC::ContextSave, TpmTypeId::ContextSaveResponse_ID, &_resp);
    return _resp.context;
}

TPM_HANDLE Tpm2::AsyncMethods::ContextLoadComplete()
{
    ContextLoadResponse _resp;
    theTpm.DispatchIn(TPM_CC::ContextLoad, TpmTypeId::ContextLoadResponse_ID, &_resp);
    return _resp.handle;
}

void Tpm2::AsyncMethods::FlushContextComplete()
{
    FlushContextResponse _resp;
    theTpm.DispatchIn(TPM_CC::FlushContext, TpmTypeId::FlushContextResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::EvictControlComplete()
{
    EvictControlResponse _resp;
    theTpm.DispatchIn(TPM_CC::EvictControl, TpmTypeId::EvictControlResponse_ID, &_resp);
}

TPMS_TIME_INFO Tpm2::AsyncMethods::ReadClockComplete()
{
    ReadClockResponse _resp;
    theTpm.DispatchIn(TPM_CC::ReadClock, TpmTypeId::ReadClockResponse_ID, &_resp);
    return _resp.currentTime;
}

void Tpm2::AsyncMethods::ClockSetComplete()
{
    ClockSetResponse _resp;
    theTpm.DispatchIn(TPM_CC::ClockSet, TpmTypeId::ClockSetResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::ClockRateAdjustComplete()
{
    ClockRateAdjustResponse _resp;
    theTpm.DispatchIn(TPM_CC::ClockRateAdjust, TpmTypeId::ClockRateAdjustResponse_ID, &_resp);
}

GetCapabilityResponse Tpm2::AsyncMethods::GetCapabilityComplete()
{
    GetCapabilityResponse _resp;
    theTpm.DispatchIn(TPM_CC::GetCapability, TpmTypeId::GetCapabilityResponse_ID, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::TestParmsComplete()
{
    TestParmsResponse _resp;
    theTpm.DispatchIn(TPM_CC::TestParms, TpmTypeId::TestParmsResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_DefineSpaceComplete()
{
    NV_DefineSpaceResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_DefineSpace, TpmTypeId::NV_DefineSpaceResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_UndefineSpaceComplete()
{
    NV_UndefineSpaceResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_UndefineSpace, TpmTypeId::NV_UndefineSpaceResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_UndefineSpaceSpecialComplete()
{
    NV_UndefineSpaceSpecialResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_UndefineSpaceSpecial, TpmTypeId::NV_UndefineSpaceSpecialResponse_ID, &_resp);
}

NV_ReadPublicResponse Tpm2::AsyncMethods::NV_ReadPublicComplete()
{
    NV_ReadPublicResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_ReadPublic, TpmTypeId::NV_ReadPublicResponse_ID, &_resp);
    return _resp;
}

void Tpm2::AsyncMethods::NV_WriteComplete()
{
    NV_WriteResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_Write, TpmTypeId::NV_WriteResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_IncrementComplete()
{
    NV_IncrementResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_Increment, TpmTypeId::NV_IncrementResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_ExtendComplete()
{
    NV_ExtendResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_Extend, TpmTypeId::NV_ExtendResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_SetBitsComplete()
{
    NV_SetBitsResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_SetBits, TpmTypeId::NV_SetBitsResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_WriteLockComplete()
{
    NV_WriteLockResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_WriteLock, TpmTypeId::NV_WriteLockResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_GlobalWriteLockComplete()
{
    NV_GlobalWriteLockResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_GlobalWriteLock, TpmTypeId::NV_GlobalWriteLockResponse_ID, &_resp);
}

ByteVec Tpm2::AsyncMethods::NV_ReadComplete()
{
    NV_ReadResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_Read, TpmTypeId::NV_ReadResponse_ID, &_resp);
    return _resp.data;
}

void Tpm2::AsyncMethods::NV_ReadLockComplete()
{
    NV_ReadLockResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_ReadLock, TpmTypeId::NV_ReadLockResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::NV_ChangeAuthComplete()
{
    NV_ChangeAuthResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_ChangeAuth, TpmTypeId::NV_ChangeAuthResponse_ID, &_resp);
}

NV_CertifyResponse Tpm2::AsyncMethods::NV_CertifyComplete()
{
    NV_CertifyResponse _resp;
    theTpm.DispatchIn(TPM_CC::NV_Certify, TpmTypeId::NV_CertifyResponse_ID, &_resp);
    return _resp;
}

AC_GetCapabilityResponse Tpm2::AsyncMethods::AC_GetCapabilityComplete()
{
    AC_GetCapabilityResponse _resp;
    theTpm.DispatchIn(TPM_CC::AC_GetCapability, TpmTypeId::AC_GetCapabilityResponse_ID, &_resp);
    return _resp;
}

TPMS_AC_OUTPUT Tpm2::AsyncMethods::AC_SendComplete()
{
    AC_SendResponse _resp;
    theTpm.DispatchIn(TPM_CC::AC_Send, TpmTypeId::AC_SendResponse_ID, &_resp);
    return _resp.acDataOut;
}

void Tpm2::AsyncMethods::Policy_AC_SendSelectComplete()
{
    Policy_AC_SendSelectResponse _resp;
    theTpm.DispatchIn(TPM_CC::Policy_AC_SendSelect, TpmTypeId::Policy_AC_SendSelectResponse_ID, &_resp);
}

void Tpm2::AsyncMethods::ACT_SetTimeoutComplete()
{
    ACT_SetTimeoutResponse _resp;
    theTpm.DispatchIn(TPM_CC::ACT_SetTimeout, TpmTypeId::ACT_SetTimeoutResponse_ID, &_resp);
}

ByteVec Tpm2::AsyncMethods::Vendor_TCG_TestComplete()
{
    Vendor_TCG_TestResponse _resp;
    theTpm.DispatchIn(TPM_CC::Vendor_TCG_Test, TpmTypeId::Vendor_TCG_TestResponse_ID, &_resp);
    return _resp.outputData;
}

TpmTypeId TPMS_NULL_UNION::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_UNION_ID;
}

/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TPMS_NULL_UNION::~TPMS_NULL_UNION() {}

/// <summary>
/// Base class for empty union elements.
/// An empty union element does not contain any data to marshal.
/// This data structure can be used in place of any other union
/// initialized with its own empty element.
/// </summary>
TpmStructureBase* TPMS_NULL_UNION::Clone() const
{
    return new TPMS_NULL_UNION(*this);
}

void* TPMS_NULL_UNION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId _TPMT_HA::GetTypeId() const
{
    return TpmTypeId::TPMT_HA_ID;
}

_TPMT_HA::_TPMT_HA(
    TPM_ALG_ID _hashAlg,
    const ByteVec& _digest
)
{
    hashAlg = _hashAlg;
    digest = _digest;
}

/// <summary> TPM Hash structure </summary>
_TPMT_HA::~_TPMT_HA() {}

/// <summary> TPM Hash structure </summary>
TpmStructureBase* _TPMT_HA::Clone() const
{
    return new TPMT_HA(dynamic_cast<const TPMT_HA&>(*this));
}

void* _TPMT_HA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId _TPM_HANDLE::GetTypeId() const
{
    return TpmTypeId::TPM_HANDLE_ID;
}

_TPM_HANDLE::_TPM_HANDLE(UINT32 _handle)
{
    handle = _handle;
}

/// <summary> TPM object handle (and related data) </summary>
_TPM_HANDLE::~_TPM_HANDLE() {}

/// <summary> TPM object handle (and related data) </summary>
TpmStructureBase* _TPM_HANDLE::Clone() const
{
    return new TPM_HANDLE(dynamic_cast<const TPM_HANDLE&>(*this));
}

void* _TPM_HANDLE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_EMPTY::GetTypeId() const
{
    return TpmTypeId::TPMS_EMPTY_ID;
}

/// <summary> This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected. </summary>
TPMS_EMPTY::~TPMS_EMPTY() {}

/// <summary> This structure is used as a placeholder. In some cases, a union will have a selector value with no data to unmarshal when that type is selected. Rather than leave the entry empty, TPMS_EMPTY may be selected. </summary>
TpmStructureBase* TPMS_EMPTY::Clone() const
{
    return new TPMS_EMPTY(*this);
}

void* TPMS_EMPTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_ALGORITHM_DESCRIPTION::GetTypeId() const
{
    return TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
}

TPMS_ALGORITHM_DESCRIPTION::TPMS_ALGORITHM_DESCRIPTION(
    TPM_ALG_ID _alg,
    TPMA_ALGORITHM _attributes
)
{
    alg = _alg;
    attributes = _attributes;
}

/// <summary> This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms. </summary>
TPMS_ALGORITHM_DESCRIPTION::~TPMS_ALGORITHM_DESCRIPTION() {}

/// <summary> This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms. </summary>
TpmStructureBase* TPMS_ALGORITHM_DESCRIPTION::Clone() const
{
    return new TPMS_ALGORITHM_DESCRIPTION(*this);
}

void* TPMS_ALGORITHM_DESCRIPTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &alg;
            case 1: return &attributes;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_DIGEST::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_ID;
}

TPM2B_DIGEST::TPM2B_DIGEST(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM. </summary>
TPM2B_DIGEST::~TPM2B_DIGEST() {}

/// <summary> This structure is used for a sized buffer that cannot be larger than the largest digest produced by any hash algorithm implemented on the TPM. </summary>
TpmStructureBase* TPM2B_DIGEST::Clone() const
{
    return new TPM2B_DIGEST(*this);
}

void* TPM2B_DIGEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_DATA_ID;
}

TPM2B_DATA::TPM2B_DATA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used for a data buffer that is required to be no larger than the size of the Name of an object. </summary>
TPM2B_DATA::~TPM2B_DATA() {}

/// <summary> This structure is used for a data buffer that is required to be no larger than the size of the Name of an object. </summary>
TpmStructureBase* TPM2B_DATA::Clone() const
{
    return new TPM2B_DATA(*this);
}

void* TPM2B_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_EVENT::GetTypeId() const
{
    return TpmTypeId::TPM2B_EVENT_ID;
}

TPM2B_EVENT::TPM2B_EVENT(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This type is a sized buffer that can hold event data. </summary>
TPM2B_EVENT::~TPM2B_EVENT() {}

/// <summary> This type is a sized buffer that can hold event data. </summary>
TpmStructureBase* TPM2B_EVENT::Clone() const
{
    return new TPM2B_EVENT(*this);
}

void* TPM2B_EVENT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_MAX_BUFFER::GetTypeId() const
{
    return TpmTypeId::TPM2B_MAX_BUFFER_ID;
}

TPM2B_MAX_BUFFER::TPM2B_MAX_BUFFER(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData(). </summary>
TPM2B_MAX_BUFFER::~TPM2B_MAX_BUFFER() {}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for commands that use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData(). </summary>
TpmStructureBase* TPM2B_MAX_BUFFER::Clone() const
{
    return new TPM2B_MAX_BUFFER(*this);
}

void* TPM2B_MAX_BUFFER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_MAX_NV_BUFFER::GetTypeId() const
{
    return TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
}

TPM2B_MAX_NV_BUFFER::TPM2B_MAX_NV_BUFFER(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify(). </summary>
TPM2B_MAX_NV_BUFFER::~TPM2B_MAX_NV_BUFFER() {}

/// <summary> This type is a sized buffer that can hold a maximally sized buffer for NV data commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify(). </summary>
TpmStructureBase* TPM2B_MAX_NV_BUFFER::Clone() const
{
    return new TPM2B_MAX_NV_BUFFER(*this);
}

void* TPM2B_MAX_NV_BUFFER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_TIMEOUT::GetTypeId() const
{
    return TpmTypeId::TPM2B_TIMEOUT_ID;
}

TPM2B_TIMEOUT::TPM2B_TIMEOUT(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less. </summary>
TPM2B_TIMEOUT::~TPM2B_TIMEOUT() {}

/// <summary> This TPM-dependent structure is used to provide the timeout value for an authorization. The size shall be 8 or less. </summary>
TpmStructureBase* TPM2B_TIMEOUT::Clone() const
{
    return new TPM2B_TIMEOUT(*this);
}

void* TPM2B_TIMEOUT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_IV::GetTypeId() const
{
    return TpmTypeId::TPM2B_IV_ID;
}

TPM2B_IV::TPM2B_IV(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM. </summary>
TPM2B_IV::~TPM2B_IV() {}

/// <summary> This structure is used for passing an initial value for a symmetric block cipher to or from the TPM. The size is set to be the largest block size of any implemented symmetric cipher implemented on the TPM. </summary>
TpmStructureBase* TPM2B_IV::Clone() const
{
    return new TPM2B_IV(*this);
}

void* TPM2B_IV::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_NAME::GetTypeId() const
{
    return TpmTypeId::TPM2B_NAME_ID;
}

TPM2B_NAME::TPM2B_NAME(
    const ByteVec& _name
)
{
    name = _name;
}

/// <summary> This buffer holds a Name for any entity type. </summary>
TPM2B_NAME::~TPM2B_NAME() {}

/// <summary> This buffer holds a Name for any entity type. </summary>
TpmStructureBase* TPM2B_NAME::Clone() const
{
    return new TPM2B_NAME(*this);
}

void* TPM2B_NAME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_PCR_SELECT::GetTypeId() const
{
    return TpmTypeId::TPMS_PCR_SELECT_ID;
}

TPMS_PCR_SELECT::TPMS_PCR_SELECT(
    const ByteVec& _pcrSelect
)
{
    pcrSelect = _pcrSelect;
}

/// <summary> This structure provides a standard method of specifying a list of PCR. </summary>
TPMS_PCR_SELECT::~TPMS_PCR_SELECT() {}

/// <summary> This structure provides a standard method of specifying a list of PCR. </summary>
TpmStructureBase* TPMS_PCR_SELECT::Clone() const
{
    return new TPMS_PCR_SELECT(*this);
}

void* TPMS_PCR_SELECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sizeofSelect;
            case 1: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &pcrSelect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId _TPMS_PCR_SELECTION::GetTypeId() const
{
    return TpmTypeId::TPMS_PCR_SELECTION_ID;
}

_TPMS_PCR_SELECTION::_TPMS_PCR_SELECTION(
    TPM_ALG_ID _hash,
    const ByteVec& _pcrSelect
)
{
    hash = _hash;
    pcrSelect = _pcrSelect;
}

/// <summary> Table 94  Definition of TPMS_PCR_SELECTION Structure </summary>
_TPMS_PCR_SELECTION::~_TPMS_PCR_SELECTION() {}

/// <summary> Table 94  Definition of TPMS_PCR_SELECTION Structure </summary>
TpmStructureBase* _TPMS_PCR_SELECTION::Clone() const
{
    return new TPMS_PCR_SELECTION(dynamic_cast<const TPMS_PCR_SELECTION&>(*this));
}

void* _TPMS_PCR_SELECTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sizeofSelect;
            case 2: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &pcrSelect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMT_TK_CREATION::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_CREATION_ID;
}

TPMT_TK_CREATION::TPMT_TK_CREATION(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by </summary>
TPMT_TK_CREATION::~TPMT_TK_CREATION() {}

/// <summary> This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind the creation data to the object to which it applies. The ticket is computed by </summary>
TpmStructureBase* TPMT_TK_CREATION::Clone() const
{
    return new TPMT_TK_CREATION(*this);
}

void* TPMT_TK_CREATION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMT_TK_VERIFIED::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_VERIFIED_ID;
}

TPMT_TK_VERIFIED::TPMT_TK_VERIFIED(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by </summary>
TPMT_TK_VERIFIED::~TPMT_TK_VERIFIED() {}

/// <summary> This ticket is produced by TPM2_VerifySignature(). This formulation is used for multiple ticket uses. The ticket provides evidence that the TPM has validated that a digest was signed by a key with the Name of keyName. The ticket is computed by </summary>
TpmStructureBase* TPMT_TK_VERIFIED::Clone() const
{
    return new TPMT_TK_VERIFIED(*this);
}

void* TPMT_TK_VERIFIED::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMT_TK_AUTH::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_AUTH_ID;
}

TPMT_TK_AUTH::TPMT_TK_AUTH(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by </summary>
TPMT_TK_AUTH::~TPMT_TK_AUTH() {}

/// <summary> This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the authorization has an expiration time. If nonceTPM was provided in the policy command, the ticket is computed by </summary>
TpmStructureBase* TPMT_TK_AUTH::Clone() const
{
    return new TPMT_TK_AUTH(*this);
}

void* TPMT_TK_AUTH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId _TPMT_TK_HASHCHECK::GetTypeId() const
{
    return TpmTypeId::TPMT_TK_HASHCHECK_ID;
}

_TPMT_TK_HASHCHECK::_TPMT_TK_HASHCHECK(
    TPM_ST _tag,
    const TPM_HANDLE& _hierarchy,
    const ByteVec& _digest
)
{
    tag = _tag;
    hierarchy = _hierarchy;
    digest = _digest;
}

/// <summary> This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by </summary>
_TPMT_TK_HASHCHECK::~_TPMT_TK_HASHCHECK() {}

/// <summary> This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by </summary>
TpmStructureBase* _TPMT_TK_HASHCHECK::Clone() const
{
    return new TPMT_TK_HASHCHECK(dynamic_cast<const TPMT_TK_HASHCHECK&>(*this));
}

void* _TPMT_TK_HASHCHECK::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 2: return &digestSize;
            case 3: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ALG_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPMS_ALG_PROPERTY_ID;
}

TPMS_ALG_PROPERTY::TPMS_ALG_PROPERTY(
    TPM_ALG_ID _alg,
    TPMA_ALGORITHM _algProperties
)
{
    alg = _alg;
    algProperties = _algProperties;
}

/// <summary> This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG. </summary>
TPMS_ALG_PROPERTY::~TPMS_ALG_PROPERTY() {}

/// <summary> This structure is used to report the properties of an algorithm identifier. It is returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG. </summary>
TpmStructureBase* TPMS_ALG_PROPERTY::Clone() const
{
    return new TPMS_ALG_PROPERTY(*this);
}

void* TPMS_ALG_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &alg;
            case 1: return &algProperties;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TAGGED_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
}

TPMS_TAGGED_PROPERTY::TPMS_TAGGED_PROPERTY(
    TPM_PT _property,
    UINT32 _value
)
{
    property = _property;
    value = _value;
}

/// <summary> This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability(). </summary>
TPMS_TAGGED_PROPERTY::~TPMS_TAGGED_PROPERTY() {}

/// <summary> This structure is used to report the properties that are UINT32 values. It is returned in response to a TPM2_GetCapability(). </summary>
TpmStructureBase* TPMS_TAGGED_PROPERTY::Clone() const
{
    return new TPMS_TAGGED_PROPERTY(*this);
}

void* TPMS_TAGGED_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &property;
            case 1: return &value;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TAGGED_PCR_SELECT::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
}

TPMS_TAGGED_PCR_SELECT::TPMS_TAGGED_PCR_SELECT(
    TPM_PT_PCR _tag,
    const ByteVec& _pcrSelect
)
{
    tag = _tag;
    pcrSelect = _pcrSelect;
}

/// <summary> This structure is used in TPM2_GetCapability() to return the attributes of the PCR. </summary>
TPMS_TAGGED_PCR_SELECT::~TPMS_TAGGED_PCR_SELECT() {}

/// <summary> This structure is used in TPM2_GetCapability() to return the attributes of the PCR. </summary>
TpmStructureBase* TPMS_TAGGED_PCR_SELECT::Clone() const
{
    return new TPMS_TAGGED_PCR_SELECT(*this);
}

void* TPMS_TAGGED_PCR_SELECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: return &sizeofSelect;
            case 2: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &pcrSelect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_TAGGED_POLICY::GetTypeId() const
{
    return TpmTypeId::TPMS_TAGGED_POLICY_ID;
}

TPMS_TAGGED_POLICY::TPMS_TAGGED_POLICY(
    const TPM_HANDLE& _handle,
    const TPMT_HA& _policyHash
)
{
    handle = _handle;
    policyHash = _policyHash;
}

/// <summary> This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle. </summary>
TPMS_TAGGED_POLICY::~TPMS_TAGGED_POLICY() {}

/// <summary> This structure is used in TPM2_GetCapability() to return the policy associated with a permanent handle. </summary>
TpmStructureBase* TPMS_TAGGED_POLICY::Clone() const
{
    return new TPMS_TAGGED_POLICY(*this);
}

void* TPMS_TAGGED_POLICY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policyHash); return &policyHash;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ACT_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_ACT_DATA_ID;
}

TPMS_ACT_DATA::TPMS_ACT_DATA(
    const TPM_HANDLE& _handle,
    UINT32 _timeout,
    TPMA_ACT _attributes
)
{
    handle = _handle;
    timeout = _timeout;
    attributes = _attributes;
}

/// <summary> This structure is used in TPM2_GetCapability() to return the ACT data. </summary>
TPMS_ACT_DATA::~TPMS_ACT_DATA() {}

/// <summary> This structure is used in TPM2_GetCapability() to return the ACT data. </summary>
TpmStructureBase* TPMS_ACT_DATA::Clone() const
{
    return new TPMS_ACT_DATA(*this);
}

void* TPMS_ACT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &timeout;
            case 2: return &attributes;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPML_CC::GetTypeId() const
{
    return TpmTypeId::TPML_CC_ID;
}

TPML_CC::TPML_CC(
    const vector<TPM_CC>& _commandCodes
)
{
    commandCodes = _commandCodes;
}

/// <summary> A list of command codes may be input to the TPM or returned by the TPM depending on the command. </summary>
TPML_CC::~TPML_CC() {}

/// <summary> A list of command codes may be input to the TPM or returned by the TPM depending on the command. </summary>
TpmStructureBase* TPML_CC::Clone() const
{
    return new TPML_CC(*this);
}

void* TPML_CC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) commandCodes.resize(newArraySize); arraySize = (int)commandCodes.size(); return &commandCodes; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &commandCodes[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_CCA::GetTypeId() const
{
    return TpmTypeId::TPML_CCA_ID;
}

TPML_CCA::TPML_CCA(
    const vector<TPMA_CC>& _commandAttributes
)
{
    commandAttributes = _commandAttributes;
}

/// <summary> This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS). </summary>
TPML_CCA::~TPML_CCA() {}

/// <summary> This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS). </summary>
TpmStructureBase* TPML_CCA::Clone() const
{
    return new TPML_CCA(*this);
}

void* TPML_CCA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) commandAttributes.resize(newArraySize); arraySize = (int)commandAttributes.size(); return &commandAttributes; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &commandAttributes[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ALG::GetTypeId() const
{
    return TpmTypeId::TPML_ALG_ID;
}

TPML_ALG::TPML_ALG(
    const vector<TPM_ALG_ID>& _algorithms
)
{
    algorithms = _algorithms;
}

/// <summary> This list is returned by TPM2_IncrementalSelfTest(). </summary>
TPML_ALG::~TPML_ALG() {}

/// <summary> This list is returned by TPM2_IncrementalSelfTest(). </summary>
TpmStructureBase* TPML_ALG::Clone() const
{
    return new TPML_ALG(*this);
}

void* TPML_ALG::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) algorithms.resize(newArraySize); arraySize = (int)algorithms.size(); return &algorithms; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &algorithms[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_HANDLE::GetTypeId() const
{
    return TpmTypeId::TPML_HANDLE_ID;
}

TPML_HANDLE::TPML_HANDLE(
    const vector<TPM_HANDLE>& _handle
)
{
    handle = _handle;
}

/// <summary> This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE. </summary>
TPML_HANDLE::~TPML_HANDLE() {}

/// <summary> This structure is used when the TPM returns a list of loaded handles when the capability in TPM2_GetCapability() is TPM_CAP_HANDLE. </summary>
TpmStructureBase* TPML_HANDLE::Clone() const
{
    return new TPML_HANDLE(*this);
}

void* TPML_HANDLE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) handle.resize(newArraySize); arraySize = (int)handle.size(); return &handle; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&handle[arrayIndex]); return &handle[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_DIGEST::GetTypeId() const
{
    return TpmTypeId::TPML_DIGEST_ID;
}

TPML_DIGEST::TPML_DIGEST(
    const vector<TPM2B_DIGEST>& _digests
)
{
    digests = _digests;
}

/// <summary> This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read(). </summary>
TPML_DIGEST::~TPML_DIGEST() {}

/// <summary> This list is used to convey a list of digest values. This type is used in TPM2_PolicyOR() and in TPM2_PCR_Read(). </summary>
TpmStructureBase* TPML_DIGEST::Clone() const
{
    return new TPML_DIGEST(*this);
}

void* TPML_DIGEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_DIGEST_VALUES::GetTypeId() const
{
    return TpmTypeId::TPML_DIGEST_VALUES_ID;
}

TPML_DIGEST_VALUES::TPML_DIGEST_VALUES(
    const vector<TPMT_HA>& _digests
)
{
    digests = _digests;
}

/// <summary> This list is used to convey a list of digest values. This type is returned by TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend(). </summary>
TPML_DIGEST_VALUES::~TPML_DIGEST_VALUES() {}

/// <summary> This list is used to convey a list of digest values. This type is returned by TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend(). </summary>
TpmStructureBase* TPML_DIGEST_VALUES::Clone() const
{
    return new TPML_DIGEST_VALUES(*this);
}

void* TPML_DIGEST_VALUES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_PCR_SELECTION::GetTypeId() const
{
    return TpmTypeId::TPML_PCR_SELECTION_ID;
}

TPML_PCR_SELECTION::TPML_PCR_SELECTION(
    const vector<TPMS_PCR_SELECTION>& _pcrSelections
)
{
    pcrSelections = _pcrSelections;
}

/// <summary> This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected. </summary>
TPML_PCR_SELECTION::~TPML_PCR_SELECTION() {}

/// <summary> This list is used to indicate the PCR that are included in a selection when more than one PCR value may be selected. </summary>
TpmStructureBase* TPML_PCR_SELECTION::Clone() const
{
    return new TPML_PCR_SELECTION(*this);
}

void* TPML_PCR_SELECTION::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) pcrSelections.resize(newArraySize); arraySize = (int)pcrSelections.size(); return &pcrSelections; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelections[arrayIndex]); return &pcrSelections[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ALG_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_ALG_PROPERTY_ID;
}

TPML_ALG_PROPERTY::TPML_ALG_PROPERTY(
    const vector<TPMS_ALG_PROPERTY>& _algProperties
)
{
    algProperties = _algProperties;
}

/// <summary> This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability(). </summary>
TPML_ALG_PROPERTY::~TPML_ALG_PROPERTY() {}

/// <summary> This list is used to report on a list of algorithm attributes. It is returned in a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_ALG_PROPERTY::Clone() const
{
    return new TPML_ALG_PROPERTY(*this);
}

void* TPML_ALG_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) algProperties.resize(newArraySize); arraySize = (int)algProperties.size(); return &algProperties; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&algProperties[arrayIndex]); return &algProperties[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_TAGGED_TPM_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
}

TPML_TAGGED_TPM_PROPERTY::TPML_TAGGED_TPM_PROPERTY(
    const vector<TPMS_TAGGED_PROPERTY>& _tpmProperty
)
{
    tpmProperty = _tpmProperty;
}

/// <summary> This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability(). </summary>
TPML_TAGGED_TPM_PROPERTY::~TPML_TAGGED_TPM_PROPERTY() {}

/// <summary> This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY values. It is returned by a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_TAGGED_TPM_PROPERTY::Clone() const
{
    return new TPML_TAGGED_TPM_PROPERTY(*this);
}

void* TPML_TAGGED_TPM_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) tpmProperty.resize(newArraySize); arraySize = (int)tpmProperty.size(); return &tpmProperty; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&tpmProperty[arrayIndex]); return &tpmProperty[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_TAGGED_PCR_PROPERTY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
}

TPML_TAGGED_PCR_PROPERTY::TPML_TAGGED_PCR_PROPERTY(
    const vector<TPMS_TAGGED_PCR_SELECT>& _pcrProperty
)
{
    pcrProperty = _pcrProperty;
}

/// <summary> This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability(). </summary>
TPML_TAGGED_PCR_PROPERTY::~TPML_TAGGED_PCR_PROPERTY() {}

/// <summary> This list is used to report on a list of properties that are TPMS_PCR_SELECT values. It is returned by a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_TAGGED_PCR_PROPERTY::Clone() const
{
    return new TPML_TAGGED_PCR_PROPERTY(*this);
}

void* TPML_TAGGED_PCR_PROPERTY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) pcrProperty.resize(newArraySize); arraySize = (int)pcrProperty.size(); return &pcrProperty; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrProperty[arrayIndex]); return &pcrProperty[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ECC_CURVE::GetTypeId() const
{
    return TpmTypeId::TPML_ECC_CURVE_ID;
}

TPML_ECC_CURVE::TPML_ECC_CURVE(
    const vector<TPM_ECC_CURVE>& _eccCurves
)
{
    eccCurves = _eccCurves;
}

/// <summary> This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability(). </summary>
TPML_ECC_CURVE::~TPML_ECC_CURVE() {}

/// <summary> This list is used to report the ECC curve ID values supported by the TPM. It is returned by a TPM2_GetCapability(). </summary>
TpmStructureBase* TPML_ECC_CURVE::Clone() const
{
    return new TPML_ECC_CURVE(*this);
}

void* TPML_ECC_CURVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) eccCurves.resize(newArraySize); arraySize = (int)eccCurves.size(); return &eccCurves; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &eccCurves[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_TAGGED_POLICY::GetTypeId() const
{
    return TpmTypeId::TPML_TAGGED_POLICY_ID;
}

TPML_TAGGED_POLICY::TPML_TAGGED_POLICY(
    const vector<TPMS_TAGGED_POLICY>& _policies
)
{
    policies = _policies;
}

/// <summary> This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list. </summary>
TPML_TAGGED_POLICY::~TPML_TAGGED_POLICY() {}

/// <summary> This list is used to report the authorization policy values for permanent handles. This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot have a policy is not included in the list. </summary>
TpmStructureBase* TPML_TAGGED_POLICY::Clone() const
{
    return new TPML_TAGGED_POLICY(*this);
}

void* TPML_TAGGED_POLICY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) policies.resize(newArraySize); arraySize = (int)policies.size(); return &policies; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policies[arrayIndex]); return &policies[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPML_ACT_DATA::GetTypeId() const
{
    return TpmTypeId::TPML_ACT_DATA_ID;
}

TPML_ACT_DATA::TPML_ACT_DATA(
    const vector<TPMS_ACT_DATA>& _actData
)
{
    actData = _actData;
}

/// <summary> This list is used to report the timeout and state for the ACT. This list may be generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list </summary>
TPML_ACT_DATA::~TPML_ACT_DATA() {}

/// <summary> This list is used to report the timeout and state for the ACT. This list may be generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list </summary>
TpmStructureBase* TPML_ACT_DATA::Clone() const
{
    return new TPML_ACT_DATA(*this);
}

void* TPML_ACT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) actData.resize(newArraySize); arraySize = (int)actData.size(); return &actData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&actData[arrayIndex]); return &actData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_CAPABILITY_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CAPABILITY_DATA_ID;
}

TPMS_CAPABILITY_DATA::TPMS_CAPABILITY_DATA(
    const TPMU_CAPABILITIES& _data
)
{
    data.reset(dynamic_cast<TPMU_CAPABILITIES*>(_data.Clone()));
}

/// <summary> This data area is returned in response to a TPM2_GetCapability(). </summary>
TPMS_CAPABILITY_DATA::~TPMS_CAPABILITY_DATA() {}

/// <summary> This data area is returned in response to a TPM2_GetCapability(). </summary>
TpmStructureBase* TPMS_CAPABILITY_DATA::Clone() const
{
    return new TPMS_CAPABILITY_DATA(*this);
}

void* TPMS_CAPABILITY_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &capability;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*data); return &data;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CLOCK_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CLOCK_INFO_ID;
}

TPMS_CLOCK_INFO::TPMS_CLOCK_INFO(
    UINT64 _clock,
    UINT32 _resetCount,
    UINT32 _restartCount,
    BYTE _safe
)
{
    clock = _clock;
    resetCount = _resetCount;
    restartCount = _restartCount;
    safe = _safe;
}

/// <summary> This structure is used in each of the attestation commands. </summary>
TPMS_CLOCK_INFO::~TPMS_CLOCK_INFO() {}

/// <summary> This structure is used in each of the attestation commands. </summary>
TpmStructureBase* TPMS_CLOCK_INFO::Clone() const
{
    return new TPMS_CLOCK_INFO(*this);
}

void* TPMS_CLOCK_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &clock;
            case 1: return &resetCount;
            case 2: return &restartCount;
            case 3: return &safe;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TIME_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_TIME_INFO_ID;
}

TPMS_TIME_INFO::TPMS_TIME_INFO(
    UINT64 _time,
    const TPMS_CLOCK_INFO& _clockInfo
)
{
    time = _time;
    clockInfo = _clockInfo;
}

/// <summary> This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock(). </summary>
TPMS_TIME_INFO::~TPMS_TIME_INFO() {}

/// <summary> This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock(). </summary>
TpmStructureBase* TPMS_TIME_INFO::Clone() const
{
    return new TPMS_TIME_INFO(*this);
}

void* TPMS_TIME_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &time;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&clockInfo); return &clockInfo;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_TIME_ATTEST_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
}

TPMS_TIME_ATTEST_INFO::TPMS_TIME_ATTEST_INFO(
    const TPMS_TIME_INFO& _time,
    UINT64 _firmwareVersion
)
{
    time = _time;
    firmwareVersion = _firmwareVersion;
}

/// <summary> This structure is used when the TPM performs TPM2_GetTime. </summary>
TPMS_TIME_ATTEST_INFO::~TPMS_TIME_ATTEST_INFO() {}

/// <summary> This structure is used when the TPM performs TPM2_GetTime. </summary>
TpmStructureBase* TPMS_TIME_ATTEST_INFO::Clone() const
{
    return new TPMS_TIME_ATTEST_INFO(*this);
}

void* TPMS_TIME_ATTEST_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&time); return &time;
            case 1: return &firmwareVersion;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CERTIFY_INFO_ID;
}

TPMS_CERTIFY_INFO::TPMS_CERTIFY_INFO(
    const ByteVec& _name,
    const ByteVec& _qualifiedName
)
{
    name = _name;
    qualifiedName = _qualifiedName;
}

/// <summary> This is the attested data for TPM2_Certify(). </summary>
TPMS_CERTIFY_INFO::~TPMS_CERTIFY_INFO() {}

/// <summary> This is the attested data for TPM2_Certify(). </summary>
TpmStructureBase* TPMS_CERTIFY_INFO::Clone() const
{
    return new TPMS_CERTIFY_INFO(*this);
}

void* TPMS_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nameSize;
            case 1: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            case 2: return &qualifiedNameSize;
            case 3: { if (newArraySize != -1) qualifiedName.resize(newArraySize); arraySize = (int)qualifiedName.size(); return &qualifiedName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &name[arrayIndex];
            case 3: return &qualifiedName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_QUOTE_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_QUOTE_INFO_ID;
}

TPMS_QUOTE_INFO::TPMS_QUOTE_INFO(
    const vector<TPMS_PCR_SELECTION>& _pcrSelect,
    const ByteVec& _pcrDigest
)
{
    pcrSelect = _pcrSelect;
    pcrDigest = _pcrDigest;
}

/// <summary> This is the attested data for TPM2_Quote(). </summary>
TPMS_QUOTE_INFO::~TPMS_QUOTE_INFO() {}

/// <summary> This is the attested data for TPM2_Quote(). </summary>
TpmStructureBase* TPMS_QUOTE_INFO::Clone() const
{
    return new TPMS_QUOTE_INFO(*this);
}

void* TPMS_QUOTE_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrSelectCount;
            case 1: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            case 2: return &pcrDigestSize;
            case 3: { if (newArraySize != -1) pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return &pcrDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelect[arrayIndex]); return &pcrSelect[arrayIndex];
            case 3: return &pcrDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_COMMAND_AUDIT_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
}

TPMS_COMMAND_AUDIT_INFO::TPMS_COMMAND_AUDIT_INFO(
    UINT64 _auditCounter,
    TPM_ALG_ID _digestAlg,
    const ByteVec& _auditDigest,
    const ByteVec& _commandDigest
)
{
    auditCounter = _auditCounter;
    digestAlg = _digestAlg;
    auditDigest = _auditDigest;
    commandDigest = _commandDigest;
}

/// <summary> This is the attested data for TPM2_GetCommandAuditDigest(). </summary>
TPMS_COMMAND_AUDIT_INFO::~TPMS_COMMAND_AUDIT_INFO() {}

/// <summary> This is the attested data for TPM2_GetCommandAuditDigest(). </summary>
TpmStructureBase* TPMS_COMMAND_AUDIT_INFO::Clone() const
{
    return new TPMS_COMMAND_AUDIT_INFO(*this);
}

void* TPMS_COMMAND_AUDIT_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &auditCounter;
            case 1: return &digestAlg;
            case 2: return &auditDigestSize;
            case 3: { if (newArraySize != -1) auditDigest.resize(newArraySize); arraySize = (int)auditDigest.size(); return &auditDigest; }
            case 4: return &commandDigestSize;
            case 5: { if (newArraySize != -1) commandDigest.resize(newArraySize); arraySize = (int)commandDigest.size(); return &commandDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &auditDigest[arrayIndex];
            case 5: return &commandDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SESSION_AUDIT_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
}

TPMS_SESSION_AUDIT_INFO::TPMS_SESSION_AUDIT_INFO(
    BYTE _exclusiveSession,
    const ByteVec& _sessionDigest
)
{
    exclusiveSession = _exclusiveSession;
    sessionDigest = _sessionDigest;
}

/// <summary> This is the attested data for TPM2_GetSessionAuditDigest(). </summary>
TPMS_SESSION_AUDIT_INFO::~TPMS_SESSION_AUDIT_INFO() {}

/// <summary> This is the attested data for TPM2_GetSessionAuditDigest(). </summary>
TpmStructureBase* TPMS_SESSION_AUDIT_INFO::Clone() const
{
    return new TPMS_SESSION_AUDIT_INFO(*this);
}

void* TPMS_SESSION_AUDIT_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &exclusiveSession;
            case 1: return &sessionDigestSize;
            case 2: { if (newArraySize != -1) sessionDigest.resize(newArraySize); arraySize = (int)sessionDigest.size(); return &sessionDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sessionDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_CREATION_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_CREATION_INFO_ID;
}

TPMS_CREATION_INFO::TPMS_CREATION_INFO(
    const ByteVec& _objectName,
    const ByteVec& _creationHash
)
{
    objectName = _objectName;
    creationHash = _creationHash;
}

/// <summary> This is the attested data for TPM2_CertifyCreation(). </summary>
TPMS_CREATION_INFO::~TPMS_CREATION_INFO() {}

/// <summary> This is the attested data for TPM2_CertifyCreation(). </summary>
TpmStructureBase* TPMS_CREATION_INFO::Clone() const
{
    return new TPMS_CREATION_INFO(*this);
}

void* TPMS_CREATION_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &objectNameSize;
            case 1: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            case 2: return &creationHashSize;
            case 3: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &objectName[arrayIndex];
            case 3: return &creationHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NV_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
}

TPMS_NV_CERTIFY_INFO::TPMS_NV_CERTIFY_INFO(
    const ByteVec& _indexName,
    UINT16 _offset,
    const ByteVec& _nvContents
)
{
    indexName = _indexName;
    offset = _offset;
    nvContents = _nvContents;
}

/// <summary> This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify(). </summary>
TPMS_NV_CERTIFY_INFO::~TPMS_NV_CERTIFY_INFO() {}

/// <summary> This structure contains the Name and contents of the selected NV Index that is certified by TPM2_NV_Certify(). </summary>
TpmStructureBase* TPMS_NV_CERTIFY_INFO::Clone() const
{
    return new TPMS_NV_CERTIFY_INFO(*this);
}

void* TPMS_NV_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &indexNameSize;
            case 1: { if (newArraySize != -1) indexName.resize(newArraySize); arraySize = (int)indexName.size(); return &indexName; }
            case 2: return &offset;
            case 3: return &nvContentsSize;
            case 4: { if (newArraySize != -1) nvContents.resize(newArraySize); arraySize = (int)nvContents.size(); return &nvContents; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &indexName[arrayIndex];
            case 4: return &nvContents[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NV_DIGEST_CERTIFY_INFO::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
}

TPMS_NV_DIGEST_CERTIFY_INFO::TPMS_NV_DIGEST_CERTIFY_INFO(
    const ByteVec& _indexName,
    const ByteVec& _nvDigest
)
{
    indexName = _indexName;
    nvDigest = _nvDigest;
}

/// <summary> This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme. </summary>
TPMS_NV_DIGEST_CERTIFY_INFO::~TPMS_NV_DIGEST_CERTIFY_INFO() {}

/// <summary> This structure contains the Name and hash of the contents of the selected NV Index that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme. </summary>
TpmStructureBase* TPMS_NV_DIGEST_CERTIFY_INFO::Clone() const
{
    return new TPMS_NV_DIGEST_CERTIFY_INFO(*this);
}

void* TPMS_NV_DIGEST_CERTIFY_INFO::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &indexNameSize;
            case 1: { if (newArraySize != -1) indexName.resize(newArraySize); arraySize = (int)indexName.size(); return &indexName; }
            case 2: return &nvDigestSize;
            case 3: { if (newArraySize != -1) nvDigest.resize(newArraySize); arraySize = (int)nvDigest.size(); return &nvDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &indexName[arrayIndex];
            case 3: return &nvDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ATTEST::GetTypeId() const
{
    return TpmTypeId::TPMS_ATTEST_ID;
}

TPMS_ATTEST::TPMS_ATTEST(
    TPM_GENERATED _magic,
    const ByteVec& _qualifiedSigner,
    const ByteVec& _extraData,
    const TPMS_CLOCK_INFO& _clockInfo,
    UINT64 _firmwareVersion,
    const TPMU_ATTEST& _attested
)
{
    magic = _magic;
    qualifiedSigner = _qualifiedSigner;
    extraData = _extraData;
    clockInfo = _clockInfo;
    firmwareVersion = _firmwareVersion;
    attested.reset(dynamic_cast<TPMU_ATTEST*>(_attested.Clone()));
}

/// <summary> This structure is used on each TPM-generated signed structure. The signature is over this structure. </summary>
TPMS_ATTEST::~TPMS_ATTEST() {}

/// <summary> This structure is used on each TPM-generated signed structure. The signature is over this structure. </summary>
TpmStructureBase* TPMS_ATTEST::Clone() const
{
    return new TPMS_ATTEST(*this);
}

void* TPMS_ATTEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &magic;
            case 1: return &type;
            case 2: return &qualifiedSignerSize;
            case 3: { if (newArraySize != -1) qualifiedSigner.resize(newArraySize); arraySize = (int)qualifiedSigner.size(); return &qualifiedSigner; }
            case 4: return &extraDataSize;
            case 5: { if (newArraySize != -1) extraData.resize(newArraySize); arraySize = (int)extraData.size(); return &extraData; }
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&clockInfo); return &clockInfo;
            case 7: return &firmwareVersion;
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&*attested); return &attested;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifiedSigner[arrayIndex];
            case 5: return &extraData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ATTEST::GetTypeId() const
{
    return TpmTypeId::TPM2B_ATTEST_ID;
}

TPM2B_ATTEST::TPM2B_ATTEST(
    const TPMS_ATTEST& _attestationData
)
{
    attestationData = _attestationData;
}

/// <summary> This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed. </summary>
TPM2B_ATTEST::~TPM2B_ATTEST() {}

/// <summary> This sized buffer to contain the signed structure. The attestationData is the signed portion of the structure. The size parameter is not signed. </summary>
TpmStructureBase* TPM2B_ATTEST::Clone() const
{
    return new TPM2B_ATTEST(*this);
}

void* TPM2B_ATTEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&attestationData); return &attestationData;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_AUTH_COMMAND::GetTypeId() const
{
    return TpmTypeId::TPMS_AUTH_COMMAND_ID;
}

TPMS_AUTH_COMMAND::TPMS_AUTH_COMMAND(
    const TPM_HANDLE& _sessionHandle,
    const ByteVec& _nonce,
    TPMA_SESSION _sessionAttributes,
    const ByteVec& _hmac
)
{
    sessionHandle = _sessionHandle;
    nonce = _nonce;
    sessionAttributes = _sessionAttributes;
    hmac = _hmac;
}

/// <summary> This is the format used for each of the authorizations in the session area of a command. </summary>
TPMS_AUTH_COMMAND::~TPMS_AUTH_COMMAND() {}

/// <summary> This is the format used for each of the authorizations in the session area of a command. </summary>
TpmStructureBase* TPMS_AUTH_COMMAND::Clone() const
{
    return new TPMS_AUTH_COMMAND(*this);
}

void* TPMS_AUTH_COMMAND::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return &sessionHandle;
            case 1: return &nonceSize;
            case 2: { if (newArraySize != -1) nonce.resize(newArraySize); arraySize = (int)nonce.size(); return &nonce; }
            case 3: return &sessionAttributes;
            case 4: return &hmacSize;
            case 5: { if (newArraySize != -1) hmac.resize(newArraySize); arraySize = (int)hmac.size(); return &hmac; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nonce[arrayIndex];
            case 5: return &hmac[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId AUTHResponse::GetTypeId() const
{
    return TpmTypeId::AUTHResponse_ID;
}

AUTHResponse::AUTHResponse(
    const ByteVec& _nonce,
    TPMA_SESSION _sessionAttributes,
    const ByteVec& _hmac
)
{
    nonce = _nonce;
    sessionAttributes = _sessionAttributes;
    hmac = _hmac;
}

/// <summary> This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order. </summary>
AUTHResponse::~AUTHResponse() {}

/// <summary> This is the format for each of the authorizations in the session area of the response. If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the same number of authorizations as the command and the authorizations are in the same order. </summary>
TpmStructureBase* AUTHResponse::Clone() const
{
    return new AUTHResponse(*this);
}

void* AUTHResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nonceSize;
            case 1: { if (newArraySize != -1) nonce.resize(newArraySize); arraySize = (int)nonce.size(); return &nonce; }
            case 2: return &sessionAttributes;
            case 3: return &hmacSize;
            case 4: { if (newArraySize != -1) hmac.resize(newArraySize); arraySize = (int)hmac.size(); return &hmac; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &nonce[arrayIndex];
            case 4: return &hmac[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SYM_KEY_BITS::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TPMS_NULL_SYM_KEY_BITS::~TPMS_NULL_SYM_KEY_BITS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymKeyBits
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_KEY_BITS::Clone() const
{
    return new TPMS_NULL_SYM_KEY_BITS(*this);
}

void* TPMS_NULL_SYM_KEY_BITS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_XOR_SYM_MODE::GetTypeId() const
{
    return TpmTypeId::TPMS_XOR_SYM_MODE_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TPMS_XOR_SYM_MODE::~TPMS_XOR_SYM_MODE() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymMode
/// </summary>
TpmStructureBase* TPMS_XOR_SYM_MODE::Clone() const
{
    return new TPMS_XOR_SYM_MODE(*this);
}

void* TPMS_XOR_SYM_MODE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_NULL_SYM_MODE::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_MODE_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TPMS_NULL_SYM_MODE::~TPMS_NULL_SYM_MODE() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymMode
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_MODE::Clone() const
{
    return new TPMS_NULL_SYM_MODE(*this);
}

void* TPMS_NULL_SYM_MODE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_TDES_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_TDES_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TPMS_TDES_SYM_DETAILS::~TPMS_TDES_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_TDES for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_TDES_SYM_DETAILS::Clone() const
{
    return new TPMS_TDES_SYM_DETAILS(*this);
}

void* TPMS_TDES_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_AES_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_AES_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TPMS_AES_SYM_DETAILS::~TPMS_AES_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_AES for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_AES_SYM_DETAILS::Clone() const
{
    return new TPMS_AES_SYM_DETAILS(*this);
}

void* TPMS_AES_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_SM4_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_SM4_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TPMS_SM4_SYM_DETAILS::~TPMS_SM4_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_SM4_SYM_DETAILS::Clone() const
{
    return new TPMS_SM4_SYM_DETAILS(*this);
}

void* TPMS_SM4_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_CAMELLIA_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TPMS_CAMELLIA_SYM_DETAILS::~TPMS_CAMELLIA_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_CAMELLIA_SYM_DETAILS::Clone() const
{
    return new TPMS_CAMELLIA_SYM_DETAILS(*this);
}

void* TPMS_CAMELLIA_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_ANY_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_ANY_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TPMS_ANY_SYM_DETAILS::~TPMS_ANY_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_ANY for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_ANY_SYM_DETAILS::Clone() const
{
    return new TPMS_ANY_SYM_DETAILS(*this);
}

void* TPMS_ANY_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_XOR_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_XOR_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TPMS_XOR_SYM_DETAILS::~TPMS_XOR_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_XOR for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_XOR_SYM_DETAILS::Clone() const
{
    return new TPMS_XOR_SYM_DETAILS(*this);
}

void* TPMS_XOR_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_NULL_SYM_DETAILS::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SYM_DETAILS_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TPMS_NULL_SYM_DETAILS::~TPMS_NULL_SYM_DETAILS() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSymDetails
/// </summary>
TpmStructureBase* TPMS_NULL_SYM_DETAILS::Clone() const
{
    return new TPMS_NULL_SYM_DETAILS(*this);
}

void* TPMS_NULL_SYM_DETAILS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId _TPMT_SYM_DEF::GetTypeId() const
{
    return TpmTypeId::TPMT_SYM_DEF_ID;
}

_TPMT_SYM_DEF::_TPMT_SYM_DEF(
    TPM_ALG_ID _algorithm,
    UINT16 _keyBits,
    TPM_ALG_ID _mode
)
{
    algorithm = _algorithm;
    keyBits = _keyBits;
    mode = _mode;
}

/// <summary> The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected. </summary>
_TPMT_SYM_DEF::~_TPMT_SYM_DEF() {}

/// <summary> The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter encryption in those cases when different symmetric algorithms may be selected. </summary>
TpmStructureBase* _TPMT_SYM_DEF::Clone() const
{
    return new TPMT_SYM_DEF(dynamic_cast<const TPMT_SYM_DEF&>(*this));
}

void* _TPMT_SYM_DEF::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &algorithm;
            case 1: return &keyBits;
            case 2: return &mode;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _TPMT_SYM_DEF_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
}

_TPMT_SYM_DEF_OBJECT::_TPMT_SYM_DEF_OBJECT(
    TPM_ALG_ID _algorithm,
    UINT16 _keyBits,
    TPM_ALG_ID _mode
)
{
    algorithm = _algorithm;
    keyBits = _keyBits;
    mode = _mode;
}

/// <summary> This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field. </summary>
_TPMT_SYM_DEF_OBJECT::~_TPMT_SYM_DEF_OBJECT() {}

/// <summary> This structure is used when different symmetric block cipher (not XOR) algorithms may be selected. If the Object can be an ordinary parent (not a derivation parent), this must be the first field in the Object's parameter (see 12.2.3.7) field. </summary>
TpmStructureBase* _TPMT_SYM_DEF_OBJECT::Clone() const
{
    return new TPMT_SYM_DEF_OBJECT(dynamic_cast<const TPMT_SYM_DEF_OBJECT&>(*this));
}

void* _TPMT_SYM_DEF_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &algorithm;
            case 1: return &keyBits;
            case 2: return &mode;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_SYM_KEY::GetTypeId() const
{
    return TpmTypeId::TPM2B_SYM_KEY_ID;
}

TPM2B_SYM_KEY::TPM2B_SYM_KEY(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used to hold a symmetric key in the sensitive area of an asymmetric object. </summary>
TPM2B_SYM_KEY::~TPM2B_SYM_KEY() {}

/// <summary> This structure is used to hold a symmetric key in the sensitive area of an asymmetric object. </summary>
TpmStructureBase* TPM2B_SYM_KEY::Clone() const
{
    return new TPM2B_SYM_KEY(*this);
}

void* TPM2B_SYM_KEY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SYMCIPHER_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
}

TPMS_SYMCIPHER_PARMS::TPMS_SYMCIPHER_PARMS(const TPMT_SYM_DEF_OBJECT& _sym)
{
    sym = _sym;
}

/// <summary> This structure contains the parameters for a symmetric block cipher object. </summary>
TPMS_SYMCIPHER_PARMS::~TPMS_SYMCIPHER_PARMS() {}

/// <summary> This structure contains the parameters for a symmetric block cipher object. </summary>
TpmStructureBase* TPMS_SYMCIPHER_PARMS::Clone() const
{
    return new TPMS_SYMCIPHER_PARMS(*this);
}

void* TPMS_SYMCIPHER_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sym); return &sym;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_LABEL::GetTypeId() const
{
    return TpmTypeId::TPM2B_LABEL_ID;
}

TPM2B_LABEL::TPM2B_LABEL(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes. </summary>
TPM2B_LABEL::~TPM2B_LABEL() {}

/// <summary> This buffer holds a label or context value. For interoperability and backwards compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes. </summary>
TpmStructureBase* TPM2B_LABEL::Clone() const
{
    return new TPM2B_LABEL(*this);
}

void* TPM2B_LABEL::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_DERIVE::GetTypeId() const
{
    return TpmTypeId::TPMS_DERIVE_ID;
}

TPMS_DERIVE::TPMS_DERIVE(
    const ByteVec& _label,
    const ByteVec& _context
)
{
    label = _label;
    context = _context;
}

/// <summary> This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter. </summary>
TPMS_DERIVE::~TPMS_DERIVE() {}

/// <summary> This structure contains the label and context fields for a derived object. These values are used in the derivation KDF. The values in the unique field of inPublic area template take precedence over the values in the inSensitive parameter. </summary>
TpmStructureBase* TPMS_DERIVE::Clone() const
{
    return new TPMS_DERIVE(*this);
}

void* TPMS_DERIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &labelSize;
            case 1: { if (newArraySize != -1) label.resize(newArraySize); arraySize = (int)label.size(); return &label; }
            case 2: return &contextSize;
            case 3: { if (newArraySize != -1) context.resize(newArraySize); arraySize = (int)context.size(); return &context; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &label[arrayIndex];
            case 3: return &context[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DERIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_DERIVE_ID;
}

TPM2B_DERIVE::TPM2B_DERIVE(
    const TPMS_DERIVE& _buffer
)
{
    buffer = _buffer;
}

/// <summary> Table 147  Definition of TPM2B_DERIVE Structure </summary>
TPM2B_DERIVE::~TPM2B_DERIVE() {}

/// <summary> Table 147  Definition of TPM2B_DERIVE Structure </summary>
TpmStructureBase* TPM2B_DERIVE::Clone() const
{
    return new TPM2B_DERIVE(*this);
}

void* TPM2B_DERIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&buffer); return &buffer;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_SENSITIVE_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
}

TPM2B_SENSITIVE_DATA::TPM2B_SENSITIVE_DATA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This buffer wraps the TPMU_SENSITIVE_CREATE structure. </summary>
TPM2B_SENSITIVE_DATA::~TPM2B_SENSITIVE_DATA() {}

/// <summary> This buffer wraps the TPMU_SENSITIVE_CREATE structure. </summary>
TpmStructureBase* TPM2B_SENSITIVE_DATA::Clone() const
{
    return new TPM2B_SENSITIVE_DATA(*this);
}

void* TPM2B_SENSITIVE_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SENSITIVE_CREATE::GetTypeId() const
{
    return TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
}

TPMS_SENSITIVE_CREATE::TPMS_SENSITIVE_CREATE(
    const ByteVec& _userAuth,
    const ByteVec& _data
)
{
    userAuth = _userAuth;
    data = _data;
}

/// <summary> This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure. </summary>
TPMS_SENSITIVE_CREATE::~TPMS_SENSITIVE_CREATE() {}

/// <summary> This structure defines the values to be placed in the sensitive area of a created object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure. </summary>
TpmStructureBase* TPMS_SENSITIVE_CREATE::Clone() const
{
    return new TPMS_SENSITIVE_CREATE(*this);
}

void* TPMS_SENSITIVE_CREATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &userAuthSize;
            case 1: { if (newArraySize != -1) userAuth.resize(newArraySize); arraySize = (int)userAuth.size(); return &userAuth; }
            case 2: return &dataSize;
            case 3: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &userAuth[arrayIndex];
            case 3: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_SENSITIVE_CREATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
}

TPM2B_SENSITIVE_CREATE::TPM2B_SENSITIVE_CREATE(
    const TPMS_SENSITIVE_CREATE& _sensitive
)
{
    sensitive = _sensitive;
}

/// <summary> This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes. </summary>
TPM2B_SENSITIVE_CREATE::~TPM2B_SENSITIVE_CREATE() {}

/// <summary> This structure contains the sensitive creation data in a sized buffer. This structure is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may be passed as a single parameter for parameter encryption purposes. </summary>
TpmStructureBase* TPM2B_SENSITIVE_CREATE::Clone() const
{
    return new TPM2B_SENSITIVE_CREATE(*this);
}

void* TPM2B_SENSITIVE_CREATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sensitive); return &sensitive;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_HASH::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_HASH_ID;
}

TPMS_SCHEME_HASH::TPMS_SCHEME_HASH(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> This structure is the scheme data for schemes that only require a hash to complete their definition. </summary>
TPMS_SCHEME_HASH::~TPMS_SCHEME_HASH() {}

/// <summary> This structure is the scheme data for schemes that only require a hash to complete their definition. </summary>
TpmStructureBase* TPMS_SCHEME_HASH::Clone() const
{
    return new TPMS_SCHEME_HASH(*this);
}

void* TPMS_SCHEME_HASH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_ECDAA_ID;
}

TPMS_SCHEME_ECDAA::TPMS_SCHEME_ECDAA(
    TPM_ALG_ID _hashAlg,
    UINT16 _count
)
{
    hashAlg = _hashAlg;
    count = _count;
}

/// <summary> This definition is for split signing schemes that require a commit count. </summary>
TPMS_SCHEME_ECDAA::~TPMS_SCHEME_ECDAA() {}

/// <summary> This definition is for split signing schemes that require a commit count. </summary>
TpmStructureBase* TPMS_SCHEME_ECDAA::Clone() const
{
    return new TPMS_SCHEME_ECDAA(*this);
}

void* TPMS_SCHEME_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: return &count;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_HMAC::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_HMAC_ID;
}

TPMS_SCHEME_HMAC::TPMS_SCHEME_HMAC(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Table 155  Definition of Types for HMAC_SIG_SCHEME </summary>
TPMS_SCHEME_HMAC::~TPMS_SCHEME_HMAC() {}

/// <summary> Table 155  Definition of Types for HMAC_SIG_SCHEME </summary>
TpmStructureBase* TPMS_SCHEME_HMAC::Clone() const
{
    return new TPMS_SCHEME_HMAC(*this);
}

void* TPMS_SCHEME_HMAC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SCHEME_XOR::GetTypeId() const
{
    return TpmTypeId::TPMS_SCHEME_XOR_ID;
}

TPMS_SCHEME_XOR::TPMS_SCHEME_XOR(
    TPM_ALG_ID _hashAlg,
    TPM_ALG_ID _kdf
)
{
    hashAlg = _hashAlg;
    kdf = _kdf;
}

/// <summary> This structure is for the XOR encryption scheme. </summary>
TPMS_SCHEME_XOR::~TPMS_SCHEME_XOR() {}

/// <summary> This structure is for the XOR encryption scheme. </summary>
TpmStructureBase* TPMS_SCHEME_XOR::Clone() const
{
    return new TPMS_SCHEME_XOR(*this);
}

void* TPMS_SCHEME_XOR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: return &kdf;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SCHEME_KEYEDHASH::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TPMS_NULL_SCHEME_KEYEDHASH::~TPMS_NULL_SCHEME_KEYEDHASH() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSchemeKeyedhash
/// </summary>
TpmStructureBase* TPMS_NULL_SCHEME_KEYEDHASH::Clone() const
{
    return new TPMS_NULL_SCHEME_KEYEDHASH(*this);
}

void* TPMS_NULL_SCHEME_KEYEDHASH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_KEYEDHASH_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
}

TPMT_KEYEDHASH_SCHEME::TPMT_KEYEDHASH_SCHEME(
    const TPMU_SCHEME_KEYEDHASH& _details
)
{
    details.reset(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_details.Clone()));
}

/// <summary> This structure is used for a hash signing object. </summary>
TPMT_KEYEDHASH_SCHEME::~TPMT_KEYEDHASH_SCHEME() {}

/// <summary> This structure is used for a hash signing object. </summary>
TpmStructureBase* TPMT_KEYEDHASH_SCHEME::Clone() const
{
    return new TPMT_KEYEDHASH_SCHEME(*this);
}

void* TPMT_KEYEDHASH_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_RSASSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
}

TPMS_SIG_SCHEME_RSASSA::TPMS_SIG_SCHEME_RSASSA(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TPMS_SIG_SCHEME_RSASSA::~TPMS_SIG_SCHEME_RSASSA() {}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_RSASSA::Clone() const
{
    return new TPMS_SIG_SCHEME_RSASSA(*this);
}

void* TPMS_SIG_SCHEME_RSASSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_RSAPSS::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
}

TPMS_SIG_SCHEME_RSAPSS::TPMS_SIG_SCHEME_RSAPSS(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TPMS_SIG_SCHEME_RSAPSS::~TPMS_SIG_SCHEME_RSAPSS() {}

/// <summary> These are the RSA schemes that only need a hash algorithm as a scheme parameter. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_RSAPSS::Clone() const
{
    return new TPMS_SIG_SCHEME_RSAPSS(*this);
}

void* TPMS_SIG_SCHEME_RSAPSS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_ECDSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
}

TPMS_SIG_SCHEME_ECDSA::TPMS_SIG_SCHEME_ECDSA(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_ECDSA::~TPMS_SIG_SCHEME_ECDSA() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECDSA::Clone() const
{
    return new TPMS_SIG_SCHEME_ECDSA(*this);
}

void* TPMS_SIG_SCHEME_ECDSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_SM2::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
}

TPMS_SIG_SCHEME_SM2::TPMS_SIG_SCHEME_SM2(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_SM2::~TPMS_SIG_SCHEME_SM2() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_SM2::Clone() const
{
    return new TPMS_SIG_SCHEME_SM2(*this);
}

void* TPMS_SIG_SCHEME_SM2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_ECSCHNORR::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
}

TPMS_SIG_SCHEME_ECSCHNORR::TPMS_SIG_SCHEME_ECSCHNORR(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_ECSCHNORR::~TPMS_SIG_SCHEME_ECSCHNORR() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECSCHNORR::Clone() const
{
    return new TPMS_SIG_SCHEME_ECSCHNORR(*this);
}

void* TPMS_SIG_SCHEME_ECSCHNORR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_SIG_SCHEME_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
}

TPMS_SIG_SCHEME_ECDAA::TPMS_SIG_SCHEME_ECDAA(
    TPM_ALG_ID _hashAlg,
    UINT16 _count
)
{
    hashAlg = _hashAlg;
    count = _count;
}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TPMS_SIG_SCHEME_ECDAA::~TPMS_SIG_SCHEME_ECDAA() {}

/// <summary> Most of the ECC signature schemes only require a hash algorithm to complete the definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a count value so they are typed to be TPMS_SCHEME_ECDAA. </summary>
TpmStructureBase* TPMS_SIG_SCHEME_ECDAA::Clone() const
{
    return new TPMS_SIG_SCHEME_ECDAA(*this);
}

void* TPMS_SIG_SCHEME_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            case 1: return &count;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SIG_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SIG_SCHEME_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TPMS_NULL_SIG_SCHEME::~TPMS_NULL_SIG_SCHEME() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSigScheme
/// </summary>
TpmStructureBase* TPMS_NULL_SIG_SCHEME::Clone() const
{
    return new TPMS_NULL_SIG_SCHEME(*this);
}

void* TPMS_NULL_SIG_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_SIG_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_SIG_SCHEME_ID;
}

TPMT_SIG_SCHEME::TPMT_SIG_SCHEME(
    const TPMU_SIG_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_details.Clone()));
}

/// <summary> Table 162  Definition of TPMT_SIG_SCHEME Structure </summary>
TPMT_SIG_SCHEME::~TPMT_SIG_SCHEME() {}

/// <summary> Table 162  Definition of TPMT_SIG_SCHEME Structure </summary>
TpmStructureBase* TPMT_SIG_SCHEME::Clone() const
{
    return new TPMT_SIG_SCHEME(*this);
}

void* TPMT_SIG_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ENC_SCHEME_OAEP::GetTypeId() const
{
    return TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
}

TPMS_ENC_SCHEME_OAEP::TPMS_ENC_SCHEME_OAEP(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_ENC_SCHEME_OAEP::~TPMS_ENC_SCHEME_OAEP() {}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_ENC_SCHEME_OAEP::Clone() const
{
    return new TPMS_ENC_SCHEME_OAEP(*this);
}

void* TPMS_ENC_SCHEME_OAEP::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ENC_SCHEME_RSAES::GetTypeId() const
{
    return TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID;
}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_ENC_SCHEME_RSAES::~TPMS_ENC_SCHEME_RSAES() {}

/// <summary> These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_ENC_SCHEME_RSAES::Clone() const
{
    return new TPMS_ENC_SCHEME_RSAES(*this);
}

void* TPMS_ENC_SCHEME_RSAES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMS_KEY_SCHEME_ECDH::GetTypeId() const
{
    return TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
}

TPMS_KEY_SCHEME_ECDH::TPMS_KEY_SCHEME_ECDH(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_KEY_SCHEME_ECDH::~TPMS_KEY_SCHEME_ECDH() {}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_KEY_SCHEME_ECDH::Clone() const
{
    return new TPMS_KEY_SCHEME_ECDH(*this);
}

void* TPMS_KEY_SCHEME_ECDH::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KEY_SCHEME_ECMQV::GetTypeId() const
{
    return TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
}

TPMS_KEY_SCHEME_ECMQV::TPMS_KEY_SCHEME_ECMQV(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TPMS_KEY_SCHEME_ECMQV::~TPMS_KEY_SCHEME_ECMQV() {}

/// <summary> These are the ECC schemes that only need a hash algorithm as a controlling parameter. </summary>
TpmStructureBase* TPMS_KEY_SCHEME_ECMQV::Clone() const
{
    return new TPMS_KEY_SCHEME_ECMQV(*this);
}

void* TPMS_KEY_SCHEME_ECMQV::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_MGF1::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID;
}

TPMS_KDF_SCHEME_MGF1::TPMS_KDF_SCHEME_MGF1(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_MGF1::~TPMS_KDF_SCHEME_MGF1() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_MGF1::Clone() const
{
    return new TPMS_KDF_SCHEME_MGF1(*this);
}

void* TPMS_KDF_SCHEME_MGF1::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_KDF1_SP800_56A::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID;
}

TPMS_KDF_SCHEME_KDF1_SP800_56A::TPMS_KDF_SCHEME_KDF1_SP800_56A(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_KDF1_SP800_56A::~TPMS_KDF_SCHEME_KDF1_SP800_56A() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_KDF1_SP800_56A::Clone() const
{
    return new TPMS_KDF_SCHEME_KDF1_SP800_56A(*this);
}

void* TPMS_KDF_SCHEME_KDF1_SP800_56A::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_KDF2::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID;
}

TPMS_KDF_SCHEME_KDF2::TPMS_KDF_SCHEME_KDF2(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_KDF2::~TPMS_KDF_SCHEME_KDF2() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_KDF2::Clone() const
{
    return new TPMS_KDF_SCHEME_KDF2(*this);
}

void* TPMS_KDF_SCHEME_KDF2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_KDF_SCHEME_KDF1_SP800_108::GetTypeId() const
{
    return TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID;
}

TPMS_KDF_SCHEME_KDF1_SP800_108::TPMS_KDF_SCHEME_KDF1_SP800_108(TPM_ALG_ID _hashAlg)
{
    hashAlg = _hashAlg;
}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TPMS_KDF_SCHEME_KDF1_SP800_108::~TPMS_KDF_SCHEME_KDF1_SP800_108() {}

/// <summary> These structures are used to define the key derivation for symmetric secret sharing using asymmetric methods. A secret sharing scheme is required in any asymmetric key with the decrypt attribute SET. </summary>
TpmStructureBase* TPMS_KDF_SCHEME_KDF1_SP800_108::Clone() const
{
    return new TPMS_KDF_SCHEME_KDF1_SP800_108(*this);
}

void* TPMS_KDF_SCHEME_KDF1_SP800_108::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_KDF_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_KDF_SCHEME_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TPMS_NULL_KDF_SCHEME::~TPMS_NULL_KDF_SCHEME() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuKdfScheme
/// </summary>
TpmStructureBase* TPMS_NULL_KDF_SCHEME::Clone() const
{
    return new TPMS_NULL_KDF_SCHEME(*this);
}

void* TPMS_NULL_KDF_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_KDF_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_KDF_SCHEME_ID;
}

TPMT_KDF_SCHEME::TPMT_KDF_SCHEME(
    const TPMU_KDF_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_details.Clone()));
}

/// <summary> Table 167  Definition of TPMT_KDF_SCHEME Structure </summary>
TPMT_KDF_SCHEME::~TPMT_KDF_SCHEME() {}

/// <summary> Table 167  Definition of TPMT_KDF_SCHEME Structure </summary>
TpmStructureBase* TPMT_KDF_SCHEME::Clone() const
{
    return new TPMT_KDF_SCHEME(*this);
}

void* TPMT_KDF_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NULL_ASYM_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TPMS_NULL_ASYM_SCHEME::~TPMS_NULL_ASYM_SCHEME() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuAsymScheme
/// </summary>
TpmStructureBase* TPMS_NULL_ASYM_SCHEME::Clone() const
{
    return new TPMS_NULL_ASYM_SCHEME(*this);
}

void* TPMS_NULL_ASYM_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_ASYM_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_ASYM_SCHEME_ID;
}

TPMT_ASYM_SCHEME::TPMT_ASYM_SCHEME(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure. </summary>
TPMT_ASYM_SCHEME::~TPMT_ASYM_SCHEME() {}

/// <summary> This structure is defined to allow overlay of all of the schemes for any asymmetric object. This structure is not sent on the interface. It is defined so that common functions may operate on any similar scheme structure. </summary>
TpmStructureBase* TPMT_ASYM_SCHEME::Clone() const
{
    return new TPMT_ASYM_SCHEME(*this);
}

void* TPMT_ASYM_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_RSA_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_RSA_SCHEME_ID;
}

TPMT_RSA_SCHEME::TPMT_RSA_SCHEME(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> Table 172  Definition of {RSA} TPMT_RSA_SCHEME Structure </summary>
TPMT_RSA_SCHEME::~TPMT_RSA_SCHEME() {}

/// <summary> Table 172  Definition of {RSA} TPMT_RSA_SCHEME Structure </summary>
TpmStructureBase* TPMT_RSA_SCHEME::Clone() const
{
    return new TPMT_RSA_SCHEME(*this);
}

void* TPMT_RSA_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_RSA_DECRYPT::GetTypeId() const
{
    return TpmTypeId::TPMT_RSA_DECRYPT_ID;
}

TPMT_RSA_DECRYPT::TPMT_RSA_DECRYPT(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> Table 174  Definition of {RSA} TPMT_RSA_DECRYPT Structure </summary>
TPMT_RSA_DECRYPT::~TPMT_RSA_DECRYPT() {}

/// <summary> Table 174  Definition of {RSA} TPMT_RSA_DECRYPT Structure </summary>
TpmStructureBase* TPMT_RSA_DECRYPT::Clone() const
{
    return new TPMT_RSA_DECRYPT(*this);
}

void* TPMT_RSA_DECRYPT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_PUBLIC_KEY_RSA::GetTypeId() const
{
    return TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
}

TPM2B_PUBLIC_KEY_RSA::TPM2B_PUBLIC_KEY_RSA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer holds the largest RSA public key supported by the TPM. </summary>
TPM2B_PUBLIC_KEY_RSA::~TPM2B_PUBLIC_KEY_RSA() {}

/// <summary> This sized buffer holds the largest RSA public key supported by the TPM. </summary>
TpmStructureBase* TPM2B_PUBLIC_KEY_RSA::Clone() const
{
    return new TPM2B_PUBLIC_KEY_RSA(*this);
}

void* TPM2B_PUBLIC_KEY_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PRIVATE_KEY_RSA::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
}

TPM2B_PRIVATE_KEY_RSA::TPM2B_PRIVATE_KEY_RSA(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer holds the largest RSA prime number supported by the TPM. </summary>
TPM2B_PRIVATE_KEY_RSA::~TPM2B_PRIVATE_KEY_RSA() {}

/// <summary> This sized buffer holds the largest RSA prime number supported by the TPM. </summary>
TpmStructureBase* TPM2B_PRIVATE_KEY_RSA::Clone() const
{
    return new TPM2B_PRIVATE_KEY_RSA(*this);
}

void* TPM2B_PRIVATE_KEY_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ECC_PARAMETER::GetTypeId() const
{
    return TpmTypeId::TPM2B_ECC_PARAMETER_ID;
}

TPM2B_ECC_PARAMETER::TPM2B_ECC_PARAMETER(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM. </summary>
TPM2B_ECC_PARAMETER::~TPM2B_ECC_PARAMETER() {}

/// <summary> This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM. </summary>
TpmStructureBase* TPM2B_ECC_PARAMETER::Clone() const
{
    return new TPM2B_ECC_PARAMETER(*this);
}

void* TPM2B_ECC_PARAMETER::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ECC_POINT::GetTypeId() const
{
    return TpmTypeId::TPMS_ECC_POINT_ID;
}

TPMS_ECC_POINT::TPMS_ECC_POINT(
    const ByteVec& _x,
    const ByteVec& _y
)
{
    x = _x;
    y = _y;
}

/// <summary> This structure holds two ECC coordinates that, together, make up an ECC point. </summary>
TPMS_ECC_POINT::~TPMS_ECC_POINT() {}

/// <summary> This structure holds two ECC coordinates that, together, make up an ECC point. </summary>
TpmStructureBase* TPMS_ECC_POINT::Clone() const
{
    return new TPMS_ECC_POINT(*this);
}

void* TPMS_ECC_POINT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &xSize;
            case 1: { if (newArraySize != -1) x.resize(newArraySize); arraySize = (int)x.size(); return &x; }
            case 2: return &ySize;
            case 3: { if (newArraySize != -1) y.resize(newArraySize); arraySize = (int)y.size(); return &y; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &x[arrayIndex];
            case 3: return &y[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ECC_POINT::GetTypeId() const
{
    return TpmTypeId::TPM2B_ECC_POINT_ID;
}

TPM2B_ECC_POINT::TPM2B_ECC_POINT(
    const TPMS_ECC_POINT& _point
)
{
    point = _point;
}

/// <summary> This structure is defined to allow a point to be a single sized parameter so that it may be encrypted. </summary>
TPM2B_ECC_POINT::~TPM2B_ECC_POINT() {}

/// <summary> This structure is defined to allow a point to be a single sized parameter so that it may be encrypted. </summary>
TpmStructureBase* TPM2B_ECC_POINT::Clone() const
{
    return new TPM2B_ECC_POINT(*this);
}

void* TPM2B_ECC_POINT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&point); return &point;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_ECC_SCHEME::GetTypeId() const
{
    return TpmTypeId::TPMT_ECC_SCHEME_ID;
}

TPMT_ECC_SCHEME::TPMT_ECC_SCHEME(
    const TPMU_ASYM_SCHEME& _details
)
{
    details.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()));
}

/// <summary> Table 183  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure </summary>
TPMT_ECC_SCHEME::~TPMT_ECC_SCHEME() {}

/// <summary> Table 183  Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure </summary>
TpmStructureBase* TPMT_ECC_SCHEME::Clone() const
{
    return new TPMT_ECC_SCHEME(*this);
}

void* TPMT_ECC_SCHEME::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &scheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*details); return &details;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ALGORITHM_DETAIL_ECC::GetTypeId() const
{
    return TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
}

TPMS_ALGORITHM_DETAIL_ECC::TPMS_ALGORITHM_DETAIL_ECC(
    TPM_ECC_CURVE _curveID,
    UINT16 _keySize,
    const TPMU_KDF_SCHEME& _kdf,
    const TPMU_ASYM_SCHEME& _sign,
    const ByteVec& _p,
    const ByteVec& _a,
    const ByteVec& _b,
    const ByteVec& _gX,
    const ByteVec& _gY,
    const ByteVec& _n,
    const ByteVec& _h
)
{
    curveID = _curveID;
    keySize = _keySize;
    kdf.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone()));
    sign.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_sign.Clone()));
    p = _p;
    a = _a;
    b = _b;
    gX = _gX;
    gY = _gY;
    n = _n;
    h = _h;
}

/// <summary> This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters(). </summary>
TPMS_ALGORITHM_DETAIL_ECC::~TPMS_ALGORITHM_DETAIL_ECC() {}

/// <summary> This structure is used to report on the curve parameters of an ECC curve. It is returned by TPM2_ECC_Parameters(). </summary>
TpmStructureBase* TPMS_ALGORITHM_DETAIL_ECC::Clone() const
{
    return new TPMS_ALGORITHM_DETAIL_ECC(*this);
}

void* TPMS_ALGORITHM_DETAIL_ECC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &curveID;
            case 1: return &keySize;
            case 2: return &kdfScheme;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*kdf); return &kdf;
            case 4: return &signScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*sign); return &sign;
            case 6: return &pSize;
            case 7: { if (newArraySize != -1) p.resize(newArraySize); arraySize = (int)p.size(); return &p; }
            case 8: return &aSize;
            case 9: { if (newArraySize != -1) a.resize(newArraySize); arraySize = (int)a.size(); return &a; }
            case 10: return &bSize;
            case 11: { if (newArraySize != -1) b.resize(newArraySize); arraySize = (int)b.size(); return &b; }
            case 12: return &gXSize;
            case 13: { if (newArraySize != -1) gX.resize(newArraySize); arraySize = (int)gX.size(); return &gX; }
            case 14: return &gYSize;
            case 15: { if (newArraySize != -1) gY.resize(newArraySize); arraySize = (int)gY.size(); return &gY; }
            case 16: return &nSize;
            case 17: { if (newArraySize != -1) n.resize(newArraySize); arraySize = (int)n.size(); return &n; }
            case 18: return &hSize;
            case 19: { if (newArraySize != -1) h.resize(newArraySize); arraySize = (int)h.size(); return &h; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 7: return &p[arrayIndex];
            case 9: return &a[arrayIndex];
            case 11: return &b[arrayIndex];
            case 13: return &gX[arrayIndex];
            case 15: return &gY[arrayIndex];
            case 17: return &n[arrayIndex];
            case 19: return &h[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_RSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSA_ID;
}

TPMS_SIGNATURE_RSA::TPMS_SIGNATURE_RSA(
    TPM_ALG_ID _hash,
    const ByteVec& _sig
)
{
    hash = _hash;
    sig = _sig;
}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TPMS_SIGNATURE_RSA::~TPMS_SIGNATURE_RSA() {}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_RSA::Clone() const
{
    return new TPMS_SIGNATURE_RSA(*this);
}

void* TPMS_SIGNATURE_RSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sigSize;
            case 2: { if (newArraySize != -1) sig.resize(newArraySize); arraySize = (int)sig.size(); return &sig; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sig[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_RSASSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
}

TPMS_SIGNATURE_RSASSA::TPMS_SIGNATURE_RSASSA(
    TPM_ALG_ID _hash,
    const ByteVec& _sig
)
{
    hash = _hash;
    sig = _sig;
}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TPMS_SIGNATURE_RSASSA::~TPMS_SIGNATURE_RSASSA() {}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_RSASSA::Clone() const
{
    return new TPMS_SIGNATURE_RSASSA(*this);
}

void* TPMS_SIGNATURE_RSASSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sigSize;
            case 2: { if (newArraySize != -1) sig.resize(newArraySize); arraySize = (int)sig.size(); return &sig; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sig[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_RSAPSS::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
}

TPMS_SIGNATURE_RSAPSS::TPMS_SIGNATURE_RSAPSS(
    TPM_ALG_ID _hash,
    const ByteVec& _sig
)
{
    hash = _hash;
    sig = _sig;
}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TPMS_SIGNATURE_RSAPSS::~TPMS_SIGNATURE_RSAPSS() {}

/// <summary> Table 185  Definition of {RSA} TPMS_SIGNATURE_RSA Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_RSAPSS::Clone() const
{
    return new TPMS_SIGNATURE_RSAPSS(*this);
}

void* TPMS_SIGNATURE_RSAPSS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &sigSize;
            case 2: { if (newArraySize != -1) sig.resize(newArraySize); arraySize = (int)sig.size(); return &sig; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &sig[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECC::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECC_ID;
}

TPMS_SIGNATURE_ECC::TPMS_SIGNATURE_ECC(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECC::~TPMS_SIGNATURE_ECC() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECC::Clone() const
{
    return new TPMS_SIGNATURE_ECC(*this);
}

void* TPMS_SIGNATURE_ECC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECDSA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
}

TPMS_SIGNATURE_ECDSA::TPMS_SIGNATURE_ECDSA(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECDSA::~TPMS_SIGNATURE_ECDSA() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECDSA::Clone() const
{
    return new TPMS_SIGNATURE_ECDSA(*this);
}

void* TPMS_SIGNATURE_ECDSA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECDAA::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
}

TPMS_SIGNATURE_ECDAA::TPMS_SIGNATURE_ECDAA(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECDAA::~TPMS_SIGNATURE_ECDAA() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECDAA::Clone() const
{
    return new TPMS_SIGNATURE_ECDAA(*this);
}

void* TPMS_SIGNATURE_ECDAA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_SM2::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_SM2_ID;
}

TPMS_SIGNATURE_SM2::TPMS_SIGNATURE_SM2(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_SM2::~TPMS_SIGNATURE_SM2() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_SM2::Clone() const
{
    return new TPMS_SIGNATURE_SM2(*this);
}

void* TPMS_SIGNATURE_SM2::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_SIGNATURE_ECSCHNORR::GetTypeId() const
{
    return TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
}

TPMS_SIGNATURE_ECSCHNORR::TPMS_SIGNATURE_ECSCHNORR(
    TPM_ALG_ID _hash,
    const ByteVec& _signatureR,
    const ByteVec& _signatureS
)
{
    hash = _hash;
    signatureR = _signatureR;
    signatureS = _signatureS;
}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TPMS_SIGNATURE_ECSCHNORR::~TPMS_SIGNATURE_ECSCHNORR() {}

/// <summary> Table 187  Definition of {ECC} TPMS_SIGNATURE_ECC Structure </summary>
TpmStructureBase* TPMS_SIGNATURE_ECSCHNORR::Clone() const
{
    return new TPMS_SIGNATURE_ECSCHNORR(*this);
}

void* TPMS_SIGNATURE_ECSCHNORR::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &hash;
            case 1: return &signatureRSize;
            case 2: { if (newArraySize != -1) signatureR.resize(newArraySize); arraySize = (int)signatureR.size(); return &signatureR; }
            case 3: return &signatureSSize;
            case 4: { if (newArraySize != -1) signatureS.resize(newArraySize); arraySize = (int)signatureS.size(); return &signatureS; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &signatureR[arrayIndex];
            case 4: return &signatureS[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_NULL_SIGNATURE::GetTypeId() const
{
    return TpmTypeId::TPMS_NULL_SIGNATURE_ID;
}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TPMS_NULL_SIGNATURE::~TPMS_NULL_SIGNATURE() {}

/// <summary>
/// Custom data structure representing an empty element (i.e. the one with 
/// no data to marshal) for selector algorithm TPM_ALG_NULL for the union TpmuSignature
/// </summary>
TpmStructureBase* TPMS_NULL_SIGNATURE::Clone() const
{
    return new TPMS_NULL_SIGNATURE(*this);
}

void* TPMS_NULL_SIGNATURE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPMT_SIGNATURE::GetTypeId() const
{
    return TpmTypeId::TPMT_SIGNATURE_ID;
}

TPMT_SIGNATURE::TPMT_SIGNATURE(
    const TPMU_SIGNATURE& _signature
)
{
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart(). </summary>
TPMT_SIGNATURE::~TPMT_SIGNATURE() {}

/// <summary> Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric signature is indicated. The sigAlg parameter indicates the algorithm used for the signature. This structure is output from commands such as the attestation commands and TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(), TPM2_PolicySigned(), and TPM2_FieldUpgradeStart(). </summary>
TpmStructureBase* TPMT_SIGNATURE::Clone() const
{
    return new TPMT_SIGNATURE(*this);
}

void* TPMT_SIGNATURE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sigAlg;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_ENCRYPTED_SECRET::GetTypeId() const
{
    return TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
}

TPM2B_ENCRYPTED_SECRET::TPM2B_ENCRYPTED_SECRET(
    const ByteVec& _secret
)
{
    secret = _secret;
}

/// <summary> Table 192  Definition of TPM2B_ENCRYPTED_SECRET Structure </summary>
TPM2B_ENCRYPTED_SECRET::~TPM2B_ENCRYPTED_SECRET() {}

/// <summary> Table 192  Definition of TPM2B_ENCRYPTED_SECRET Structure </summary>
TpmStructureBase* TPM2B_ENCRYPTED_SECRET::Clone() const
{
    return new TPM2B_ENCRYPTED_SECRET(*this);
}

void* TPM2B_ENCRYPTED_SECRET::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) secret.resize(newArraySize); arraySize = (int)secret.size(); return &secret; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &secret[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_KEYEDHASH_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
}

TPMS_KEYEDHASH_PARMS::TPMS_KEYEDHASH_PARMS(
    const TPMU_SCHEME_KEYEDHASH& _scheme
)
{
    scheme.reset(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_scheme.Clone()));
}

/// <summary> This structure describes the parameters that would appear in the public area of a KEYEDHASH object. </summary>
TPMS_KEYEDHASH_PARMS::~TPMS_KEYEDHASH_PARMS() {}

/// <summary> This structure describes the parameters that would appear in the public area of a KEYEDHASH object. </summary>
TpmStructureBase* TPMS_KEYEDHASH_PARMS::Clone() const
{
    return new TPMS_KEYEDHASH_PARMS(*this);
}

void* TPMS_KEYEDHASH_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &schemeScheme;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ASYM_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_ASYM_PARMS_ID;
}

TPMS_ASYM_PARMS::TPMS_ASYM_PARMS(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme
)
{
    symmetric = _symmetric;
    scheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()));
}

/// <summary> This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components. </summary>
TPMS_ASYM_PARMS::~TPMS_ASYM_PARMS() {}

/// <summary> This structure contains the common public area parameters for an asymmetric key. The first two parameters of the parameter definition structures of an asymmetric key shall have the same two first components. </summary>
TpmStructureBase* TPMS_ASYM_PARMS::Clone() const
{
    return new TPMS_ASYM_PARMS(*this);
}

void* TPMS_ASYM_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 1: return &schemeScheme;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_RSA_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_RSA_PARMS_ID;
}

TPMS_RSA_PARMS::TPMS_RSA_PARMS(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme,
    UINT16 _keyBits,
    UINT32 _exponent
)
{
    symmetric = _symmetric;
    scheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()));
    keyBits = _keyBits;
    exponent = _exponent;
}

/// <summary> A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs. </summary>
TPMS_RSA_PARMS::~TPMS_RSA_PARMS() {}

/// <summary> A TPM compatible with this specification and supporting RSA shall support two primes and an exponent of zero. An exponent of zero indicates that the exponent is the default of 216 + 1. Support for other values is optional. Use of other exponents in duplicated keys is not recommended because the resulting keys would not be interoperable with other TPMs. </summary>
TpmStructureBase* TPMS_RSA_PARMS::Clone() const
{
    return new TPMS_RSA_PARMS(*this);
}

void* TPMS_RSA_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 1: return &schemeScheme;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            case 3: return &keyBits;
            case 4: return &exponent;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_ECC_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMS_ECC_PARMS_ID;
}

TPMS_ECC_PARMS::TPMS_ECC_PARMS(
    const TPMT_SYM_DEF_OBJECT& _symmetric,
    const TPMU_ASYM_SCHEME& _scheme,
    TPM_ECC_CURVE _curveID,
    const TPMU_KDF_SCHEME& _kdf
)
{
    symmetric = _symmetric;
    scheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()));
    curveID = _curveID;
    kdf.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone()));
}

/// <summary> This structure contains the parameters for prime modulus ECC. </summary>
TPMS_ECC_PARMS::~TPMS_ECC_PARMS() {}

/// <summary> This structure contains the parameters for prime modulus ECC. </summary>
TpmStructureBase* TPMS_ECC_PARMS::Clone() const
{
    return new TPMS_ECC_PARMS(*this);
}

void* TPMS_ECC_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 1: return &schemeScheme;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*scheme); return &scheme;
            case 3: return &curveID;
            case 4: return &kdfScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*kdf); return &kdf;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMT_PUBLIC_PARMS::GetTypeId() const
{
    return TpmTypeId::TPMT_PUBLIC_PARMS_ID;
}

TPMT_PUBLIC_PARMS::TPMT_PUBLIC_PARMS(
    const TPMU_PUBLIC_PARMS& _parameters
)
{
    parameters.reset(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()));
}

/// <summary> This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM. </summary>
TPMT_PUBLIC_PARMS::~TPMT_PUBLIC_PARMS() {}

/// <summary> This structure is used in TPM2_TestParms() to validate that a set of algorithm parameters is supported by the TPM. </summary>
TpmStructureBase* TPMT_PUBLIC_PARMS::Clone() const
{
    return new TPMT_PUBLIC_PARMS(*this);
}

void* TPMT_PUBLIC_PARMS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &type;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*parameters); return &parameters;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _TPMT_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPMT_PUBLIC_ID;
}

_TPMT_PUBLIC::_TPMT_PUBLIC(
    TPM_ALG_ID _nameAlg,
    TPMA_OBJECT _objectAttributes,
    const ByteVec& _authPolicy,
    const TPMU_PUBLIC_PARMS& _parameters,
    const TPMU_PUBLIC_ID& _unique
)
{
    nameAlg = _nameAlg;
    objectAttributes = _objectAttributes;
    authPolicy = _authPolicy;
    parameters.reset(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()));
    unique.reset(dynamic_cast<TPMU_PUBLIC_ID*>(_unique.Clone()));
}

/// <summary> Table 201 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg. </summary>
_TPMT_PUBLIC::~_TPMT_PUBLIC() {}

/// <summary> Table 201 defines the public area structure. The Name of the object is nameAlg concatenated with the digest of this structure using nameAlg. </summary>
TpmStructureBase* _TPMT_PUBLIC::Clone() const
{
    return new TPMT_PUBLIC(dynamic_cast<const TPMT_PUBLIC&>(*this));
}

void* _TPMT_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &type;
            case 1: return &nameAlg;
            case 2: return &objectAttributes;
            case 3: return &authPolicySize;
            case 4: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*parameters); return &parameters;
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&*unique); return &unique;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_PUBLIC_ID;
}

TPM2B_PUBLIC::TPM2B_PUBLIC(
    const TPMT_PUBLIC& _publicArea
)
{
    publicArea = _publicArea;
}

/// <summary> This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area. </summary>
TPM2B_PUBLIC::~TPM2B_PUBLIC() {}

/// <summary> This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response that returns a public area. </summary>
TpmStructureBase* TPM2B_PUBLIC::Clone() const
{
    return new TPM2B_PUBLIC(*this);
}

void* TPM2B_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&publicArea); return &publicArea;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_TEMPLATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_TEMPLATE_ID;
}

TPM2B_TEMPLATE::TPM2B_TEMPLATE(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded(). </summary>
TPM2B_TEMPLATE::~TPM2B_TEMPLATE() {}

/// <summary> This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded(). </summary>
TpmStructureBase* TPM2B_TEMPLATE::Clone() const
{
    return new TPM2B_TEMPLATE(*this);
}

void* TPM2B_TEMPLATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PRIVATE_VENDOR_SPECIFIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
}

TPM2B_PRIVATE_VENDOR_SPECIFIC::TPM2B_PRIVATE_VENDOR_SPECIFIC(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations. </summary>
TPM2B_PRIVATE_VENDOR_SPECIFIC::~TPM2B_PRIVATE_VENDOR_SPECIFIC() {}

/// <summary> This structure is defined for coding purposes. For IO to the TPM, the sensitive portion of the key will be in a canonical form. For an RSA key, this will be one of the prime factors of the public modulus. After loading, it is typical that other values will be computed so that computations using the private key will not need to start with just one prime factor. This structure can be used to store the results of such vendor-specific calculations. </summary>
TpmStructureBase* TPM2B_PRIVATE_VENDOR_SPECIFIC::Clone() const
{
    return new TPM2B_PRIVATE_VENDOR_SPECIFIC(*this);
}

void* TPM2B_PRIVATE_VENDOR_SPECIFIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId _TPMT_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPMT_SENSITIVE_ID;
}

_TPMT_SENSITIVE::_TPMT_SENSITIVE(
    const ByteVec& _authValue,
    const ByteVec& _seedValue,
    const TPMU_SENSITIVE_COMPOSITE& _sensitive
)
{
    authValue = _authValue;
    seedValue = _seedValue;
    sensitive.reset(dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(_sensitive.Clone()));
}

/// <summary> authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object. </summary>
_TPMT_SENSITIVE::~_TPMT_SENSITIVE() {}

/// <summary> authValue shall not be larger than the size of the digest produced by the nameAlg of the object. seedValue shall be the size of the digest produced by the nameAlg of the object. </summary>
TpmStructureBase* _TPMT_SENSITIVE::Clone() const
{
    return new TPMT_SENSITIVE(dynamic_cast<const TPMT_SENSITIVE&>(*this));
}

void* _TPMT_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sensitiveType;
            case 1: return &authValueSize;
            case 2: { if (newArraySize != -1) authValue.resize(newArraySize); arraySize = (int)authValue.size(); return &authValue; }
            case 3: return &seedValueSize;
            case 4: { if (newArraySize != -1) seedValue.resize(newArraySize); arraySize = (int)seedValue.size(); return &seedValue; }
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*sensitive); return &sensitive;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &authValue[arrayIndex];
            case 4: return &seedValue[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_SENSITIVE_ID;
}

TPM2B_SENSITIVE::TPM2B_SENSITIVE(
    const TPMT_SENSITIVE& _sensitiveArea
)
{
    sensitiveArea = _sensitiveArea;
}

/// <summary> The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption. </summary>
TPM2B_SENSITIVE::~TPM2B_SENSITIVE() {}

/// <summary> The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an unencrypted sensitive area but it may be encrypted using parameter encryption. </summary>
TpmStructureBase* TPM2B_SENSITIVE::Clone() const
{
    return new TPM2B_SENSITIVE(*this);
}

void* TPM2B_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sensitiveArea); return &sensitiveArea;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _PRIVATE::GetTypeId() const
{
    return TpmTypeId::_PRIVATE_ID;
}

_PRIVATE::_PRIVATE(
    const ByteVec& _integrityOuter,
    const ByteVec& _integrityInner,
    const TPMT_SENSITIVE& _sensitive
)
{
    integrityOuter = _integrityOuter;
    integrityInner = _integrityInner;
    sensitive = _sensitive;
}

/// <summary> This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled. </summary>
_PRIVATE::~_PRIVATE() {}

/// <summary> This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is not directly marshaled or unmarshaled. </summary>
TpmStructureBase* _PRIVATE::Clone() const
{
    return new _PRIVATE(*this);
}

void* _PRIVATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &integrityOuterSize;
            case 1: { if (newArraySize != -1) integrityOuter.resize(newArraySize); arraySize = (int)integrityOuter.size(); return &integrityOuter; }
            case 2: return &integrityInnerSize;
            case 3: { if (newArraySize != -1) integrityInner.resize(newArraySize); arraySize = (int)integrityInner.size(); return &integrityInner; }
            case 4: return &sensitiveSize;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&sensitive); return &sensitive;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &integrityOuter[arrayIndex];
            case 3: return &integrityInner[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_PRIVATE::GetTypeId() const
{
    return TpmTypeId::TPM2B_PRIVATE_ID;
}

TPM2B_PRIVATE::TPM2B_PRIVATE(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object. </summary>
TPM2B_PRIVATE::~TPM2B_PRIVATE() {}

/// <summary> The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create, load, and modify the sensitive area of an object. </summary>
TpmStructureBase* TPM2B_PRIVATE::Clone() const
{
    return new TPM2B_PRIVATE(*this);
}

void* TPM2B_PRIVATE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_ID_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPMS_ID_OBJECT_ID;
}

TPMS_ID_OBJECT::TPMS_ID_OBJECT(
    const ByteVec& _integrityHMAC,
    const ByteVec& _encIdentity
)
{
    integrityHMAC = _integrityHMAC;
    encIdentity = _encIdentity;
}

/// <summary> This structure is used for sizing the TPM2B_ID_OBJECT. </summary>
TPMS_ID_OBJECT::~TPMS_ID_OBJECT() {}

/// <summary> This structure is used for sizing the TPM2B_ID_OBJECT. </summary>
TpmStructureBase* TPMS_ID_OBJECT::Clone() const
{
    return new TPMS_ID_OBJECT(*this);
}

void* TPMS_ID_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &integrityHMACSize;
            case 1: { if (newArraySize != -1) integrityHMAC.resize(newArraySize); arraySize = (int)integrityHMAC.size(); return &integrityHMAC; }
            case 2: { if (newArraySize != -1) encIdentity.resize(newArraySize); arraySize = (int)encIdentity.size(); return &encIdentity; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &integrityHMAC[arrayIndex];
            case 2: return &encIdentity[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_ID_OBJECT::GetTypeId() const
{
    return TpmTypeId::TPM2B_ID_OBJECT_ID;
}

TPM2B_ID_OBJECT::TPM2B_ID_OBJECT(
    const TPMS_ID_OBJECT& _credential
)
{
    credential = _credential;
}

/// <summary> This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential(). </summary>
TPM2B_ID_OBJECT::~TPM2B_ID_OBJECT() {}

/// <summary> This structure is an output from TPM2_MakeCredential() and is an input to TPM2_ActivateCredential(). </summary>
TpmStructureBase* TPM2B_ID_OBJECT::Clone() const
{
    return new TPM2B_ID_OBJECT(*this);
}

void* TPM2B_ID_OBJECT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&credential); return &credential;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NV_PIN_COUNTER_PARAMETERS::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
}

TPMS_NV_PIN_COUNTER_PARAMETERS::TPMS_NV_PIN_COUNTER_PARAMETERS(
    UINT32 _pinCount,
    UINT32 _pinLimit
)
{
    pinCount = _pinCount;
    pinLimit = _pinLimit;
}

/// <summary> This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets. </summary>
TPMS_NV_PIN_COUNTER_PARAMETERS::~TPMS_NV_PIN_COUNTER_PARAMETERS() {}

/// <summary> This is the data that can be written to and read from a TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit is the least significant octets. </summary>
TpmStructureBase* TPMS_NV_PIN_COUNTER_PARAMETERS::Clone() const
{
    return new TPMS_NV_PIN_COUNTER_PARAMETERS(*this);
}

void* TPMS_NV_PIN_COUNTER_PARAMETERS::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pinCount;
            case 1: return &pinLimit;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_NV_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPMS_NV_PUBLIC_ID;
}

TPMS_NV_PUBLIC::TPMS_NV_PUBLIC(
    const TPM_HANDLE& _nvIndex,
    TPM_ALG_ID _nameAlg,
    TPMA_NV _attributes,
    const ByteVec& _authPolicy,
    UINT16 _dataSize
)
{
    nvIndex = _nvIndex;
    nameAlg = _nameAlg;
    attributes = _attributes;
    authPolicy = _authPolicy;
    dataSize = _dataSize;
}

/// <summary> This structure describes an NV Index. </summary>
TPMS_NV_PUBLIC::~TPMS_NV_PUBLIC() {}

/// <summary> This structure describes an NV Index. </summary>
TpmStructureBase* TPMS_NV_PUBLIC::Clone() const
{
    return new TPMS_NV_PUBLIC(*this);
}

void* TPMS_NV_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 1: return &nameAlg;
            case 2: return &attributes;
            case 3: return &authPolicySize;
            case 4: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 5: return &dataSize;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_NV_PUBLIC::GetTypeId() const
{
    return TpmTypeId::TPM2B_NV_PUBLIC_ID;
}

TPM2B_NV_PUBLIC::TPM2B_NV_PUBLIC(
    const TPMS_NV_PUBLIC& _nvPublic
)
{
    nvPublic = _nvPublic;
}

/// <summary> This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface. </summary>
TPM2B_NV_PUBLIC::~TPM2B_NV_PUBLIC() {}

/// <summary> This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface. </summary>
TpmStructureBase* TPM2B_NV_PUBLIC::Clone() const
{
    return new TPM2B_NV_PUBLIC(*this);
}

void* TPM2B_NV_PUBLIC::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvPublic); return &nvPublic;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2B_CONTEXT_SENSITIVE::GetTypeId() const
{
    return TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
}

TPM2B_CONTEXT_SENSITIVE::TPM2B_CONTEXT_SENSITIVE(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure holds the object or session context data. When saved, the full structure is encrypted. </summary>
TPM2B_CONTEXT_SENSITIVE::~TPM2B_CONTEXT_SENSITIVE() {}

/// <summary> This structure holds the object or session context data. When saved, the full structure is encrypted. </summary>
TpmStructureBase* TPM2B_CONTEXT_SENSITIVE::Clone() const
{
    return new TPM2B_CONTEXT_SENSITIVE(*this);
}

void* TPM2B_CONTEXT_SENSITIVE::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPMS_CONTEXT_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CONTEXT_DATA_ID;
}

TPMS_CONTEXT_DATA::TPMS_CONTEXT_DATA(
    const ByteVec& _integrity,
    const ByteVec& _encrypted
)
{
    integrity = _integrity;
    encrypted = _encrypted;
}

/// <summary> This structure holds the integrity value and the encrypted data for a context. </summary>
TPMS_CONTEXT_DATA::~TPMS_CONTEXT_DATA() {}

/// <summary> This structure holds the integrity value and the encrypted data for a context. </summary>
TpmStructureBase* TPMS_CONTEXT_DATA::Clone() const
{
    return new TPMS_CONTEXT_DATA(*this);
}

void* TPMS_CONTEXT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &integritySize;
            case 1: { if (newArraySize != -1) integrity.resize(newArraySize); arraySize = (int)integrity.size(); return &integrity; }
            case 2: { if (newArraySize != -1) encrypted.resize(newArraySize); arraySize = (int)encrypted.size(); return &encrypted; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &integrity[arrayIndex];
            case 2: return &encrypted[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_CONTEXT_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_CONTEXT_DATA_ID;
}

TPM2B_CONTEXT_DATA::TPM2B_CONTEXT_DATA(
    const TPMS_CONTEXT_DATA& _buffer
)
{
    buffer = _buffer;
}

/// <summary> This structure is used in a TPMS_CONTEXT. </summary>
TPM2B_CONTEXT_DATA::~TPM2B_CONTEXT_DATA() {}

/// <summary> This structure is used in a TPMS_CONTEXT. </summary>
TpmStructureBase* TPM2B_CONTEXT_DATA::Clone() const
{
    return new TPM2B_CONTEXT_DATA(*this);
}

void* TPM2B_CONTEXT_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&buffer); return &buffer;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CONTEXT::GetTypeId() const
{
    return TpmTypeId::TPMS_CONTEXT_ID;
}

TPMS_CONTEXT::TPMS_CONTEXT(
    UINT64 _sequence,
    const TPM_HANDLE& _savedHandle,
    const TPM_HANDLE& _hierarchy,
    const TPMS_CONTEXT_DATA& _contextBlob
)
{
    sequence = _sequence;
    savedHandle = _savedHandle;
    hierarchy = _hierarchy;
    contextBlob = _contextBlob;
}

/// <summary> This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context. </summary>
TPMS_CONTEXT::~TPMS_CONTEXT() {}

/// <summary> This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when the context was saved (TPM2_ContextSave()), then the TPM shall not load the context. </summary>
TpmStructureBase* TPMS_CONTEXT::Clone() const
{
    return new TPMS_CONTEXT(*this);
}

void* TPMS_CONTEXT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sequence;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&savedHandle); return &savedHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            case 3: return &contextBlobSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&contextBlob); return &contextBlob;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_CREATION_DATA::GetTypeId() const
{
    return TpmTypeId::TPMS_CREATION_DATA_ID;
}

TPMS_CREATION_DATA::TPMS_CREATION_DATA(
    const vector<TPMS_PCR_SELECTION>& _pcrSelect,
    const ByteVec& _pcrDigest,
    TPMA_LOCALITY _locality,
    TPM_ALG_ID _parentNameAlg,
    const ByteVec& _parentName,
    const ByteVec& _parentQualifiedName,
    const ByteVec& _outsideInfo
)
{
    pcrSelect = _pcrSelect;
    pcrDigest = _pcrDigest;
    locality = _locality;
    parentNameAlg = _parentNameAlg;
    parentName = _parentName;
    parentQualifiedName = _parentQualifiedName;
    outsideInfo = _outsideInfo;
}

/// <summary> This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present. </summary>
TPMS_CREATION_DATA::~TPMS_CREATION_DATA() {}

/// <summary> This structure provides information relating to the creation environment for the object. The creation data includes the parent Name, parent Qualified Name, and the digest of selected PCR. These values represent the environment in which the object was created. Creation data allows a relying party to determine if an object was created when some appropriate protections were present. </summary>
TpmStructureBase* TPMS_CREATION_DATA::Clone() const
{
    return new TPMS_CREATION_DATA(*this);
}

void* TPMS_CREATION_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrSelectCount;
            case 1: { if (newArraySize != -1) pcrSelect.resize(newArraySize); arraySize = (int)pcrSelect.size(); return &pcrSelect; }
            case 2: return &pcrDigestSize;
            case 3: { if (newArraySize != -1) pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return &pcrDigest; }
            case 4: return &locality;
            case 5: return &parentNameAlg;
            case 6: return &parentNameSize;
            case 7: { if (newArraySize != -1) parentName.resize(newArraySize); arraySize = (int)parentName.size(); return &parentName; }
            case 8: return &parentQualifiedNameSize;
            case 9: { if (newArraySize != -1) parentQualifiedName.resize(newArraySize); arraySize = (int)parentQualifiedName.size(); return &parentQualifiedName; }
            case 10: return &outsideInfoSize;
            case 11: { if (newArraySize != -1) outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return &outsideInfo; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelect[arrayIndex]); return &pcrSelect[arrayIndex];
            case 3: return &pcrDigest[arrayIndex];
            case 7: return &parentName[arrayIndex];
            case 9: return &parentQualifiedName[arrayIndex];
            case 11: return &outsideInfo[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_CREATION_DATA::GetTypeId() const
{
    return TpmTypeId::TPM2B_CREATION_DATA_ID;
}

TPM2B_CREATION_DATA::TPM2B_CREATION_DATA(
    const TPMS_CREATION_DATA& _creationData
)
{
    creationData = _creationData;
}

/// <summary> This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero. </summary>
TPM2B_CREATION_DATA::~TPM2B_CREATION_DATA() {}

/// <summary> This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never entered into the TPM and never has a size of zero. </summary>
TpmStructureBase* TPM2B_CREATION_DATA::Clone() const
{
    return new TPM2B_CREATION_DATA(*this);
}

void* TPM2B_CREATION_DATA::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return &creationData;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPMS_AC_OUTPUT::GetTypeId() const
{
    return TpmTypeId::TPMS_AC_OUTPUT_ID;
}

TPMS_AC_OUTPUT::TPMS_AC_OUTPUT(
    TPM_AT _tag,
    UINT32 _data
)
{
    tag = _tag;
    data = _data;
}

/// <summary> TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value. </summary>
TPMS_AC_OUTPUT::~TPMS_AC_OUTPUT() {}

/// <summary> TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter indicates the type of the data value. </summary>
TpmStructureBase* TPMS_AC_OUTPUT::Clone() const
{
    return new TPMS_AC_OUTPUT(*this);
}

void* TPMS_AC_OUTPUT::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &tag;
            case 1: return &data;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPML_AC_CAPABILITIES::GetTypeId() const
{
    return TpmTypeId::TPML_AC_CAPABILITIES_ID;
}

TPML_AC_CAPABILITIES::TPML_AC_CAPABILITIES(
    const vector<TPMS_AC_OUTPUT>& _acCapabilities
)
{
    acCapabilities = _acCapabilities;
}

/// <summary> This list is only used in TPM2_AC_GetCapability(). </summary>
TPML_AC_CAPABILITIES::~TPML_AC_CAPABILITIES() {}

/// <summary> This list is only used in TPM2_AC_GetCapability(). </summary>
TpmStructureBase* TPML_AC_CAPABILITIES::Clone() const
{
    return new TPML_AC_CAPABILITIES(*this);
}

void* TPML_AC_CAPABILITIES::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &count;
            case 1: { if (newArraySize != -1) acCapabilities.resize(newArraySize); arraySize = (int)acCapabilities.size(); return &acCapabilities; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&acCapabilities[arrayIndex]); return &acCapabilities[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Startup_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Startup_REQUEST_ID;
}

TPM2_Startup_REQUEST::TPM2_Startup_REQUEST(TPM_SU _startupType)
{
    startupType = _startupType;
}

/// <summary> TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE. </summary>
TPM2_Startup_REQUEST::~TPM2_Startup_REQUEST() {}

/// <summary> TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE. </summary>
TpmStructureBase* TPM2_Startup_REQUEST::Clone() const
{
    return new TPM2_Startup_REQUEST(*this);
}

void* TPM2_Startup_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &startupType;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId StartupResponse::GetTypeId() const
{
    return TpmTypeId::StartupResponse_ID;
}

/// <summary> TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE. </summary>
StartupResponse::~StartupResponse() {}

/// <summary> TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has completed successfully. If a TPM requires TPM2_Startup() and another command is received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall return TPM_RC_INITIALIZE. </summary>
TpmStructureBase* StartupResponse::Clone() const
{
    return new StartupResponse(*this);
}

void* StartupResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_Shutdown_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Shutdown_REQUEST_ID;
}

TPM2_Shutdown_REQUEST::TPM2_Shutdown_REQUEST(TPM_SU _shutdownType)
{
    shutdownType = _shutdownType;
}

/// <summary> This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed. </summary>
TPM2_Shutdown_REQUEST::~TPM2_Shutdown_REQUEST() {}

/// <summary> This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed. </summary>
TpmStructureBase* TPM2_Shutdown_REQUEST::Clone() const
{
    return new TPM2_Shutdown_REQUEST(*this);
}

void* TPM2_Shutdown_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &shutdownType;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ShutdownResponse::GetTypeId() const
{
    return TpmTypeId::ShutdownResponse_ID;
}

/// <summary> This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed. </summary>
ShutdownResponse::~ShutdownResponse() {}

/// <summary> This command is used to prepare the TPM for a power cycle. The shutdownType parameter indicates how the subsequent TPM2_Startup() will be processed. </summary>
TpmStructureBase* ShutdownResponse::Clone() const
{
    return new ShutdownResponse(*this);
}

void* ShutdownResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_SelfTest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SelfTest_REQUEST_ID;
}

TPM2_SelfTest_REQUEST::TPM2_SelfTest_REQUEST(BYTE _fullTest)
{
    fullTest = _fullTest;
}

/// <summary> This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested. </summary>
TPM2_SelfTest_REQUEST::~TPM2_SelfTest_REQUEST() {}

/// <summary> This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested. </summary>
TpmStructureBase* TPM2_SelfTest_REQUEST::Clone() const
{
    return new TPM2_SelfTest_REQUEST(*this);
}

void* TPM2_SelfTest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &fullTest;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId SelfTestResponse::GetTypeId() const
{
    return TpmTypeId::SelfTestResponse_ID;
}

/// <summary> This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested. </summary>
SelfTestResponse::~SelfTestResponse() {}

/// <summary> This command causes the TPM to perform a test of its capabilities. If the fullTest is YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those functions that have not previously been tested. </summary>
TpmStructureBase* SelfTestResponse::Clone() const
{
    return new SelfTestResponse(*this);
}

void* SelfTestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_IncrementalSelfTest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
}

TPM2_IncrementalSelfTest_REQUEST::TPM2_IncrementalSelfTest_REQUEST(
    const vector<TPM_ALG_ID>& _toTest
)
{
    toTest = _toTest;
}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
TPM2_IncrementalSelfTest_REQUEST::~TPM2_IncrementalSelfTest_REQUEST() {}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
TpmStructureBase* TPM2_IncrementalSelfTest_REQUEST::Clone() const
{
    return new TPM2_IncrementalSelfTest_REQUEST(*this);
}

void* TPM2_IncrementalSelfTest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &toTestCount;
            case 1: { if (newArraySize != -1) toTest.resize(newArraySize); arraySize = (int)toTest.size(); return &toTest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &toTest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId IncrementalSelfTestResponse::GetTypeId() const
{
    return TpmTypeId::IncrementalSelfTestResponse_ID;
}

IncrementalSelfTestResponse::IncrementalSelfTestResponse(
    const vector<TPM_ALG_ID>& _toDoList
)
{
    toDoList = _toDoList;
}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
IncrementalSelfTestResponse::~IncrementalSelfTestResponse() {}

/// <summary> This command causes the TPM to perform a test of the selected algorithms. </summary>
TpmStructureBase* IncrementalSelfTestResponse::Clone() const
{
    return new IncrementalSelfTestResponse(*this);
}

void* IncrementalSelfTestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &toDoListCount;
            case 1: { if (newArraySize != -1) toDoList.resize(newArraySize); arraySize = (int)toDoList.size(); return &toDoList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &toDoList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_GetTestResult_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetTestResult_REQUEST_ID;
}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
TPM2_GetTestResult_REQUEST::~TPM2_GetTestResult_REQUEST() {}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
TpmStructureBase* TPM2_GetTestResult_REQUEST::Clone() const
{
    return new TPM2_GetTestResult_REQUEST(*this);
}

void* TPM2_GetTestResult_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId GetTestResultResponse::GetTypeId() const
{
    return TpmTypeId::GetTestResultResponse_ID;
}

GetTestResultResponse::GetTestResultResponse(
    const ByteVec& _outData,
    TPM_RC _testResult
)
{
    outData = _outData;
    testResult = _testResult;
}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
GetTestResultResponse::~GetTestResultResponse() {}

/// <summary> This command returns manufacturer-specific information regarding the results of a self-test and an indication of the test status. </summary>
TpmStructureBase* GetTestResultResponse::Clone() const
{
    return new GetTestResultResponse(*this);
}

void* GetTestResultResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            case 2: return &testResult;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_StartAuthSession_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
}

TPM2_StartAuthSession_REQUEST::TPM2_StartAuthSession_REQUEST(
    const TPM_HANDLE& _tpmKey,
    const TPM_HANDLE& _bind,
    const ByteVec& _nonceCaller,
    const ByteVec& _encryptedSalt,
    TPM_SE _sessionType,
    const TPMT_SYM_DEF& _symmetric,
    TPM_ALG_ID _authHash
)
{
    tpmKey = _tpmKey;
    bind = _bind;
    nonceCaller = _nonceCaller;
    encryptedSalt = _encryptedSalt;
    sessionType = _sessionType;
    symmetric = _symmetric;
    authHash = _authHash;
}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
TPM2_StartAuthSession_REQUEST::~TPM2_StartAuthSession_REQUEST() {}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
TpmStructureBase* TPM2_StartAuthSession_REQUEST::Clone() const
{
    return new TPM2_StartAuthSession_REQUEST(*this);
}

void* TPM2_StartAuthSession_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&tpmKey); return &tpmKey;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&bind); return &bind;
            case 2: return &nonceCallerSize;
            case 3: { if (newArraySize != -1) nonceCaller.resize(newArraySize); arraySize = (int)nonceCaller.size(); return &nonceCaller; }
            case 4: return &encryptedSaltSize;
            case 5: { if (newArraySize != -1) encryptedSalt.resize(newArraySize); arraySize = (int)encryptedSalt.size(); return &encryptedSalt; }
            case 6: return &sessionType;
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&symmetric); return &symmetric;
            case 8: return &authHash;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nonceCaller[arrayIndex];
            case 5: return &encryptedSalt[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId StartAuthSessionResponse::GetTypeId() const
{
    return TpmTypeId::StartAuthSessionResponse_ID;
}

StartAuthSessionResponse::StartAuthSessionResponse(
    const TPM_HANDLE& _handle,
    const ByteVec& _nonceTPM
)
{
    handle = _handle;
    nonceTPM = _nonceTPM;
}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
StartAuthSessionResponse::~StartAuthSessionResponse() {}

/// <summary> This command is used to start an authorization session using alternative methods of establishing the session key (sessionKey). The session key is then used to derive values used for authorization and for encrypting parameters. </summary>
TpmStructureBase* StartAuthSessionResponse::Clone() const
{
    return new StartAuthSessionResponse(*this);
}

void* StartAuthSessionResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nonceTPMSize;
            case 2: { if (newArraySize != -1) nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return &nonceTPM; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nonceTPM[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyRestart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyRestart_REQUEST_ID;
}

TPM2_PolicyRestart_REQUEST::TPM2_PolicyRestart_REQUEST(const TPM_HANDLE& _sessionHandle)
{
    sessionHandle = _sessionHandle;
}

/// <summary> This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed. </summary>
TPM2_PolicyRestart_REQUEST::~TPM2_PolicyRestart_REQUEST() {}

/// <summary> This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed. </summary>
TpmStructureBase* TPM2_PolicyRestart_REQUEST::Clone() const
{
    return new TPM2_PolicyRestart_REQUEST(*this);
}

void* TPM2_PolicyRestart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return &sessionHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyRestartResponse::GetTypeId() const
{
    return TpmTypeId::PolicyRestartResponse_ID;
}

/// <summary> This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed. </summary>
PolicyRestartResponse::~PolicyRestartResponse() {}

/// <summary> This command allows a policy authorization session to be returned to its initial state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response code indicates that a policy will fail because the PCR have changed after TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be replayed because the session restarts with the same nonceTPM. If the PCR are valid for the policy, the policy may then succeed. </summary>
TpmStructureBase* PolicyRestartResponse::Clone() const
{
    return new PolicyRestartResponse(*this);
}

void* PolicyRestartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_Create_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Create_REQUEST_ID;
}

TPM2_Create_REQUEST::TPM2_Create_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const TPMT_PUBLIC& _inPublic,
    const ByteVec& _outsideInfo,
    const vector<TPMS_PCR_SELECTION>& _creationPCR
)
{
    parentHandle = _parentHandle;
    inSensitive = _inSensitive;
    inPublic = _inPublic;
    outsideInfo = _outsideInfo;
    creationPCR = _creationPCR;
}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
TPM2_Create_REQUEST::~TPM2_Create_REQUEST() {}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
TpmStructureBase* TPM2_Create_REQUEST::Clone() const
{
    return new TPM2_Create_REQUEST(*this);
}

void* TPM2_Create_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: return &inSensitiveSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return &inSensitive;
            case 3: return &inPublicSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            case 5: return &outsideInfoSize;
            case 6: { if (newArraySize != -1) outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return &outsideInfo; }
            case 7: return &creationPCRCount;
            case 8: { if (newArraySize != -1) creationPCR.resize(newArraySize); arraySize = (int)creationPCR.size(); return &creationPCR; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &outsideInfo[arrayIndex];
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationPCR[arrayIndex]); return &creationPCR[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CreateResponse::GetTypeId() const
{
    return TpmTypeId::CreateResponse_ID;
}

CreateResponse::CreateResponse(
    const TPM2B_PRIVATE& _outPrivate,
    const TPMT_PUBLIC& _outPublic,
    const TPMS_CREATION_DATA& _creationData,
    const ByteVec& _creationHash,
    const TPMT_TK_CREATION& _creationTicket
)
{
    outPrivate = _outPrivate;
    outPublic = _outPublic;
    creationData = _creationData;
    creationHash = _creationHash;
    creationTicket = _creationTicket;
}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
CreateResponse::~CreateResponse() {}

/// <summary> This command is used to create an object that can be loaded into a TPM using TPM2_Load(). If the command completes successfully, the TPM will create the new object and return the objects creation data (creationData), its public area (outPublic), and its encrypted sensitive area (outPrivate). Preservation of the returned data is the responsibility of the caller. The object will need to be loaded (TPM2_Load()) before it may be used. The only difference between the inPublic TPMT_PUBLIC template and the outPublic TPMT_PUBLIC object is in the unique field. </summary>
TpmStructureBase* CreateResponse::Clone() const
{
    return new CreateResponse(*this);
}

void* CreateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            case 1: return &outPublicSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 3: return &creationDataSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return &creationData;
            case 5: return &creationHashSize;
            case 6: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return &creationTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &creationHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Load_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Load_REQUEST_ID;
}

TPM2_Load_REQUEST::TPM2_Load_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const TPM2B_PRIVATE& _inPrivate,
    const TPMT_PUBLIC& _inPublic
)
{
    parentHandle = _parentHandle;
    inPrivate = _inPrivate;
    inPublic = _inPublic;
}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
TPM2_Load_REQUEST::~TPM2_Load_REQUEST() {}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
TpmStructureBase* TPM2_Load_REQUEST::Clone() const
{
    return new TPM2_Load_REQUEST(*this);
}

void* TPM2_Load_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&inPrivate); return &inPrivate;
            case 2: return &inPublicSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId LoadResponse::GetTypeId() const
{
    return TpmTypeId::LoadResponse_ID;
}

LoadResponse::LoadResponse(
    const TPM_HANDLE& _handle,
    const ByteVec& _name
)
{
    handle = _handle;
    name = _name;
}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
LoadResponse::~LoadResponse() {}

/// <summary> This command is used to load objects into the TPM. This command is used when both a TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be loaded, the TPM2_LoadExternal command is used. </summary>
TpmStructureBase* LoadResponse::Clone() const
{
    return new LoadResponse(*this);
}

void* LoadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nameSize;
            case 2: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_LoadExternal_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
}

TPM2_LoadExternal_REQUEST::TPM2_LoadExternal_REQUEST(
    const TPMT_SENSITIVE& _inPrivate,
    const TPMT_PUBLIC& _inPublic,
    const TPM_HANDLE& _hierarchy
)
{
    inPrivate = _inPrivate;
    inPublic = _inPublic;
    hierarchy = _hierarchy;
}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
TPM2_LoadExternal_REQUEST::~TPM2_LoadExternal_REQUEST() {}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
TpmStructureBase* TPM2_LoadExternal_REQUEST::Clone() const
{
    return new TPM2_LoadExternal_REQUEST(*this);
}

void* TPM2_LoadExternal_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &inPrivateSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&inPrivate); return &inPrivate;
            case 2: return &inPublicSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId LoadExternalResponse::GetTypeId() const
{
    return TpmTypeId::LoadExternalResponse_ID;
}

LoadExternalResponse::LoadExternalResponse(
    const TPM_HANDLE& _handle,
    const ByteVec& _name
)
{
    handle = _handle;
    name = _name;
}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
LoadExternalResponse::~LoadExternalResponse() {}

/// <summary> This command is used to load an object that is not a Protected Object into the TPM. The command allows loading of a public area or both a public and sensitive area. </summary>
TpmStructureBase* LoadExternalResponse::Clone() const
{
    return new LoadExternalResponse(*this);
}

void* LoadExternalResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nameSize;
            case 2: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ReadPublic_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ReadPublic_REQUEST_ID;
}

TPM2_ReadPublic_REQUEST::TPM2_ReadPublic_REQUEST(const TPM_HANDLE& _objectHandle)
{
    objectHandle = _objectHandle;
}

/// <summary> This command allows access to the public area of a loaded object. </summary>
TPM2_ReadPublic_REQUEST::~TPM2_ReadPublic_REQUEST() {}

/// <summary> This command allows access to the public area of a loaded object. </summary>
TpmStructureBase* TPM2_ReadPublic_REQUEST::Clone() const
{
    return new TPM2_ReadPublic_REQUEST(*this);
}

void* TPM2_ReadPublic_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ReadPublicResponse::GetTypeId() const
{
    return TpmTypeId::ReadPublicResponse_ID;
}

ReadPublicResponse::ReadPublicResponse(
    const TPMT_PUBLIC& _outPublic,
    const ByteVec& _name,
    const ByteVec& _qualifiedName
)
{
    outPublic = _outPublic;
    name = _name;
    qualifiedName = _qualifiedName;
}

/// <summary> This command allows access to the public area of a loaded object. </summary>
ReadPublicResponse::~ReadPublicResponse() {}

/// <summary> This command allows access to the public area of a loaded object. </summary>
TpmStructureBase* ReadPublicResponse::Clone() const
{
    return new ReadPublicResponse(*this);
}

void* ReadPublicResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outPublicSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 2: return &nameSize;
            case 3: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            case 4: return &qualifiedNameSize;
            case 5: { if (newArraySize != -1) qualifiedName.resize(newArraySize); arraySize = (int)qualifiedName.size(); return &qualifiedName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &name[arrayIndex];
            case 5: return &qualifiedName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ActivateCredential_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
}

TPM2_ActivateCredential_REQUEST::TPM2_ActivateCredential_REQUEST(
    const TPM_HANDLE& _activateHandle,
    const TPM_HANDLE& _keyHandle,
    const TPMS_ID_OBJECT& _credentialBlob,
    const ByteVec& _secret
)
{
    activateHandle = _activateHandle;
    keyHandle = _keyHandle;
    credentialBlob = _credentialBlob;
    secret = _secret;
}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
TPM2_ActivateCredential_REQUEST::~TPM2_ActivateCredential_REQUEST() {}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
TpmStructureBase* TPM2_ActivateCredential_REQUEST::Clone() const
{
    return new TPM2_ActivateCredential_REQUEST(*this);
}

void* TPM2_ActivateCredential_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&activateHandle); return &activateHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 2: return &credentialBlobSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&credentialBlob); return &credentialBlob;
            case 4: return &secretSize;
            case 5: { if (newArraySize != -1) secret.resize(newArraySize); arraySize = (int)secret.size(); return &secret; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 5: return &secret[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ActivateCredentialResponse::GetTypeId() const
{
    return TpmTypeId::ActivateCredentialResponse_ID;
}

ActivateCredentialResponse::ActivateCredentialResponse(
    const ByteVec& _certInfo
)
{
    certInfo = _certInfo;
}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
ActivateCredentialResponse::~ActivateCredentialResponse() {}

/// <summary> This command enables the association of a credential with an object in a way that ensures that the TPM has validated the parameters of the credentialed object. </summary>
TpmStructureBase* ActivateCredentialResponse::Clone() const
{
    return new ActivateCredentialResponse(*this);
}

void* ActivateCredentialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certInfoSize;
            case 1: { if (newArraySize != -1) certInfo.resize(newArraySize); arraySize = (int)certInfo.size(); return &certInfo; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &certInfo[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_MakeCredential_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
}

TPM2_MakeCredential_REQUEST::TPM2_MakeCredential_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _credential,
    const ByteVec& _objectName
)
{
    handle = _handle;
    credential = _credential;
    objectName = _objectName;
}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
TPM2_MakeCredential_REQUEST::~TPM2_MakeCredential_REQUEST() {}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
TpmStructureBase* TPM2_MakeCredential_REQUEST::Clone() const
{
    return new TPM2_MakeCredential_REQUEST(*this);
}

void* TPM2_MakeCredential_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &credentialSize;
            case 2: { if (newArraySize != -1) credential.resize(newArraySize); arraySize = (int)credential.size(); return &credential; }
            case 3: return &objectNameSize;
            case 4: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &credential[arrayIndex];
            case 4: return &objectName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId MakeCredentialResponse::GetTypeId() const
{
    return TpmTypeId::MakeCredentialResponse_ID;
}

MakeCredentialResponse::MakeCredentialResponse(
    const TPMS_ID_OBJECT& _credentialBlob,
    const ByteVec& _secret
)
{
    credentialBlob = _credentialBlob;
    secret = _secret;
}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
MakeCredentialResponse::~MakeCredentialResponse() {}

/// <summary> This command allows the TPM to perform the actions required of a Certificate Authority (CA) in creating a TPM2B_ID_OBJECT containing an activation credential. </summary>
TpmStructureBase* MakeCredentialResponse::Clone() const
{
    return new MakeCredentialResponse(*this);
}

void* MakeCredentialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &credentialBlobSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&credentialBlob); return &credentialBlob;
            case 2: return &secretSize;
            case 3: { if (newArraySize != -1) secret.resize(newArraySize); arraySize = (int)secret.size(); return &secret; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &secret[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Unseal_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Unseal_REQUEST_ID;
}

TPM2_Unseal_REQUEST::TPM2_Unseal_REQUEST(const TPM_HANDLE& _itemHandle)
{
    itemHandle = _itemHandle;
}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
TPM2_Unseal_REQUEST::~TPM2_Unseal_REQUEST() {}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
TpmStructureBase* TPM2_Unseal_REQUEST::Clone() const
{
    return new TPM2_Unseal_REQUEST(*this);
}

void* TPM2_Unseal_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&itemHandle); return &itemHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId UnsealResponse::GetTypeId() const
{
    return TpmTypeId::UnsealResponse_ID;
}

UnsealResponse::UnsealResponse(
    const ByteVec& _outData
)
{
    outData = _outData;
}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
UnsealResponse::~UnsealResponse() {}

/// <summary> This command returns the data in a loaded Sealed Data Object. </summary>
TpmStructureBase* UnsealResponse::Clone() const
{
    return new UnsealResponse(*this);
}

void* UnsealResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ObjectChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
}

TPM2_ObjectChangeAuth_REQUEST::TPM2_ObjectChangeAuth_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _parentHandle,
    const ByteVec& _newAuth
)
{
    objectHandle = _objectHandle;
    parentHandle = _parentHandle;
    newAuth = _newAuth;
}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
TPM2_ObjectChangeAuth_REQUEST::~TPM2_ObjectChangeAuth_REQUEST() {}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
TpmStructureBase* TPM2_ObjectChangeAuth_REQUEST::Clone() const
{
    return new TPM2_ObjectChangeAuth_REQUEST(*this);
}

void* TPM2_ObjectChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 2: return &newAuthSize;
            case 3: { if (newArraySize != -1) newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return &newAuth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &newAuth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ObjectChangeAuthResponse::GetTypeId() const
{
    return TpmTypeId::ObjectChangeAuthResponse_ID;
}

ObjectChangeAuthResponse::ObjectChangeAuthResponse(const TPM2B_PRIVATE& _outPrivate)
{
    outPrivate = _outPrivate;
}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
ObjectChangeAuthResponse::~ObjectChangeAuthResponse() {}

/// <summary> This command is used to change the authorization secret for a TPM-resident object. </summary>
TpmStructureBase* ObjectChangeAuthResponse::Clone() const
{
    return new ObjectChangeAuthResponse(*this);
}

void* ObjectChangeAuthResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_CreateLoaded_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
}

TPM2_CreateLoaded_REQUEST::TPM2_CreateLoaded_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const ByteVec& _inPublic
)
{
    parentHandle = _parentHandle;
    inSensitive = _inSensitive;
    inPublic = _inPublic;
}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
TPM2_CreateLoaded_REQUEST::~TPM2_CreateLoaded_REQUEST() {}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
TpmStructureBase* TPM2_CreateLoaded_REQUEST::Clone() const
{
    return new TPM2_CreateLoaded_REQUEST(*this);
}

void* TPM2_CreateLoaded_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: return &inSensitiveSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return &inSensitive;
            case 3: return &inPublicSize;
            case 4: { if (newArraySize != -1) inPublic.resize(newArraySize); arraySize = (int)inPublic.size(); return &inPublic; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &inPublic[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CreateLoadedResponse::GetTypeId() const
{
    return TpmTypeId::CreateLoadedResponse_ID;
}

CreateLoadedResponse::CreateLoadedResponse(
    const TPM_HANDLE& _handle,
    const TPM2B_PRIVATE& _outPrivate,
    const TPMT_PUBLIC& _outPublic,
    const ByteVec& _name
)
{
    handle = _handle;
    outPrivate = _outPrivate;
    outPublic = _outPublic;
    name = _name;
}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
CreateLoadedResponse::~CreateLoadedResponse() {}

/// <summary> This command creates an object and loads it in the TPM. This command allows creation of any type of object (Primary, Ordinary, or Derived) depending on the type of parentHandle. If parentHandle references a Primary Seed, then a Primary Object is created; if parentHandle references a Storage Parent, then an Ordinary Object is created; and if parentHandle references a Derivation Parent, then a Derived Object is generated. </summary>
TpmStructureBase* CreateLoadedResponse::Clone() const
{
    return new CreateLoadedResponse(*this);
}

void* CreateLoadedResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            case 2: return &outPublicSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 4: return &nameSize;
            case 5: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 5: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Duplicate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Duplicate_REQUEST_ID;
}

TPM2_Duplicate_REQUEST::TPM2_Duplicate_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _newParentHandle,
    const ByteVec& _encryptionKeyIn,
    const TPMT_SYM_DEF_OBJECT& _symmetricAlg
)
{
    objectHandle = _objectHandle;
    newParentHandle = _newParentHandle;
    encryptionKeyIn = _encryptionKeyIn;
    symmetricAlg = _symmetricAlg;
}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
TPM2_Duplicate_REQUEST::~TPM2_Duplicate_REQUEST() {}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
TpmStructureBase* TPM2_Duplicate_REQUEST::Clone() const
{
    return new TPM2_Duplicate_REQUEST(*this);
}

void* TPM2_Duplicate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&newParentHandle); return &newParentHandle;
            case 2: return &encryptionKeyInSize;
            case 3: { if (newArraySize != -1) encryptionKeyIn.resize(newArraySize); arraySize = (int)encryptionKeyIn.size(); return &encryptionKeyIn; }
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&symmetricAlg); return &symmetricAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &encryptionKeyIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId DuplicateResponse::GetTypeId() const
{
    return TpmTypeId::DuplicateResponse_ID;
}

DuplicateResponse::DuplicateResponse(
    const ByteVec& _encryptionKeyOut,
    const TPM2B_PRIVATE& _duplicate,
    const ByteVec& _outSymSeed
)
{
    encryptionKeyOut = _encryptionKeyOut;
    duplicate = _duplicate;
    outSymSeed = _outSymSeed;
}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
DuplicateResponse::~DuplicateResponse() {}

/// <summary> This command duplicates a loaded object so that it may be used in a different hierarchy. The new parent key for the duplicate may be on the same or different TPM or TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded. </summary>
TpmStructureBase* DuplicateResponse::Clone() const
{
    return new DuplicateResponse(*this);
}

void* DuplicateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &encryptionKeyOutSize;
            case 1: { if (newArraySize != -1) encryptionKeyOut.resize(newArraySize); arraySize = (int)encryptionKeyOut.size(); return &encryptionKeyOut; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&duplicate); return &duplicate;
            case 3: return &outSymSeedSize;
            case 4: { if (newArraySize != -1) outSymSeed.resize(newArraySize); arraySize = (int)outSymSeed.size(); return &outSymSeed; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &encryptionKeyOut[arrayIndex];
            case 4: return &outSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Rewrap_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Rewrap_REQUEST_ID;
}

TPM2_Rewrap_REQUEST::TPM2_Rewrap_REQUEST(
    const TPM_HANDLE& _oldParent,
    const TPM_HANDLE& _newParent,
    const TPM2B_PRIVATE& _inDuplicate,
    const ByteVec& _name,
    const ByteVec& _inSymSeed
)
{
    oldParent = _oldParent;
    newParent = _newParent;
    inDuplicate = _inDuplicate;
    name = _name;
    inSymSeed = _inSymSeed;
}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
TPM2_Rewrap_REQUEST::~TPM2_Rewrap_REQUEST() {}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
TpmStructureBase* TPM2_Rewrap_REQUEST::Clone() const
{
    return new TPM2_Rewrap_REQUEST(*this);
}

void* TPM2_Rewrap_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&oldParent); return &oldParent;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&newParent); return &newParent;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inDuplicate); return &inDuplicate;
            case 3: return &nameSize;
            case 4: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            case 5: return &inSymSeedSize;
            case 6: { if (newArraySize != -1) inSymSeed.resize(newArraySize); arraySize = (int)inSymSeed.size(); return &inSymSeed; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &name[arrayIndex];
            case 6: return &inSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId RewrapResponse::GetTypeId() const
{
    return TpmTypeId::RewrapResponse_ID;
}

RewrapResponse::RewrapResponse(
    const TPM2B_PRIVATE& _outDuplicate,
    const ByteVec& _outSymSeed
)
{
    outDuplicate = _outDuplicate;
    outSymSeed = _outSymSeed;
}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
RewrapResponse::~RewrapResponse() {}

/// <summary> This command allows the TPM to serve in the role as a Duplication Authority. If proper authorization for use of the oldParent is provided, then an HMAC key and a symmetric key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate. A new protection seed value is generated according to the methods appropriate for newParent and the blob is re-encrypted and a new integrity value is computed. The re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey. </summary>
TpmStructureBase* RewrapResponse::Clone() const
{
    return new RewrapResponse(*this);
}

void* RewrapResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outDuplicate); return &outDuplicate;
            case 1: return &outSymSeedSize;
            case 2: { if (newArraySize != -1) outSymSeed.resize(newArraySize); arraySize = (int)outSymSeed.size(); return &outSymSeed; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &outSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Import_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Import_REQUEST_ID;
}

TPM2_Import_REQUEST::TPM2_Import_REQUEST(
    const TPM_HANDLE& _parentHandle,
    const ByteVec& _encryptionKey,
    const TPMT_PUBLIC& _objectPublic,
    const TPM2B_PRIVATE& _duplicate,
    const ByteVec& _inSymSeed,
    const TPMT_SYM_DEF_OBJECT& _symmetricAlg
)
{
    parentHandle = _parentHandle;
    encryptionKey = _encryptionKey;
    objectPublic = _objectPublic;
    duplicate = _duplicate;
    inSymSeed = _inSymSeed;
    symmetricAlg = _symmetricAlg;
}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
TPM2_Import_REQUEST::~TPM2_Import_REQUEST() {}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
TpmStructureBase* TPM2_Import_REQUEST::Clone() const
{
    return new TPM2_Import_REQUEST(*this);
}

void* TPM2_Import_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parentHandle); return &parentHandle;
            case 1: return &encryptionKeySize;
            case 2: { if (newArraySize != -1) encryptionKey.resize(newArraySize); arraySize = (int)encryptionKey.size(); return &encryptionKey; }
            case 3: return &objectPublicSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&objectPublic); return &objectPublic;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&duplicate); return &duplicate;
            case 6: return &inSymSeedSize;
            case 7: { if (newArraySize != -1) inSymSeed.resize(newArraySize); arraySize = (int)inSymSeed.size(); return &inSymSeed; }
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&symmetricAlg); return &symmetricAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &encryptionKey[arrayIndex];
            case 7: return &inSymSeed[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ImportResponse::GetTypeId() const
{
    return TpmTypeId::ImportResponse_ID;
}

ImportResponse::ImportResponse(const TPM2B_PRIVATE& _outPrivate)
{
    outPrivate = _outPrivate;
}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
ImportResponse::~ImportResponse() {}

/// <summary> This command allows an object to be encrypted using the symmetric encryption values of a Storage Key. After encryption, the object may be loaded and used in the new hierarchy. The imported object (duplicate) may be singly encrypted, multiply encrypted, or unencrypted. </summary>
TpmStructureBase* ImportResponse::Clone() const
{
    return new ImportResponse(*this);
}

void* ImportResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&outPrivate); return &outPrivate;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_RSA_Encrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
}

TPM2_RSA_Encrypt_REQUEST::TPM2_RSA_Encrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _message,
    const TPMU_ASYM_SCHEME& _inScheme,
    const ByteVec& _label
)
{
    keyHandle = _keyHandle;
    message = _message;
    inScheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone()));
    label = _label;
}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
TPM2_RSA_Encrypt_REQUEST::~TPM2_RSA_Encrypt_REQUEST() {}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
TpmStructureBase* TPM2_RSA_Encrypt_REQUEST::Clone() const
{
    return new TPM2_RSA_Encrypt_REQUEST(*this);
}

void* TPM2_RSA_Encrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &messageSize;
            case 2: { if (newArraySize != -1) message.resize(newArraySize); arraySize = (int)message.size(); return &message; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: return &labelSize;
            case 6: { if (newArraySize != -1) label.resize(newArraySize); arraySize = (int)label.size(); return &label; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &message[arrayIndex];
            case 6: return &label[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId RSA_EncryptResponse::GetTypeId() const
{
    return TpmTypeId::RSA_EncryptResponse_ID;
}

RSA_EncryptResponse::RSA_EncryptResponse(
    const ByteVec& _outData
)
{
    outData = _outData;
}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
RSA_EncryptResponse::~RSA_EncryptResponse() {}

/// <summary> This command performs RSA encryption using the indicated padding scheme according to IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL, then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME). </summary>
TpmStructureBase* RSA_EncryptResponse::Clone() const
{
    return new RSA_EncryptResponse(*this);
}

void* RSA_EncryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_RSA_Decrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
}

TPM2_RSA_Decrypt_REQUEST::TPM2_RSA_Decrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _cipherText,
    const TPMU_ASYM_SCHEME& _inScheme,
    const ByteVec& _label
)
{
    keyHandle = _keyHandle;
    cipherText = _cipherText;
    inScheme.reset(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone()));
    label = _label;
}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
TPM2_RSA_Decrypt_REQUEST::~TPM2_RSA_Decrypt_REQUEST() {}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
TpmStructureBase* TPM2_RSA_Decrypt_REQUEST::Clone() const
{
    return new TPM2_RSA_Decrypt_REQUEST(*this);
}

void* TPM2_RSA_Decrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &cipherTextSize;
            case 2: { if (newArraySize != -1) cipherText.resize(newArraySize); arraySize = (int)cipherText.size(); return &cipherText; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: return &labelSize;
            case 6: { if (newArraySize != -1) label.resize(newArraySize); arraySize = (int)label.size(); return &label; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &cipherText[arrayIndex];
            case 6: return &label[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId RSA_DecryptResponse::GetTypeId() const
{
    return TpmTypeId::RSA_DecryptResponse_ID;
}

RSA_DecryptResponse::RSA_DecryptResponse(
    const ByteVec& _message
)
{
    message = _message;
}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
RSA_DecryptResponse::~RSA_DecryptResponse() {}

/// <summary> This command performs RSA decryption using the indicated padding scheme according to IETF RFC 8017 ((PKCS#1). </summary>
TpmStructureBase* RSA_DecryptResponse::Clone() const
{
    return new RSA_DecryptResponse(*this);
}

void* RSA_DecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &messageSize;
            case 1: { if (newArraySize != -1) message.resize(newArraySize); arraySize = (int)message.size(); return &message; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &message[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ECDH_KeyGen_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID;
}

TPM2_ECDH_KeyGen_REQUEST::TPM2_ECDH_KeyGen_REQUEST(const TPM_HANDLE& _keyHandle)
{
    keyHandle = _keyHandle;
}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
TPM2_ECDH_KeyGen_REQUEST::~TPM2_ECDH_KeyGen_REQUEST() {}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
TpmStructureBase* TPM2_ECDH_KeyGen_REQUEST::Clone() const
{
    return new TPM2_ECDH_KeyGen_REQUEST(*this);
}

void* TPM2_ECDH_KeyGen_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ECDH_KeyGenResponse::GetTypeId() const
{
    return TpmTypeId::ECDH_KeyGenResponse_ID;
}

ECDH_KeyGenResponse::ECDH_KeyGenResponse(
    const TPMS_ECC_POINT& _zPoint,
    const TPMS_ECC_POINT& _pubPoint
)
{
    zPoint = _zPoint;
    pubPoint = _pubPoint;
}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
ECDH_KeyGenResponse::~ECDH_KeyGenResponse() {}

/// <summary> This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe  [de]G). It uses the private ephemeral key and a loaded public key (QS) to compute the shared secret value (P  [hde]QS). </summary>
TpmStructureBase* ECDH_KeyGenResponse::Clone() const
{
    return new ECDH_KeyGenResponse(*this);
}

void* ECDH_KeyGenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &zPointSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&zPoint); return &zPoint;
            case 2: return &pubPointSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&pubPoint); return &pubPoint;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ECDH_ZGen_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
}

TPM2_ECDH_ZGen_REQUEST::TPM2_ECDH_ZGen_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const TPMS_ECC_POINT& _inPoint
)
{
    keyHandle = _keyHandle;
    inPoint = _inPoint;
}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
TPM2_ECDH_ZGen_REQUEST::~TPM2_ECDH_ZGen_REQUEST() {}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
TpmStructureBase* TPM2_ECDH_ZGen_REQUEST::Clone() const
{
    return new TPM2_ECDH_ZGen_REQUEST(*this);
}

void* TPM2_ECDH_ZGen_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &inPointSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inPoint); return &inPoint;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ECDH_ZGenResponse::GetTypeId() const
{
    return TpmTypeId::ECDH_ZGenResponse_ID;
}

ECDH_ZGenResponse::ECDH_ZGenResponse(
    const TPMS_ECC_POINT& _outPoint
)
{
    outPoint = _outPoint;
}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
ECDH_ZGenResponse::~ECDH_ZGenResponse() {}

/// <summary> This command uses the TPM to recover the Z value from a public point (QB) and a private key (ds). It will perform the multiplication of the provided inPoint (QB) with the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)  [hds]QB; where h is the cofactor of the curve). </summary>
TpmStructureBase* ECDH_ZGenResponse::Clone() const
{
    return new ECDH_ZGenResponse(*this);
}

void* ECDH_ZGenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outPointSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outPoint); return &outPoint;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ECC_Parameters_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID;
}

TPM2_ECC_Parameters_REQUEST::TPM2_ECC_Parameters_REQUEST(TPM_ECC_CURVE _curveID)
{
    curveID = _curveID;
}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
TPM2_ECC_Parameters_REQUEST::~TPM2_ECC_Parameters_REQUEST() {}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
TpmStructureBase* TPM2_ECC_Parameters_REQUEST::Clone() const
{
    return new TPM2_ECC_Parameters_REQUEST(*this);
}

void* TPM2_ECC_Parameters_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &curveID;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ECC_ParametersResponse::GetTypeId() const
{
    return TpmTypeId::ECC_ParametersResponse_ID;
}

ECC_ParametersResponse::ECC_ParametersResponse(const TPMS_ALGORITHM_DETAIL_ECC& _parameters)
{
    parameters = _parameters;
}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
ECC_ParametersResponse::~ECC_ParametersResponse() {}

/// <summary> This command returns the parameters of an ECC curve identified by its TCG-assigned curveID. </summary>
TpmStructureBase* ECC_ParametersResponse::Clone() const
{
    return new ECC_ParametersResponse(*this);
}

void* ECC_ParametersResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&parameters); return &parameters;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ZGen_2Phase_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
}

TPM2_ZGen_2Phase_REQUEST::TPM2_ZGen_2Phase_REQUEST(
    const TPM_HANDLE& _keyA,
    const TPMS_ECC_POINT& _inQsB,
    const TPMS_ECC_POINT& _inQeB,
    TPM_ALG_ID _inScheme,
    UINT16 _counter
)
{
    keyA = _keyA;
    inQsB = _inQsB;
    inQeB = _inQeB;
    inScheme = _inScheme;
    counter = _counter;
}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
TPM2_ZGen_2Phase_REQUEST::~TPM2_ZGen_2Phase_REQUEST() {}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
TpmStructureBase* TPM2_ZGen_2Phase_REQUEST::Clone() const
{
    return new TPM2_ZGen_2Phase_REQUEST(*this);
}

void* TPM2_ZGen_2Phase_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyA); return &keyA;
            case 1: return &inQsBSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inQsB); return &inQsB;
            case 3: return &inQeBSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inQeB); return &inQeB;
            case 5: return &inScheme;
            case 6: return &counter;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ZGen_2PhaseResponse::GetTypeId() const
{
    return TpmTypeId::ZGen_2PhaseResponse_ID;
}

ZGen_2PhaseResponse::ZGen_2PhaseResponse(
    const TPMS_ECC_POINT& _outZ1,
    const TPMS_ECC_POINT& _outZ2
)
{
    outZ1 = _outZ1;
    outZ2 = _outZ2;
}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
ZGen_2PhaseResponse::~ZGen_2PhaseResponse() {}

/// <summary> This command supports two-phase key exchange protocols. The command is used in combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key and returns the public point of that ephemeral key along with a numeric value that allows the TPM to regenerate the associated private key. </summary>
TpmStructureBase* ZGen_2PhaseResponse::Clone() const
{
    return new ZGen_2PhaseResponse(*this);
}

void* ZGen_2PhaseResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outZ1Size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&outZ1); return &outZ1;
            case 2: return &outZ2Size;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&outZ2); return &outZ2;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ECC_Encrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
}

TPM2_ECC_Encrypt_REQUEST::TPM2_ECC_Encrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _plainText,
    const TPMU_KDF_SCHEME& _inScheme
)
{
    keyHandle = _keyHandle;
    plainText = _plainText;
    inScheme.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
TPM2_ECC_Encrypt_REQUEST::~TPM2_ECC_Encrypt_REQUEST() {}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
TpmStructureBase* TPM2_ECC_Encrypt_REQUEST::Clone() const
{
    return new TPM2_ECC_Encrypt_REQUEST(*this);
}

void* TPM2_ECC_Encrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &plainTextSize;
            case 2: { if (newArraySize != -1) plainText.resize(newArraySize); arraySize = (int)plainText.size(); return &plainText; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &plainText[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ECC_EncryptResponse::GetTypeId() const
{
    return TpmTypeId::ECC_EncryptResponse_ID;
}

ECC_EncryptResponse::ECC_EncryptResponse(
    const TPMS_ECC_POINT& _C1,
    const ByteVec& _C2,
    const ByteVec& _C3
)
{
    C1 = _C1;
    C2 = _C2;
    C3 = _C3;
}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
ECC_EncryptResponse::~ECC_EncryptResponse() {}

/// <summary> This command performs ECC encryption as described in Part 1, Annex D. </summary>
TpmStructureBase* ECC_EncryptResponse::Clone() const
{
    return new ECC_EncryptResponse(*this);
}

void* ECC_EncryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &C1Size;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&C1); return &C1;
            case 2: return &C2Size;
            case 3: { if (newArraySize != -1) C2.resize(newArraySize); arraySize = (int)C2.size(); return &C2; }
            case 4: return &C3Size;
            case 5: { if (newArraySize != -1) C3.resize(newArraySize); arraySize = (int)C3.size(); return &C3; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &C2[arrayIndex];
            case 5: return &C3[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ECC_Decrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
}

TPM2_ECC_Decrypt_REQUEST::TPM2_ECC_Decrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const TPMS_ECC_POINT& _C1,
    const ByteVec& _C2,
    const ByteVec& _C3,
    const TPMU_KDF_SCHEME& _inScheme
)
{
    keyHandle = _keyHandle;
    C1 = _C1;
    C2 = _C2;
    C3 = _C3;
    inScheme.reset(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command performs ECC decryption. </summary>
TPM2_ECC_Decrypt_REQUEST::~TPM2_ECC_Decrypt_REQUEST() {}

/// <summary> This command performs ECC decryption. </summary>
TpmStructureBase* TPM2_ECC_Decrypt_REQUEST::Clone() const
{
    return new TPM2_ECC_Decrypt_REQUEST(*this);
}

void* TPM2_ECC_Decrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &C1Size;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&C1); return &C1;
            case 3: return &C2Size;
            case 4: { if (newArraySize != -1) C2.resize(newArraySize); arraySize = (int)C2.size(); return &C2; }
            case 5: return &C3Size;
            case 6: { if (newArraySize != -1) C3.resize(newArraySize); arraySize = (int)C3.size(); return &C3; }
            case 7: return &inSchemeScheme;
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &C2[arrayIndex];
            case 6: return &C3[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId ECC_DecryptResponse::GetTypeId() const
{
    return TpmTypeId::ECC_DecryptResponse_ID;
}

ECC_DecryptResponse::ECC_DecryptResponse(
    const ByteVec& _plainText
)
{
    plainText = _plainText;
}

/// <summary> This command performs ECC decryption. </summary>
ECC_DecryptResponse::~ECC_DecryptResponse() {}

/// <summary> This command performs ECC decryption. </summary>
TpmStructureBase* ECC_DecryptResponse::Clone() const
{
    return new ECC_DecryptResponse(*this);
}

void* ECC_DecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &plainTextSize;
            case 1: { if (newArraySize != -1) plainText.resize(newArraySize); arraySize = (int)plainText.size(); return &plainText; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &plainText[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_EncryptDecrypt_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
}

TPM2_EncryptDecrypt_REQUEST::TPM2_EncryptDecrypt_REQUEST(
    const TPM_HANDLE& _keyHandle,
    BYTE _decrypt,
    TPM_ALG_ID _mode,
    const ByteVec& _ivIn,
    const ByteVec& _inData
)
{
    keyHandle = _keyHandle;
    decrypt = _decrypt;
    mode = _mode;
    ivIn = _ivIn;
    inData = _inData;
}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
TPM2_EncryptDecrypt_REQUEST::~TPM2_EncryptDecrypt_REQUEST() {}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
TpmStructureBase* TPM2_EncryptDecrypt_REQUEST::Clone() const
{
    return new TPM2_EncryptDecrypt_REQUEST(*this);
}

void* TPM2_EncryptDecrypt_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &decrypt;
            case 2: return &mode;
            case 3: return &ivInSize;
            case 4: { if (newArraySize != -1) ivIn.resize(newArraySize); arraySize = (int)ivIn.size(); return &ivIn; }
            case 5: return &inDataSize;
            case 6: { if (newArraySize != -1) inData.resize(newArraySize); arraySize = (int)inData.size(); return &inData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &ivIn[arrayIndex];
            case 6: return &inData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId EncryptDecryptResponse::GetTypeId() const
{
    return TpmTypeId::EncryptDecryptResponse_ID;
}

EncryptDecryptResponse::EncryptDecryptResponse(
    const ByteVec& _outData,
    const ByteVec& _ivOut
)
{
    outData = _outData;
    ivOut = _ivOut;
}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
EncryptDecryptResponse::~EncryptDecryptResponse() {}

/// <summary> NOTE 1	This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This should be reflected in platform-specific specifications. </summary>
TpmStructureBase* EncryptDecryptResponse::Clone() const
{
    return new EncryptDecryptResponse(*this);
}

void* EncryptDecryptResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            case 2: return &ivOutSize;
            case 3: { if (newArraySize != -1) ivOut.resize(newArraySize); arraySize = (int)ivOut.size(); return &ivOut; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            case 3: return &ivOut[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_EncryptDecrypt2_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
}

TPM2_EncryptDecrypt2_REQUEST::TPM2_EncryptDecrypt2_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _inData,
    BYTE _decrypt,
    TPM_ALG_ID _mode,
    const ByteVec& _ivIn
)
{
    keyHandle = _keyHandle;
    inData = _inData;
    decrypt = _decrypt;
    mode = _mode;
    ivIn = _ivIn;
}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
TPM2_EncryptDecrypt2_REQUEST::~TPM2_EncryptDecrypt2_REQUEST() {}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
TpmStructureBase* TPM2_EncryptDecrypt2_REQUEST::Clone() const
{
    return new TPM2_EncryptDecrypt2_REQUEST(*this);
}

void* TPM2_EncryptDecrypt2_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &inDataSize;
            case 2: { if (newArraySize != -1) inData.resize(newArraySize); arraySize = (int)inData.size(); return &inData; }
            case 3: return &decrypt;
            case 4: return &mode;
            case 5: return &ivInSize;
            case 6: { if (newArraySize != -1) ivIn.resize(newArraySize); arraySize = (int)ivIn.size(); return &ivIn; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &inData[arrayIndex];
            case 6: return &ivIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId EncryptDecrypt2Response::GetTypeId() const
{
    return TpmTypeId::EncryptDecrypt2Response_ID;
}

EncryptDecrypt2Response::EncryptDecrypt2Response(
    const ByteVec& _outData,
    const ByteVec& _ivOut
)
{
    outData = _outData;
    ivOut = _ivOut;
}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
EncryptDecrypt2Response::~EncryptDecrypt2Response() {}

/// <summary> This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter is the first parameter. This permits inData to be parameter encrypted. </summary>
TpmStructureBase* EncryptDecrypt2Response::Clone() const
{
    return new EncryptDecrypt2Response(*this);
}

void* EncryptDecrypt2Response::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outDataSize;
            case 1: { if (newArraySize != -1) outData.resize(newArraySize); arraySize = (int)outData.size(); return &outData; }
            case 2: return &ivOutSize;
            case 3: { if (newArraySize != -1) ivOut.resize(newArraySize); arraySize = (int)ivOut.size(); return &ivOut; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outData[arrayIndex];
            case 3: return &ivOut[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Hash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Hash_REQUEST_ID;
}

TPM2_Hash_REQUEST::TPM2_Hash_REQUEST(
    const ByteVec& _data,
    TPM_ALG_ID _hashAlg,
    const TPM_HANDLE& _hierarchy
)
{
    data = _data;
    hashAlg = _hashAlg;
    hierarchy = _hierarchy;
}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
TPM2_Hash_REQUEST::~TPM2_Hash_REQUEST() {}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
TpmStructureBase* TPM2_Hash_REQUEST::Clone() const
{
    return new TPM2_Hash_REQUEST(*this);
}

void* TPM2_Hash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &dataSize;
            case 1: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            case 2: return &hashAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HashResponse::GetTypeId() const
{
    return TpmTypeId::HashResponse_ID;
}

HashResponse::HashResponse(
    const ByteVec& _outHash,
    const TPMT_TK_HASHCHECK& _validation
)
{
    outHash = _outHash;
    validation = _validation;
}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
HashResponse::~HashResponse() {}

/// <summary> This command performs a hash operation on a data buffer and returns the results. </summary>
TpmStructureBase* HashResponse::Clone() const
{
    return new HashResponse(*this);
}

void* HashResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outHashSize;
            case 1: { if (newArraySize != -1) outHash.resize(newArraySize); arraySize = (int)outHash.size(); return &outHash; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_HMAC_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HMAC_REQUEST_ID;
}

TPM2_HMAC_REQUEST::TPM2_HMAC_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _buffer,
    TPM_ALG_ID _hashAlg
)
{
    handle = _handle;
    buffer = _buffer;
    hashAlg = _hashAlg;
}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
TPM2_HMAC_REQUEST::~TPM2_HMAC_REQUEST() {}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
TpmStructureBase* TPM2_HMAC_REQUEST::Clone() const
{
    return new TPM2_HMAC_REQUEST(*this);
}

void* TPM2_HMAC_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            case 3: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HMACResponse::GetTypeId() const
{
    return TpmTypeId::HMACResponse_ID;
}

HMACResponse::HMACResponse(
    const ByteVec& _outHMAC
)
{
    outHMAC = _outHMAC;
}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
HMACResponse::~HMACResponse() {}

/// <summary> This command performs an HMAC on the supplied data using the indicated hash algorithm. </summary>
TpmStructureBase* HMACResponse::Clone() const
{
    return new HMACResponse(*this);
}

void* HMACResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outHMACSize;
            case 1: { if (newArraySize != -1) outHMAC.resize(newArraySize); arraySize = (int)outHMAC.size(); return &outHMAC; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outHMAC[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_MAC_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MAC_REQUEST_ID;
}

TPM2_MAC_REQUEST::TPM2_MAC_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _buffer,
    TPM_ALG_ID _inScheme
)
{
    handle = _handle;
    buffer = _buffer;
    inScheme = _inScheme;
}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
TPM2_MAC_REQUEST::~TPM2_MAC_REQUEST() {}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
TpmStructureBase* TPM2_MAC_REQUEST::Clone() const
{
    return new TPM2_MAC_REQUEST(*this);
}

void* TPM2_MAC_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            case 3: return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId MACResponse::GetTypeId() const
{
    return TpmTypeId::MACResponse_ID;
}

MACResponse::MACResponse(
    const ByteVec& _outMAC
)
{
    outMAC = _outMAC;
}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
MACResponse::~MACResponse() {}

/// <summary> This command performs an HMAC or a block cipher MAC on the supplied data using the indicated algorithm. </summary>
TpmStructureBase* MACResponse::Clone() const
{
    return new MACResponse(*this);
}

void* MACResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outMACSize;
            case 1: { if (newArraySize != -1) outMAC.resize(newArraySize); arraySize = (int)outMAC.size(); return &outMAC; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outMAC[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_GetRandom_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetRandom_REQUEST_ID;
}

TPM2_GetRandom_REQUEST::TPM2_GetRandom_REQUEST(UINT16 _bytesRequested)
{
    bytesRequested = _bytesRequested;
}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
TPM2_GetRandom_REQUEST::~TPM2_GetRandom_REQUEST() {}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
TpmStructureBase* TPM2_GetRandom_REQUEST::Clone() const
{
    return new TPM2_GetRandom_REQUEST(*this);
}

void* TPM2_GetRandom_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &bytesRequested;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId GetRandomResponse::GetTypeId() const
{
    return TpmTypeId::GetRandomResponse_ID;
}

GetRandomResponse::GetRandomResponse(
    const ByteVec& _randomBytes
)
{
    randomBytes = _randomBytes;
}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
GetRandomResponse::~GetRandomResponse() {}

/// <summary> This command returns the next bytesRequested octets from the random number generator (RNG). </summary>
TpmStructureBase* GetRandomResponse::Clone() const
{
    return new GetRandomResponse(*this);
}

void* GetRandomResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &randomBytesSize;
            case 1: { if (newArraySize != -1) randomBytes.resize(newArraySize); arraySize = (int)randomBytes.size(); return &randomBytes; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &randomBytes[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_StirRandom_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_StirRandom_REQUEST_ID;
}

TPM2_StirRandom_REQUEST::TPM2_StirRandom_REQUEST(
    const ByteVec& _inData
)
{
    inData = _inData;
}

/// <summary> This command is used to add "additional information" to the RNG state. </summary>
TPM2_StirRandom_REQUEST::~TPM2_StirRandom_REQUEST() {}

/// <summary> This command is used to add "additional information" to the RNG state. </summary>
TpmStructureBase* TPM2_StirRandom_REQUEST::Clone() const
{
    return new TPM2_StirRandom_REQUEST(*this);
}

void* TPM2_StirRandom_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &inDataSize;
            case 1: { if (newArraySize != -1) inData.resize(newArraySize); arraySize = (int)inData.size(); return &inData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &inData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId StirRandomResponse::GetTypeId() const
{
    return TpmTypeId::StirRandomResponse_ID;
}

/// <summary> This command is used to add "additional information" to the RNG state. </summary>
StirRandomResponse::~StirRandomResponse() {}

/// <summary> This command is used to add "additional information" to the RNG state. </summary>
TpmStructureBase* StirRandomResponse::Clone() const
{
    return new StirRandomResponse(*this);
}

void* StirRandomResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_HMAC_Start_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
}

TPM2_HMAC_Start_REQUEST::TPM2_HMAC_Start_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _auth,
    TPM_ALG_ID _hashAlg
)
{
    handle = _handle;
    auth = _auth;
    hashAlg = _hashAlg;
}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TPM2_HMAC_Start_REQUEST::~TPM2_HMAC_Start_REQUEST() {}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* TPM2_HMAC_Start_REQUEST::Clone() const
{
    return new TPM2_HMAC_Start_REQUEST(*this);
}

void* TPM2_HMAC_Start_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 3: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HMAC_StartResponse::GetTypeId() const
{
    return TpmTypeId::HMAC_StartResponse_ID;
}

HMAC_StartResponse::HMAC_StartResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
HMAC_StartResponse::~HMAC_StartResponse() {}

/// <summary> This command starts an HMAC sequence. The TPM will create and initialize an HMAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* HMAC_StartResponse::Clone() const
{
    return new HMAC_StartResponse(*this);
}

void* HMAC_StartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_MAC_Start_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
}

TPM2_MAC_Start_REQUEST::TPM2_MAC_Start_REQUEST(
    const TPM_HANDLE& _handle,
    const ByteVec& _auth,
    TPM_ALG_ID _inScheme
)
{
    handle = _handle;
    auth = _auth;
    inScheme = _inScheme;
}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TPM2_MAC_Start_REQUEST::~TPM2_MAC_Start_REQUEST() {}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* TPM2_MAC_Start_REQUEST::Clone() const
{
    return new TPM2_MAC_Start_REQUEST(*this);
}

void* TPM2_MAC_Start_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 3: return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId MAC_StartResponse::GetTypeId() const
{
    return TpmTypeId::MAC_StartResponse_ID;
}

MAC_StartResponse::MAC_StartResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
MAC_StartResponse::~MAC_StartResponse() {}

/// <summary> This command starts a MAC sequence. The TPM will create and initialize a MAC sequence structure, assign a handle to the sequence, and set the authValue of the sequence object to the value in auth. </summary>
TpmStructureBase* MAC_StartResponse::Clone() const
{
    return new MAC_StartResponse(*this);
}

void* MAC_StartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_HashSequenceStart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
}

TPM2_HashSequenceStart_REQUEST::TPM2_HashSequenceStart_REQUEST(
    const ByteVec& _auth,
    TPM_ALG_ID _hashAlg
)
{
    auth = _auth;
    hashAlg = _hashAlg;
}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
TPM2_HashSequenceStart_REQUEST::~TPM2_HashSequenceStart_REQUEST() {}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
TpmStructureBase* TPM2_HashSequenceStart_REQUEST::Clone() const
{
    return new TPM2_HashSequenceStart_REQUEST(*this);
}

void* TPM2_HashSequenceStart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &authSize;
            case 1: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 2: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HashSequenceStartResponse::GetTypeId() const
{
    return TpmTypeId::HashSequenceStartResponse_ID;
}

HashSequenceStartResponse::HashSequenceStartResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
HashSequenceStartResponse::~HashSequenceStartResponse() {}

/// <summary> This command starts a hash or an Event Sequence. If hashAlg is an implemented hash, then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM shall return TPM_RC_HASH. </summary>
TpmStructureBase* HashSequenceStartResponse::Clone() const
{
    return new HashSequenceStartResponse(*this);
}

void* HashSequenceStartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_SequenceUpdate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
}

TPM2_SequenceUpdate_REQUEST::TPM2_SequenceUpdate_REQUEST(
    const TPM_HANDLE& _sequenceHandle,
    const ByteVec& _buffer
)
{
    sequenceHandle = _sequenceHandle;
    buffer = _buffer;
}

/// <summary> This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM. </summary>
TPM2_SequenceUpdate_REQUEST::~TPM2_SequenceUpdate_REQUEST() {}

/// <summary> This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM. </summary>
TpmStructureBase* TPM2_SequenceUpdate_REQUEST::Clone() const
{
    return new TPM2_SequenceUpdate_REQUEST(*this);
}

void* TPM2_SequenceUpdate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return &sequenceHandle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SequenceUpdateResponse::GetTypeId() const
{
    return TpmTypeId::SequenceUpdateResponse_ID;
}

/// <summary> This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM. </summary>
SequenceUpdateResponse::~SequenceUpdateResponse() {}

/// <summary> This command is used to add data to a hash or HMAC sequence. The amount of data in buffer may be any size up to the limits of the TPM. </summary>
TpmStructureBase* SequenceUpdateResponse::Clone() const
{
    return new SequenceUpdateResponse(*this);
}

void* SequenceUpdateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_SequenceComplete_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
}

TPM2_SequenceComplete_REQUEST::TPM2_SequenceComplete_REQUEST(
    const TPM_HANDLE& _sequenceHandle,
    const ByteVec& _buffer,
    const TPM_HANDLE& _hierarchy
)
{
    sequenceHandle = _sequenceHandle;
    buffer = _buffer;
    hierarchy = _hierarchy;
}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
TPM2_SequenceComplete_REQUEST::~TPM2_SequenceComplete_REQUEST() {}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
TpmStructureBase* TPM2_SequenceComplete_REQUEST::Clone() const
{
    return new TPM2_SequenceComplete_REQUEST(*this);
}

void* TPM2_SequenceComplete_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return &sequenceHandle;
            case 1: return &bufferSize;
            case 2: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&hierarchy); return &hierarchy;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SequenceCompleteResponse::GetTypeId() const
{
    return TpmTypeId::SequenceCompleteResponse_ID;
}

SequenceCompleteResponse::SequenceCompleteResponse(
    const ByteVec& _result,
    const TPMT_TK_HASHCHECK& _validation
)
{
    result = _result;
    validation = _validation;
}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
SequenceCompleteResponse::~SequenceCompleteResponse() {}

/// <summary> This command adds the last part of data, if any, to a hash/HMAC sequence and returns the result. </summary>
TpmStructureBase* SequenceCompleteResponse::Clone() const
{
    return new SequenceCompleteResponse(*this);
}

void* SequenceCompleteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &resultSize;
            case 1: { if (newArraySize != -1) result.resize(newArraySize); arraySize = (int)result.size(); return &result; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &result[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_EventSequenceComplete_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
}

TPM2_EventSequenceComplete_REQUEST::TPM2_EventSequenceComplete_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const TPM_HANDLE& _sequenceHandle,
    const ByteVec& _buffer
)
{
    pcrHandle = _pcrHandle;
    sequenceHandle = _sequenceHandle;
    buffer = _buffer;
}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
TPM2_EventSequenceComplete_REQUEST::~TPM2_EventSequenceComplete_REQUEST() {}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
TpmStructureBase* TPM2_EventSequenceComplete_REQUEST::Clone() const
{
    return new TPM2_EventSequenceComplete_REQUEST(*this);
}

void* TPM2_EventSequenceComplete_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&sequenceHandle); return &sequenceHandle;
            case 2: return &bufferSize;
            case 3: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId EventSequenceCompleteResponse::GetTypeId() const
{
    return TpmTypeId::EventSequenceCompleteResponse_ID;
}

EventSequenceCompleteResponse::EventSequenceCompleteResponse(
    const vector<TPMT_HA>& _results
)
{
    results = _results;
}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
EventSequenceCompleteResponse::~EventSequenceCompleteResponse() {}

/// <summary> This command adds the last part of data, if any, to an Event Sequence and returns the result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the returned digest list is processed in the same manner as the digest list input parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with pcrHandle, it is extended with the associated digest value from the list. </summary>
TpmStructureBase* EventSequenceCompleteResponse::Clone() const
{
    return new EventSequenceCompleteResponse(*this);
}

void* EventSequenceCompleteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &resultsCount;
            case 1: { if (newArraySize != -1) results.resize(newArraySize); arraySize = (int)results.size(); return &results; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&results[arrayIndex]); return &results[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Certify_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Certify_REQUEST_ID;
}

TPM2_Certify_REQUEST::TPM2_Certify_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    objectHandle = _objectHandle;
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
TPM2_Certify_REQUEST::~TPM2_Certify_REQUEST() {}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
TpmStructureBase* TPM2_Certify_REQUEST::Clone() const
{
    return new TPM2_Certify_REQUEST(*this);
}

void* TPM2_Certify_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CertifyResponse::GetTypeId() const
{
    return TpmTypeId::CertifyResponse_ID;
}

CertifyResponse::CertifyResponse(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo = _certifyInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
CertifyResponse::~CertifyResponse() {}

/// <summary> The purpose of this command is to prove that an object with a specific Name is loaded in the TPM. By certifying that the object is loaded, the TPM warrants that a public area with a given Name is self-consistent and associated with a valid sensitive area. If a relying party has a public area that has the same Name as a Name certified with this command, then the values in that public area are correct. </summary>
TpmStructureBase* CertifyResponse::Clone() const
{
    return new CertifyResponse(*this);
}

void* CertifyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certifyInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return &certifyInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_CertifyCreation_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
}

TPM2_CertifyCreation_REQUEST::TPM2_CertifyCreation_REQUEST(
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _objectHandle,
    const ByteVec& _qualifyingData,
    const ByteVec& _creationHash,
    const TPMU_SIG_SCHEME& _inScheme,
    const TPMT_TK_CREATION& _creationTicket
)
{
    signHandle = _signHandle;
    objectHandle = _objectHandle;
    qualifyingData = _qualifyingData;
    creationHash = _creationHash;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    creationTicket = _creationTicket;
}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
TPM2_CertifyCreation_REQUEST::~TPM2_CertifyCreation_REQUEST() {}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
TpmStructureBase* TPM2_CertifyCreation_REQUEST::Clone() const
{
    return new TPM2_CertifyCreation_REQUEST(*this);
}

void* TPM2_CertifyCreation_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &creationHashSize;
            case 5: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            case 6: return &inSchemeScheme;
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return &creationTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            case 5: return &creationHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CertifyCreationResponse::GetTypeId() const
{
    return TpmTypeId::CertifyCreationResponse_ID;
}

CertifyCreationResponse::CertifyCreationResponse(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo = _certifyInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
CertifyCreationResponse::~CertifyCreationResponse() {}

/// <summary> This command is used to prove the association between an object and its creation data. The TPM will validate that the ticket was produced by the TPM and that the ticket validates the association between a loaded public area and the provided hash of the creation data (creationHash). </summary>
TpmStructureBase* CertifyCreationResponse::Clone() const
{
    return new CertifyCreationResponse(*this);
}

void* CertifyCreationResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certifyInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return &certifyInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Quote_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Quote_REQUEST_ID;
}

TPM2_Quote_REQUEST::TPM2_Quote_REQUEST(
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme,
    const vector<TPMS_PCR_SELECTION>& _PCRselect
)
{
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    PCRselect = _PCRselect;
}

/// <summary> This command is used to quote PCR values. </summary>
TPM2_Quote_REQUEST::~TPM2_Quote_REQUEST() {}

/// <summary> This command is used to quote PCR values. </summary>
TpmStructureBase* TPM2_Quote_REQUEST::Clone() const
{
    return new TPM2_Quote_REQUEST(*this);
}

void* TPM2_Quote_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: return &qualifyingDataSize;
            case 2: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: return &PCRselectCount;
            case 6: { if (newArraySize != -1) PCRselect.resize(newArraySize); arraySize = (int)PCRselect.size(); return &PCRselect; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &qualifyingData[arrayIndex];
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&PCRselect[arrayIndex]); return &PCRselect[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId QuoteResponse::GetTypeId() const
{
    return TpmTypeId::QuoteResponse_ID;
}

QuoteResponse::QuoteResponse(
    const TPMS_ATTEST& _quoted,
    const TPMU_SIGNATURE& _signature
)
{
    quoted = _quoted;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command is used to quote PCR values. </summary>
QuoteResponse::~QuoteResponse() {}

/// <summary> This command is used to quote PCR values. </summary>
TpmStructureBase* QuoteResponse::Clone() const
{
    return new QuoteResponse(*this);
}

void* QuoteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &quotedSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&quoted); return &quoted;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_GetSessionAuditDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
}

TPM2_GetSessionAuditDigest_REQUEST::TPM2_GetSessionAuditDigest_REQUEST(
    const TPM_HANDLE& _privacyAdminHandle,
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _sessionHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyAdminHandle = _privacyAdminHandle;
    signHandle = _signHandle;
    sessionHandle = _sessionHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
TPM2_GetSessionAuditDigest_REQUEST::~TPM2_GetSessionAuditDigest_REQUEST() {}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
TpmStructureBase* TPM2_GetSessionAuditDigest_REQUEST::Clone() const
{
    return new TPM2_GetSessionAuditDigest_REQUEST(*this);
}

void* TPM2_GetSessionAuditDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyAdminHandle); return &privacyAdminHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&sessionHandle); return &sessionHandle;
            case 3: return &qualifyingDataSize;
            case 4: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 5: return &inSchemeScheme;
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId GetSessionAuditDigestResponse::GetTypeId() const
{
    return TpmTypeId::GetSessionAuditDigestResponse_ID;
}

GetSessionAuditDigestResponse::GetSessionAuditDigestResponse(
    const TPMS_ATTEST& _auditInfo,
    const TPMU_SIGNATURE& _signature
)
{
    auditInfo = _auditInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
GetSessionAuditDigestResponse::~GetSessionAuditDigestResponse() {}

/// <summary> This command returns a digital signature of the audit session digest. </summary>
TpmStructureBase* GetSessionAuditDigestResponse::Clone() const
{
    return new GetSessionAuditDigestResponse(*this);
}

void* GetSessionAuditDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &auditInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&auditInfo); return &auditInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_GetCommandAuditDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
}

TPM2_GetCommandAuditDigest_REQUEST::TPM2_GetCommandAuditDigest_REQUEST(
    const TPM_HANDLE& _privacyHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyHandle = _privacyHandle;
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
TPM2_GetCommandAuditDigest_REQUEST::~TPM2_GetCommandAuditDigest_REQUEST() {}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
TpmStructureBase* TPM2_GetCommandAuditDigest_REQUEST::Clone() const
{
    return new TPM2_GetCommandAuditDigest_REQUEST(*this);
}

void* TPM2_GetCommandAuditDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyHandle); return &privacyHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId GetCommandAuditDigestResponse::GetTypeId() const
{
    return TpmTypeId::GetCommandAuditDigestResponse_ID;
}

GetCommandAuditDigestResponse::GetCommandAuditDigestResponse(
    const TPMS_ATTEST& _auditInfo,
    const TPMU_SIGNATURE& _signature
)
{
    auditInfo = _auditInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
GetCommandAuditDigestResponse::~GetCommandAuditDigestResponse() {}

/// <summary> This command returns the current value of the command audit digest, a digest of the commands being audited, and the audit hash algorithm. These values are placed in an attestation structure and signed with the key referenced by signHandle. </summary>
TpmStructureBase* GetCommandAuditDigestResponse::Clone() const
{
    return new GetCommandAuditDigestResponse(*this);
}

void* GetCommandAuditDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &auditInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&auditInfo); return &auditInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_GetTime_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetTime_REQUEST_ID;
}

TPM2_GetTime_REQUEST::TPM2_GetTime_REQUEST(
    const TPM_HANDLE& _privacyAdminHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme
)
{
    privacyAdminHandle = _privacyAdminHandle;
    signHandle = _signHandle;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
}

/// <summary> This command returns the current values of Time and Clock. </summary>
TPM2_GetTime_REQUEST::~TPM2_GetTime_REQUEST() {}

/// <summary> This command returns the current values of Time and Clock. </summary>
TpmStructureBase* TPM2_GetTime_REQUEST::Clone() const
{
    return new TPM2_GetTime_REQUEST(*this);
}

void* TPM2_GetTime_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&privacyAdminHandle); return &privacyAdminHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &qualifyingDataSize;
            case 3: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId GetTimeResponse::GetTypeId() const
{
    return TpmTypeId::GetTimeResponse_ID;
}

GetTimeResponse::GetTimeResponse(
    const TPMS_ATTEST& _timeInfo,
    const TPMU_SIGNATURE& _signature
)
{
    timeInfo = _timeInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command returns the current values of Time and Clock. </summary>
GetTimeResponse::~GetTimeResponse() {}

/// <summary> This command returns the current values of Time and Clock. </summary>
TpmStructureBase* GetTimeResponse::Clone() const
{
    return new GetTimeResponse(*this);
}

void* GetTimeResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &timeInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&timeInfo); return &timeInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_CertifyX509_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
}

TPM2_CertifyX509_REQUEST::TPM2_CertifyX509_REQUEST(
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _signHandle,
    const ByteVec& _reserved,
    const TPMU_SIG_SCHEME& _inScheme,
    const ByteVec& _partialCertificate
)
{
    objectHandle = _objectHandle;
    signHandle = _signHandle;
    reserved = _reserved;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    partialCertificate = _partialCertificate;
}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
TPM2_CertifyX509_REQUEST::~TPM2_CertifyX509_REQUEST() {}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
TpmStructureBase* TPM2_CertifyX509_REQUEST::Clone() const
{
    return new TPM2_CertifyX509_REQUEST(*this);
}

void* TPM2_CertifyX509_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 2: return &reservedSize;
            case 3: { if (newArraySize != -1) reserved.resize(newArraySize); arraySize = (int)reserved.size(); return &reserved; }
            case 4: return &inSchemeScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 6: return &partialCertificateSize;
            case 7: { if (newArraySize != -1) partialCertificate.resize(newArraySize); arraySize = (int)partialCertificate.size(); return &partialCertificate; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &reserved[arrayIndex];
            case 7: return &partialCertificate[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CertifyX509Response::GetTypeId() const
{
    return TpmTypeId::CertifyX509Response_ID;
}

CertifyX509Response::CertifyX509Response(
    const ByteVec& _addedToCertificate,
    const ByteVec& _tbsDigest,
    const TPMU_SIGNATURE& _signature
)
{
    addedToCertificate = _addedToCertificate;
    tbsDigest = _tbsDigest;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
CertifyX509Response::~CertifyX509Response() {}

/// <summary> The purpose of this command is to generate an X.509 certificate that proves an object with a specific public key and attributes is loaded in the TPM. In contrast to TPM2_Certify, which uses a TCG-defined data structure to convey attestation information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. </summary>
TpmStructureBase* CertifyX509Response::Clone() const
{
    return new CertifyX509Response(*this);
}

void* CertifyX509Response::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &addedToCertificateSize;
            case 1: { if (newArraySize != -1) addedToCertificate.resize(newArraySize); arraySize = (int)addedToCertificate.size(); return &addedToCertificate; }
            case 2: return &tbsDigestSize;
            case 3: { if (newArraySize != -1) tbsDigest.resize(newArraySize); arraySize = (int)tbsDigest.size(); return &tbsDigest; }
            case 4: return &signatureSigAlg;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &addedToCertificate[arrayIndex];
            case 3: return &tbsDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_Commit_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Commit_REQUEST_ID;
}

TPM2_Commit_REQUEST::TPM2_Commit_REQUEST(
    const TPM_HANDLE& _signHandle,
    const TPMS_ECC_POINT& _P1,
    const ByteVec& _s2,
    const ByteVec& _y2
)
{
    signHandle = _signHandle;
    P1 = _P1;
    s2 = _s2;
    y2 = _y2;
}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
TPM2_Commit_REQUEST::~TPM2_Commit_REQUEST() {}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
TpmStructureBase* TPM2_Commit_REQUEST::Clone() const
{
    return new TPM2_Commit_REQUEST(*this);
}

void* TPM2_Commit_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: return &P1Size;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&P1); return &P1;
            case 3: return &s2Size;
            case 4: { if (newArraySize != -1) s2.resize(newArraySize); arraySize = (int)s2.size(); return &s2; }
            case 5: return &y2Size;
            case 6: { if (newArraySize != -1) y2.resize(newArraySize); arraySize = (int)y2.size(); return &y2; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &s2[arrayIndex];
            case 6: return &y2[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CommitResponse::GetTypeId() const
{
    return TpmTypeId::CommitResponse_ID;
}

CommitResponse::CommitResponse(
    const TPMS_ECC_POINT& _K,
    const TPMS_ECC_POINT& _L,
    const TPMS_ECC_POINT& _E,
    UINT16 _counter
)
{
    K = _K;
    L = _L;
    E = _E;
    counter = _counter;
}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
CommitResponse::~CommitResponse() {}

/// <summary> TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM will perform the point multiplications on the provided points and return intermediate signing values. The signHandle parameter shall refer to an ECC key and the signing scheme must be anonymous (TPM_RC_SCHEME). </summary>
TpmStructureBase* CommitResponse::Clone() const
{
    return new CommitResponse(*this);
}

void* CommitResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &KSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&K); return &K;
            case 2: return &LSize;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&L); return &L;
            case 4: return &ESize;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&E); return &E;
            case 6: return &counter;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_EC_Ephemeral_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID;
}

TPM2_EC_Ephemeral_REQUEST::TPM2_EC_Ephemeral_REQUEST(TPM_ECC_CURVE _curveID)
{
    curveID = _curveID;
}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
TPM2_EC_Ephemeral_REQUEST::~TPM2_EC_Ephemeral_REQUEST() {}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
TpmStructureBase* TPM2_EC_Ephemeral_REQUEST::Clone() const
{
    return new TPM2_EC_Ephemeral_REQUEST(*this);
}

void* TPM2_EC_Ephemeral_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &curveID;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId EC_EphemeralResponse::GetTypeId() const
{
    return TpmTypeId::EC_EphemeralResponse_ID;
}

EC_EphemeralResponse::EC_EphemeralResponse(
    const TPMS_ECC_POINT& _Q,
    UINT16 _counter
)
{
    Q = _Q;
    counter = _counter;
}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
EC_EphemeralResponse::~EC_EphemeralResponse() {}

/// <summary> TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol. </summary>
TpmStructureBase* EC_EphemeralResponse::Clone() const
{
    return new EC_EphemeralResponse(*this);
}

void* EC_EphemeralResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &QSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&Q); return &Q;
            case 2: return &counter;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_VerifySignature_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
}

TPM2_VerifySignature_REQUEST::TPM2_VerifySignature_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _digest,
    const TPMU_SIGNATURE& _signature
)
{
    keyHandle = _keyHandle;
    digest = _digest;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
TPM2_VerifySignature_REQUEST::~TPM2_VerifySignature_REQUEST() {}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
TpmStructureBase* TPM2_VerifySignature_REQUEST::Clone() const
{
    return new TPM2_VerifySignature_REQUEST(*this);
}

void* TPM2_VerifySignature_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &digestSize;
            case 2: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            case 3: return &signatureSigAlg;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId VerifySignatureResponse::GetTypeId() const
{
    return TpmTypeId::VerifySignatureResponse_ID;
}

VerifySignatureResponse::VerifySignatureResponse(const TPMT_TK_VERIFIED& _validation)
{
    validation = _validation;
}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
VerifySignatureResponse::~VerifySignatureResponse() {}

/// <summary> This command uses loaded keys to validate a signature on a message with the message digest passed to the TPM. </summary>
TpmStructureBase* VerifySignatureResponse::Clone() const
{
    return new VerifySignatureResponse(*this);
}

void* VerifySignatureResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Sign_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Sign_REQUEST_ID;
}

TPM2_Sign_REQUEST::TPM2_Sign_REQUEST(
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _digest,
    const TPMU_SIG_SCHEME& _inScheme,
    const TPMT_TK_HASHCHECK& _validation
)
{
    keyHandle = _keyHandle;
    digest = _digest;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    validation = _validation;
}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
TPM2_Sign_REQUEST::~TPM2_Sign_REQUEST() {}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
TpmStructureBase* TPM2_Sign_REQUEST::Clone() const
{
    return new TPM2_Sign_REQUEST(*this);
}

void* TPM2_Sign_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 1: return &digestSize;
            case 2: { if (newArraySize != -1) digest.resize(newArraySize); arraySize = (int)digest.size(); return &digest; }
            case 3: return &inSchemeScheme;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&validation); return &validation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &digest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SignResponse::GetTypeId() const
{
    return TpmTypeId::SignResponse_ID;
}

SignResponse::SignResponse(
    const TPMU_SIGNATURE& _signature
)
{
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
SignResponse::~SignResponse() {}

/// <summary> This command causes the TPM to sign an externally provided hash with the specified symmetric or asymmetric signing key. </summary>
TpmStructureBase* SignResponse::Clone() const
{
    return new SignResponse(*this);
}

void* SignResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &signatureSigAlg;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_SetCommandCodeAuditStatus_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
}

TPM2_SetCommandCodeAuditStatus_REQUEST::TPM2_SetCommandCodeAuditStatus_REQUEST(
    const TPM_HANDLE& _auth,
    TPM_ALG_ID _auditAlg,
    const vector<TPM_CC>& _setList,
    const vector<TPM_CC>& _clearList
)
{
    auth = _auth;
    auditAlg = _auditAlg;
    setList = _setList;
    clearList = _clearList;
}

/// <summary> This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time. </summary>
TPM2_SetCommandCodeAuditStatus_REQUEST::~TPM2_SetCommandCodeAuditStatus_REQUEST() {}

/// <summary> This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time. </summary>
TpmStructureBase* TPM2_SetCommandCodeAuditStatus_REQUEST::Clone() const
{
    return new TPM2_SetCommandCodeAuditStatus_REQUEST(*this);
}

void* TPM2_SetCommandCodeAuditStatus_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &auditAlg;
            case 2: return &setListCount;
            case 3: { if (newArraySize != -1) setList.resize(newArraySize); arraySize = (int)setList.size(); return &setList; }
            case 4: return &clearListCount;
            case 5: { if (newArraySize != -1) clearList.resize(newArraySize); arraySize = (int)clearList.size(); return &clearList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &setList[arrayIndex];
            case 5: return &clearList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SetCommandCodeAuditStatusResponse::GetTypeId() const
{
    return TpmTypeId::SetCommandCodeAuditStatusResponse_ID;
}

/// <summary> This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time. </summary>
SetCommandCodeAuditStatusResponse::~SetCommandCodeAuditStatusResponse() {}

/// <summary> This command may be used by the Privacy Administrator or platform to change the audit status of a command or to set the hash algorithm used for the audit digest, but not both at the same time. </summary>
TpmStructureBase* SetCommandCodeAuditStatusResponse::Clone() const
{
    return new SetCommandCodeAuditStatusResponse(*this);
}

void* SetCommandCodeAuditStatusResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PCR_Extend_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
}

TPM2_PCR_Extend_REQUEST::TPM2_PCR_Extend_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const vector<TPMT_HA>& _digests
)
{
    pcrHandle = _pcrHandle;
    digests = _digests;
}

/// <summary> This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg). </summary>
TPM2_PCR_Extend_REQUEST::~TPM2_PCR_Extend_REQUEST() {}

/// <summary> This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg). </summary>
TpmStructureBase* TPM2_PCR_Extend_REQUEST::Clone() const
{
    return new TPM2_PCR_Extend_REQUEST(*this);
}

void* TPM2_PCR_Extend_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: return &digestsCount;
            case 2: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_ExtendResponse::GetTypeId() const
{
    return TpmTypeId::PCR_ExtendResponse_ID;
}

/// <summary> This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg). </summary>
PCR_ExtendResponse::~PCR_ExtendResponse() {}

/// <summary> This command is used to cause an update to the indicated PCR. The digests parameter contains one or more tagged digest values identified by an algorithm ID. For each digest, the PCR associated with pcrHandle is Extended into the bank identified by the tag (hashAlg). </summary>
TpmStructureBase* PCR_ExtendResponse::Clone() const
{
    return new PCR_ExtendResponse(*this);
}

void* PCR_ExtendResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PCR_Event_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
}

TPM2_PCR_Event_REQUEST::TPM2_PCR_Event_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const ByteVec& _eventData
)
{
    pcrHandle = _pcrHandle;
    eventData = _eventData;
}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
TPM2_PCR_Event_REQUEST::~TPM2_PCR_Event_REQUEST() {}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
TpmStructureBase* TPM2_PCR_Event_REQUEST::Clone() const
{
    return new TPM2_PCR_Event_REQUEST(*this);
}

void* TPM2_PCR_Event_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: return &eventDataSize;
            case 2: { if (newArraySize != -1) eventData.resize(newArraySize); arraySize = (int)eventData.size(); return &eventData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &eventData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_EventResponse::GetTypeId() const
{
    return TpmTypeId::PCR_EventResponse_ID;
}

PCR_EventResponse::PCR_EventResponse(
    const vector<TPMT_HA>& _digests
)
{
    digests = _digests;
}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
PCR_EventResponse::~PCR_EventResponse() {}

/// <summary> This command is used to cause an update to the indicated PCR. </summary>
TpmStructureBase* PCR_EventResponse::Clone() const
{
    return new PCR_EventResponse(*this);
}

void* PCR_EventResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &digestsCount;
            case 1: { if (newArraySize != -1) digests.resize(newArraySize); arraySize = (int)digests.size(); return &digests; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&digests[arrayIndex]); return &digests[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_Read_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
}

TPM2_PCR_Read_REQUEST::TPM2_PCR_Read_REQUEST(
    const vector<TPMS_PCR_SELECTION>& _pcrSelectionIn
)
{
    pcrSelectionIn = _pcrSelectionIn;
}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
TPM2_PCR_Read_REQUEST::~TPM2_PCR_Read_REQUEST() {}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
TpmStructureBase* TPM2_PCR_Read_REQUEST::Clone() const
{
    return new TPM2_PCR_Read_REQUEST(*this);
}

void* TPM2_PCR_Read_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrSelectionInCount;
            case 1: { if (newArraySize != -1) pcrSelectionIn.resize(newArraySize); arraySize = (int)pcrSelectionIn.size(); return &pcrSelectionIn; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelectionIn[arrayIndex]); return &pcrSelectionIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_ReadResponse::GetTypeId() const
{
    return TpmTypeId::PCR_ReadResponse_ID;
}

PCR_ReadResponse::PCR_ReadResponse(
    UINT32 _pcrUpdateCounter,
    const vector<TPMS_PCR_SELECTION>& _pcrSelectionOut,
    const vector<TPM2B_DIGEST>& _pcrValues
)
{
    pcrUpdateCounter = _pcrUpdateCounter;
    pcrSelectionOut = _pcrSelectionOut;
    pcrValues = _pcrValues;
}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
PCR_ReadResponse::~PCR_ReadResponse() {}

/// <summary> This command returns the values of all PCR specified in pcrSelectionIn. </summary>
TpmStructureBase* PCR_ReadResponse::Clone() const
{
    return new PCR_ReadResponse(*this);
}

void* PCR_ReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &pcrUpdateCounter;
            case 1: return &pcrSelectionOutCount;
            case 2: { if (newArraySize != -1) pcrSelectionOut.resize(newArraySize); arraySize = (int)pcrSelectionOut.size(); return &pcrSelectionOut; }
            case 3: return &pcrValuesCount;
            case 4: { if (newArraySize != -1) pcrValues.resize(newArraySize); arraySize = (int)pcrValues.size(); return &pcrValues; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pcrSelectionOut[arrayIndex]); return &pcrSelectionOut[arrayIndex];
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrValues[arrayIndex]); return &pcrValues[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PCR_Allocate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
}

TPM2_PCR_Allocate_REQUEST::TPM2_PCR_Allocate_REQUEST(
    const TPM_HANDLE& _authHandle,
    const vector<TPMS_PCR_SELECTION>& _pcrAllocation
)
{
    authHandle = _authHandle;
    pcrAllocation = _pcrAllocation;
}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
TPM2_PCR_Allocate_REQUEST::~TPM2_PCR_Allocate_REQUEST() {}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
TpmStructureBase* TPM2_PCR_Allocate_REQUEST::Clone() const
{
    return new TPM2_PCR_Allocate_REQUEST(*this);
}

void* TPM2_PCR_Allocate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &pcrAllocationCount;
            case 2: { if (newArraySize != -1) pcrAllocation.resize(newArraySize); arraySize = (int)pcrAllocation.size(); return &pcrAllocation; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pcrAllocation[arrayIndex]); return &pcrAllocation[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_AllocateResponse::GetTypeId() const
{
    return TpmTypeId::PCR_AllocateResponse_ID;
}

PCR_AllocateResponse::PCR_AllocateResponse(
    BYTE _allocationSuccess,
    UINT32 _maxPCR,
    UINT32 _sizeNeeded,
    UINT32 _sizeAvailable
)
{
    allocationSuccess = _allocationSuccess;
    maxPCR = _maxPCR;
    sizeNeeded = _sizeNeeded;
    sizeAvailable = _sizeAvailable;
}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
PCR_AllocateResponse::~PCR_AllocateResponse() {}

/// <summary> This command is used to set the desired PCR allocation of PCR and algorithms. This command requires Platform Authorization. </summary>
TpmStructureBase* PCR_AllocateResponse::Clone() const
{
    return new PCR_AllocateResponse(*this);
}

void* PCR_AllocateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &allocationSuccess;
            case 1: return &maxPCR;
            case 2: return &sizeNeeded;
            case 3: return &sizeAvailable;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_PCR_SetAuthPolicy_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
}

TPM2_PCR_SetAuthPolicy_REQUEST::TPM2_PCR_SetAuthPolicy_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _authPolicy,
    TPM_ALG_ID _hashAlg,
    const TPM_HANDLE& _pcrNum
)
{
    authHandle = _authHandle;
    authPolicy = _authPolicy;
    hashAlg = _hashAlg;
    pcrNum = _pcrNum;
}

/// <summary> This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset. </summary>
TPM2_PCR_SetAuthPolicy_REQUEST::~TPM2_PCR_SetAuthPolicy_REQUEST() {}

/// <summary> This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset. </summary>
TpmStructureBase* TPM2_PCR_SetAuthPolicy_REQUEST::Clone() const
{
    return new TPM2_PCR_SetAuthPolicy_REQUEST(*this);
}

void* TPM2_PCR_SetAuthPolicy_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &authPolicySize;
            case 2: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 3: return &hashAlg;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrNum); return &pcrNum;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_SetAuthPolicyResponse::GetTypeId() const
{
    return TpmTypeId::PCR_SetAuthPolicyResponse_ID;
}

/// <summary> This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset. </summary>
PCR_SetAuthPolicyResponse::~PCR_SetAuthPolicyResponse() {}

/// <summary> This command is used to associate a policy with a PCR or group of PCR. The policy determines the conditions under which a PCR may be extended or reset. </summary>
TpmStructureBase* PCR_SetAuthPolicyResponse::Clone() const
{
    return new PCR_SetAuthPolicyResponse(*this);
}

void* PCR_SetAuthPolicyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PCR_SetAuthValue_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
}

TPM2_PCR_SetAuthValue_REQUEST::TPM2_PCR_SetAuthValue_REQUEST(
    const TPM_HANDLE& _pcrHandle,
    const ByteVec& _auth
)
{
    pcrHandle = _pcrHandle;
    auth = _auth;
}

/// <summary> This command changes the authValue of a PCR or group of PCR. </summary>
TPM2_PCR_SetAuthValue_REQUEST::~TPM2_PCR_SetAuthValue_REQUEST() {}

/// <summary> This command changes the authValue of a PCR or group of PCR. </summary>
TpmStructureBase* TPM2_PCR_SetAuthValue_REQUEST::Clone() const
{
    return new TPM2_PCR_SetAuthValue_REQUEST(*this);
}

void* TPM2_PCR_SetAuthValue_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PCR_SetAuthValueResponse::GetTypeId() const
{
    return TpmTypeId::PCR_SetAuthValueResponse_ID;
}

/// <summary> This command changes the authValue of a PCR or group of PCR. </summary>
PCR_SetAuthValueResponse::~PCR_SetAuthValueResponse() {}

/// <summary> This command changes the authValue of a PCR or group of PCR. </summary>
TpmStructureBase* PCR_SetAuthValueResponse::Clone() const
{
    return new PCR_SetAuthValueResponse(*this);
}

void* PCR_SetAuthValueResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PCR_Reset_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PCR_Reset_REQUEST_ID;
}

TPM2_PCR_Reset_REQUEST::TPM2_PCR_Reset_REQUEST(const TPM_HANDLE& _pcrHandle)
{
    pcrHandle = _pcrHandle;
}

/// <summary> If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation. </summary>
TPM2_PCR_Reset_REQUEST::~TPM2_PCR_Reset_REQUEST() {}

/// <summary> If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation. </summary>
TpmStructureBase* TPM2_PCR_Reset_REQUEST::Clone() const
{
    return new TPM2_PCR_Reset_REQUEST(*this);
}

void* TPM2_PCR_Reset_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&pcrHandle); return &pcrHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PCR_ResetResponse::GetTypeId() const
{
    return TpmTypeId::PCR_ResetResponse_ID;
}

/// <summary> If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation. </summary>
PCR_ResetResponse::~PCR_ResetResponse() {}

/// <summary> If the attribute of a PCR allows the PCR to be reset and proper authorization is provided, then this command may be used to set the PCR in all banks to zero. The attributes of the PCR may restrict the locality that can perform the reset operation. </summary>
TpmStructureBase* PCR_ResetResponse::Clone() const
{
    return new PCR_ResetResponse(*this);
}

void* PCR_ResetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicySigned_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
}

TPM2_PolicySigned_REQUEST::TPM2_PolicySigned_REQUEST(
    const TPM_HANDLE& _authObject,
    const TPM_HANDLE& _policySession,
    const ByteVec& _nonceTPM,
    const ByteVec& _cpHashA,
    const ByteVec& _policyRef,
    INT32 _expiration,
    const TPMU_SIGNATURE& _auth
)
{
    authObject = _authObject;
    policySession = _policySession;
    nonceTPM = _nonceTPM;
    cpHashA = _cpHashA;
    policyRef = _policyRef;
    expiration = _expiration;
    auth.reset(dynamic_cast<TPMU_SIGNATURE*>(_auth.Clone()));
}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
TPM2_PolicySigned_REQUEST::~TPM2_PolicySigned_REQUEST() {}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
TpmStructureBase* TPM2_PolicySigned_REQUEST::Clone() const
{
    return new TPM2_PolicySigned_REQUEST(*this);
}

void* TPM2_PolicySigned_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authObject); return &authObject;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 2: return &nonceTPMSize;
            case 3: { if (newArraySize != -1) nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return &nonceTPM; }
            case 4: return &cpHashASize;
            case 5: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            case 6: return &policyRefSize;
            case 7: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 8: return &expiration;
            case 9: return &authSigAlg;
            case 10: pStruct = dynamic_cast<TpmStructureBase*>(&*auth); return &auth;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nonceTPM[arrayIndex];
            case 5: return &cpHashA[arrayIndex];
            case 7: return &policyRef[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicySignedResponse::GetTypeId() const
{
    return TpmTypeId::PolicySignedResponse_ID;
}

PolicySignedResponse::PolicySignedResponse(
    const ByteVec& _timeout,
    const TPMT_TK_AUTH& _policyTicket
)
{
    timeout = _timeout;
    policyTicket = _policyTicket;
}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
PolicySignedResponse::~PolicySignedResponse() {}

/// <summary> This command includes a signed authorization in a policy. The command ties the policy to a signing key by including the Name of the signing key in the policyDigest </summary>
TpmStructureBase* PolicySignedResponse::Clone() const
{
    return new PolicySignedResponse(*this);
}

void* PolicySignedResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &timeoutSize;
            case 1: { if (newArraySize != -1) timeout.resize(newArraySize); arraySize = (int)timeout.size(); return &timeout; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policyTicket); return &policyTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &timeout[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicySecret_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
}

TPM2_PolicySecret_REQUEST::TPM2_PolicySecret_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _policySession,
    const ByteVec& _nonceTPM,
    const ByteVec& _cpHashA,
    const ByteVec& _policyRef,
    INT32 _expiration
)
{
    authHandle = _authHandle;
    policySession = _policySession;
    nonceTPM = _nonceTPM;
    cpHashA = _cpHashA;
    policyRef = _policyRef;
    expiration = _expiration;
}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
TPM2_PolicySecret_REQUEST::~TPM2_PolicySecret_REQUEST() {}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
TpmStructureBase* TPM2_PolicySecret_REQUEST::Clone() const
{
    return new TPM2_PolicySecret_REQUEST(*this);
}

void* TPM2_PolicySecret_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 2: return &nonceTPMSize;
            case 3: { if (newArraySize != -1) nonceTPM.resize(newArraySize); arraySize = (int)nonceTPM.size(); return &nonceTPM; }
            case 4: return &cpHashASize;
            case 5: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            case 6: return &policyRefSize;
            case 7: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 8: return &expiration;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nonceTPM[arrayIndex];
            case 5: return &cpHashA[arrayIndex];
            case 7: return &policyRef[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicySecretResponse::GetTypeId() const
{
    return TpmTypeId::PolicySecretResponse_ID;
}

PolicySecretResponse::PolicySecretResponse(
    const ByteVec& _timeout,
    const TPMT_TK_AUTH& _policyTicket
)
{
    timeout = _timeout;
    policyTicket = _policyTicket;
}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
PolicySecretResponse::~PolicySecretResponse() {}

/// <summary> This command includes a secret-based authorization to a policy. The caller proves knowledge of the secret value using an authorization session using the authValue associated with authHandle. A password session, an HMAC session, or a policy session containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement. </summary>
TpmStructureBase* PolicySecretResponse::Clone() const
{
    return new PolicySecretResponse(*this);
}

void* PolicySecretResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &timeoutSize;
            case 1: { if (newArraySize != -1) timeout.resize(newArraySize); arraySize = (int)timeout.size(); return &timeout; }
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policyTicket); return &policyTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &timeout[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyTicket_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
}

TPM2_PolicyTicket_REQUEST::TPM2_PolicyTicket_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _timeout,
    const ByteVec& _cpHashA,
    const ByteVec& _policyRef,
    const ByteVec& _authName,
    const TPMT_TK_AUTH& _ticket
)
{
    policySession = _policySession;
    timeout = _timeout;
    cpHashA = _cpHashA;
    policyRef = _policyRef;
    authName = _authName;
    ticket = _ticket;
}

/// <summary> This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it. </summary>
TPM2_PolicyTicket_REQUEST::~TPM2_PolicyTicket_REQUEST() {}

/// <summary> This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it. </summary>
TpmStructureBase* TPM2_PolicyTicket_REQUEST::Clone() const
{
    return new TPM2_PolicyTicket_REQUEST(*this);
}

void* TPM2_PolicyTicket_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &timeoutSize;
            case 2: { if (newArraySize != -1) timeout.resize(newArraySize); arraySize = (int)timeout.size(); return &timeout; }
            case 3: return &cpHashASize;
            case 4: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            case 5: return &policyRefSize;
            case 6: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 7: return &authNameSize;
            case 8: { if (newArraySize != -1) authName.resize(newArraySize); arraySize = (int)authName.size(); return &authName; }
            case 9: pStruct = dynamic_cast<TpmStructureBase*>(&ticket); return &ticket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &timeout[arrayIndex];
            case 4: return &cpHashA[arrayIndex];
            case 6: return &policyRef[arrayIndex];
            case 8: return &authName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyTicketResponse::GetTypeId() const
{
    return TpmTypeId::PolicyTicketResponse_ID;
}

/// <summary> This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it. </summary>
PolicyTicketResponse::~PolicyTicketResponse() {}

/// <summary> This command is similar to TPM2_PolicySigned() except that it takes a ticket instead of a signed authorization. The ticket represents a validated authorization that had an expiration time associated with it. </summary>
TpmStructureBase* PolicyTicketResponse::Clone() const
{
    return new PolicyTicketResponse(*this);
}

void* PolicyTicketResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyOR_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
}

TPM2_PolicyOR_REQUEST::TPM2_PolicyOR_REQUEST(
    const TPM_HANDLE& _policySession,
    const vector<TPM2B_DIGEST>& _pHashList
)
{
    policySession = _policySession;
    pHashList = _pHashList;
}

/// <summary> This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied. </summary>
TPM2_PolicyOR_REQUEST::~TPM2_PolicyOR_REQUEST() {}

/// <summary> This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied. </summary>
TpmStructureBase* TPM2_PolicyOR_REQUEST::Clone() const
{
    return new TPM2_PolicyOR_REQUEST(*this);
}

void* TPM2_PolicyOR_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &pHashListCount;
            case 2: { if (newArraySize != -1) pHashList.resize(newArraySize); arraySize = (int)pHashList.size(); return &pHashList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&pHashList[arrayIndex]); return &pHashList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyORResponse::GetTypeId() const
{
    return TpmTypeId::PolicyORResponse_ID;
}

/// <summary> This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied. </summary>
PolicyORResponse::~PolicyORResponse() {}

/// <summary> This command allows options in authorizations without requiring that the TPM evaluate all of the options. If a policy may be satisfied by different sets of conditions, the TPM need only evaluate one set that satisfies the policy. This command will indicate that one of the required sets of conditions has been satisfied. </summary>
TpmStructureBase* PolicyORResponse::Clone() const
{
    return new PolicyORResponse(*this);
}

void* PolicyORResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyPCR_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
}

TPM2_PolicyPCR_REQUEST::TPM2_PolicyPCR_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _pcrDigest,
    const vector<TPMS_PCR_SELECTION>& _pcrs
)
{
    policySession = _policySession;
    pcrDigest = _pcrDigest;
    pcrs = _pcrs;
}

/// <summary> This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state. </summary>
TPM2_PolicyPCR_REQUEST::~TPM2_PolicyPCR_REQUEST() {}

/// <summary> This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state. </summary>
TpmStructureBase* TPM2_PolicyPCR_REQUEST::Clone() const
{
    return new TPM2_PolicyPCR_REQUEST(*this);
}

void* TPM2_PolicyPCR_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &pcrDigestSize;
            case 2: { if (newArraySize != -1) pcrDigest.resize(newArraySize); arraySize = (int)pcrDigest.size(); return &pcrDigest; }
            case 3: return &pcrsCount;
            case 4: { if (newArraySize != -1) pcrs.resize(newArraySize); arraySize = (int)pcrs.size(); return &pcrs; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &pcrDigest[arrayIndex];
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&pcrs[arrayIndex]); return &pcrs[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyPCRResponse::GetTypeId() const
{
    return TpmTypeId::PolicyPCRResponse_ID;
}

/// <summary> This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state. </summary>
PolicyPCRResponse::~PolicyPCRResponse() {}

/// <summary> This command is used to cause conditional gating of a policy based on PCR. This command together with TPM2_PolicyOR() allows one group of authorizations to occur when PCR are in one state and a different set of authorizations when the PCR are in a different state. </summary>
TpmStructureBase* PolicyPCRResponse::Clone() const
{
    return new PolicyPCRResponse(*this);
}

void* PolicyPCRResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyLocality_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
}

TPM2_PolicyLocality_REQUEST::TPM2_PolicyLocality_REQUEST(
    const TPM_HANDLE& _policySession,
    TPMA_LOCALITY _locality
)
{
    policySession = _policySession;
    locality = _locality;
}

/// <summary> This command indicates that the authorization will be limited to a specific locality. </summary>
TPM2_PolicyLocality_REQUEST::~TPM2_PolicyLocality_REQUEST() {}

/// <summary> This command indicates that the authorization will be limited to a specific locality. </summary>
TpmStructureBase* TPM2_PolicyLocality_REQUEST::Clone() const
{
    return new TPM2_PolicyLocality_REQUEST(*this);
}

void* TPM2_PolicyLocality_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &locality;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyLocalityResponse::GetTypeId() const
{
    return TpmTypeId::PolicyLocalityResponse_ID;
}

/// <summary> This command indicates that the authorization will be limited to a specific locality. </summary>
PolicyLocalityResponse::~PolicyLocalityResponse() {}

/// <summary> This command indicates that the authorization will be limited to a specific locality. </summary>
TpmStructureBase* PolicyLocalityResponse::Clone() const
{
    return new PolicyLocalityResponse(*this);
}

void* PolicyLocalityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyNV_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
}

TPM2_PolicyNV_REQUEST::TPM2_PolicyNV_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _policySession,
    const ByteVec& _operandB,
    UINT16 _offset,
    TPM_EO _operation
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    policySession = _policySession;
    operandB = _operandB;
    offset = _offset;
    operation = _operation;
}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization. </summary>
TPM2_PolicyNV_REQUEST::~TPM2_PolicyNV_REQUEST() {}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization. </summary>
TpmStructureBase* TPM2_PolicyNV_REQUEST::Clone() const
{
    return new TPM2_PolicyNV_REQUEST(*this);
}

void* TPM2_PolicyNV_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 3: return &operandBSize;
            case 4: { if (newArraySize != -1) operandB.resize(newArraySize); arraySize = (int)operandB.size(); return &operandB; }
            case 5: return &offset;
            case 6: return &operation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &operandB[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyNVResponse::GetTypeId() const
{
    return TpmTypeId::PolicyNVResponse_ID;
}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization. </summary>
PolicyNVResponse::~PolicyNVResponse() {}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of an NV Index. It is an immediate assertion. The NV index is validated during the TPM2_PolicyNV() command, not when the session is used for authorization. </summary>
TpmStructureBase* PolicyNVResponse::Clone() const
{
    return new PolicyNVResponse(*this);
}

void* PolicyNVResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyCounterTimer_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
}

TPM2_PolicyCounterTimer_REQUEST::TPM2_PolicyCounterTimer_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _operandB,
    UINT16 _offset,
    TPM_EO _operation
)
{
    policySession = _policySession;
    operandB = _operandB;
    offset = _offset;
    operation = _operation;
}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure. </summary>
TPM2_PolicyCounterTimer_REQUEST::~TPM2_PolicyCounterTimer_REQUEST() {}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure. </summary>
TpmStructureBase* TPM2_PolicyCounterTimer_REQUEST::Clone() const
{
    return new TPM2_PolicyCounterTimer_REQUEST(*this);
}

void* TPM2_PolicyCounterTimer_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &operandBSize;
            case 2: { if (newArraySize != -1) operandB.resize(newArraySize); arraySize = (int)operandB.size(); return &operandB; }
            case 3: return &offset;
            case 4: return &operation;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &operandB[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyCounterTimerResponse::GetTypeId() const
{
    return TpmTypeId::PolicyCounterTimerResponse_ID;
}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure. </summary>
PolicyCounterTimerResponse::~PolicyCounterTimerResponse() {}

/// <summary> This command is used to cause conditional gating of a policy based on the contents of the TPMS_TIME_INFO structure. </summary>
TpmStructureBase* PolicyCounterTimerResponse::Clone() const
{
    return new PolicyCounterTimerResponse(*this);
}

void* PolicyCounterTimerResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyCommandCode_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
}

TPM2_PolicyCommandCode_REQUEST::TPM2_PolicyCommandCode_REQUEST(
    const TPM_HANDLE& _policySession,
    TPM_CC _code
)
{
    policySession = _policySession;
    code = _code;
}

/// <summary> This command indicates that the authorization will be limited to a specific command code. </summary>
TPM2_PolicyCommandCode_REQUEST::~TPM2_PolicyCommandCode_REQUEST() {}

/// <summary> This command indicates that the authorization will be limited to a specific command code. </summary>
TpmStructureBase* TPM2_PolicyCommandCode_REQUEST::Clone() const
{
    return new TPM2_PolicyCommandCode_REQUEST(*this);
}

void* TPM2_PolicyCommandCode_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &code;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyCommandCodeResponse::GetTypeId() const
{
    return TpmTypeId::PolicyCommandCodeResponse_ID;
}

/// <summary> This command indicates that the authorization will be limited to a specific command code. </summary>
PolicyCommandCodeResponse::~PolicyCommandCodeResponse() {}

/// <summary> This command indicates that the authorization will be limited to a specific command code. </summary>
TpmStructureBase* PolicyCommandCodeResponse::Clone() const
{
    return new PolicyCommandCodeResponse(*this);
}

void* PolicyCommandCodeResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyPhysicalPresence_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID;
}

TPM2_PolicyPhysicalPresence_REQUEST::TPM2_PolicyPhysicalPresence_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command indicates that physical presence will need to be asserted at the time the authorization is performed. </summary>
TPM2_PolicyPhysicalPresence_REQUEST::~TPM2_PolicyPhysicalPresence_REQUEST() {}

/// <summary> This command indicates that physical presence will need to be asserted at the time the authorization is performed. </summary>
TpmStructureBase* TPM2_PolicyPhysicalPresence_REQUEST::Clone() const
{
    return new TPM2_PolicyPhysicalPresence_REQUEST(*this);
}

void* TPM2_PolicyPhysicalPresence_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyPhysicalPresenceResponse::GetTypeId() const
{
    return TpmTypeId::PolicyPhysicalPresenceResponse_ID;
}

/// <summary> This command indicates that physical presence will need to be asserted at the time the authorization is performed. </summary>
PolicyPhysicalPresenceResponse::~PolicyPhysicalPresenceResponse() {}

/// <summary> This command indicates that physical presence will need to be asserted at the time the authorization is performed. </summary>
TpmStructureBase* PolicyPhysicalPresenceResponse::Clone() const
{
    return new PolicyPhysicalPresenceResponse(*this);
}

void* PolicyPhysicalPresenceResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyCpHash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
}

TPM2_PolicyCpHash_REQUEST::TPM2_PolicyCpHash_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _cpHashA
)
{
    policySession = _policySession;
    cpHashA = _cpHashA;
}

/// <summary> This command is used to allow a policy to be bound to a specific command and command parameters. </summary>
TPM2_PolicyCpHash_REQUEST::~TPM2_PolicyCpHash_REQUEST() {}

/// <summary> This command is used to allow a policy to be bound to a specific command and command parameters. </summary>
TpmStructureBase* TPM2_PolicyCpHash_REQUEST::Clone() const
{
    return new TPM2_PolicyCpHash_REQUEST(*this);
}

void* TPM2_PolicyCpHash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &cpHashASize;
            case 2: { if (newArraySize != -1) cpHashA.resize(newArraySize); arraySize = (int)cpHashA.size(); return &cpHashA; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &cpHashA[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyCpHashResponse::GetTypeId() const
{
    return TpmTypeId::PolicyCpHashResponse_ID;
}

/// <summary> This command is used to allow a policy to be bound to a specific command and command parameters. </summary>
PolicyCpHashResponse::~PolicyCpHashResponse() {}

/// <summary> This command is used to allow a policy to be bound to a specific command and command parameters. </summary>
TpmStructureBase* PolicyCpHashResponse::Clone() const
{
    return new PolicyCpHashResponse(*this);
}

void* PolicyCpHashResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyNameHash_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
}

TPM2_PolicyNameHash_REQUEST::TPM2_PolicyNameHash_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _nameHash
)
{
    policySession = _policySession;
    nameHash = _nameHash;
}

/// <summary> This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy. </summary>
TPM2_PolicyNameHash_REQUEST::~TPM2_PolicyNameHash_REQUEST() {}

/// <summary> This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy. </summary>
TpmStructureBase* TPM2_PolicyNameHash_REQUEST::Clone() const
{
    return new TPM2_PolicyNameHash_REQUEST(*this);
}

void* TPM2_PolicyNameHash_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &nameHashSize;
            case 2: { if (newArraySize != -1) nameHash.resize(newArraySize); arraySize = (int)nameHash.size(); return &nameHash; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nameHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyNameHashResponse::GetTypeId() const
{
    return TpmTypeId::PolicyNameHashResponse_ID;
}

/// <summary> This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy. </summary>
PolicyNameHashResponse::~PolicyNameHashResponse() {}

/// <summary> This command allows a policy to be bound to a specific set of TPM entities without being bound to the parameters of the command. This is most useful for commands such as TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy. </summary>
TpmStructureBase* PolicyNameHashResponse::Clone() const
{
    return new PolicyNameHashResponse(*this);
}

void* PolicyNameHashResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyDuplicationSelect_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
}

TPM2_PolicyDuplicationSelect_REQUEST::TPM2_PolicyDuplicationSelect_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _objectName,
    const ByteVec& _newParentName,
    BYTE _includeObject
)
{
    policySession = _policySession;
    objectName = _objectName;
    newParentName = _newParentName;
    includeObject = _includeObject;
}

/// <summary> This command allows qualification of duplication to allow duplication to a selected new parent. </summary>
TPM2_PolicyDuplicationSelect_REQUEST::~TPM2_PolicyDuplicationSelect_REQUEST() {}

/// <summary> This command allows qualification of duplication to allow duplication to a selected new parent. </summary>
TpmStructureBase* TPM2_PolicyDuplicationSelect_REQUEST::Clone() const
{
    return new TPM2_PolicyDuplicationSelect_REQUEST(*this);
}

void* TPM2_PolicyDuplicationSelect_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &objectNameSize;
            case 2: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            case 3: return &newParentNameSize;
            case 4: { if (newArraySize != -1) newParentName.resize(newArraySize); arraySize = (int)newParentName.size(); return &newParentName; }
            case 5: return &includeObject;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &objectName[arrayIndex];
            case 4: return &newParentName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyDuplicationSelectResponse::GetTypeId() const
{
    return TpmTypeId::PolicyDuplicationSelectResponse_ID;
}

/// <summary> This command allows qualification of duplication to allow duplication to a selected new parent. </summary>
PolicyDuplicationSelectResponse::~PolicyDuplicationSelectResponse() {}

/// <summary> This command allows qualification of duplication to allow duplication to a selected new parent. </summary>
TpmStructureBase* PolicyDuplicationSelectResponse::Clone() const
{
    return new PolicyDuplicationSelectResponse(*this);
}

void* PolicyDuplicationSelectResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyAuthorize_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
}

TPM2_PolicyAuthorize_REQUEST::TPM2_PolicyAuthorize_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _approvedPolicy,
    const ByteVec& _policyRef,
    const ByteVec& _keySign,
    const TPMT_TK_VERIFIED& _checkTicket
)
{
    policySession = _policySession;
    approvedPolicy = _approvedPolicy;
    policyRef = _policyRef;
    keySign = _keySign;
    checkTicket = _checkTicket;
}

/// <summary> This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy. </summary>
TPM2_PolicyAuthorize_REQUEST::~TPM2_PolicyAuthorize_REQUEST() {}

/// <summary> This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy. </summary>
TpmStructureBase* TPM2_PolicyAuthorize_REQUEST::Clone() const
{
    return new TPM2_PolicyAuthorize_REQUEST(*this);
}

void* TPM2_PolicyAuthorize_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &approvedPolicySize;
            case 2: { if (newArraySize != -1) approvedPolicy.resize(newArraySize); arraySize = (int)approvedPolicy.size(); return &approvedPolicy; }
            case 3: return &policyRefSize;
            case 4: { if (newArraySize != -1) policyRef.resize(newArraySize); arraySize = (int)policyRef.size(); return &policyRef; }
            case 5: return &keySignSize;
            case 6: { if (newArraySize != -1) keySign.resize(newArraySize); arraySize = (int)keySign.size(); return &keySign; }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&checkTicket); return &checkTicket;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &approvedPolicy[arrayIndex];
            case 4: return &policyRef[arrayIndex];
            case 6: return &keySign[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyAuthorizeResponse::GetTypeId() const
{
    return TpmTypeId::PolicyAuthorizeResponse_ID;
}

/// <summary> This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy. </summary>
PolicyAuthorizeResponse::~PolicyAuthorizeResponse() {}

/// <summary> This command allows policies to change. If a policy were static, then it would be difficult to add users to a policy. This command lets a policy authority sign a new policy so that it may be used in an existing policy. </summary>
TpmStructureBase* PolicyAuthorizeResponse::Clone() const
{
    return new PolicyAuthorizeResponse(*this);
}

void* PolicyAuthorizeResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyAuthValue_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID;
}

TPM2_PolicyAuthValue_REQUEST::TPM2_PolicyAuthValue_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized entity. </summary>
TPM2_PolicyAuthValue_REQUEST::~TPM2_PolicyAuthValue_REQUEST() {}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized entity. </summary>
TpmStructureBase* TPM2_PolicyAuthValue_REQUEST::Clone() const
{
    return new TPM2_PolicyAuthValue_REQUEST(*this);
}

void* TPM2_PolicyAuthValue_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyAuthValueResponse::GetTypeId() const
{
    return TpmTypeId::PolicyAuthValueResponse_ID;
}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized entity. </summary>
PolicyAuthValueResponse::~PolicyAuthValueResponse() {}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized entity. </summary>
TpmStructureBase* PolicyAuthValueResponse::Clone() const
{
    return new PolicyAuthValueResponse(*this);
}

void* PolicyAuthValueResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyPassword_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyPassword_REQUEST_ID;
}

TPM2_PolicyPassword_REQUEST::TPM2_PolicyPassword_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized object. </summary>
TPM2_PolicyPassword_REQUEST::~TPM2_PolicyPassword_REQUEST() {}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized object. </summary>
TpmStructureBase* TPM2_PolicyPassword_REQUEST::Clone() const
{
    return new TPM2_PolicyPassword_REQUEST(*this);
}

void* TPM2_PolicyPassword_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyPasswordResponse::GetTypeId() const
{
    return TpmTypeId::PolicyPasswordResponse_ID;
}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized object. </summary>
PolicyPasswordResponse::~PolicyPasswordResponse() {}

/// <summary> This command allows a policy to be bound to the authorization value of the authorized object. </summary>
TpmStructureBase* PolicyPasswordResponse::Clone() const
{
    return new PolicyPasswordResponse(*this);
}

void* PolicyPasswordResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyGetDigest_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID;
}

TPM2_PolicyGetDigest_REQUEST::TPM2_PolicyGetDigest_REQUEST(const TPM_HANDLE& _policySession)
{
    policySession = _policySession;
}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
TPM2_PolicyGetDigest_REQUEST::~TPM2_PolicyGetDigest_REQUEST() {}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
TpmStructureBase* TPM2_PolicyGetDigest_REQUEST::Clone() const
{
    return new TPM2_PolicyGetDigest_REQUEST(*this);
}

void* TPM2_PolicyGetDigest_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyGetDigestResponse::GetTypeId() const
{
    return TpmTypeId::PolicyGetDigestResponse_ID;
}

PolicyGetDigestResponse::PolicyGetDigestResponse(
    const ByteVec& _policyDigest
)
{
    policyDigest = _policyDigest;
}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
PolicyGetDigestResponse::~PolicyGetDigestResponse() {}

/// <summary> This command returns the current policyDigest of the session. This command allows the TPM to be used to perform the actions required to pre-compute the authPolicy for an object. </summary>
TpmStructureBase* PolicyGetDigestResponse::Clone() const
{
    return new PolicyGetDigestResponse(*this);
}

void* PolicyGetDigestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &policyDigestSize;
            case 1: { if (newArraySize != -1) policyDigest.resize(newArraySize); arraySize = (int)policyDigest.size(); return &policyDigest; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &policyDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_PolicyNvWritten_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
}

TPM2_PolicyNvWritten_REQUEST::TPM2_PolicyNvWritten_REQUEST(
    const TPM_HANDLE& _policySession,
    BYTE _writtenSet
)
{
    policySession = _policySession;
    writtenSet = _writtenSet;
}

/// <summary> This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization. </summary>
TPM2_PolicyNvWritten_REQUEST::~TPM2_PolicyNvWritten_REQUEST() {}

/// <summary> This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization. </summary>
TpmStructureBase* TPM2_PolicyNvWritten_REQUEST::Clone() const
{
    return new TPM2_PolicyNvWritten_REQUEST(*this);
}

void* TPM2_PolicyNvWritten_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &writtenSet;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyNvWrittenResponse::GetTypeId() const
{
    return TpmTypeId::PolicyNvWrittenResponse_ID;
}

/// <summary> This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization. </summary>
PolicyNvWrittenResponse::~PolicyNvWrittenResponse() {}

/// <summary> This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a deferred assertion. Values are stored in the policy session context and checked when the policy is used for authorization. </summary>
TpmStructureBase* PolicyNvWrittenResponse::Clone() const
{
    return new PolicyNvWrittenResponse(*this);
}

void* PolicyNvWrittenResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyTemplate_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
}

TPM2_PolicyTemplate_REQUEST::TPM2_PolicyTemplate_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _templateHash
)
{
    policySession = _policySession;
    templateHash = _templateHash;
}

/// <summary> This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded(). </summary>
TPM2_PolicyTemplate_REQUEST::~TPM2_PolicyTemplate_REQUEST() {}

/// <summary> This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded(). </summary>
TpmStructureBase* TPM2_PolicyTemplate_REQUEST::Clone() const
{
    return new TPM2_PolicyTemplate_REQUEST(*this);
}

void* TPM2_PolicyTemplate_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &templateHashSize;
            case 2: { if (newArraySize != -1) templateHash.resize(newArraySize); arraySize = (int)templateHash.size(); return &templateHash; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &templateHash[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PolicyTemplateResponse::GetTypeId() const
{
    return TpmTypeId::PolicyTemplateResponse_ID;
}

/// <summary> This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded(). </summary>
PolicyTemplateResponse::~PolicyTemplateResponse() {}

/// <summary> This command allows a policy to be bound to a specific creation template. This is most useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or TPM2_CreateLoaded(). </summary>
TpmStructureBase* PolicyTemplateResponse::Clone() const
{
    return new PolicyTemplateResponse(*this);
}

void* PolicyTemplateResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PolicyAuthorizeNV_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
}

TPM2_PolicyAuthorizeNV_REQUEST::TPM2_PolicyAuthorizeNV_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _policySession
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    policySession = _policySession;
}

/// <summary> This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable. </summary>
TPM2_PolicyAuthorizeNV_REQUEST::~TPM2_PolicyAuthorizeNV_REQUEST() {}

/// <summary> This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable. </summary>
TpmStructureBase* TPM2_PolicyAuthorizeNV_REQUEST::Clone() const
{
    return new TPM2_PolicyAuthorizeNV_REQUEST(*this);
}

void* TPM2_PolicyAuthorizeNV_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PolicyAuthorizeNVResponse::GetTypeId() const
{
    return TpmTypeId::PolicyAuthorizeNVResponse_ID;
}

/// <summary> This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable. </summary>
PolicyAuthorizeNVResponse::~PolicyAuthorizeNVResponse() {}

/// <summary> This command provides a capability that is the equivalent of a revocable policy. With TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization may not be withdrawn. With this command, the approved policy is kept in an NV Index location so that the policy may be changed as needed to render the old policy unusable. </summary>
TpmStructureBase* PolicyAuthorizeNVResponse::Clone() const
{
    return new PolicyAuthorizeNVResponse(*this);
}

void* PolicyAuthorizeNVResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_CreatePrimary_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
}

TPM2_CreatePrimary_REQUEST::TPM2_CreatePrimary_REQUEST(
    const TPM_HANDLE& _primaryHandle,
    const TPMS_SENSITIVE_CREATE& _inSensitive,
    const TPMT_PUBLIC& _inPublic,
    const ByteVec& _outsideInfo,
    const vector<TPMS_PCR_SELECTION>& _creationPCR
)
{
    primaryHandle = _primaryHandle;
    inSensitive = _inSensitive;
    inPublic = _inPublic;
    outsideInfo = _outsideInfo;
    creationPCR = _creationPCR;
}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
TPM2_CreatePrimary_REQUEST::~TPM2_CreatePrimary_REQUEST() {}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
TpmStructureBase* TPM2_CreatePrimary_REQUEST::Clone() const
{
    return new TPM2_CreatePrimary_REQUEST(*this);
}

void* TPM2_CreatePrimary_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&primaryHandle); return &primaryHandle;
            case 1: return &inSensitiveSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&inSensitive); return &inSensitive;
            case 3: return &inPublicSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&inPublic); return &inPublic;
            case 5: return &outsideInfoSize;
            case 6: { if (newArraySize != -1) outsideInfo.resize(newArraySize); arraySize = (int)outsideInfo.size(); return &outsideInfo; }
            case 7: return &creationPCRCount;
            case 8: { if (newArraySize != -1) creationPCR.resize(newArraySize); arraySize = (int)creationPCR.size(); return &creationPCR; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &outsideInfo[arrayIndex];
            case 8: pStruct = dynamic_cast<TpmStructureBase*>(&creationPCR[arrayIndex]); return &creationPCR[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CreatePrimaryResponse::GetTypeId() const
{
    return TpmTypeId::CreatePrimaryResponse_ID;
}

CreatePrimaryResponse::CreatePrimaryResponse(
    const TPM_HANDLE& _handle,
    const TPMT_PUBLIC& _outPublic,
    const TPMS_CREATION_DATA& _creationData,
    const ByteVec& _creationHash,
    const TPMT_TK_CREATION& _creationTicket,
    const ByteVec& _name
)
{
    handle = _handle;
    outPublic = _outPublic;
    creationData = _creationData;
    creationHash = _creationHash;
    creationTicket = _creationTicket;
    name = _name;
}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
CreatePrimaryResponse::~CreatePrimaryResponse() {}

/// <summary> This command is used to create a Primary Object under one of the Primary Seeds or a Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for the object to be created. The size of the unique field shall not be checked for consistency with the other object parameters. The command will create and load a Primary Object. The sensitive area is not returned. </summary>
TpmStructureBase* CreatePrimaryResponse::Clone() const
{
    return new CreatePrimaryResponse(*this);
}

void* CreatePrimaryResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &outPublicSize;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&outPublic); return &outPublic;
            case 3: return &creationDataSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&creationData); return &creationData;
            case 5: return &creationHashSize;
            case 6: { if (newArraySize != -1) creationHash.resize(newArraySize); arraySize = (int)creationHash.size(); return &creationHash; }
            case 7: pStruct = dynamic_cast<TpmStructureBase*>(&creationTicket); return &creationTicket;
            case 8: return &nameSize;
            case 9: { if (newArraySize != -1) name.resize(newArraySize); arraySize = (int)name.size(); return &name; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 6: return &creationHash[arrayIndex];
            case 9: return &name[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_HierarchyControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
}

TPM2_HierarchyControl_REQUEST::TPM2_HierarchyControl_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _enable,
    BYTE _state
)
{
    authHandle = _authHandle;
    enable = _enable;
    state = _state;
}

/// <summary> This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided. </summary>
TPM2_HierarchyControl_REQUEST::~TPM2_HierarchyControl_REQUEST() {}

/// <summary> This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided. </summary>
TpmStructureBase* TPM2_HierarchyControl_REQUEST::Clone() const
{
    return new TPM2_HierarchyControl_REQUEST(*this);
}

void* TPM2_HierarchyControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&enable); return &enable;
            case 2: return &state;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId HierarchyControlResponse::GetTypeId() const
{
    return TpmTypeId::HierarchyControlResponse_ID;
}

/// <summary> This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided. </summary>
HierarchyControlResponse::~HierarchyControlResponse() {}

/// <summary> This command enables and disables use of a hierarchy and its associated NV storage. The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the proper authorization is provided. </summary>
TpmStructureBase* HierarchyControlResponse::Clone() const
{
    return new HierarchyControlResponse(*this);
}

void* HierarchyControlResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_SetPrimaryPolicy_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
}

TPM2_SetPrimaryPolicy_REQUEST::TPM2_SetPrimaryPolicy_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _authPolicy,
    TPM_ALG_ID _hashAlg
)
{
    authHandle = _authHandle;
    authPolicy = _authPolicy;
    hashAlg = _hashAlg;
}

/// <summary> This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown Timers (ACT), this command may also be used to set the authorization policy for an ACT. </summary>
TPM2_SetPrimaryPolicy_REQUEST::~TPM2_SetPrimaryPolicy_REQUEST() {}

/// <summary> This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown Timers (ACT), this command may also be used to set the authorization policy for an ACT. </summary>
TpmStructureBase* TPM2_SetPrimaryPolicy_REQUEST::Clone() const
{
    return new TPM2_SetPrimaryPolicy_REQUEST(*this);
}

void* TPM2_SetPrimaryPolicy_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &authPolicySize;
            case 2: { if (newArraySize != -1) authPolicy.resize(newArraySize); arraySize = (int)authPolicy.size(); return &authPolicy; }
            case 3: return &hashAlg;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &authPolicy[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SetPrimaryPolicyResponse::GetTypeId() const
{
    return TpmTypeId::SetPrimaryPolicyResponse_ID;
}

/// <summary> This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown Timers (ACT), this command may also be used to set the authorization policy for an ACT. </summary>
SetPrimaryPolicyResponse::~SetPrimaryPolicyResponse() {}

/// <summary> This command allows setting of the authorization policy for the lockout (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing Authenticated Countdown Timers (ACT), this command may also be used to set the authorization policy for an ACT. </summary>
TpmStructureBase* SetPrimaryPolicyResponse::Clone() const
{
    return new SetPrimaryPolicyResponse(*this);
}

void* SetPrimaryPolicyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_ChangePPS_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ChangePPS_REQUEST_ID;
}

TPM2_ChangePPS_REQUEST::TPM2_ChangePPS_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer). </summary>
TPM2_ChangePPS_REQUEST::~TPM2_ChangePPS_REQUEST() {}

/// <summary> This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer). </summary>
TpmStructureBase* TPM2_ChangePPS_REQUEST::Clone() const
{
    return new TPM2_ChangePPS_REQUEST(*this);
}

void* TPM2_ChangePPS_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ChangePPSResponse::GetTypeId() const
{
    return TpmTypeId::ChangePPSResponse_ID;
}

/// <summary> This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer). </summary>
ChangePPSResponse::~ChangePPSResponse() {}

/// <summary> This replaces the current platform primary seed (PPS) with a value from the RNG and sets platformPolicy to the default initialization value (the Empty Buffer). </summary>
TpmStructureBase* ChangePPSResponse::Clone() const
{
    return new ChangePPSResponse(*this);
}

void* ChangePPSResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_ChangeEPS_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ChangeEPS_REQUEST_ID;
}

TPM2_ChangeEPS_REQUEST::TPM2_ChangeEPS_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded. </summary>
TPM2_ChangeEPS_REQUEST::~TPM2_ChangeEPS_REQUEST() {}

/// <summary> This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded. </summary>
TpmStructureBase* TPM2_ChangeEPS_REQUEST::Clone() const
{
    return new TPM2_ChangeEPS_REQUEST(*this);
}

void* TPM2_ChangeEPS_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ChangeEPSResponse::GetTypeId() const
{
    return TpmTypeId::ChangeEPSResponse_ID;
}

/// <summary> This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded. </summary>
ChangeEPSResponse::~ChangeEPSResponse() {}

/// <summary> This replaces the current endorsement primary seed (EPS) with a value from the RNG and sets the Endorsement hierarchy controls to their default initialization values: ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty Buffer. It will flush any resident objects (transient or persistent) in the Endorsement hierarchy and not allow objects in the hierarchy associated with the previous EPS to be loaded. </summary>
TpmStructureBase* ChangeEPSResponse::Clone() const
{
    return new ChangeEPSResponse(*this);
}

void* ChangeEPSResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_Clear_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Clear_REQUEST_ID;
}

TPM2_Clear_REQUEST::TPM2_Clear_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> This command removes all TPM context associated with a specific Owner. </summary>
TPM2_Clear_REQUEST::~TPM2_Clear_REQUEST() {}

/// <summary> This command removes all TPM context associated with a specific Owner. </summary>
TpmStructureBase* TPM2_Clear_REQUEST::Clone() const
{
    return new TPM2_Clear_REQUEST(*this);
}

void* TPM2_Clear_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ClearResponse::GetTypeId() const
{
    return TpmTypeId::ClearResponse_ID;
}

/// <summary> This command removes all TPM context associated with a specific Owner. </summary>
ClearResponse::~ClearResponse() {}

/// <summary> This command removes all TPM context associated with a specific Owner. </summary>
TpmStructureBase* ClearResponse::Clone() const
{
    return new ClearResponse(*this);
}

void* ClearResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_ClearControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClearControl_REQUEST_ID;
}

TPM2_ClearControl_REQUEST::TPM2_ClearControl_REQUEST(
    const TPM_HANDLE& _auth,
    BYTE _disable
)
{
    auth = _auth;
    disable = _disable;
}

/// <summary> TPM2_ClearControl() disables and enables the execution of TPM2_Clear(). </summary>
TPM2_ClearControl_REQUEST::~TPM2_ClearControl_REQUEST() {}

/// <summary> TPM2_ClearControl() disables and enables the execution of TPM2_Clear(). </summary>
TpmStructureBase* TPM2_ClearControl_REQUEST::Clone() const
{
    return new TPM2_ClearControl_REQUEST(*this);
}

void* TPM2_ClearControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &disable;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ClearControlResponse::GetTypeId() const
{
    return TpmTypeId::ClearControlResponse_ID;
}

/// <summary> TPM2_ClearControl() disables and enables the execution of TPM2_Clear(). </summary>
ClearControlResponse::~ClearControlResponse() {}

/// <summary> TPM2_ClearControl() disables and enables the execution of TPM2_Clear(). </summary>
TpmStructureBase* ClearControlResponse::Clone() const
{
    return new ClearControlResponse(*this);
}

void* ClearControlResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_HierarchyChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
}

TPM2_HierarchyChangeAuth_REQUEST::TPM2_HierarchyChangeAuth_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _newAuth
)
{
    authHandle = _authHandle;
    newAuth = _newAuth;
}

/// <summary> This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization. </summary>
TPM2_HierarchyChangeAuth_REQUEST::~TPM2_HierarchyChangeAuth_REQUEST() {}

/// <summary> This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization. </summary>
TpmStructureBase* TPM2_HierarchyChangeAuth_REQUEST::Clone() const
{
    return new TPM2_HierarchyChangeAuth_REQUEST(*this);
}

void* TPM2_HierarchyChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &newAuthSize;
            case 2: { if (newArraySize != -1) newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return &newAuth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &newAuth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId HierarchyChangeAuthResponse::GetTypeId() const
{
    return TpmTypeId::HierarchyChangeAuthResponse_ID;
}

/// <summary> This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization. </summary>
HierarchyChangeAuthResponse::~HierarchyChangeAuthResponse() {}

/// <summary> This command allows the authorization secret for a hierarchy or lockout to be changed using the current authorization value as the command authorization. </summary>
TpmStructureBase* HierarchyChangeAuthResponse::Clone() const
{
    return new HierarchyChangeAuthResponse(*this);
}

void* HierarchyChangeAuthResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_DictionaryAttackLockReset_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID;
}

TPM2_DictionaryAttackLockReset_REQUEST::TPM2_DictionaryAttackLockReset_REQUEST(const TPM_HANDLE& _lockHandle)
{
    lockHandle = _lockHandle;
}

/// <summary> This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero. </summary>
TPM2_DictionaryAttackLockReset_REQUEST::~TPM2_DictionaryAttackLockReset_REQUEST() {}

/// <summary> This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero. </summary>
TpmStructureBase* TPM2_DictionaryAttackLockReset_REQUEST::Clone() const
{
    return new TPM2_DictionaryAttackLockReset_REQUEST(*this);
}

void* TPM2_DictionaryAttackLockReset_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&lockHandle); return &lockHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId DictionaryAttackLockResetResponse::GetTypeId() const
{
    return TpmTypeId::DictionaryAttackLockResetResponse_ID;
}

/// <summary> This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero. </summary>
DictionaryAttackLockResetResponse::~DictionaryAttackLockResetResponse() {}

/// <summary> This command cancels the effect of a TPM lockout due to a number of successive authorization failures. If this command is properly authorized, the lockout counter is set to zero. </summary>
TpmStructureBase* DictionaryAttackLockResetResponse::Clone() const
{
    return new DictionaryAttackLockResetResponse(*this);
}

void* DictionaryAttackLockResetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_DictionaryAttackParameters_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
}

TPM2_DictionaryAttackParameters_REQUEST::TPM2_DictionaryAttackParameters_REQUEST(
    const TPM_HANDLE& _lockHandle,
    UINT32 _newMaxTries,
    UINT32 _newRecoveryTime,
    UINT32 _lockoutRecovery
)
{
    lockHandle = _lockHandle;
    newMaxTries = _newMaxTries;
    newRecoveryTime = _newRecoveryTime;
    lockoutRecovery = _lockoutRecovery;
}

/// <summary> This command changes the lockout parameters. </summary>
TPM2_DictionaryAttackParameters_REQUEST::~TPM2_DictionaryAttackParameters_REQUEST() {}

/// <summary> This command changes the lockout parameters. </summary>
TpmStructureBase* TPM2_DictionaryAttackParameters_REQUEST::Clone() const
{
    return new TPM2_DictionaryAttackParameters_REQUEST(*this);
}

void* TPM2_DictionaryAttackParameters_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&lockHandle); return &lockHandle;
            case 1: return &newMaxTries;
            case 2: return &newRecoveryTime;
            case 3: return &lockoutRecovery;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId DictionaryAttackParametersResponse::GetTypeId() const
{
    return TpmTypeId::DictionaryAttackParametersResponse_ID;
}

/// <summary> This command changes the lockout parameters. </summary>
DictionaryAttackParametersResponse::~DictionaryAttackParametersResponse() {}

/// <summary> This command changes the lockout parameters. </summary>
TpmStructureBase* DictionaryAttackParametersResponse::Clone() const
{
    return new DictionaryAttackParametersResponse(*this);
}

void* DictionaryAttackParametersResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_PP_Commands_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
}

TPM2_PP_Commands_REQUEST::TPM2_PP_Commands_REQUEST(
    const TPM_HANDLE& _auth,
    const vector<TPM_CC>& _setList,
    const vector<TPM_CC>& _clearList
)
{
    auth = _auth;
    setList = _setList;
    clearList = _clearList;
}

/// <summary> This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy. </summary>
TPM2_PP_Commands_REQUEST::~TPM2_PP_Commands_REQUEST() {}

/// <summary> This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy. </summary>
TpmStructureBase* TPM2_PP_Commands_REQUEST::Clone() const
{
    return new TPM2_PP_Commands_REQUEST(*this);
}

void* TPM2_PP_Commands_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &setListCount;
            case 2: { if (newArraySize != -1) setList.resize(newArraySize); arraySize = (int)setList.size(); return &setList; }
            case 3: return &clearListCount;
            case 4: { if (newArraySize != -1) clearList.resize(newArraySize); arraySize = (int)clearList.size(); return &clearList; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &setList[arrayIndex];
            case 4: return &clearList[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId PP_CommandsResponse::GetTypeId() const
{
    return TpmTypeId::PP_CommandsResponse_ID;
}

/// <summary> This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy. </summary>
PP_CommandsResponse::~PP_CommandsResponse() {}

/// <summary> This command is used to determine which commands require assertion of Physical Presence (PP) in addition to platformAuth/platformPolicy. </summary>
TpmStructureBase* PP_CommandsResponse::Clone() const
{
    return new PP_CommandsResponse(*this);
}

void* PP_CommandsResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_SetAlgorithmSet_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
}

TPM2_SetAlgorithmSet_REQUEST::TPM2_SetAlgorithmSet_REQUEST(
    const TPM_HANDLE& _authHandle,
    UINT32 _algorithmSet
)
{
    authHandle = _authHandle;
    algorithmSet = _algorithmSet;
}

/// <summary> This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value. </summary>
TPM2_SetAlgorithmSet_REQUEST::~TPM2_SetAlgorithmSet_REQUEST() {}

/// <summary> This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value. </summary>
TpmStructureBase* TPM2_SetAlgorithmSet_REQUEST::Clone() const
{
    return new TPM2_SetAlgorithmSet_REQUEST(*this);
}

void* TPM2_SetAlgorithmSet_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &algorithmSet;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId SetAlgorithmSetResponse::GetTypeId() const
{
    return TpmTypeId::SetAlgorithmSetResponse_ID;
}

/// <summary> This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value. </summary>
SetAlgorithmSetResponse::~SetAlgorithmSetResponse() {}

/// <summary> This command allows the platform to change the set of algorithms that are used by the TPM. The algorithmSet setting is a vendor-dependent value. </summary>
TpmStructureBase* SetAlgorithmSetResponse::Clone() const
{
    return new SetAlgorithmSetResponse(*this);
}

void* SetAlgorithmSetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_FieldUpgradeStart_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
}

TPM2_FieldUpgradeStart_REQUEST::TPM2_FieldUpgradeStart_REQUEST(
    const TPM_HANDLE& _authorization,
    const TPM_HANDLE& _keyHandle,
    const ByteVec& _fuDigest,
    const TPMU_SIGNATURE& _manifestSignature
)
{
    authorization = _authorization;
    keyHandle = _keyHandle;
    fuDigest = _fuDigest;
    manifestSignature.reset(dynamic_cast<TPMU_SIGNATURE*>(_manifestSignature.Clone()));
}

/// <summary> This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest. </summary>
TPM2_FieldUpgradeStart_REQUEST::~TPM2_FieldUpgradeStart_REQUEST() {}

/// <summary> This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest. </summary>
TpmStructureBase* TPM2_FieldUpgradeStart_REQUEST::Clone() const
{
    return new TPM2_FieldUpgradeStart_REQUEST(*this);
}

void* TPM2_FieldUpgradeStart_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authorization); return &authorization;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&keyHandle); return &keyHandle;
            case 2: return &fuDigestSize;
            case 3: { if (newArraySize != -1) fuDigest.resize(newArraySize); arraySize = (int)fuDigest.size(); return &fuDigest; }
            case 4: return &manifestSignatureSigAlg;
            case 5: pStruct = dynamic_cast<TpmStructureBase*>(&*manifestSignature); return &manifestSignature;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &fuDigest[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId FieldUpgradeStartResponse::GetTypeId() const
{
    return TpmTypeId::FieldUpgradeStartResponse_ID;
}

/// <summary> This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest. </summary>
FieldUpgradeStartResponse::~FieldUpgradeStartResponse() {}

/// <summary> This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a Field Upgrade Manifest. </summary>
TpmStructureBase* FieldUpgradeStartResponse::Clone() const
{
    return new FieldUpgradeStartResponse(*this);
}

void* FieldUpgradeStartResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_FieldUpgradeData_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
}

TPM2_FieldUpgradeData_REQUEST::TPM2_FieldUpgradeData_REQUEST(
    const ByteVec& _fuData
)
{
    fuData = _fuData;
}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
TPM2_FieldUpgradeData_REQUEST::~TPM2_FieldUpgradeData_REQUEST() {}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
TpmStructureBase* TPM2_FieldUpgradeData_REQUEST::Clone() const
{
    return new TPM2_FieldUpgradeData_REQUEST(*this);
}

void* TPM2_FieldUpgradeData_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &fuDataSize;
            case 1: { if (newArraySize != -1) fuData.resize(newArraySize); arraySize = (int)fuData.size(); return &fuData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &fuData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId FieldUpgradeDataResponse::GetTypeId() const
{
    return TpmTypeId::FieldUpgradeDataResponse_ID;
}

FieldUpgradeDataResponse::FieldUpgradeDataResponse(
    const TPMT_HA& _nextDigest,
    const TPMT_HA& _firstDigest
)
{
    nextDigest = _nextDigest;
    firstDigest = _firstDigest;
}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
FieldUpgradeDataResponse::~FieldUpgradeDataResponse() {}

/// <summary> This command will take the actual field upgrade image to be installed on the TPM. The exact format of fuData is vendor-specific. This command is only possible following a successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE. </summary>
TpmStructureBase* FieldUpgradeDataResponse::Clone() const
{
    return new FieldUpgradeDataResponse(*this);
}

void* FieldUpgradeDataResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nextDigest); return &nextDigest;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&firstDigest); return &firstDigest;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_FirmwareRead_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FirmwareRead_REQUEST_ID;
}

TPM2_FirmwareRead_REQUEST::TPM2_FirmwareRead_REQUEST(UINT32 _sequenceNumber)
{
    sequenceNumber = _sequenceNumber;
}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
TPM2_FirmwareRead_REQUEST::~TPM2_FirmwareRead_REQUEST() {}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
TpmStructureBase* TPM2_FirmwareRead_REQUEST::Clone() const
{
    return new TPM2_FirmwareRead_REQUEST(*this);
}

void* TPM2_FirmwareRead_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &sequenceNumber;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId FirmwareReadResponse::GetTypeId() const
{
    return TpmTypeId::FirmwareReadResponse_ID;
}

FirmwareReadResponse::FirmwareReadResponse(
    const ByteVec& _fuData
)
{
    fuData = _fuData;
}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
FirmwareReadResponse::~FirmwareReadResponse() {}

/// <summary> This command is used to read a copy of the current firmware installed in the TPM. </summary>
TpmStructureBase* FirmwareReadResponse::Clone() const
{
    return new FirmwareReadResponse(*this);
}

void* FirmwareReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &fuDataSize;
            case 1: { if (newArraySize != -1) fuData.resize(newArraySize); arraySize = (int)fuData.size(); return &fuData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &fuData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_ContextSave_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ContextSave_REQUEST_ID;
}

TPM2_ContextSave_REQUEST::TPM2_ContextSave_REQUEST(const TPM_HANDLE& _saveHandle)
{
    saveHandle = _saveHandle;
}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
TPM2_ContextSave_REQUEST::~TPM2_ContextSave_REQUEST() {}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
TpmStructureBase* TPM2_ContextSave_REQUEST::Clone() const
{
    return new TPM2_ContextSave_REQUEST(*this);
}

void* TPM2_ContextSave_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&saveHandle); return &saveHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ContextSaveResponse::GetTypeId() const
{
    return TpmTypeId::ContextSaveResponse_ID;
}

ContextSaveResponse::ContextSaveResponse(const TPMS_CONTEXT& _context)
{
    context = _context;
}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
ContextSaveResponse::~ContextSaveResponse() {}

/// <summary> This command saves a session context, object context, or sequence object context outside the TPM. </summary>
TpmStructureBase* ContextSaveResponse::Clone() const
{
    return new ContextSaveResponse(*this);
}

void* ContextSaveResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&context); return &context;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ContextLoad_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ContextLoad_REQUEST_ID;
}

TPM2_ContextLoad_REQUEST::TPM2_ContextLoad_REQUEST(const TPMS_CONTEXT& _context)
{
    context = _context;
}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
TPM2_ContextLoad_REQUEST::~TPM2_ContextLoad_REQUEST() {}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
TpmStructureBase* TPM2_ContextLoad_REQUEST::Clone() const
{
    return new TPM2_ContextLoad_REQUEST(*this);
}

void* TPM2_ContextLoad_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&context); return &context;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ContextLoadResponse::GetTypeId() const
{
    return TpmTypeId::ContextLoadResponse_ID;
}

ContextLoadResponse::ContextLoadResponse(const TPM_HANDLE& _handle)
{
    handle = _handle;
}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
ContextLoadResponse::~ContextLoadResponse() {}

/// <summary> This command is used to reload a context that has been saved by TPM2_ContextSave(). </summary>
TpmStructureBase* ContextLoadResponse::Clone() const
{
    return new ContextLoadResponse(*this);
}

void* ContextLoadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_FlushContext_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_FlushContext_REQUEST_ID;
}

TPM2_FlushContext_REQUEST::TPM2_FlushContext_REQUEST(const TPM_HANDLE& _flushHandle)
{
    flushHandle = _flushHandle;
}

/// <summary> This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory. </summary>
TPM2_FlushContext_REQUEST::~TPM2_FlushContext_REQUEST() {}

/// <summary> This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory. </summary>
TpmStructureBase* TPM2_FlushContext_REQUEST::Clone() const
{
    return new TPM2_FlushContext_REQUEST(*this);
}

void* TPM2_FlushContext_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&flushHandle); return &flushHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId FlushContextResponse::GetTypeId() const
{
    return TpmTypeId::FlushContextResponse_ID;
}

/// <summary> This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory. </summary>
FlushContextResponse::~FlushContextResponse() {}

/// <summary> This command causes all context associated with a loaded object, sequence object, or session to be removed from TPM memory. </summary>
TpmStructureBase* FlushContextResponse::Clone() const
{
    return new FlushContextResponse(*this);
}

void* FlushContextResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_EvictControl_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_EvictControl_REQUEST_ID;
}

TPM2_EvictControl_REQUEST::TPM2_EvictControl_REQUEST(
    const TPM_HANDLE& _auth,
    const TPM_HANDLE& _objectHandle,
    const TPM_HANDLE& _persistentHandle
)
{
    auth = _auth;
    objectHandle = _objectHandle;
    persistentHandle = _persistentHandle;
}

/// <summary> This command allows certain Transient Objects to be made persistent or a persistent object to be evicted. </summary>
TPM2_EvictControl_REQUEST::~TPM2_EvictControl_REQUEST() {}

/// <summary> This command allows certain Transient Objects to be made persistent or a persistent object to be evicted. </summary>
TpmStructureBase* TPM2_EvictControl_REQUEST::Clone() const
{
    return new TPM2_EvictControl_REQUEST(*this);
}

void* TPM2_EvictControl_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&objectHandle); return &objectHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&persistentHandle); return &persistentHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId EvictControlResponse::GetTypeId() const
{
    return TpmTypeId::EvictControlResponse_ID;
}

/// <summary> This command allows certain Transient Objects to be made persistent or a persistent object to be evicted. </summary>
EvictControlResponse::~EvictControlResponse() {}

/// <summary> This command allows certain Transient Objects to be made persistent or a persistent object to be evicted. </summary>
TpmStructureBase* EvictControlResponse::Clone() const
{
    return new EvictControlResponse(*this);
}

void* EvictControlResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_ReadClock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ReadClock_REQUEST_ID;
}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
TPM2_ReadClock_REQUEST::~TPM2_ReadClock_REQUEST() {}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
TpmStructureBase* TPM2_ReadClock_REQUEST::Clone() const
{
    return new TPM2_ReadClock_REQUEST(*this);
}

void* TPM2_ReadClock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId ReadClockResponse::GetTypeId() const
{
    return TpmTypeId::ReadClockResponse_ID;
}

ReadClockResponse::ReadClockResponse(const TPMS_TIME_INFO& _currentTime)
{
    currentTime = _currentTime;
}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
ReadClockResponse::~ReadClockResponse() {}

/// <summary> This command reads the current TPMS_TIME_INFO structure that contains the current setting of Time, Clock, resetCount, and restartCount. </summary>
TpmStructureBase* ReadClockResponse::Clone() const
{
    return new ReadClockResponse(*this);
}

void* ReadClockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&currentTime); return &currentTime;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_ClockSet_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClockSet_REQUEST_ID;
}

TPM2_ClockSet_REQUEST::TPM2_ClockSet_REQUEST(
    const TPM_HANDLE& _auth,
    UINT64 _newTime
)
{
    auth = _auth;
    newTime = _newTime;
}

/// <summary> This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock. </summary>
TPM2_ClockSet_REQUEST::~TPM2_ClockSet_REQUEST() {}

/// <summary> This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock. </summary>
TpmStructureBase* TPM2_ClockSet_REQUEST::Clone() const
{
    return new TPM2_ClockSet_REQUEST(*this);
}

void* TPM2_ClockSet_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &newTime;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ClockSetResponse::GetTypeId() const
{
    return TpmTypeId::ClockSetResponse_ID;
}

/// <summary> This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock. </summary>
ClockSetResponse::~ClockSetResponse() {}

/// <summary> This command is used to advance the value of the TPMs Clock. The command will fail if newTime is less than the current value of Clock or if the new time is greater than FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock. </summary>
TpmStructureBase* ClockSetResponse::Clone() const
{
    return new ClockSetResponse(*this);
}

void* ClockSetResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_ClockRateAdjust_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
}

TPM2_ClockRateAdjust_REQUEST::TPM2_ClockRateAdjust_REQUEST(
    const TPM_HANDLE& _auth,
    TPM_CLOCK_ADJUST _rateAdjust
)
{
    auth = _auth;
    rateAdjust = _rateAdjust;
}

/// <summary> This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time. </summary>
TPM2_ClockRateAdjust_REQUEST::~TPM2_ClockRateAdjust_REQUEST() {}

/// <summary> This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time. </summary>
TpmStructureBase* TPM2_ClockRateAdjust_REQUEST::Clone() const
{
    return new TPM2_ClockRateAdjust_REQUEST(*this);
}

void* TPM2_ClockRateAdjust_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&auth); return &auth;
            case 1: return &rateAdjust;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ClockRateAdjustResponse::GetTypeId() const
{
    return TpmTypeId::ClockRateAdjustResponse_ID;
}

/// <summary> This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time. </summary>
ClockRateAdjustResponse::~ClockRateAdjustResponse() {}

/// <summary> This command adjusts the rate of advance of Clock and Time to provide a better approximation to real time. </summary>
TpmStructureBase* ClockRateAdjustResponse::Clone() const
{
    return new ClockRateAdjustResponse(*this);
}

void* ClockRateAdjustResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_GetCapability_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_GetCapability_REQUEST_ID;
}

TPM2_GetCapability_REQUEST::TPM2_GetCapability_REQUEST(
    TPM_CAP _capability,
    UINT32 _property,
    UINT32 _propertyCount
)
{
    capability = _capability;
    property = _property;
    propertyCount = _propertyCount;
}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
TPM2_GetCapability_REQUEST::~TPM2_GetCapability_REQUEST() {}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
TpmStructureBase* TPM2_GetCapability_REQUEST::Clone() const
{
    return new TPM2_GetCapability_REQUEST(*this);
}

void* TPM2_GetCapability_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &capability;
            case 1: return &property;
            case 2: return &propertyCount;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId GetCapabilityResponse::GetTypeId() const
{
    return TpmTypeId::GetCapabilityResponse_ID;
}

GetCapabilityResponse::GetCapabilityResponse(
    BYTE _moreData,
    const TPMU_CAPABILITIES& _capabilityData
)
{
    moreData = _moreData;
    capabilityData.reset(dynamic_cast<TPMU_CAPABILITIES*>(_capabilityData.Clone()));
}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
GetCapabilityResponse::~GetCapabilityResponse() {}

/// <summary> This command returns various information regarding the TPM and its current state. </summary>
TpmStructureBase* GetCapabilityResponse::Clone() const
{
    return new GetCapabilityResponse(*this);
}

void* GetCapabilityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &moreData;
            case 1: return &capabilityDataCapability;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&*capabilityData); return &capabilityData;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_TestParms_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_TestParms_REQUEST_ID;
}

TPM2_TestParms_REQUEST::TPM2_TestParms_REQUEST(
    const TPMU_PUBLIC_PARMS& _parameters
)
{
    parameters.reset(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()));
}

/// <summary> This command is used to check to see if specific combinations of algorithm parameters are supported. </summary>
TPM2_TestParms_REQUEST::~TPM2_TestParms_REQUEST() {}

/// <summary> This command is used to check to see if specific combinations of algorithm parameters are supported. </summary>
TpmStructureBase* TPM2_TestParms_REQUEST::Clone() const
{
    return new TPM2_TestParms_REQUEST(*this);
}

void* TPM2_TestParms_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &parametersType;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&*parameters); return &parameters;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TestParmsResponse::GetTypeId() const
{
    return TpmTypeId::TestParmsResponse_ID;
}

/// <summary> This command is used to check to see if specific combinations of algorithm parameters are supported. </summary>
TestParmsResponse::~TestParmsResponse() {}

/// <summary> This command is used to check to see if specific combinations of algorithm parameters are supported. </summary>
TpmStructureBase* TestParmsResponse::Clone() const
{
    return new TestParmsResponse(*this);
}

void* TestParmsResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_DefineSpace_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
}

TPM2_NV_DefineSpace_REQUEST::TPM2_NV_DefineSpace_REQUEST(
    const TPM_HANDLE& _authHandle,
    const ByteVec& _auth,
    const TPMS_NV_PUBLIC& _publicInfo
)
{
    authHandle = _authHandle;
    auth = _auth;
    publicInfo = _publicInfo;
}

/// <summary> This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED. </summary>
TPM2_NV_DefineSpace_REQUEST::~TPM2_NV_DefineSpace_REQUEST() {}

/// <summary> This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED. </summary>
TpmStructureBase* TPM2_NV_DefineSpace_REQUEST::Clone() const
{
    return new TPM2_NV_DefineSpace_REQUEST(*this);
}

void* TPM2_NV_DefineSpace_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: return &authSize;
            case 2: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            case 3: return &publicInfoSize;
            case 4: pStruct = dynamic_cast<TpmStructureBase*>(&publicInfo); return &publicInfo;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId NV_DefineSpaceResponse::GetTypeId() const
{
    return TpmTypeId::NV_DefineSpaceResponse_ID;
}

/// <summary> This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED. </summary>
NV_DefineSpaceResponse::~NV_DefineSpaceResponse() {}

/// <summary> This command defines the attributes of an NV Index and causes the TPM to reserve space to hold the data associated with the NV Index. If a definition already exists at the NV Index, the TPM will return TPM_RC_NV_DEFINED. </summary>
TpmStructureBase* NV_DefineSpaceResponse::Clone() const
{
    return new NV_DefineSpaceResponse(*this);
}

void* NV_DefineSpaceResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_UndefineSpace_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
}

TPM2_NV_UndefineSpace_REQUEST::TPM2_NV_UndefineSpace_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> This command removes an Index from the TPM. </summary>
TPM2_NV_UndefineSpace_REQUEST::~TPM2_NV_UndefineSpace_REQUEST() {}

/// <summary> This command removes an Index from the TPM. </summary>
TpmStructureBase* TPM2_NV_UndefineSpace_REQUEST::Clone() const
{
    return new TPM2_NV_UndefineSpace_REQUEST(*this);
}

void* TPM2_NV_UndefineSpace_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_UndefineSpaceResponse::GetTypeId() const
{
    return TpmTypeId::NV_UndefineSpaceResponse_ID;
}

/// <summary> This command removes an Index from the TPM. </summary>
NV_UndefineSpaceResponse::~NV_UndefineSpaceResponse() {}

/// <summary> This command removes an Index from the TPM. </summary>
TpmStructureBase* NV_UndefineSpaceResponse::Clone() const
{
    return new NV_UndefineSpaceResponse(*this);
}

void* NV_UndefineSpaceResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_UndefineSpaceSpecial_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
}

TPM2_NV_UndefineSpaceSpecial_REQUEST::TPM2_NV_UndefineSpaceSpecial_REQUEST(
    const TPM_HANDLE& _nvIndex,
    const TPM_HANDLE& _platform
)
{
    nvIndex = _nvIndex;
    platform = _platform;
}

/// <summary> This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET. </summary>
TPM2_NV_UndefineSpaceSpecial_REQUEST::~TPM2_NV_UndefineSpaceSpecial_REQUEST() {}

/// <summary> This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET. </summary>
TpmStructureBase* TPM2_NV_UndefineSpaceSpecial_REQUEST::Clone() const
{
    return new TPM2_NV_UndefineSpaceSpecial_REQUEST(*this);
}

void* TPM2_NV_UndefineSpaceSpecial_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&platform); return &platform;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_UndefineSpaceSpecialResponse::GetTypeId() const
{
    return TpmTypeId::NV_UndefineSpaceSpecialResponse_ID;
}

/// <summary> This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET. </summary>
NV_UndefineSpaceSpecialResponse::~NV_UndefineSpaceSpecialResponse() {}

/// <summary> This command allows removal of a platform-created NV Index that has TPMA_NV_POLICY_DELETE SET. </summary>
TpmStructureBase* NV_UndefineSpaceSpecialResponse::Clone() const
{
    return new NV_UndefineSpaceSpecialResponse(*this);
}

void* NV_UndefineSpaceSpecialResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_ReadPublic_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID;
}

TPM2_NV_ReadPublic_REQUEST::TPM2_NV_ReadPublic_REQUEST(const TPM_HANDLE& _nvIndex)
{
    nvIndex = _nvIndex;
}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
TPM2_NV_ReadPublic_REQUEST::~TPM2_NV_ReadPublic_REQUEST() {}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
TpmStructureBase* TPM2_NV_ReadPublic_REQUEST::Clone() const
{
    return new TPM2_NV_ReadPublic_REQUEST(*this);
}

void* TPM2_NV_ReadPublic_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_ReadPublicResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadPublicResponse_ID;
}

NV_ReadPublicResponse::NV_ReadPublicResponse(
    const TPMS_NV_PUBLIC& _nvPublic,
    const ByteVec& _nvName
)
{
    nvPublic = _nvPublic;
    nvName = _nvName;
}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
NV_ReadPublicResponse::~NV_ReadPublicResponse() {}

/// <summary> This command is used to read the public area and Name of an NV Index. The public area of an Index is not privacy-sensitive and no authorization is required to read this data. </summary>
TpmStructureBase* NV_ReadPublicResponse::Clone() const
{
    return new NV_ReadPublicResponse(*this);
}

void* NV_ReadPublicResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nvPublicSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvPublic); return &nvPublic;
            case 2: return &nvNameSize;
            case 3: { if (newArraySize != -1) nvName.resize(newArraySize); arraySize = (int)nvName.size(); return &nvName; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &nvName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_Write_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Write_REQUEST_ID;
}

TPM2_NV_Write_REQUEST::TPM2_NV_Write_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _data,
    UINT16 _offset
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    data = _data;
    offset = _offset;
}

/// <summary> This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace(). </summary>
TPM2_NV_Write_REQUEST::~TPM2_NV_Write_REQUEST() {}

/// <summary> This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace(). </summary>
TpmStructureBase* TPM2_NV_Write_REQUEST::Clone() const
{
    return new TPM2_NV_Write_REQUEST(*this);
}

void* TPM2_NV_Write_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &dataSize;
            case 3: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            case 4: return &offset;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId NV_WriteResponse::GetTypeId() const
{
    return TpmTypeId::NV_WriteResponse_ID;
}

/// <summary> This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace(). </summary>
NV_WriteResponse::~NV_WriteResponse() {}

/// <summary> This command writes a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace(). </summary>
TpmStructureBase* NV_WriteResponse::Clone() const
{
    return new NV_WriteResponse(*this);
}

void* NV_WriteResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_Increment_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
}

TPM2_NV_Increment_REQUEST::TPM2_NV_Increment_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one. </summary>
TPM2_NV_Increment_REQUEST::~TPM2_NV_Increment_REQUEST() {}

/// <summary> This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one. </summary>
TpmStructureBase* TPM2_NV_Increment_REQUEST::Clone() const
{
    return new TPM2_NV_Increment_REQUEST(*this);
}

void* TPM2_NV_Increment_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_IncrementResponse::GetTypeId() const
{
    return TpmTypeId::NV_IncrementResponse_ID;
}

/// <summary> This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one. </summary>
NV_IncrementResponse::~NV_IncrementResponse() {}

/// <summary> This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER attribute. The data value of the NV Index is incremented by one. </summary>
TpmStructureBase* NV_IncrementResponse::Clone() const
{
    return new NV_IncrementResponse(*this);
}

void* NV_IncrementResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_Extend_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
}

TPM2_NV_Extend_REQUEST::TPM2_NV_Extend_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _data
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    data = _data;
}

/// <summary> This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace. </summary>
TPM2_NV_Extend_REQUEST::~TPM2_NV_Extend_REQUEST() {}

/// <summary> This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace. </summary>
TpmStructureBase* TPM2_NV_Extend_REQUEST::Clone() const
{
    return new TPM2_NV_Extend_REQUEST(*this);
}

void* TPM2_NV_Extend_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &dataSize;
            case 3: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 3: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId NV_ExtendResponse::GetTypeId() const
{
    return TpmTypeId::NV_ExtendResponse_ID;
}

/// <summary> This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace. </summary>
NV_ExtendResponse::~NV_ExtendResponse() {}

/// <summary> This command extends a value to an area in NV memory that was previously defined by TPM2_NV_DefineSpace. </summary>
TpmStructureBase* NV_ExtendResponse::Clone() const
{
    return new NV_ExtendResponse(*this);
}

void* NV_ExtendResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_SetBits_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
}

TPM2_NV_SetBits_REQUEST::TPM2_NV_SetBits_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    UINT64 _bits
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    bits = _bits;
}

/// <summary> This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index. </summary>
TPM2_NV_SetBits_REQUEST::~TPM2_NV_SetBits_REQUEST() {}

/// <summary> This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index. </summary>
TpmStructureBase* TPM2_NV_SetBits_REQUEST::Clone() const
{
    return new TPM2_NV_SetBits_REQUEST(*this);
}

void* TPM2_NV_SetBits_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &bits;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_SetBitsResponse::GetTypeId() const
{
    return TpmTypeId::NV_SetBitsResponse_ID;
}

/// <summary> This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index. </summary>
NV_SetBitsResponse::~NV_SetBitsResponse() {}

/// <summary> This command is used to SET bits in an NV Index that was created as a bit field. Any number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current contents of the NV Index. </summary>
TpmStructureBase* NV_SetBitsResponse::Clone() const
{
    return new NV_SetBitsResponse(*this);
}

void* NV_SetBitsResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_WriteLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
}

TPM2_NV_WriteLock_REQUEST::TPM2_NV_WriteLock_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index. </summary>
TPM2_NV_WriteLock_REQUEST::~TPM2_NV_WriteLock_REQUEST() {}

/// <summary> If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index. </summary>
TpmStructureBase* TPM2_NV_WriteLock_REQUEST::Clone() const
{
    return new TPM2_NV_WriteLock_REQUEST(*this);
}

void* TPM2_NV_WriteLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_WriteLockResponse::GetTypeId() const
{
    return TpmTypeId::NV_WriteLockResponse_ID;
}

/// <summary> If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index. </summary>
NV_WriteLockResponse::~NV_WriteLockResponse() {}

/// <summary> If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are SET, then this command may be used to inhibit further writes of the NV Index. </summary>
TpmStructureBase* NV_WriteLockResponse::Clone() const
{
    return new NV_WriteLockResponse(*this);
}

void* NV_WriteLockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_GlobalWriteLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID;
}

TPM2_NV_GlobalWriteLock_REQUEST::TPM2_NV_GlobalWriteLock_REQUEST(const TPM_HANDLE& _authHandle)
{
    authHandle = _authHandle;
}

/// <summary> The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET. </summary>
TPM2_NV_GlobalWriteLock_REQUEST::~TPM2_NV_GlobalWriteLock_REQUEST() {}

/// <summary> The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET. </summary>
TpmStructureBase* TPM2_NV_GlobalWriteLock_REQUEST::Clone() const
{
    return new TPM2_NV_GlobalWriteLock_REQUEST(*this);
}

void* TPM2_NV_GlobalWriteLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_GlobalWriteLockResponse::GetTypeId() const
{
    return TpmTypeId::NV_GlobalWriteLockResponse_ID;
}

/// <summary> The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET. </summary>
NV_GlobalWriteLockResponse::~NV_GlobalWriteLockResponse() {}

/// <summary> The command will SET TPMA_NV_WRITELOCKED for all indexes that have their TPMA_NV_GLOBALLOCK attribute SET. </summary>
TpmStructureBase* NV_GlobalWriteLockResponse::Clone() const
{
    return new NV_GlobalWriteLockResponse(*this);
}

void* NV_GlobalWriteLockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_Read_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Read_REQUEST_ID;
}

TPM2_NV_Read_REQUEST::TPM2_NV_Read_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    UINT16 _size,
    UINT16 _offset
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    size = _size;
    offset = _offset;
}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
TPM2_NV_Read_REQUEST::~TPM2_NV_Read_REQUEST() {}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
TpmStructureBase* TPM2_NV_Read_REQUEST::Clone() const
{
    return new TPM2_NV_Read_REQUEST(*this);
}

void* TPM2_NV_Read_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 2: return &size;
            case 3: return &offset;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_ReadResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadResponse_ID;
}

NV_ReadResponse::NV_ReadResponse(
    const ByteVec& _data
)
{
    data = _data;
}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
NV_ReadResponse::~NV_ReadResponse() {}

/// <summary> This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace(). </summary>
TpmStructureBase* NV_ReadResponse::Clone() const
{
    return new NV_ReadResponse(*this);
}

void* NV_ReadResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &dataSize;
            case 1: { if (newArraySize != -1) data.resize(newArraySize); arraySize = (int)data.size(); return &data; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &data[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_NV_ReadLock_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
}

TPM2_NV_ReadLock_REQUEST::TPM2_NV_ReadLock_REQUEST(
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex
)
{
    authHandle = _authHandle;
    nvIndex = _nvIndex;
}

/// <summary> If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR). </summary>
TPM2_NV_ReadLock_REQUEST::~TPM2_NV_ReadLock_REQUEST() {}

/// <summary> If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR). </summary>
TpmStructureBase* TPM2_NV_ReadLock_REQUEST::Clone() const
{
    return new TPM2_NV_ReadLock_REQUEST(*this);
}

void* TPM2_NV_ReadLock_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId NV_ReadLockResponse::GetTypeId() const
{
    return TpmTypeId::NV_ReadLockResponse_ID;
}

/// <summary> If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR). </summary>
NV_ReadLockResponse::~NV_ReadLockResponse() {}

/// <summary> If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR). </summary>
TpmStructureBase* NV_ReadLockResponse::Clone() const
{
    return new NV_ReadLockResponse(*this);
}

void* NV_ReadLockResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_ChangeAuth_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
}

TPM2_NV_ChangeAuth_REQUEST::TPM2_NV_ChangeAuth_REQUEST(
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _newAuth
)
{
    nvIndex = _nvIndex;
    newAuth = _newAuth;
}

/// <summary> This command allows the authorization secret for an NV Index to be changed. </summary>
TPM2_NV_ChangeAuth_REQUEST::~TPM2_NV_ChangeAuth_REQUEST() {}

/// <summary> This command allows the authorization secret for an NV Index to be changed. </summary>
TpmStructureBase* TPM2_NV_ChangeAuth_REQUEST::Clone() const
{
    return new TPM2_NV_ChangeAuth_REQUEST(*this);
}

void* TPM2_NV_ChangeAuth_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 1: return &newAuthSize;
            case 2: { if (newArraySize != -1) newAuth.resize(newArraySize); arraySize = (int)newAuth.size(); return &newAuth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &newAuth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId NV_ChangeAuthResponse::GetTypeId() const
{
    return TpmTypeId::NV_ChangeAuthResponse_ID;
}

/// <summary> This command allows the authorization secret for an NV Index to be changed. </summary>
NV_ChangeAuthResponse::~NV_ChangeAuthResponse() {}

/// <summary> This command allows the authorization secret for an NV Index to be changed. </summary>
TpmStructureBase* NV_ChangeAuthResponse::Clone() const
{
    return new NV_ChangeAuthResponse(*this);
}

void* NV_ChangeAuthResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_NV_Certify_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
}

TPM2_NV_Certify_REQUEST::TPM2_NV_Certify_REQUEST(
    const TPM_HANDLE& _signHandle,
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _nvIndex,
    const ByteVec& _qualifyingData,
    const TPMU_SIG_SCHEME& _inScheme,
    UINT16 _size,
    UINT16 _offset
)
{
    signHandle = _signHandle;
    authHandle = _authHandle;
    nvIndex = _nvIndex;
    qualifyingData = _qualifyingData;
    inScheme.reset(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()));
    size = _size;
    offset = _offset;
}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
TPM2_NV_Certify_REQUEST::~TPM2_NV_Certify_REQUEST() {}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
TpmStructureBase* TPM2_NV_Certify_REQUEST::Clone() const
{
    return new TPM2_NV_Certify_REQUEST(*this);
}

void* TPM2_NV_Certify_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&signHandle); return &signHandle;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&nvIndex); return &nvIndex;
            case 3: return &qualifyingDataSize;
            case 4: { if (newArraySize != -1) qualifyingData.resize(newArraySize); arraySize = (int)qualifyingData.size(); return &qualifyingData; }
            case 5: return &inSchemeScheme;
            case 6: pStruct = dynamic_cast<TpmStructureBase*>(&*inScheme); return &inScheme;
            case 7: return &size;
            case 8: return &offset;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &qualifyingData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId NV_CertifyResponse::GetTypeId() const
{
    return TpmTypeId::NV_CertifyResponse_ID;
}

NV_CertifyResponse::NV_CertifyResponse(
    const TPMS_ATTEST& _certifyInfo,
    const TPMU_SIGNATURE& _signature
)
{
    certifyInfo = _certifyInfo;
    signature.reset(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()));
}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
NV_CertifyResponse::~NV_CertifyResponse() {}

/// <summary> The purpose of this command is to certify the contents of an NV Index or portion of an NV Index. </summary>
TpmStructureBase* NV_CertifyResponse::Clone() const
{
    return new NV_CertifyResponse(*this);
}

void* NV_CertifyResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &certifyInfoSize;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&certifyInfo); return &certifyInfo;
            case 2: return &signatureSigAlg;
            case 3: pStruct = dynamic_cast<TpmStructureBase*>(&*signature); return &signature;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_AC_GetCapability_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
}

TPM2_AC_GetCapability_REQUEST::TPM2_AC_GetCapability_REQUEST(
    const TPM_HANDLE& _ac,
    TPM_AT _capability,
    UINT32 _count
)
{
    ac = _ac;
    capability = _capability;
    count = _count;
}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
TPM2_AC_GetCapability_REQUEST::~TPM2_AC_GetCapability_REQUEST() {}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
TpmStructureBase* TPM2_AC_GetCapability_REQUEST::Clone() const
{
    return new TPM2_AC_GetCapability_REQUEST(*this);
}

void* TPM2_AC_GetCapability_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&ac); return &ac;
            case 1: return &capability;
            case 2: return &count;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId AC_GetCapabilityResponse::GetTypeId() const
{
    return TpmTypeId::AC_GetCapabilityResponse_ID;
}

AC_GetCapabilityResponse::AC_GetCapabilityResponse(
    BYTE _moreData,
    const vector<TPMS_AC_OUTPUT>& _capabilitiesData
)
{
    moreData = _moreData;
    capabilitiesData = _capabilitiesData;
}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
AC_GetCapabilityResponse::~AC_GetCapabilityResponse() {}

/// <summary> The purpose of this command is to obtain information about an Attached Component referenced by an AC handle. </summary>
TpmStructureBase* AC_GetCapabilityResponse::Clone() const
{
    return new AC_GetCapabilityResponse(*this);
}

void* AC_GetCapabilityResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &moreData;
            case 1: return &capabilitiesDataCount;
            case 2: { if (newArraySize != -1) capabilitiesData.resize(newArraySize); arraySize = (int)capabilitiesData.size(); return &capabilitiesData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&capabilitiesData[arrayIndex]); return &capabilitiesData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2_AC_Send_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_AC_Send_REQUEST_ID;
}

TPM2_AC_Send_REQUEST::TPM2_AC_Send_REQUEST(
    const TPM_HANDLE& _sendObject,
    const TPM_HANDLE& _authHandle,
    const TPM_HANDLE& _ac,
    const ByteVec& _acDataIn
)
{
    sendObject = _sendObject;
    authHandle = _authHandle;
    ac = _ac;
    acDataIn = _acDataIn;
}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
TPM2_AC_Send_REQUEST::~TPM2_AC_Send_REQUEST() {}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
TpmStructureBase* TPM2_AC_Send_REQUEST::Clone() const
{
    return new TPM2_AC_Send_REQUEST(*this);
}

void* TPM2_AC_Send_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&sendObject); return &sendObject;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&authHandle); return &authHandle;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&ac); return &ac;
            case 3: return &acDataInSize;
            case 4: { if (newArraySize != -1) acDataIn.resize(newArraySize); arraySize = (int)acDataIn.size(); return &acDataIn; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 4: return &acDataIn[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId AC_SendResponse::GetTypeId() const
{
    return TpmTypeId::AC_SendResponse_ID;
}

AC_SendResponse::AC_SendResponse(const TPMS_AC_OUTPUT& _acDataOut)
{
    acDataOut = _acDataOut;
}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
AC_SendResponse::~AC_SendResponse() {}

/// <summary> The purpose of this command is to send (copy) a loaded object from the TPM to an Attached Component. </summary>
TpmStructureBase* AC_SendResponse::Clone() const
{
    return new AC_SendResponse(*this);
}

void* AC_SendResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&acDataOut); return &acDataOut;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId TPM2_Policy_AC_SendSelect_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
}

TPM2_Policy_AC_SendSelect_REQUEST::TPM2_Policy_AC_SendSelect_REQUEST(
    const TPM_HANDLE& _policySession,
    const ByteVec& _objectName,
    const ByteVec& _authHandleName,
    const ByteVec& _acName,
    BYTE _includeObject
)
{
    policySession = _policySession;
    objectName = _objectName;
    authHandleName = _authHandleName;
    acName = _acName;
    includeObject = _includeObject;
}

/// <summary> This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified. </summary>
TPM2_Policy_AC_SendSelect_REQUEST::~TPM2_Policy_AC_SendSelect_REQUEST() {}

/// <summary> This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified. </summary>
TpmStructureBase* TPM2_Policy_AC_SendSelect_REQUEST::Clone() const
{
    return new TPM2_Policy_AC_SendSelect_REQUEST(*this);
}

void* TPM2_Policy_AC_SendSelect_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&policySession); return &policySession;
            case 1: return &objectNameSize;
            case 2: { if (newArraySize != -1) objectName.resize(newArraySize); arraySize = (int)objectName.size(); return &objectName; }
            case 3: return &authHandleNameSize;
            case 4: { if (newArraySize != -1) authHandleName.resize(newArraySize); arraySize = (int)authHandleName.size(); return &authHandleName; }
            case 5: return &acNameSize;
            case 6: { if (newArraySize != -1) acName.resize(newArraySize); arraySize = (int)acName.size(); return &acName; }
            case 7: return &includeObject;
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &objectName[arrayIndex];
            case 4: return &authHandleName[arrayIndex];
            case 6: return &acName[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId Policy_AC_SendSelectResponse::GetTypeId() const
{
    return TpmTypeId::Policy_AC_SendSelectResponse_ID;
}

/// <summary> This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified. </summary>
Policy_AC_SendSelectResponse::~Policy_AC_SendSelectResponse() {}

/// <summary> This command allows qualification of the sending (copying) of an Object to an Attached Component (AC). Qualification includes selection of the receiving AC and the method of authentication for the AC, and, in certain circumstances, the Object to be sent may be specified. </summary>
TpmStructureBase* Policy_AC_SendSelectResponse::Clone() const
{
    return new Policy_AC_SendSelectResponse(*this);
}

void* Policy_AC_SendSelectResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_ACT_SetTimeout_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID;
}

TPM2_ACT_SetTimeout_REQUEST::TPM2_ACT_SetTimeout_REQUEST(
    const TPM_HANDLE& _actHandle,
    UINT32 _startTimeout
)
{
    actHandle = _actHandle;
    startTimeout = _startTimeout;
}

/// <summary> This command is used to set the time remaining before an Authenticated Countdown Timer (ACT) expires. </summary>
TPM2_ACT_SetTimeout_REQUEST::~TPM2_ACT_SetTimeout_REQUEST() {}

/// <summary> This command is used to set the time remaining before an Authenticated Countdown Timer (ACT) expires. </summary>
TpmStructureBase* TPM2_ACT_SetTimeout_REQUEST::Clone() const
{
    return new TPM2_ACT_SetTimeout_REQUEST(*this);
}

void* TPM2_ACT_SetTimeout_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&actHandle); return &actHandle;
            case 1: return &startTimeout;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId ACT_SetTimeoutResponse::GetTypeId() const
{
    return TpmTypeId::ACT_SetTimeoutResponse_ID;
}

/// <summary> This command is used to set the time remaining before an Authenticated Countdown Timer (ACT) expires. </summary>
ACT_SetTimeoutResponse::~ACT_SetTimeoutResponse() {}

/// <summary> This command is used to set the time remaining before an Authenticated Countdown Timer (ACT) expires. </summary>
TpmStructureBase* ACT_SetTimeoutResponse::Clone() const
{
    return new ACT_SetTimeoutResponse(*this);
}

void* ACT_SetTimeoutResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    throw logic_error("error");
    return NULL;
}

TpmTypeId TPM2_Vendor_TCG_Test_REQUEST::GetTypeId() const
{
    return TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
}

TPM2_Vendor_TCG_Test_REQUEST::TPM2_Vendor_TCG_Test_REQUEST(
    const ByteVec& _inputData
)
{
    inputData = _inputData;
}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
TPM2_Vendor_TCG_Test_REQUEST::~TPM2_Vendor_TCG_Test_REQUEST() {}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
TpmStructureBase* TPM2_Vendor_TCG_Test_REQUEST::Clone() const
{
    return new TPM2_Vendor_TCG_Test_REQUEST(*this);
}

void* TPM2_Vendor_TCG_Test_REQUEST::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &inputDataSize;
            case 1: { if (newArraySize != -1) inputData.resize(newArraySize); arraySize = (int)inputData.size(); return &inputData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &inputData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId Vendor_TCG_TestResponse::GetTypeId() const
{
    return TpmTypeId::Vendor_TCG_TestResponse_ID;
}

Vendor_TCG_TestResponse::Vendor_TCG_TestResponse(
    const ByteVec& _outputData
)
{
    outputData = _outputData;
}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
Vendor_TCG_TestResponse::~Vendor_TCG_TestResponse() {}

/// <summary> This is a placeholder to allow testing of the dispatch code. </summary>
TpmStructureBase* Vendor_TCG_TestResponse::Clone() const
{
    return new Vendor_TCG_TestResponse(*this);
}

void* Vendor_TCG_TestResponse::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &outputDataSize;
            case 1: { if (newArraySize != -1) outputData.resize(newArraySize); arraySize = (int)outputData.size(); return &outputData; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &outputData[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TssObject::GetTypeId() const
{
    return TpmTypeId::TssObject_ID;
}

TssObject::TssObject(
    const TPMT_PUBLIC& _Public,
    const TPMT_SENSITIVE& _Sensitive,
    const TPM2B_PRIVATE& _Private
)
{
    Public = _Public;
    Sensitive = _Sensitive;
    Private = _Private;
}

/// <summary> Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object) </summary>
TssObject::~TssObject() {}

/// <summary> Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM key (or other object) </summary>
TpmStructureBase* TssObject::Clone() const
{
    return new TssObject(*this);
}

void* TssObject::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&Public); return &Public;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&Sensitive); return &Sensitive;
            case 2: pStruct = dynamic_cast<TpmStructureBase*>(&Private); return &Private;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId PcrValue::GetTypeId() const
{
    return TpmTypeId::PcrValue_ID;
}

PcrValue::PcrValue(
    UINT32 _index,
    const TPMT_HA& _value
)
{
    index = _index;
    value = _value;
}

/// <summary> Contains a PCR index and associated hash(pcr-value) [TSS] </summary>
PcrValue::~PcrValue() {}

/// <summary> Contains a PCR index and associated hash(pcr-value) [TSS] </summary>
TpmStructureBase* PcrValue::Clone() const
{
    return new PcrValue(*this);
}

void* PcrValue::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &index;
            case 1: pStruct = dynamic_cast<TpmStructureBase*>(&value); return &value;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId SessionIn::GetTypeId() const
{
    return TpmTypeId::SessionIn_ID;
}

SessionIn::SessionIn(
    const TPM_HANDLE& _handle,
    const ByteVec& _nonceCaller,
    TPMA_SESSION _attributes,
    const ByteVec& _auth
)
{
    handle = _handle;
    nonceCaller = _nonceCaller;
    attributes = _attributes;
    auth = _auth;
}

/// <summary> Structure representing a session block in a command buffer [TSS] </summary>
SessionIn::~SessionIn() {}

/// <summary> Structure representing a session block in a command buffer [TSS] </summary>
TpmStructureBase* SessionIn::Clone() const
{
    return new SessionIn(*this);
}

void* SessionIn::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&handle); return &handle;
            case 1: return &nonceCallerSize;
            case 2: { if (newArraySize != -1) nonceCaller.resize(newArraySize); arraySize = (int)nonceCaller.size(); return &nonceCaller; }
            case 3: return &attributes;
            case 4: return &authSize;
            case 5: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &nonceCaller[arrayIndex];
            case 5: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId SessionOut::GetTypeId() const
{
    return TpmTypeId::SessionOut_ID;
}

SessionOut::SessionOut(
    const ByteVec& _nonceTpm,
    TPMA_SESSION _attributes,
    const ByteVec& _auth
)
{
    nonceTpm = _nonceTpm;
    attributes = _attributes;
    auth = _auth;
}

/// <summary> Structure representing a session block in a response buffer [TSS] </summary>
SessionOut::~SessionOut() {}

/// <summary> Structure representing a session block in a response buffer [TSS] </summary>
TpmStructureBase* SessionOut::Clone() const
{
    return new SessionOut(*this);
}

void* SessionOut::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &nonceTpmSize;
            case 1: { if (newArraySize != -1) nonceTpm.resize(newArraySize); arraySize = (int)nonceTpm.size(); return &nonceTpm; }
            case 2: return &attributes;
            case 3: return &authSize;
            case 4: { if (newArraySize != -1) auth.resize(newArraySize); arraySize = (int)auth.size(); return &auth; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &nonceTpm[arrayIndex];
            case 4: return &auth[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId CommandHeader::GetTypeId() const
{
    return TpmTypeId::CommandHeader_ID;
}

CommandHeader::CommandHeader(
    TPM_ST _Tag,
    UINT32 _CommandSize,
    TPM_CC _CommandCode
)
{
    Tag = _Tag;
    CommandSize = _CommandSize;
    CommandCode = _CommandCode;
}

/// <summary> Command header [TSS] </summary>
CommandHeader::~CommandHeader() {}

/// <summary> Command header [TSS] </summary>
TpmStructureBase* CommandHeader::Clone() const
{
    return new CommandHeader(*this);
}

void* CommandHeader::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &Tag;
            case 1: return &CommandSize;
            case 2: return &CommandCode;
            default: throw runtime_error("element out of range.");
        }

    } else {
    }
    return NULL;
}

TpmTypeId _TSS_KEY::GetTypeId() const
{
    return TpmTypeId::TSS_KEY_ID;
}

_TSS_KEY::_TSS_KEY(
    const TPMT_PUBLIC& _publicPart,
    const ByteVec& _privatePart
)
{
    publicPart = _publicPart;
    privatePart = _privatePart;
}

/// <summary> Contains the public and private part of a TPM key </summary>
_TSS_KEY::~_TSS_KEY() {}

/// <summary> Contains the public and private part of a TPM key </summary>
TpmStructureBase* _TSS_KEY::Clone() const
{
    return new TSS_KEY(dynamic_cast<const TSS_KEY&>(*this));
}

void* _TSS_KEY::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: pStruct = dynamic_cast<TpmStructureBase*>(&publicPart); return &publicPart;
            case 1: return &privatePartSize;
            case 2: { if (newArraySize != -1) privatePart.resize(newArraySize); arraySize = (int)privatePart.size(); return &privatePart; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 2: return &privatePart[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DIGEST_Symcipher::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
}

TPM2B_DIGEST_Symcipher::TPM2B_DIGEST_Symcipher(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation </summary>
TPM2B_DIGEST_Symcipher::~TPM2B_DIGEST_Symcipher() {}

/// <summary> Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation </summary>
TpmStructureBase* TPM2B_DIGEST_Symcipher::Clone() const
{
    return new TPM2B_DIGEST_Symcipher(*this);
}

void* TPM2B_DIGEST_Symcipher::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmTypeId TPM2B_DIGEST_Keyedhash::GetTypeId() const
{
    return TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
}

TPM2B_DIGEST_Keyedhash::TPM2B_DIGEST_Keyedhash(
    const ByteVec& _buffer
)
{
    buffer = _buffer;
}

/// <summary> Auto-derived from TPM2B_DIGEST </summary>
TPM2B_DIGEST_Keyedhash::~TPM2B_DIGEST_Keyedhash() {}

/// <summary> Auto-derived from TPM2B_DIGEST </summary>
TpmStructureBase* TPM2B_DIGEST_Keyedhash::Clone() const
{
    return new TPM2B_DIGEST_Keyedhash(*this);
}

void* TPM2B_DIGEST_Keyedhash::ElementInfo(int memIndex, int arrayIndex, int& arraySize, TpmStructureBase*& pStruct, int newArraySize)
{
    arraySize = 0;
    pStruct = NULL;
    if(arrayIndex == -1)
    {
        switch(memIndex)
        {
            case 0: return &size;
            case 1: { if (newArraySize != -1) buffer.resize(newArraySize); arraySize = (int)buffer.size(); return &buffer; }
            default: throw runtime_error("element out of range.");
        }

    } else {
        switch (memIndex)
        {
            case 1: return &buffer[arrayIndex];
            default: throw runtime_error("element out of range.");
        }
    }
    return NULL;
}

TpmStructureBase* TpmStructureBase::UnionFactory(TpmTypeId objTypeID, TpmTypeId unionTypeID, void* pUnion)
{
    _ASSERT(pUnion && objTypeID != TpmTypeId::None && unionTypeID != TpmTypeId::None);
    
    TpmStructureBase* obj = TypeMap[objTypeID]->Factory();
    switch (unionTypeID)
    {
    case TpmTypeId::TPMU_HA_ID: new (pUnion) shared_ptr<TPMU_HA>(dynamic_cast<TPMU_HA*>(obj)); break;
    case TpmTypeId::TPMU_NAME_ID: new (pUnion) shared_ptr<TPMU_NAME>(dynamic_cast<TPMU_NAME*>(obj)); break;
    case TpmTypeId::TPMU_CAPABILITIES_ID: new (pUnion) shared_ptr<TPMU_CAPABILITIES>(dynamic_cast<TPMU_CAPABILITIES*>(obj)); break;
    case TpmTypeId::TPMU_ATTEST_ID: new (pUnion) shared_ptr<TPMU_ATTEST>(dynamic_cast<TPMU_ATTEST*>(obj)); break;
    case TpmTypeId::TPMU_SYM_KEY_BITS_ID: new (pUnion) shared_ptr<TPMU_SYM_KEY_BITS>(dynamic_cast<TPMU_SYM_KEY_BITS*>(obj)); break;
    case TpmTypeId::TPMU_SYM_MODE_ID: new (pUnion) shared_ptr<TPMU_SYM_MODE>(dynamic_cast<TPMU_SYM_MODE*>(obj)); break;
    case TpmTypeId::TPMU_SYM_DETAILS_ID: new (pUnion) shared_ptr<TPMU_SYM_DETAILS>(dynamic_cast<TPMU_SYM_DETAILS*>(obj)); break;
    case TpmTypeId::TPMU_SENSITIVE_CREATE_ID: new (pUnion) shared_ptr<TPMU_SENSITIVE_CREATE>(dynamic_cast<TPMU_SENSITIVE_CREATE*>(obj)); break;
    case TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID: new (pUnion) shared_ptr<TPMU_SCHEME_KEYEDHASH>(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(obj)); break;
    case TpmTypeId::TPMU_SIG_SCHEME_ID: new (pUnion) shared_ptr<TPMU_SIG_SCHEME>(dynamic_cast<TPMU_SIG_SCHEME*>(obj)); break;
    case TpmTypeId::TPMU_KDF_SCHEME_ID: new (pUnion) shared_ptr<TPMU_KDF_SCHEME>(dynamic_cast<TPMU_KDF_SCHEME*>(obj)); break;
    case TpmTypeId::TPMU_ASYM_SCHEME_ID: new (pUnion) shared_ptr<TPMU_ASYM_SCHEME>(dynamic_cast<TPMU_ASYM_SCHEME*>(obj)); break;
    case TpmTypeId::TPMU_SIGNATURE_ID: new (pUnion) shared_ptr<TPMU_SIGNATURE>(dynamic_cast<TPMU_SIGNATURE*>(obj)); break;
    case TpmTypeId::TPMU_ENCRYPTED_SECRET_ID: new (pUnion) shared_ptr<TPMU_ENCRYPTED_SECRET>(dynamic_cast<TPMU_ENCRYPTED_SECRET*>(obj)); break;
    case TpmTypeId::TPMU_PUBLIC_ID_ID: new (pUnion) shared_ptr<TPMU_PUBLIC_ID>(dynamic_cast<TPMU_PUBLIC_ID*>(obj)); break;
    case TpmTypeId::TPMU_PUBLIC_PARMS_ID: new (pUnion) shared_ptr<TPMU_PUBLIC_PARMS>(dynamic_cast<TPMU_PUBLIC_PARMS*>(obj)); break;
    case TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID: new (pUnion) shared_ptr<TPMU_SENSITIVE_COMPOSITE>(dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(obj)); break;
    default: throw new runtime_error("Factory only casts to TPM unions");
    }
    return obj;
}

void TpmTypeInfo::TpmTypeInitter()
{
    TpmTypeInfo* sInf;
    
    // ======== TPMS_NULL_UNION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_UNION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_UNION";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_UNION()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMT_HA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_HA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_HA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_HA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_HA_ID;
    //digest
    sInf->Fields[1].Name = "digest";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::SpecialVariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM_HANDLE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_HANDLE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM_HANDLE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM_HANDLE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM_HANDLE_ID;
    
    // ======== TPMS_EMPTY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_EMPTY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_EMPTY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_EMPTY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_ALGORITHM_DESCRIPTION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ALGORITHM_DESCRIPTION";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ALGORITHM_DESCRIPTION()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //alg
    sInf->Fields[0].Name = "alg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
    //attributes
    sInf->Fields[1].Name = "attributes";
    sInf->Fields[1].TypeId = TpmTypeId::TPMA_ALGORITHM_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ALGORITHM_DESCRIPTION_ID;
    
    // ======== TPM2B_DIGEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_DIGEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_DIGEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DIGEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DATA_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DATA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_EVENT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_EVENT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_EVENT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_EVENT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_EVENT_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_EVENT_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_MAX_BUFFER ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_MAX_BUFFER_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_MAX_BUFFER";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_MAX_BUFFER()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_MAX_BUFFER_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_MAX_BUFFER_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_MAX_NV_BUFFER ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_MAX_NV_BUFFER_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_MAX_NV_BUFFER";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_MAX_NV_BUFFER()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_MAX_NV_BUFFER_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_TIMEOUT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_TIMEOUT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_TIMEOUT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_TIMEOUT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_TIMEOUT_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_TIMEOUT_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_IV ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_IV_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_IV";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_IV()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_IV_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_IV_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_NAME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_NAME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_NAME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_NAME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_NAME_ID;
    //name
    sInf->Fields[1].Name = "name";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_NAME_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_PCR_SELECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_PCR_SELECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_PCR_SELECT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_PCR_SELECT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //sizeofSelect
    sInf->Fields[0].Name = "sizeofSelect";
    sInf->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_PCR_SELECT_ID;
    //pcrSelect
    sInf->Fields[1].Name = "pcrSelect";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_PCR_SELECT_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_PCR_SELECTION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_PCR_SELECTION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_PCR_SELECTION";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_PCR_SELECTION()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    //sizeofSelect
    sInf->Fields[1].Name = "sizeofSelect";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    //pcrSelect
    sInf->Fields[2].Name = "pcrSelect";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPMT_TK_CREATION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_TK_CREATION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_TK_CREATION";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_CREATION()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //tag
    sInf->Fields[0].Name = "tag";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].MarshalType = MarshalType::ConstantValue;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    //hierarchy
    sInf->Fields[1].Name = "hierarchy";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    //digestSize
    sInf->Fields[2].Name = "digestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    //digest
    sInf->Fields[3].Name = "digest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMT_TK_VERIFIED ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_TK_VERIFIED_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_TK_VERIFIED";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_VERIFIED()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //tag
    sInf->Fields[0].Name = "tag";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].MarshalType = MarshalType::ConstantValue;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    //hierarchy
    sInf->Fields[1].Name = "hierarchy";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    //digestSize
    sInf->Fields[2].Name = "digestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    //digest
    sInf->Fields[3].Name = "digest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMT_TK_AUTH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_TK_AUTH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_TK_AUTH";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_AUTH()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //tag
    sInf->Fields[0].Name = "tag";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    //hierarchy
    sInf->Fields[1].Name = "hierarchy";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    //digestSize
    sInf->Fields[2].Name = "digestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    //digest
    sInf->Fields[3].Name = "digest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMT_TK_HASHCHECK ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_TK_HASHCHECK_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_TK_HASHCHECK";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_TK_HASHCHECK()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //tag
    sInf->Fields[0].Name = "tag";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].MarshalType = MarshalType::ConstantValue;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    //hierarchy
    sInf->Fields[1].Name = "hierarchy";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    //digestSize
    sInf->Fields[2].Name = "digestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    //digest
    sInf->Fields[3].Name = "digest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_ALG_PROPERTY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ALG_PROPERTY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ALG_PROPERTY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ALG_PROPERTY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //alg
    sInf->Fields[0].Name = "alg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    //algProperties
    sInf->Fields[1].Name = "algProperties";
    sInf->Fields[1].TypeId = TpmTypeId::TPMA_ALGORITHM_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    
    // ======== TPMS_TAGGED_PROPERTY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_TAGGED_PROPERTY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_TAGGED_PROPERTY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TAGGED_PROPERTY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //property
    sInf->Fields[0].Name = "property";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_PT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    //value
    sInf->Fields[1].Name = "value";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    
    // ======== TPMS_TAGGED_PCR_SELECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_TAGGED_PCR_SELECT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TAGGED_PCR_SELECT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //tag
    sInf->Fields[0].Name = "tag";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_PT_PCR_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    //sizeofSelect
    sInf->Fields[1].Name = "sizeofSelect";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    //pcrSelect
    sInf->Fields[2].Name = "pcrSelect";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_TAGGED_POLICY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_TAGGED_POLICY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_TAGGED_POLICY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TAGGED_POLICY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    //policyHash
    sInf->Fields[1].Name = "policyHash";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    
    // ======== TPMS_ACT_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ACT_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ACT_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ACT_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ACT_DATA_ID;
    //timeout
    sInf->Fields[1].Name = "timeout";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ACT_DATA_ID;
    //attributes
    sInf->Fields[2].Name = "attributes";
    sInf->Fields[2].TypeId = TpmTypeId::TPMA_ACT_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ACT_DATA_ID;
    
    // ======== TPML_CC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_CC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_CC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_CC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_CC_ID;
    //commandCodes
    sInf->Fields[1].Name = "commandCodes";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_CC_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_CC_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_CCA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_CCA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_CCA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_CCA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_CCA_ID;
    //commandAttributes
    sInf->Fields[1].Name = "commandAttributes";
    sInf->Fields[1].TypeId = TpmTypeId::TPMA_CC_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_CCA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ALG ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_ALG_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_ALG";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ALG()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_ALG_ID;
    //algorithms
    sInf->Fields[1].Name = "algorithms";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_ALG_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_HANDLE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_HANDLE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_HANDLE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_HANDLE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_HANDLE_ID;
    //handle
    sInf->Fields[1].Name = "handle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_HANDLE_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_DIGEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_DIGEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_DIGEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_DIGEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_DIGEST_ID;
    //digests
    sInf->Fields[1].Name = "digests";
    sInf->Fields[1].TypeId = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_DIGEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_DIGEST_VALUES ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_DIGEST_VALUES_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_DIGEST_VALUES";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_DIGEST_VALUES()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_DIGEST_VALUES_ID;
    //digests
    sInf->Fields[1].Name = "digests";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_DIGEST_VALUES_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_PCR_SELECTION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_PCR_SELECTION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_PCR_SELECTION";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_PCR_SELECTION()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_PCR_SELECTION_ID;
    //pcrSelections
    sInf->Fields[1].Name = "pcrSelections";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_PCR_SELECTION_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ALG_PROPERTY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_ALG_PROPERTY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_ALG_PROPERTY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ALG_PROPERTY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_ALG_PROPERTY_ID;
    //algProperties
    sInf->Fields[1].Name = "algProperties";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ALG_PROPERTY_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_ALG_PROPERTY_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_TAGGED_TPM_PROPERTY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_TAGGED_TPM_PROPERTY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_TAGGED_TPM_PROPERTY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    //tpmProperty
    sInf->Fields[1].Name = "tpmProperty";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_TAGGED_PROPERTY_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_TAGGED_PCR_PROPERTY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_TAGGED_PCR_PROPERTY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_TAGGED_PCR_PROPERTY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    //pcrProperty
    sInf->Fields[1].Name = "pcrProperty";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_TAGGED_PCR_SELECT_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ECC_CURVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_ECC_CURVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_ECC_CURVE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ECC_CURVE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_ECC_CURVE_ID;
    //eccCurves
    sInf->Fields[1].Name = "eccCurves";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_ECC_CURVE_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_TAGGED_POLICY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_TAGGED_POLICY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_TAGGED_POLICY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_TAGGED_POLICY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_TAGGED_POLICY_ID;
    //policies
    sInf->Fields[1].Name = "policies";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_TAGGED_POLICY_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_TAGGED_POLICY_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPML_ACT_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_ACT_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_ACT_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_ACT_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_ACT_DATA_ID;
    //actData
    sInf->Fields[1].Name = "actData";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ACT_DATA_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_ACT_DATA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_CAPABILITY_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CAPABILITY_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CAPABILITY_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CAPABILITY_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //capability
    sInf->Fields[0].Name = "capability";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_CAP_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CAPABILITY_DATA_ID;
    sInf->Fields[0].AssociatedField = 1;
    //data
    sInf->Fields[1].Name = "data";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_CAPABILITIES_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CAPABILITY_DATA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_CLOCK_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CLOCK_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CLOCK_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CLOCK_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //clock
    sInf->Fields[0].Name = "clock";
    sInf->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    //resetCount
    sInf->Fields[1].Name = "resetCount";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    //restartCount
    sInf->Fields[2].Name = "restartCount";
    sInf->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    //safe
    sInf->Fields[3].Name = "safe";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CLOCK_INFO_ID;
    
    // ======== TPMS_TIME_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_TIME_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_TIME_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TIME_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //time
    sInf->Fields[0].Name = "time";
    sInf->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TIME_INFO_ID;
    //clockInfo
    sInf->Fields[1].Name = "clockInfo";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TIME_INFO_ID;
    
    // ======== TPMS_TIME_ATTEST_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_TIME_ATTEST_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_TIME_ATTEST_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TIME_ATTEST_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //time
    sInf->Fields[0].Name = "time";
    sInf->Fields[0].TypeId = TpmTypeId::TPMS_TIME_INFO_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    //firmwareVersion
    sInf->Fields[1].Name = "firmwareVersion";
    sInf->Fields[1].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    
    // ======== TPMS_CERTIFY_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CERTIFY_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CERTIFY_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CERTIFY_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //nameSize
    sInf->Fields[0].Name = "nameSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    //name
    sInf->Fields[1].Name = "name";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->Fields[1].AssociatedField = 0;
    //qualifiedNameSize
    sInf->Fields[2].Name = "qualifiedNameSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    //qualifiedName
    sInf->Fields[3].Name = "qualifiedName";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_QUOTE_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_QUOTE_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_QUOTE_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_QUOTE_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //pcrSelectCount
    sInf->Fields[0].Name = "pcrSelectCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    //pcrSelect
    sInf->Fields[1].Name = "pcrSelect";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->Fields[1].AssociatedField = 0;
    //pcrDigestSize
    sInf->Fields[2].Name = "pcrDigestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    //pcrDigest
    sInf->Fields[3].Name = "pcrDigest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_COMMAND_AUDIT_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_COMMAND_AUDIT_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_COMMAND_AUDIT_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //auditCounter
    sInf->Fields[0].Name = "auditCounter";
    sInf->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //digestAlg
    sInf->Fields[1].Name = "digestAlg";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //auditDigestSize
    sInf->Fields[2].Name = "auditDigestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //auditDigest
    sInf->Fields[3].Name = "auditDigest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[3].AssociatedField = 2;
    //commandDigestSize
    sInf->Fields[4].Name = "commandDigestSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    //commandDigest
    sInf->Fields[5].Name = "commandDigest";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== TPMS_SESSION_AUDIT_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SESSION_AUDIT_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SESSION_AUDIT_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //exclusiveSession
    sInf->Fields[0].Name = "exclusiveSession";
    sInf->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    //sessionDigestSize
    sInf->Fields[1].Name = "sessionDigestSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    //sessionDigest
    sInf->Fields[2].Name = "sessionDigest";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_CREATION_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CREATION_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CREATION_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CREATION_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //objectNameSize
    sInf->Fields[0].Name = "objectNameSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    //objectName
    sInf->Fields[1].Name = "objectName";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->Fields[1].AssociatedField = 0;
    //creationHashSize
    sInf->Fields[2].Name = "creationHashSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    //creationHash
    sInf->Fields[3].Name = "creationHash";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_NV_CERTIFY_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NV_CERTIFY_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NV_CERTIFY_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_CERTIFY_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //indexNameSize
    sInf->Fields[0].Name = "indexNameSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    //indexName
    sInf->Fields[1].Name = "indexName";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->Fields[1].AssociatedField = 0;
    //offset
    sInf->Fields[2].Name = "offset";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    //nvContentsSize
    sInf->Fields[3].Name = "nvContentsSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    //nvContents
    sInf->Fields[4].Name = "nvContents";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_NV_DIGEST_CERTIFY_INFO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NV_DIGEST_CERTIFY_INFO";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_DIGEST_CERTIFY_INFO()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //indexNameSize
    sInf->Fields[0].Name = "indexNameSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    //indexName
    sInf->Fields[1].Name = "indexName";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    sInf->Fields[1].AssociatedField = 0;
    //nvDigestSize
    sInf->Fields[2].Name = "nvDigestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    //nvDigest
    sInf->Fields[3].Name = "nvDigest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPMS_ATTEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ATTEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ATTEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ATTEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(9);
    //magic
    sInf->Fields[0].Name = "magic";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_GENERATED_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //type
    sInf->Fields[1].Name = "type";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ST_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].AssociatedField = 8;
    //qualifiedSignerSize
    sInf->Fields[2].Name = "qualifiedSignerSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //qualifiedSigner
    sInf->Fields[3].Name = "qualifiedSigner";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //extraDataSize
    sInf->Fields[4].Name = "extraDataSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //extraData
    sInf->Fields[5].Name = "extraData";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    //clockInfo
    sInf->Fields[6].Name = "clockInfo";
    sInf->Fields[6].TypeId = TpmTypeId::TPMS_CLOCK_INFO_ID;
    sInf->Fields[6].MarshalType = MarshalType::Normal;
    sInf->Fields[6].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //firmwareVersion
    sInf->Fields[7].Name = "firmwareVersion";
    sInf->Fields[7].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[7].MarshalType = MarshalType::Normal;
    sInf->Fields[7].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    //attested
    sInf->Fields[8].Name = "attested";
    sInf->Fields[8].TypeId = TpmTypeId::TPMU_ATTEST_ID;
    sInf->Fields[8].MarshalType = MarshalType::UnionObject;
    sInf->Fields[8].ParentType = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[8].AssociatedField = 1;
    
    // ======== TPM2B_ATTEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_ATTEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_ATTEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ATTEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ATTEST_ID;
    //attestationData
    sInf->Fields[1].Name = "attestationData";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ATTEST_ID;
    
    // ======== TPMS_AUTH_COMMAND ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_AUTH_COMMAND_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_AUTH_COMMAND";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_AUTH_COMMAND()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //sessionHandle
    sInf->Fields[0].Name = "sessionHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //nonceSize
    sInf->Fields[1].Name = "nonceSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //nonce
    sInf->Fields[2].Name = "nonce";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[2].AssociatedField = 1;
    //sessionAttributes
    sInf->Fields[3].Name = "sessionAttributes";
    sInf->Fields[3].TypeId = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //hmacSize
    sInf->Fields[4].Name = "hmacSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    //hmac
    sInf->Fields[5].Name = "hmac";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_AUTH_COMMAND_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== AUTHResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::AUTHResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "AUTHResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new AUTHResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //nonceSize
    sInf->Fields[0].Name = "nonceSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::AUTHResponse_ID;
    //nonce
    sInf->Fields[1].Name = "nonce";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::AUTHResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //sessionAttributes
    sInf->Fields[2].Name = "sessionAttributes";
    sInf->Fields[2].TypeId = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::AUTHResponse_ID;
    //hmacSize
    sInf->Fields[3].Name = "hmacSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::AUTHResponse_ID;
    //hmac
    sInf->Fields[4].Name = "hmac";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::AUTHResponse_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_NULL_SYM_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_SYM_KEY_BITS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SYM_KEY_BITS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_XOR_SYM_MODE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_XOR_SYM_MODE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_XOR_SYM_MODE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_XOR_SYM_MODE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_NULL_SYM_MODE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SYM_MODE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_SYM_MODE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SYM_MODE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_TDES_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_TDES_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_TDES_SYM_DETAILS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_TDES_SYM_DETAILS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_AES_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_AES_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_AES_SYM_DETAILS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_AES_SYM_DETAILS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_SM4_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SM4_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SM4_SYM_DETAILS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SM4_SYM_DETAILS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_CAMELLIA_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CAMELLIA_SYM_DETAILS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CAMELLIA_SYM_DETAILS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_ANY_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ANY_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ANY_SYM_DETAILS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ANY_SYM_DETAILS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_XOR_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_XOR_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_XOR_SYM_DETAILS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_XOR_SYM_DETAILS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_NULL_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_SYM_DETAILS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SYM_DETAILS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMT_SYM_DEF ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_SYM_DEF_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_SYM_DEF";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SYM_DEF()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //algorithm
    sInf->Fields[0].Name = "algorithm";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    //keyBits
    sInf->Fields[1].Name = "keyBits";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    //mode
    sInf->Fields[2].Name = "mode";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_SYM_DEF_ID;
    
    // ======== TPMT_SYM_DEF_OBJECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_SYM_DEF_OBJECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_SYM_DEF_OBJECT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SYM_DEF_OBJECT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //algorithm
    sInf->Fields[0].Name = "algorithm";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    //keyBits
    sInf->Fields[1].Name = "keyBits";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    //mode
    sInf->Fields[2].Name = "mode";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    
    // ======== TPM2B_SYM_KEY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_SYM_KEY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_SYM_KEY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SYM_KEY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SYM_KEY_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SYM_KEY_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_SYMCIPHER_PARMS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SYMCIPHER_PARMS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SYMCIPHER_PARMS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SYMCIPHER_PARMS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //sym
    sInf->Fields[0].Name = "sym";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
    
    // ======== TPM2B_LABEL ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_LABEL_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_LABEL";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_LABEL()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_LABEL_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_LABEL_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_DERIVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_DERIVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_DERIVE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_DERIVE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //labelSize
    sInf->Fields[0].Name = "labelSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    //label
    sInf->Fields[1].Name = "label";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[1].AssociatedField = 0;
    //contextSize
    sInf->Fields[2].Name = "contextSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    //context
    sInf->Fields[3].Name = "context";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2B_DERIVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_DERIVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_DERIVE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DERIVE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DERIVE_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_DERIVE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DERIVE_ID;
    
    // ======== TPM2B_SENSITIVE_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_SENSITIVE_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SENSITIVE_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_SENSITIVE_CREATE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SENSITIVE_CREATE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SENSITIVE_CREATE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SENSITIVE_CREATE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //userAuthSize
    sInf->Fields[0].Name = "userAuthSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    //userAuth
    sInf->Fields[1].Name = "userAuth";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[1].AssociatedField = 0;
    //dataSize
    sInf->Fields[2].Name = "dataSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    //data
    sInf->Fields[3].Name = "data";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2B_SENSITIVE_CREATE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_CREATE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_SENSITIVE_CREATE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SENSITIVE_CREATE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
    //sensitive
    sInf->Fields[1].Name = "sensitive";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_CREATE_ID;
    
    // ======== TPMS_SCHEME_HASH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_HASH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SCHEME_HASH";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_HASH()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_HASH_ID;
    
    // ======== TPMS_SCHEME_ECDAA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_ECDAA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SCHEME_ECDAA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_ECDAA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_ECDAA_ID;
    //count
    sInf->Fields[1].Name = "count";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SCHEME_ECDAA_ID;
    
    // ======== TPMS_SCHEME_HMAC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_HMAC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SCHEME_HMAC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_HMAC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    
    // ======== TPMS_SCHEME_XOR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SCHEME_XOR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SCHEME_XOR";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SCHEME_XOR()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SCHEME_XOR_ID;
    //kdf
    sInf->Fields[1].Name = "kdf";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SCHEME_XOR_ID;
    
    // ======== TPMS_NULL_SCHEME_KEYEDHASH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_SCHEME_KEYEDHASH";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SCHEME_KEYEDHASH()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMT_KEYEDHASH_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_KEYEDHASH_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_KEYEDHASH_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //scheme
    sInf->Fields[0].Name = "scheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
    sInf->Fields[0].AssociatedField = 1;
    //details
    sInf->Fields[1].Name = "details";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_KEYEDHASH_SCHEME_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_SIG_SCHEME_RSASSA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIG_SCHEME_RSASSA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_RSASSA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    
    // ======== TPMS_SIG_SCHEME_RSAPSS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIG_SCHEME_RSAPSS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_RSAPSS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    
    // ======== TPMS_SIG_SCHEME_ECDSA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIG_SCHEME_ECDSA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_ECDSA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    
    // ======== TPMS_SIG_SCHEME_SM2 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_SM2_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIG_SCHEME_SM2";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_SM2()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    
    // ======== TPMS_SIG_SCHEME_ECSCHNORR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIG_SCHEME_ECSCHNORR";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_ECSCHNORR()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    
    // ======== TPMS_SIG_SCHEME_ECDAA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIG_SCHEME_ECDAA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIG_SCHEME_ECDAA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    //count
    sInf->Fields[1].Name = "count";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    
    // ======== TPMS_NULL_SIG_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SIG_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_SIG_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SIG_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMT_SIG_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_SIG_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_SIG_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SIG_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //scheme
    sInf->Fields[0].Name = "scheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SIG_SCHEME_ID;
    sInf->Fields[0].AssociatedField = 1;
    //details
    sInf->Fields[1].Name = "details";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SIG_SCHEME_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ENC_SCHEME_OAEP ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ENC_SCHEME_OAEP";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ENC_SCHEME_OAEP()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
    
    // ======== TPMS_ENC_SCHEME_RSAES ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ENC_SCHEME_RSAES";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ENC_SCHEME_RSAES()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMS_KEY_SCHEME_ECDH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_KEY_SCHEME_ECDH";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KEY_SCHEME_ECDH()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
    
    // ======== TPMS_KEY_SCHEME_ECMQV ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_KEY_SCHEME_ECMQV";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KEY_SCHEME_ECMQV()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
    
    // ======== TPMS_KDF_SCHEME_MGF1 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_KDF_SCHEME_MGF1";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_MGF1()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID;
    
    // ======== TPMS_KDF_SCHEME_KDF1_SP800_56A ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_KDF_SCHEME_KDF1_SP800_56A";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_KDF1_SP800_56A()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID;
    
    // ======== TPMS_KDF_SCHEME_KDF2 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_KDF_SCHEME_KDF2";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_KDF2()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID;
    
    // ======== TPMS_KDF_SCHEME_KDF1_SP800_108 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_KDF_SCHEME_KDF1_SP800_108";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KDF_SCHEME_KDF1_SP800_108()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //hashAlg
    sInf->Fields[0].Name = "hashAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID;
    
    // ======== TPMS_NULL_KDF_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_KDF_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_KDF_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_KDF_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMT_KDF_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_KDF_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_KDF_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_KDF_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //scheme
    sInf->Fields[0].Name = "scheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_KDF_SCHEME_ID;
    sInf->Fields[0].AssociatedField = 1;
    //details
    sInf->Fields[1].Name = "details";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_KDF_SCHEME_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_NULL_ASYM_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_ASYM_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_ASYM_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMT_ASYM_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_ASYM_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_ASYM_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_ASYM_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //scheme
    sInf->Fields[0].Name = "scheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_ASYM_SCHEME_ID;
    sInf->Fields[0].AssociatedField = 1;
    //details
    sInf->Fields[1].Name = "details";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_ASYM_SCHEME_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_RSA_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_RSA_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_RSA_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_RSA_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //scheme
    sInf->Fields[0].Name = "scheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_RSA_SCHEME_ID;
    sInf->Fields[0].AssociatedField = 1;
    //details
    sInf->Fields[1].Name = "details";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_RSA_SCHEME_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_RSA_DECRYPT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_RSA_DECRYPT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_RSA_DECRYPT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_RSA_DECRYPT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //scheme
    sInf->Fields[0].Name = "scheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_RSA_DECRYPT_ID;
    sInf->Fields[0].AssociatedField = 1;
    //details
    sInf->Fields[1].Name = "details";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_RSA_DECRYPT_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_PUBLIC_KEY_RSA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_PUBLIC_KEY_RSA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PUBLIC_KEY_RSA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_PRIVATE_KEY_RSA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_PRIVATE_KEY_RSA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PRIVATE_KEY_RSA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_ECC_PARAMETER ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_ECC_PARAMETER_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_ECC_PARAMETER";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ECC_PARAMETER()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ECC_POINT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ECC_POINT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ECC_POINT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ECC_POINT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //xSize
    sInf->Fields[0].Name = "xSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    //x
    sInf->Fields[1].Name = "x";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].AssociatedField = 0;
    //ySize
    sInf->Fields[2].Name = "ySize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    //y
    sInf->Fields[3].Name = "y";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2B_ECC_POINT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_ECC_POINT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_ECC_POINT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ECC_POINT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ECC_POINT_ID;
    //point
    sInf->Fields[1].Name = "point";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ECC_POINT_ID;
    
    // ======== TPMT_ECC_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_ECC_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_ECC_SCHEME";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_ECC_SCHEME()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //scheme
    sInf->Fields[0].Name = "scheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_ECC_SCHEME_ID;
    sInf->Fields[0].AssociatedField = 1;
    //details
    sInf->Fields[1].Name = "details";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_ECC_SCHEME_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ALGORITHM_DETAIL_ECC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ALGORITHM_DETAIL_ECC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ALGORITHM_DETAIL_ECC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(20);
    //curveID
    sInf->Fields[0].Name = "curveID";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //keySize
    sInf->Fields[1].Name = "keySize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //kdfScheme
    sInf->Fields[2].Name = "kdfScheme";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[2].AssociatedField = 3;
    //kdf
    sInf->Fields[3].Name = "kdf";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[3].AssociatedField = 2;
    //signScheme
    sInf->Fields[4].Name = "signScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[4].AssociatedField = 5;
    //sign
    sInf->Fields[5].Name = "sign";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[5].AssociatedField = 4;
    //pSize
    sInf->Fields[6].Name = "pSize";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[6].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //p
    sInf->Fields[7].Name = "p";
    sInf->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[7].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[7].AssociatedField = 6;
    //aSize
    sInf->Fields[8].Name = "aSize";
    sInf->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[8].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[8].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //a
    sInf->Fields[9].Name = "a";
    sInf->Fields[9].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[9].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[9].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[9].AssociatedField = 8;
    //bSize
    sInf->Fields[10].Name = "bSize";
    sInf->Fields[10].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[10].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[10].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //b
    sInf->Fields[11].Name = "b";
    sInf->Fields[11].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[11].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[11].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[11].AssociatedField = 10;
    //gXSize
    sInf->Fields[12].Name = "gXSize";
    sInf->Fields[12].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[12].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[12].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //gX
    sInf->Fields[13].Name = "gX";
    sInf->Fields[13].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[13].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[13].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[13].AssociatedField = 12;
    //gYSize
    sInf->Fields[14].Name = "gYSize";
    sInf->Fields[14].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[14].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[14].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //gY
    sInf->Fields[15].Name = "gY";
    sInf->Fields[15].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[15].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[15].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[15].AssociatedField = 14;
    //nSize
    sInf->Fields[16].Name = "nSize";
    sInf->Fields[16].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[16].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[16].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //n
    sInf->Fields[17].Name = "n";
    sInf->Fields[17].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[17].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[17].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[17].AssociatedField = 16;
    //hSize
    sInf->Fields[18].Name = "hSize";
    sInf->Fields[18].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[18].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[18].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    //h
    sInf->Fields[19].Name = "h";
    sInf->Fields[19].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[19].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[19].ParentType = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[19].AssociatedField = 18;
    
    // ======== TPMS_SIGNATURE_RSA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_RSA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_RSA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    //sigSize
    sInf->Fields[1].Name = "sigSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    //sig
    sInf->Fields[2].Name = "sig";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSA_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_SIGNATURE_RSASSA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSASSA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_RSASSA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_RSASSA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    //sigSize
    sInf->Fields[1].Name = "sigSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    //sig
    sInf->Fields[2].Name = "sig";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_SIGNATURE_RSAPSS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_RSAPSS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_RSAPSS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    //sigSize
    sInf->Fields[1].Name = "sigSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    //sig
    sInf->Fields[2].Name = "sig";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_SIGNATURE_ECC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_ECC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    //signatureRSize
    sInf->Fields[1].Name = "signatureRSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    //signatureR
    sInf->Fields[2].Name = "signatureR";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    sInf->Fields[2].AssociatedField = 1;
    //signatureSSize
    sInf->Fields[3].Name = "signatureSSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    //signatureS
    sInf->Fields[4].Name = "signatureS";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECC_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_ECDSA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECDSA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_ECDSA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECDSA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    //signatureRSize
    sInf->Fields[1].Name = "signatureRSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    //signatureR
    sInf->Fields[2].Name = "signatureR";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->Fields[2].AssociatedField = 1;
    //signatureSSize
    sInf->Fields[3].Name = "signatureSSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    //signatureS
    sInf->Fields[4].Name = "signatureS";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_ECDAA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECDAA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_ECDAA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECDAA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    //signatureRSize
    sInf->Fields[1].Name = "signatureRSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    //signatureR
    sInf->Fields[2].Name = "signatureR";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->Fields[2].AssociatedField = 1;
    //signatureSSize
    sInf->Fields[3].Name = "signatureSSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    //signatureS
    sInf->Fields[4].Name = "signatureS";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_SM2 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_SM2_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_SM2";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_SM2()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    //signatureRSize
    sInf->Fields[1].Name = "signatureRSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    //signatureR
    sInf->Fields[2].Name = "signatureR";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->Fields[2].AssociatedField = 1;
    //signatureSSize
    sInf->Fields[3].Name = "signatureSSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    //signatureS
    sInf->Fields[4].Name = "signatureS";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_SIGNATURE_ECSCHNORR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_SIGNATURE_ECSCHNORR";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_SIGNATURE_ECSCHNORR()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //hash
    sInf->Fields[0].Name = "hash";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    //signatureRSize
    sInf->Fields[1].Name = "signatureRSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    //signatureR
    sInf->Fields[2].Name = "signatureR";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->Fields[2].AssociatedField = 1;
    //signatureSSize
    sInf->Fields[3].Name = "signatureSSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    //signatureS
    sInf->Fields[4].Name = "signatureS";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPMS_NULL_SIGNATURE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NULL_SIGNATURE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NULL_SIGNATURE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NULL_SIGNATURE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPMT_SIGNATURE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_SIGNATURE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_SIGNATURE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SIGNATURE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //sigAlg
    sInf->Fields[0].Name = "sigAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SIGNATURE_ID;
    sInf->Fields[0].AssociatedField = 1;
    //signature
    sInf->Fields[1].Name = "signature";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SIGNATURE_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_ENCRYPTED_SECRET ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_ENCRYPTED_SECRET";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ENCRYPTED_SECRET()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
    //secret
    sInf->Fields[1].Name = "secret";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ENCRYPTED_SECRET_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_KEYEDHASH_PARMS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_KEYEDHASH_PARMS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_KEYEDHASH_PARMS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_KEYEDHASH_PARMS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //schemeScheme
    sInf->Fields[0].Name = "schemeScheme";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    sInf->Fields[0].AssociatedField = 1;
    //scheme
    sInf->Fields[1].Name = "scheme";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ASYM_PARMS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ASYM_PARMS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ASYM_PARMS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ASYM_PARMS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //symmetric
    sInf->Fields[0].Name = "symmetric";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    //schemeScheme
    sInf->Fields[1].Name = "schemeScheme";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    sInf->Fields[1].AssociatedField = 2;
    //scheme
    sInf->Fields[2].Name = "scheme";
    sInf->Fields[2].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionObject;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ASYM_PARMS_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPMS_RSA_PARMS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_RSA_PARMS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_RSA_PARMS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_RSA_PARMS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //symmetric
    sInf->Fields[0].Name = "symmetric";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    //schemeScheme
    sInf->Fields[1].Name = "schemeScheme";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->Fields[1].AssociatedField = 2;
    //scheme
    sInf->Fields[2].Name = "scheme";
    sInf->Fields[2].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionObject;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->Fields[2].AssociatedField = 1;
    //keyBits
    sInf->Fields[3].Name = "keyBits";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    //exponent
    sInf->Fields[4].Name = "exponent";
    sInf->Fields[4].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_RSA_PARMS_ID;
    
    // ======== TPMS_ECC_PARMS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ECC_PARMS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ECC_PARMS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ECC_PARMS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //symmetric
    sInf->Fields[0].Name = "symmetric";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    //schemeScheme
    sInf->Fields[1].Name = "schemeScheme";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[1].AssociatedField = 2;
    //scheme
    sInf->Fields[2].Name = "scheme";
    sInf->Fields[2].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionObject;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[2].AssociatedField = 1;
    //curveID
    sInf->Fields[3].Name = "curveID";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    //kdfScheme
    sInf->Fields[4].Name = "kdfScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[4].AssociatedField = 5;
    //kdf
    sInf->Fields[5].Name = "kdf";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== TPMT_PUBLIC_PARMS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_PUBLIC_PARMS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_PUBLIC_PARMS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_PUBLIC_PARMS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //type
    sInf->Fields[0].Name = "type";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_PUBLIC_PARMS_ID;
    sInf->Fields[0].AssociatedField = 1;
    //parameters
    sInf->Fields[1].Name = "parameters";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_PUBLIC_PARMS_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_PUBLIC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_PUBLIC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_PUBLIC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_PUBLIC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(7);
    //type
    sInf->Fields[0].Name = "type";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[0].AssociatedField = 5;
    //nameAlg
    sInf->Fields[1].Name = "nameAlg";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    //objectAttributes
    sInf->Fields[2].Name = "objectAttributes";
    sInf->Fields[2].TypeId = TpmTypeId::TPMA_OBJECT_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    //authPolicySize
    sInf->Fields[3].Name = "authPolicySize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    //authPolicy
    sInf->Fields[4].Name = "authPolicy";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].AssociatedField = 3;
    //parameters
    sInf->Fields[5].Name = "parameters";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[5].AssociatedField = 0;
    //unique
    sInf->Fields[6].Name = "unique";
    sInf->Fields[6].TypeId = TpmTypeId::TPMU_PUBLIC_ID_ID;
    sInf->Fields[6].MarshalType = MarshalType::UnionObject;
    sInf->Fields[6].ParentType = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[6].AssociatedField = 0;
    
    // ======== TPM2B_PUBLIC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_PUBLIC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_PUBLIC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PUBLIC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PUBLIC_ID;
    //publicArea
    sInf->Fields[1].Name = "publicArea";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PUBLIC_ID;
    
    // ======== TPM2B_TEMPLATE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_TEMPLATE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_TEMPLATE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_TEMPLATE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_TEMPLATE_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_TEMPLATE_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_PRIVATE_VENDOR_SPECIFIC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_PRIVATE_VENDOR_SPECIFIC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PRIVATE_VENDOR_SPECIFIC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMT_SENSITIVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMT_SENSITIVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMT_SENSITIVE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMT_SENSITIVE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //sensitiveType
    sInf->Fields[0].Name = "sensitiveType";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[0].AssociatedField = 5;
    //authValueSize
    sInf->Fields[1].Name = "authValueSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    //authValue
    sInf->Fields[2].Name = "authValue";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[2].AssociatedField = 1;
    //seedValueSize
    sInf->Fields[3].Name = "seedValueSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    //seedValue
    sInf->Fields[4].Name = "seedValue";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[4].AssociatedField = 3;
    //sensitive
    sInf->Fields[5].Name = "sensitive";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[5].AssociatedField = 0;
    
    // ======== TPM2B_SENSITIVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_SENSITIVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_SENSITIVE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_SENSITIVE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_SENSITIVE_ID;
    //sensitiveArea
    sInf->Fields[1].Name = "sensitiveArea";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_SENSITIVE_ID;
    
    // ======== _PRIVATE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::_PRIVATE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "_PRIVATE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new _PRIVATE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //integrityOuterSize
    sInf->Fields[0].Name = "integrityOuterSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::_PRIVATE_ID;
    //integrityOuter
    sInf->Fields[1].Name = "integrityOuter";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[1].AssociatedField = 0;
    //integrityInnerSize
    sInf->Fields[2].Name = "integrityInnerSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::_PRIVATE_ID;
    //integrityInner
    sInf->Fields[3].Name = "integrityInner";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::_PRIVATE_ID;
    sInf->Fields[3].AssociatedField = 2;
    //sensitiveSize
    sInf->Fields[4].Name = "sensitiveSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[4].ParentType = TpmTypeId::_PRIVATE_ID;
    //sensitive
    sInf->Fields[5].Name = "sensitive";
    sInf->Fields[5].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::_PRIVATE_ID;
    
    // ======== TPM2B_PRIVATE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_PRIVATE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_PRIVATE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_PRIVATE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_PRIVATE_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_ID_OBJECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_ID_OBJECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_ID_OBJECT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_ID_OBJECT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //integrityHMACSize
    sInf->Fields[0].Name = "integrityHMACSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    //integrityHMAC
    sInf->Fields[1].Name = "integrityHMAC";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[1].AssociatedField = 0;
    //encIdentity
    sInf->Fields[2].Name = "encIdentity";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::EncryptedVariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_ID_OBJECT_ID;
    
    // ======== TPM2B_ID_OBJECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_ID_OBJECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_ID_OBJECT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_ID_OBJECT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_ID_OBJECT_ID;
    //credential
    sInf->Fields[1].Name = "credential";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_ID_OBJECT_ID;
    
    // ======== TPMS_NV_PIN_COUNTER_PARAMETERS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NV_PIN_COUNTER_PARAMETERS";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_PIN_COUNTER_PARAMETERS()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //pinCount
    sInf->Fields[0].Name = "pinCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
    //pinLimit
    sInf->Fields[1].Name = "pinLimit";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_PIN_COUNTER_PARAMETERS_ID;
    
    // ======== TPMS_NV_PUBLIC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_NV_PUBLIC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_NV_PUBLIC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_NV_PUBLIC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //nvIndex
    sInf->Fields[0].Name = "nvIndex";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //nameAlg
    sInf->Fields[1].Name = "nameAlg";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //attributes
    sInf->Fields[2].Name = "attributes";
    sInf->Fields[2].TypeId = TpmTypeId::TPMA_NV_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //authPolicySize
    sInf->Fields[3].Name = "authPolicySize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    //authPolicy
    sInf->Fields[4].Name = "authPolicy";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[4].AssociatedField = 3;
    //dataSize
    sInf->Fields[5].Name = "dataSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_NV_PUBLIC_ID;
    
    // ======== TPM2B_NV_PUBLIC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_NV_PUBLIC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_NV_PUBLIC";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_NV_PUBLIC()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_NV_PUBLIC_ID;
    //nvPublic
    sInf->Fields[1].Name = "nvPublic";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_NV_PUBLIC_ID;
    
    // ======== TPM2B_CONTEXT_SENSITIVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_CONTEXT_SENSITIVE";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_CONTEXT_SENSITIVE()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_CONTEXT_SENSITIVE_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMS_CONTEXT_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CONTEXT_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CONTEXT_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CONTEXT_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //integritySize
    sInf->Fields[0].Name = "integritySize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    //integrity
    sInf->Fields[1].Name = "integrity";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[1].AssociatedField = 0;
    //encrypted
    sInf->Fields[2].Name = "encrypted";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::EncryptedVariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    
    // ======== TPM2B_CONTEXT_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_CONTEXT_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_CONTEXT_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_CONTEXT_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_CONTEXT_DATA_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_CONTEXT_DATA_ID;
    
    // ======== TPMS_CONTEXT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CONTEXT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CONTEXT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CONTEXT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //sequence
    sInf->Fields[0].Name = "sequence";
    sInf->Fields[0].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //savedHandle
    sInf->Fields[1].Name = "savedHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //hierarchy
    sInf->Fields[2].Name = "hierarchy";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //contextBlobSize
    sInf->Fields[3].Name = "contextBlobSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    //contextBlob
    sInf->Fields[4].Name = "contextBlob";
    sInf->Fields[4].TypeId = TpmTypeId::TPMS_CONTEXT_DATA_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_CONTEXT_ID;
    
    // ======== TPMS_CREATION_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_CREATION_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_CREATION_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_CREATION_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(12);
    //pcrSelectCount
    sInf->Fields[0].Name = "pcrSelectCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //pcrSelect
    sInf->Fields[1].Name = "pcrSelect";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[1].AssociatedField = 0;
    //pcrDigestSize
    sInf->Fields[2].Name = "pcrDigestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //pcrDigest
    sInf->Fields[3].Name = "pcrDigest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[3].AssociatedField = 2;
    //locality
    sInf->Fields[4].Name = "locality";
    sInf->Fields[4].TypeId = TpmTypeId::TPMA_LOCALITY_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentNameAlg
    sInf->Fields[5].Name = "parentNameAlg";
    sInf->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentNameSize
    sInf->Fields[6].Name = "parentNameSize";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[6].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentName
    sInf->Fields[7].Name = "parentName";
    sInf->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[7].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[7].AssociatedField = 6;
    //parentQualifiedNameSize
    sInf->Fields[8].Name = "parentQualifiedNameSize";
    sInf->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[8].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[8].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //parentQualifiedName
    sInf->Fields[9].Name = "parentQualifiedName";
    sInf->Fields[9].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[9].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[9].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[9].AssociatedField = 8;
    //outsideInfoSize
    sInf->Fields[10].Name = "outsideInfoSize";
    sInf->Fields[10].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[10].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[10].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    //outsideInfo
    sInf->Fields[11].Name = "outsideInfo";
    sInf->Fields[11].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[11].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[11].ParentType = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[11].AssociatedField = 10;
    
    // ======== TPM2B_CREATION_DATA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_CREATION_DATA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_CREATION_DATA";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_CREATION_DATA()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_CREATION_DATA_ID;
    //creationData
    sInf->Fields[1].Name = "creationData";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_CREATION_DATA_ID;
    
    // ======== TPMS_AC_OUTPUT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMS_AC_OUTPUT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPMS_AC_OUTPUT";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPMS_AC_OUTPUT()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //tag
    sInf->Fields[0].Name = "tag";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_AT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    //data
    sInf->Fields[1].Name = "data";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPMS_AC_OUTPUT_ID;
    
    // ======== TPML_AC_CAPABILITIES ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPML_AC_CAPABILITIES_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPML_AC_CAPABILITIES";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPML_AC_CAPABILITIES()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //count
    sInf->Fields[0].Name = "count";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPML_AC_CAPABILITIES_ID;
    //acCapabilities
    sInf->Fields[1].Name = "acCapabilities";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPML_AC_CAPABILITIES_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_Startup_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Startup_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Startup_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Startup_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //startupType
    sInf->Fields[0].Name = "startupType";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_SU_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Startup_REQUEST_ID;
    
    // ======== StartupResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::StartupResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "StartupResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new StartupResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_Shutdown_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Shutdown_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Shutdown_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Shutdown_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //shutdownType
    sInf->Fields[0].Name = "shutdownType";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_SU_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Shutdown_REQUEST_ID;
    
    // ======== ShutdownResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ShutdownResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ShutdownResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ShutdownResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_SelfTest_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_SelfTest_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_SelfTest_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SelfTest_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //fullTest
    sInf->Fields[0].Name = "fullTest";
    sInf->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SelfTest_REQUEST_ID;
    
    // ======== SelfTestResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SelfTestResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SelfTestResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SelfTestResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_IncrementalSelfTest_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_IncrementalSelfTest_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_IncrementalSelfTest_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //toTestCount
    sInf->Fields[0].Name = "toTestCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
    //toTest
    sInf->Fields[1].Name = "toTest";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_IncrementalSelfTest_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== IncrementalSelfTestResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::IncrementalSelfTestResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "IncrementalSelfTestResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new IncrementalSelfTestResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //toDoListCount
    sInf->Fields[0].Name = "toDoListCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::IncrementalSelfTestResponse_ID;
    //toDoList
    sInf->Fields[1].Name = "toDoList";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::IncrementalSelfTestResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_GetTestResult_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_GetTestResult_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_GetTestResult_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetTestResult_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== GetTestResultResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::GetTestResultResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "GetTestResultResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetTestResultResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //outDataSize
    sInf->Fields[0].Name = "outDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::GetTestResultResponse_ID;
    //outData
    sInf->Fields[1].Name = "outData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::GetTestResultResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //testResult
    sInf->Fields[2].Name = "testResult";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_RC_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::GetTestResultResponse_ID;
    
    // ======== TPM2_StartAuthSession_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_StartAuthSession_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_StartAuthSession_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_StartAuthSession_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(9);
    //tpmKey
    sInf->Fields[0].Name = "tpmKey";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //bind
    sInf->Fields[1].Name = "bind";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //nonceCallerSize
    sInf->Fields[2].Name = "nonceCallerSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //nonceCaller
    sInf->Fields[3].Name = "nonceCaller";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //encryptedSaltSize
    sInf->Fields[4].Name = "encryptedSaltSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //encryptedSalt
    sInf->Fields[5].Name = "encryptedSalt";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    //sessionType
    sInf->Fields[6].Name = "sessionType";
    sInf->Fields[6].TypeId = TpmTypeId::TPM_SE_ID;
    sInf->Fields[6].MarshalType = MarshalType::Normal;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //symmetric
    sInf->Fields[7].Name = "symmetric";
    sInf->Fields[7].TypeId = TpmTypeId::TPMT_SYM_DEF_ID;
    sInf->Fields[7].MarshalType = MarshalType::Normal;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    //authHash
    sInf->Fields[8].Name = "authHash";
    sInf->Fields[8].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[8].MarshalType = MarshalType::Normal;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_StartAuthSession_REQUEST_ID;
    
    // ======== StartAuthSessionResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::StartAuthSessionResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "StartAuthSessionResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new StartAuthSessionResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    //nonceTPMSize
    sInf->Fields[1].Name = "nonceTPMSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    //nonceTPM
    sInf->Fields[2].Name = "nonceTPM";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::StartAuthSessionResponse_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_PolicyRestart_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyRestart_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyRestart_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyRestart_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //sessionHandle
    sInf->Fields[0].Name = "sessionHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyRestart_REQUEST_ID;
    
    // ======== PolicyRestartResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyRestartResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyRestartResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyRestartResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_Create_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Create_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Create_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Create_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(9);
    //parentHandle
    sInf->Fields[0].Name = "parentHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inSensitiveSize
    sInf->Fields[1].Name = "inSensitiveSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inSensitive
    sInf->Fields[2].Name = "inSensitive";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inPublicSize
    sInf->Fields[3].Name = "inPublicSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //inPublic
    sInf->Fields[4].Name = "inPublic";
    sInf->Fields[4].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //outsideInfoSize
    sInf->Fields[5].Name = "outsideInfoSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //outsideInfo
    sInf->Fields[6].Name = "outsideInfo";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    //creationPCRCount
    sInf->Fields[7].Name = "creationPCRCount";
    sInf->Fields[7].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[7].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    //creationPCR
    sInf->Fields[8].Name = "creationPCR";
    sInf->Fields[8].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[8].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_Create_REQUEST_ID;
    sInf->Fields[8].AssociatedField = 7;
    
    // ======== CreateResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CreateResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CreateResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CreateResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(8);
    //outPrivate
    sInf->Fields[0].Name = "outPrivate";
    sInf->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::CreateResponse_ID;
    //outPublicSize
    sInf->Fields[1].Name = "outPublicSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::CreateResponse_ID;
    //outPublic
    sInf->Fields[2].Name = "outPublic";
    sInf->Fields[2].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::CreateResponse_ID;
    //creationDataSize
    sInf->Fields[3].Name = "creationDataSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::CreateResponse_ID;
    //creationData
    sInf->Fields[4].Name = "creationData";
    sInf->Fields[4].TypeId = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::CreateResponse_ID;
    //creationHashSize
    sInf->Fields[5].Name = "creationHashSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::CreateResponse_ID;
    //creationHash
    sInf->Fields[6].Name = "creationHash";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::CreateResponse_ID;
    sInf->Fields[6].AssociatedField = 5;
    //creationTicket
    sInf->Fields[7].Name = "creationTicket";
    sInf->Fields[7].TypeId = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[7].MarshalType = MarshalType::Normal;
    sInf->Fields[7].ParentType = TpmTypeId::CreateResponse_ID;
    
    // ======== TPM2_Load_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Load_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Load_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Load_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //parentHandle
    sInf->Fields[0].Name = "parentHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    //inPrivate
    sInf->Fields[1].Name = "inPrivate";
    sInf->Fields[1].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    //inPublicSize
    sInf->Fields[2].Name = "inPublicSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    //inPublic
    sInf->Fields[3].Name = "inPublic";
    sInf->Fields[3].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Load_REQUEST_ID;
    
    // ======== LoadResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::LoadResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "LoadResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new LoadResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::LoadResponse_ID;
    //nameSize
    sInf->Fields[1].Name = "nameSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::LoadResponse_ID;
    //name
    sInf->Fields[2].Name = "name";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::LoadResponse_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_LoadExternal_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_LoadExternal_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_LoadExternal_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_LoadExternal_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //inPrivateSize
    sInf->Fields[0].Name = "inPrivateSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //inPrivate
    sInf->Fields[1].Name = "inPrivate";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //inPublicSize
    sInf->Fields[2].Name = "inPublicSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //inPublic
    sInf->Fields[3].Name = "inPublic";
    sInf->Fields[3].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    //hierarchy
    sInf->Fields[4].Name = "hierarchy";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_LoadExternal_REQUEST_ID;
    
    // ======== LoadExternalResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::LoadExternalResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "LoadExternalResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new LoadExternalResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::LoadExternalResponse_ID;
    //nameSize
    sInf->Fields[1].Name = "nameSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::LoadExternalResponse_ID;
    //name
    sInf->Fields[2].Name = "name";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::LoadExternalResponse_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_ReadPublic_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ReadPublic_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ReadPublic_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ReadPublic_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //objectHandle
    sInf->Fields[0].Name = "objectHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ReadPublic_REQUEST_ID;
    
    // ======== ReadPublicResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ReadPublicResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ReadPublicResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ReadPublicResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //outPublicSize
    sInf->Fields[0].Name = "outPublicSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //outPublic
    sInf->Fields[1].Name = "outPublic";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //nameSize
    sInf->Fields[2].Name = "nameSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //name
    sInf->Fields[3].Name = "name";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    //qualifiedNameSize
    sInf->Fields[4].Name = "qualifiedNameSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::ReadPublicResponse_ID;
    //qualifiedName
    sInf->Fields[5].Name = "qualifiedName";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::ReadPublicResponse_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_ActivateCredential_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ActivateCredential_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ActivateCredential_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ActivateCredential_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(6);
    //activateHandle
    sInf->Fields[0].Name = "activateHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //keyHandle
    sInf->Fields[1].Name = "keyHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //credentialBlobSize
    sInf->Fields[2].Name = "credentialBlobSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //credentialBlob
    sInf->Fields[3].Name = "credentialBlob";
    sInf->Fields[3].TypeId = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //secretSize
    sInf->Fields[4].Name = "secretSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    //secret
    sInf->Fields[5].Name = "secret";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_ActivateCredential_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== ActivateCredentialResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ActivateCredentialResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ActivateCredentialResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ActivateCredentialResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //certInfoSize
    sInf->Fields[0].Name = "certInfoSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::ActivateCredentialResponse_ID;
    //certInfo
    sInf->Fields[1].Name = "certInfo";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::ActivateCredentialResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_MakeCredential_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_MakeCredential_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_MakeCredential_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_MakeCredential_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    //credentialSize
    sInf->Fields[1].Name = "credentialSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    //credential
    sInf->Fields[2].Name = "credential";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //objectNameSize
    sInf->Fields[3].Name = "objectNameSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    //objectName
    sInf->Fields[4].Name = "objectName";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_MakeCredential_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== MakeCredentialResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::MakeCredentialResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "MakeCredentialResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new MakeCredentialResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //credentialBlobSize
    sInf->Fields[0].Name = "credentialBlobSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    //credentialBlob
    sInf->Fields[1].Name = "credentialBlob";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ID_OBJECT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    //secretSize
    sInf->Fields[2].Name = "secretSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    //secret
    sInf->Fields[3].Name = "secret";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::MakeCredentialResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_Unseal_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Unseal_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Unseal_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Unseal_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(1);
    //itemHandle
    sInf->Fields[0].Name = "itemHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Unseal_REQUEST_ID;
    
    // ======== UnsealResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::UnsealResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "UnsealResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new UnsealResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //outDataSize
    sInf->Fields[0].Name = "outDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::UnsealResponse_ID;
    //outData
    sInf->Fields[1].Name = "outData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::UnsealResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_ObjectChangeAuth_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ObjectChangeAuth_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ObjectChangeAuth_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //objectHandle
    sInf->Fields[0].Name = "objectHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    //parentHandle
    sInf->Fields[1].Name = "parentHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    //newAuthSize
    sInf->Fields[2].Name = "newAuthSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    //newAuth
    sInf->Fields[3].Name = "newAuth";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ObjectChangeAuth_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== ObjectChangeAuthResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ObjectChangeAuthResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ObjectChangeAuthResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ObjectChangeAuthResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //outPrivate
    sInf->Fields[0].Name = "outPrivate";
    sInf->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::ObjectChangeAuthResponse_ID;
    
    // ======== TPM2_CreateLoaded_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_CreateLoaded_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_CreateLoaded_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CreateLoaded_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(5);
    //parentHandle
    sInf->Fields[0].Name = "parentHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inSensitiveSize
    sInf->Fields[1].Name = "inSensitiveSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inSensitive
    sInf->Fields[2].Name = "inSensitive";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inPublicSize
    sInf->Fields[3].Name = "inPublicSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    //inPublic
    sInf->Fields[4].Name = "inPublic";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CreateLoaded_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== CreateLoadedResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CreateLoadedResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CreateLoadedResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CreateLoadedResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //outPrivate
    sInf->Fields[1].Name = "outPrivate";
    sInf->Fields[1].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //outPublicSize
    sInf->Fields[2].Name = "outPublicSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[2].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //outPublic
    sInf->Fields[3].Name = "outPublic";
    sInf->Fields[3].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //nameSize
    sInf->Fields[4].Name = "nameSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    //name
    sInf->Fields[5].Name = "name";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::CreateLoadedResponse_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_Duplicate_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Duplicate_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Duplicate_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Duplicate_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(5);
    //objectHandle
    sInf->Fields[0].Name = "objectHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    //newParentHandle
    sInf->Fields[1].Name = "newParentHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    //encryptionKeyInSize
    sInf->Fields[2].Name = "encryptionKeyInSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    //encryptionKeyIn
    sInf->Fields[3].Name = "encryptionKeyIn";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //symmetricAlg
    sInf->Fields[4].Name = "symmetricAlg";
    sInf->Fields[4].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Duplicate_REQUEST_ID;
    
    // ======== DuplicateResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::DuplicateResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "DuplicateResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new DuplicateResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //encryptionKeyOutSize
    sInf->Fields[0].Name = "encryptionKeyOutSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::DuplicateResponse_ID;
    //encryptionKeyOut
    sInf->Fields[1].Name = "encryptionKeyOut";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::DuplicateResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //duplicate
    sInf->Fields[2].Name = "duplicate";
    sInf->Fields[2].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::DuplicateResponse_ID;
    //outSymSeedSize
    sInf->Fields[3].Name = "outSymSeedSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::DuplicateResponse_ID;
    //outSymSeed
    sInf->Fields[4].Name = "outSymSeed";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::DuplicateResponse_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPM2_Rewrap_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Rewrap_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Rewrap_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Rewrap_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //oldParent
    sInf->Fields[0].Name = "oldParent";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //newParent
    sInf->Fields[1].Name = "newParent";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //inDuplicate
    sInf->Fields[2].Name = "inDuplicate";
    sInf->Fields[2].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //nameSize
    sInf->Fields[3].Name = "nameSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //name
    sInf->Fields[4].Name = "name";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //inSymSeedSize
    sInf->Fields[5].Name = "inSymSeedSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    //inSymSeed
    sInf->Fields[6].Name = "inSymSeed";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Rewrap_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== RewrapResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::RewrapResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "RewrapResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new RewrapResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //outDuplicate
    sInf->Fields[0].Name = "outDuplicate";
    sInf->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::RewrapResponse_ID;
    //outSymSeedSize
    sInf->Fields[1].Name = "outSymSeedSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::RewrapResponse_ID;
    //outSymSeed
    sInf->Fields[2].Name = "outSymSeed";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::RewrapResponse_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_Import_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Import_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Import_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Import_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(9);
    //parentHandle
    sInf->Fields[0].Name = "parentHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //encryptionKeySize
    sInf->Fields[1].Name = "encryptionKeySize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //encryptionKey
    sInf->Fields[2].Name = "encryptionKey";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //objectPublicSize
    sInf->Fields[3].Name = "objectPublicSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //objectPublic
    sInf->Fields[4].Name = "objectPublic";
    sInf->Fields[4].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //duplicate
    sInf->Fields[5].Name = "duplicate";
    sInf->Fields[5].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //inSymSeedSize
    sInf->Fields[6].Name = "inSymSeedSize";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    //inSymSeed
    sInf->Fields[7].Name = "inSymSeed";
    sInf->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    sInf->Fields[7].AssociatedField = 6;
    //symmetricAlg
    sInf->Fields[8].Name = "symmetricAlg";
    sInf->Fields[8].TypeId = TpmTypeId::TPMT_SYM_DEF_OBJECT_ID;
    sInf->Fields[8].MarshalType = MarshalType::Normal;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_Import_REQUEST_ID;
    
    // ======== ImportResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ImportResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ImportResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ImportResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //outPrivate
    sInf->Fields[0].Name = "outPrivate";
    sInf->Fields[0].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::ImportResponse_ID;
    
    // ======== TPM2_RSA_Encrypt_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_RSA_Encrypt_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_RSA_Encrypt_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(7);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    //messageSize
    sInf->Fields[1].Name = "messageSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    //message
    sInf->Fields[2].Name = "message";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    sInf->Fields[3].Name = "inSchemeScheme";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 4;
    //inScheme
    sInf->Fields[4].Name = "inScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionObject;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //labelSize
    sInf->Fields[5].Name = "labelSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    //label
    sInf->Fields[6].Name = "label";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_RSA_Encrypt_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== RSA_EncryptResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::RSA_EncryptResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "RSA_EncryptResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new RSA_EncryptResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //outDataSize
    sInf->Fields[0].Name = "outDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::RSA_EncryptResponse_ID;
    //outData
    sInf->Fields[1].Name = "outData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::RSA_EncryptResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_RSA_Decrypt_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_RSA_Decrypt_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_RSA_Decrypt_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    //cipherTextSize
    sInf->Fields[1].Name = "cipherTextSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    //cipherText
    sInf->Fields[2].Name = "cipherText";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    sInf->Fields[3].Name = "inSchemeScheme";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 4;
    //inScheme
    sInf->Fields[4].Name = "inScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPMU_ASYM_SCHEME_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionObject;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //labelSize
    sInf->Fields[5].Name = "labelSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    //label
    sInf->Fields[6].Name = "label";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_RSA_Decrypt_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== RSA_DecryptResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::RSA_DecryptResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "RSA_DecryptResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new RSA_DecryptResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //messageSize
    sInf->Fields[0].Name = "messageSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::RSA_DecryptResponse_ID;
    //message
    sInf->Fields[1].Name = "message";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::RSA_DecryptResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_ECDH_KeyGen_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ECDH_KeyGen_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECDH_KeyGen_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECDH_KeyGen_REQUEST_ID;
    
    // ======== ECDH_KeyGenResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ECDH_KeyGenResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ECDH_KeyGenResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECDH_KeyGenResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //zPointSize
    sInf->Fields[0].Name = "zPointSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    //zPoint
    sInf->Fields[1].Name = "zPoint";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    //pubPointSize
    sInf->Fields[2].Name = "pubPointSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[2].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    //pubPoint
    sInf->Fields[3].Name = "pubPoint";
    sInf->Fields[3].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::ECDH_KeyGenResponse_ID;
    
    // ======== TPM2_ECDH_ZGen_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ECDH_ZGen_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECDH_ZGen_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    //inPointSize
    sInf->Fields[1].Name = "inPointSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    //inPoint
    sInf->Fields[2].Name = "inPoint";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ECDH_ZGen_REQUEST_ID;
    
    // ======== ECDH_ZGenResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ECDH_ZGenResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ECDH_ZGenResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECDH_ZGenResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //outPointSize
    sInf->Fields[0].Name = "outPointSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::ECDH_ZGenResponse_ID;
    //outPoint
    sInf->Fields[1].Name = "outPoint";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::ECDH_ZGenResponse_ID;
    
    // ======== TPM2_ECC_Parameters_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ECC_Parameters_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECC_Parameters_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //curveID
    sInf->Fields[0].Name = "curveID";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECC_Parameters_REQUEST_ID;
    
    // ======== ECC_ParametersResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ECC_ParametersResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ECC_ParametersResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECC_ParametersResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //parameters
    sInf->Fields[0].Name = "parameters";
    sInf->Fields[0].TypeId = TpmTypeId::TPMS_ALGORITHM_DETAIL_ECC_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::ECC_ParametersResponse_ID;
    
    // ======== TPM2_ZGen_2Phase_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ZGen_2Phase_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ZGen_2Phase_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //keyA
    sInf->Fields[0].Name = "keyA";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQsBSize
    sInf->Fields[1].Name = "inQsBSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQsB
    sInf->Fields[2].Name = "inQsB";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQeBSize
    sInf->Fields[3].Name = "inQeBSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inQeB
    sInf->Fields[4].Name = "inQeB";
    sInf->Fields[4].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //inScheme
    sInf->Fields[5].Name = "inScheme";
    sInf->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    //counter
    sInf->Fields[6].Name = "counter";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::Normal;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_ZGen_2Phase_REQUEST_ID;
    
    // ======== ZGen_2PhaseResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ZGen_2PhaseResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ZGen_2PhaseResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ZGen_2PhaseResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //outZ1Size
    sInf->Fields[0].Name = "outZ1Size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    //outZ1
    sInf->Fields[1].Name = "outZ1";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    //outZ2Size
    sInf->Fields[2].Name = "outZ2Size";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[2].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    //outZ2
    sInf->Fields[3].Name = "outZ2";
    sInf->Fields[3].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::ZGen_2PhaseResponse_ID;
    
    // ======== TPM2_ECC_Encrypt_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ECC_Encrypt_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECC_Encrypt_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    //plainTextSize
    sInf->Fields[1].Name = "plainTextSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    //plainText
    sInf->Fields[2].Name = "plainText";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    sInf->Fields[3].Name = "inSchemeScheme";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 4;
    //inScheme
    sInf->Fields[4].Name = "inScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionObject;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_ECC_Encrypt_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== ECC_EncryptResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ECC_EncryptResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ECC_EncryptResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECC_EncryptResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //C1Size
    sInf->Fields[0].Name = "C1Size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C1
    sInf->Fields[1].Name = "C1";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C2Size
    sInf->Fields[2].Name = "C2Size";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C2
    sInf->Fields[3].Name = "C2";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    //C3Size
    sInf->Fields[4].Name = "C3Size";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    //C3
    sInf->Fields[5].Name = "C3";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::ECC_EncryptResponse_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_ECC_Decrypt_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ECC_Decrypt_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ECC_Decrypt_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(9);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C1Size
    sInf->Fields[1].Name = "C1Size";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C1
    sInf->Fields[2].Name = "C1";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C2Size
    sInf->Fields[3].Name = "C2Size";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C2
    sInf->Fields[4].Name = "C2";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //C3Size
    sInf->Fields[5].Name = "C3Size";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    //C3
    sInf->Fields[6].Name = "C3";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    //inSchemeScheme
    sInf->Fields[7].Name = "inSchemeScheme";
    sInf->Fields[7].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[7].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    sInf->Fields[7].AssociatedField = 8;
    //inScheme
    sInf->Fields[8].Name = "inScheme";
    sInf->Fields[8].TypeId = TpmTypeId::TPMU_KDF_SCHEME_ID;
    sInf->Fields[8].MarshalType = MarshalType::UnionObject;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_ECC_Decrypt_REQUEST_ID;
    sInf->Fields[8].AssociatedField = 7;
    
    // ======== ECC_DecryptResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ECC_DecryptResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ECC_DecryptResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ECC_DecryptResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //plainTextSize
    sInf->Fields[0].Name = "plainTextSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::ECC_DecryptResponse_ID;
    //plainText
    sInf->Fields[1].Name = "plainText";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::ECC_DecryptResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_EncryptDecrypt_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_EncryptDecrypt_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EncryptDecrypt_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //decrypt
    sInf->Fields[1].Name = "decrypt";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //mode
    sInf->Fields[2].Name = "mode";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //ivInSize
    sInf->Fields[3].Name = "ivInSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //ivIn
    sInf->Fields[4].Name = "ivIn";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //inDataSize
    sInf->Fields[5].Name = "inDataSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    //inData
    sInf->Fields[6].Name = "inData";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_EncryptDecrypt_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== EncryptDecryptResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::EncryptDecryptResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "EncryptDecryptResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EncryptDecryptResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //outDataSize
    sInf->Fields[0].Name = "outDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    //outData
    sInf->Fields[1].Name = "outData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //ivOutSize
    sInf->Fields[2].Name = "ivOutSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    //ivOut
    sInf->Fields[3].Name = "ivOut";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::EncryptDecryptResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_EncryptDecrypt2_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_EncryptDecrypt2_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EncryptDecrypt2_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //inDataSize
    sInf->Fields[1].Name = "inDataSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //inData
    sInf->Fields[2].Name = "inData";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //decrypt
    sInf->Fields[3].Name = "decrypt";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //mode
    sInf->Fields[4].Name = "mode";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //ivInSize
    sInf->Fields[5].Name = "ivInSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    //ivIn
    sInf->Fields[6].Name = "ivIn";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_EncryptDecrypt2_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== EncryptDecrypt2Response ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::EncryptDecrypt2Response_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "EncryptDecrypt2Response";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EncryptDecrypt2Response()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //outDataSize
    sInf->Fields[0].Name = "outDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    //outData
    sInf->Fields[1].Name = "outData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    sInf->Fields[1].AssociatedField = 0;
    //ivOutSize
    sInf->Fields[2].Name = "ivOutSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    //ivOut
    sInf->Fields[3].Name = "ivOut";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::EncryptDecrypt2Response_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_Hash_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Hash_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Hash_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Hash_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //dataSize
    sInf->Fields[0].Name = "dataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    //data
    sInf->Fields[1].Name = "data";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    //hashAlg
    sInf->Fields[2].Name = "hashAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    //hierarchy
    sInf->Fields[3].Name = "hierarchy";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Hash_REQUEST_ID;
    
    // ======== HashResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::HashResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "HashResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HashResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //outHashSize
    sInf->Fields[0].Name = "outHashSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::HashResponse_ID;
    //outHash
    sInf->Fields[1].Name = "outHash";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::HashResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //validation
    sInf->Fields[2].Name = "validation";
    sInf->Fields[2].TypeId = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::HashResponse_ID;
    
    // ======== TPM2_HMAC_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_HMAC_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_HMAC_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HMAC_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    //bufferSize
    sInf->Fields[1].Name = "bufferSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    //buffer
    sInf->Fields[2].Name = "buffer";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //hashAlg
    sInf->Fields[3].Name = "hashAlg";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_HMAC_REQUEST_ID;
    
    // ======== HMACResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::HMACResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "HMACResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HMACResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //outHMACSize
    sInf->Fields[0].Name = "outHMACSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::HMACResponse_ID;
    //outHMAC
    sInf->Fields[1].Name = "outHMAC";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::HMACResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_MAC_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_MAC_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_MAC_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_MAC_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    //bufferSize
    sInf->Fields[1].Name = "bufferSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    //buffer
    sInf->Fields[2].Name = "buffer";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //inScheme
    sInf->Fields[3].Name = "inScheme";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_MAC_REQUEST_ID;
    
    // ======== MACResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::MACResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "MACResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new MACResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //outMACSize
    sInf->Fields[0].Name = "outMACSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::MACResponse_ID;
    //outMAC
    sInf->Fields[1].Name = "outMAC";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::MACResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_GetRandom_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_GetRandom_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_GetRandom_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetRandom_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //bytesRequested
    sInf->Fields[0].Name = "bytesRequested";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetRandom_REQUEST_ID;
    
    // ======== GetRandomResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::GetRandomResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "GetRandomResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetRandomResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //randomBytesSize
    sInf->Fields[0].Name = "randomBytesSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::GetRandomResponse_ID;
    //randomBytes
    sInf->Fields[1].Name = "randomBytes";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::GetRandomResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_StirRandom_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_StirRandom_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_StirRandom_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_StirRandom_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //inDataSize
    sInf->Fields[0].Name = "inDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_StirRandom_REQUEST_ID;
    //inData
    sInf->Fields[1].Name = "inData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_StirRandom_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== StirRandomResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::StirRandomResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "StirRandomResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new StirRandomResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_HMAC_Start_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_HMAC_Start_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_HMAC_Start_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HMAC_Start_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    //authSize
    sInf->Fields[1].Name = "authSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    //auth
    sInf->Fields[2].Name = "auth";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //hashAlg
    sInf->Fields[3].Name = "hashAlg";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_HMAC_Start_REQUEST_ID;
    
    // ======== HMAC_StartResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::HMAC_StartResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "HMAC_StartResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HMAC_StartResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::HMAC_StartResponse_ID;
    
    // ======== TPM2_MAC_Start_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_MAC_Start_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_MAC_Start_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_MAC_Start_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    //authSize
    sInf->Fields[1].Name = "authSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    //auth
    sInf->Fields[2].Name = "auth";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //inScheme
    sInf->Fields[3].Name = "inScheme";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_MAC_Start_REQUEST_ID;
    
    // ======== MAC_StartResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::MAC_StartResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "MAC_StartResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new MAC_StartResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::MAC_StartResponse_ID;
    
    // ======== TPM2_HashSequenceStart_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_HashSequenceStart_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HashSequenceStart_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //authSize
    sInf->Fields[0].Name = "authSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    //auth
    sInf->Fields[1].Name = "auth";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    //hashAlg
    sInf->Fields[2].Name = "hashAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HashSequenceStart_REQUEST_ID;
    
    // ======== HashSequenceStartResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::HashSequenceStartResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "HashSequenceStartResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HashSequenceStartResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::HashSequenceStartResponse_ID;
    
    // ======== TPM2_SequenceUpdate_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_SequenceUpdate_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SequenceUpdate_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //sequenceHandle
    sInf->Fields[0].Name = "sequenceHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    //bufferSize
    sInf->Fields[1].Name = "bufferSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    //buffer
    sInf->Fields[2].Name = "buffer";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SequenceUpdate_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== SequenceUpdateResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SequenceUpdateResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SequenceUpdateResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SequenceUpdateResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_SequenceComplete_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_SequenceComplete_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_SequenceComplete_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SequenceComplete_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //sequenceHandle
    sInf->Fields[0].Name = "sequenceHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    //bufferSize
    sInf->Fields[1].Name = "bufferSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    //buffer
    sInf->Fields[2].Name = "buffer";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //hierarchy
    sInf->Fields[3].Name = "hierarchy";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_SequenceComplete_REQUEST_ID;
    
    // ======== SequenceCompleteResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SequenceCompleteResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SequenceCompleteResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SequenceCompleteResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //resultSize
    sInf->Fields[0].Name = "resultSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    //result
    sInf->Fields[1].Name = "result";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //validation
    sInf->Fields[2].Name = "validation";
    sInf->Fields[2].TypeId = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::SequenceCompleteResponse_ID;
    
    // ======== TPM2_EventSequenceComplete_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_EventSequenceComplete_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EventSequenceComplete_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(4);
    //pcrHandle
    sInf->Fields[0].Name = "pcrHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    //sequenceHandle
    sInf->Fields[1].Name = "sequenceHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    //bufferSize
    sInf->Fields[2].Name = "bufferSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    //buffer
    sInf->Fields[3].Name = "buffer";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_EventSequenceComplete_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== EventSequenceCompleteResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::EventSequenceCompleteResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "EventSequenceCompleteResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EventSequenceCompleteResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //resultsCount
    sInf->Fields[0].Name = "resultsCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::EventSequenceCompleteResponse_ID;
    //results
    sInf->Fields[1].Name = "results";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::EventSequenceCompleteResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_Certify_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Certify_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Certify_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Certify_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(6);
    //objectHandle
    sInf->Fields[0].Name = "objectHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    //signHandle
    sInf->Fields[1].Name = "signHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    //qualifyingDataSize
    sInf->Fields[2].Name = "qualifyingDataSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    //qualifyingData
    sInf->Fields[3].Name = "qualifyingData";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    sInf->Fields[4].Name = "inSchemeScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 5;
    //inScheme
    sInf->Fields[5].Name = "inScheme";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Certify_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== CertifyResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CertifyResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CertifyResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CertifyResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //certifyInfoSize
    sInf->Fields[0].Name = "certifyInfoSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::CertifyResponse_ID;
    //certifyInfo
    sInf->Fields[1].Name = "certifyInfo";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::CertifyResponse_ID;
    //signatureSigAlg
    sInf->Fields[2].Name = "signatureSigAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::CertifyResponse_ID;
    sInf->Fields[2].AssociatedField = 3;
    //signature
    sInf->Fields[3].Name = "signature";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::CertifyResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_CertifyCreation_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_CertifyCreation_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_CertifyCreation_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CertifyCreation_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(9);
    //signHandle
    sInf->Fields[0].Name = "signHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //objectHandle
    sInf->Fields[1].Name = "objectHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //qualifyingDataSize
    sInf->Fields[2].Name = "qualifyingDataSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //qualifyingData
    sInf->Fields[3].Name = "qualifyingData";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //creationHashSize
    sInf->Fields[4].Name = "creationHashSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    //creationHash
    sInf->Fields[5].Name = "creationHash";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    //inSchemeScheme
    sInf->Fields[6].Name = "inSchemeScheme";
    sInf->Fields[6].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[6].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 7;
    //inScheme
    sInf->Fields[7].Name = "inScheme";
    sInf->Fields[7].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[7].MarshalType = MarshalType::UnionObject;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    sInf->Fields[7].AssociatedField = 6;
    //creationTicket
    sInf->Fields[8].Name = "creationTicket";
    sInf->Fields[8].TypeId = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[8].MarshalType = MarshalType::Normal;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_CertifyCreation_REQUEST_ID;
    
    // ======== CertifyCreationResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CertifyCreationResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CertifyCreationResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CertifyCreationResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //certifyInfoSize
    sInf->Fields[0].Name = "certifyInfoSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    //certifyInfo
    sInf->Fields[1].Name = "certifyInfo";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    //signatureSigAlg
    sInf->Fields[2].Name = "signatureSigAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    sInf->Fields[2].AssociatedField = 3;
    //signature
    sInf->Fields[3].Name = "signature";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::CertifyCreationResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_Quote_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Quote_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Quote_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Quote_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //signHandle
    sInf->Fields[0].Name = "signHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    //qualifyingDataSize
    sInf->Fields[1].Name = "qualifyingDataSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    //qualifyingData
    sInf->Fields[2].Name = "qualifyingData";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    sInf->Fields[3].Name = "inSchemeScheme";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 4;
    //inScheme
    sInf->Fields[4].Name = "inScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionObject;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //PCRselectCount
    sInf->Fields[5].Name = "PCRselectCount";
    sInf->Fields[5].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    //PCRselect
    sInf->Fields[6].Name = "PCRselect";
    sInf->Fields[6].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Quote_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== QuoteResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::QuoteResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "QuoteResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new QuoteResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //quotedSize
    sInf->Fields[0].Name = "quotedSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::QuoteResponse_ID;
    //quoted
    sInf->Fields[1].Name = "quoted";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::QuoteResponse_ID;
    //signatureSigAlg
    sInf->Fields[2].Name = "signatureSigAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::QuoteResponse_ID;
    sInf->Fields[2].AssociatedField = 3;
    //signature
    sInf->Fields[3].Name = "signature";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::QuoteResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_GetSessionAuditDigest_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_GetSessionAuditDigest_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetSessionAuditDigest_REQUEST()); };
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(7);
    //privacyAdminHandle
    sInf->Fields[0].Name = "privacyAdminHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //signHandle
    sInf->Fields[1].Name = "signHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //sessionHandle
    sInf->Fields[2].Name = "sessionHandle";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //qualifyingDataSize
    sInf->Fields[3].Name = "qualifyingDataSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    //qualifyingData
    sInf->Fields[4].Name = "qualifyingData";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //inSchemeScheme
    sInf->Fields[5].Name = "inSchemeScheme";
    sInf->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 6;
    //inScheme
    sInf->Fields[6].Name = "inScheme";
    sInf->Fields[6].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[6].MarshalType = MarshalType::UnionObject;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_GetSessionAuditDigest_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== GetSessionAuditDigestResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::GetSessionAuditDigestResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "GetSessionAuditDigestResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetSessionAuditDigestResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //auditInfoSize
    sInf->Fields[0].Name = "auditInfoSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    //auditInfo
    sInf->Fields[1].Name = "auditInfo";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    //signatureSigAlg
    sInf->Fields[2].Name = "signatureSigAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    sInf->Fields[2].AssociatedField = 3;
    //signature
    sInf->Fields[3].Name = "signature";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::GetSessionAuditDigestResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_GetCommandAuditDigest_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_GetCommandAuditDigest_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetCommandAuditDigest_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(6);
    //privacyHandle
    sInf->Fields[0].Name = "privacyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    //signHandle
    sInf->Fields[1].Name = "signHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    //qualifyingDataSize
    sInf->Fields[2].Name = "qualifyingDataSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    //qualifyingData
    sInf->Fields[3].Name = "qualifyingData";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    sInf->Fields[4].Name = "inSchemeScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 5;
    //inScheme
    sInf->Fields[5].Name = "inScheme";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_GetCommandAuditDigest_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== GetCommandAuditDigestResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::GetCommandAuditDigestResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "GetCommandAuditDigestResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetCommandAuditDigestResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //auditInfoSize
    sInf->Fields[0].Name = "auditInfoSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    //auditInfo
    sInf->Fields[1].Name = "auditInfo";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    //signatureSigAlg
    sInf->Fields[2].Name = "signatureSigAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    sInf->Fields[2].AssociatedField = 3;
    //signature
    sInf->Fields[3].Name = "signature";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::GetCommandAuditDigestResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_GetTime_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_GetTime_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_GetTime_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetTime_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(6);
    //privacyAdminHandle
    sInf->Fields[0].Name = "privacyAdminHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    //signHandle
    sInf->Fields[1].Name = "signHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    //qualifyingDataSize
    sInf->Fields[2].Name = "qualifyingDataSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    //qualifyingData
    sInf->Fields[3].Name = "qualifyingData";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    sInf->Fields[4].Name = "inSchemeScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 5;
    //inScheme
    sInf->Fields[5].Name = "inScheme";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_GetTime_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== GetTimeResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::GetTimeResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "GetTimeResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetTimeResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //timeInfoSize
    sInf->Fields[0].Name = "timeInfoSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::GetTimeResponse_ID;
    //timeInfo
    sInf->Fields[1].Name = "timeInfo";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::GetTimeResponse_ID;
    //signatureSigAlg
    sInf->Fields[2].Name = "signatureSigAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::GetTimeResponse_ID;
    sInf->Fields[2].AssociatedField = 3;
    //signature
    sInf->Fields[3].Name = "signature";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::GetTimeResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_CertifyX509_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_CertifyX509_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_CertifyX509_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CertifyX509_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(8);
    //objectHandle
    sInf->Fields[0].Name = "objectHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //signHandle
    sInf->Fields[1].Name = "signHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //reservedSize
    sInf->Fields[2].Name = "reservedSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //reserved
    sInf->Fields[3].Name = "reserved";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //inSchemeScheme
    sInf->Fields[4].Name = "inSchemeScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 5;
    //inScheme
    sInf->Fields[5].Name = "inScheme";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    //partialCertificateSize
    sInf->Fields[6].Name = "partialCertificateSize";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    //partialCertificate
    sInf->Fields[7].Name = "partialCertificate";
    sInf->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_CertifyX509_REQUEST_ID;
    sInf->Fields[7].AssociatedField = 6;
    
    // ======== CertifyX509Response ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CertifyX509Response_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CertifyX509Response";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CertifyX509Response()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //addedToCertificateSize
    sInf->Fields[0].Name = "addedToCertificateSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::CertifyX509Response_ID;
    //addedToCertificate
    sInf->Fields[1].Name = "addedToCertificate";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[1].AssociatedField = 0;
    //tbsDigestSize
    sInf->Fields[2].Name = "tbsDigestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::CertifyX509Response_ID;
    //tbsDigest
    sInf->Fields[3].Name = "tbsDigest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[3].AssociatedField = 2;
    //signatureSigAlg
    sInf->Fields[4].Name = "signatureSigAlg";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[4].AssociatedField = 5;
    //signature
    sInf->Fields[5].Name = "signature";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::CertifyX509Response_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== TPM2_Commit_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Commit_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Commit_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Commit_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //signHandle
    sInf->Fields[0].Name = "signHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //P1Size
    sInf->Fields[1].Name = "P1Size";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //P1
    sInf->Fields[2].Name = "P1";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //s2Size
    sInf->Fields[3].Name = "s2Size";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //s2
    sInf->Fields[4].Name = "s2";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //y2Size
    sInf->Fields[5].Name = "y2Size";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    //y2
    sInf->Fields[6].Name = "y2";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Commit_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    
    // ======== CommitResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CommitResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CommitResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CommitResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(7);
    //KSize
    sInf->Fields[0].Name = "KSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::CommitResponse_ID;
    //K
    sInf->Fields[1].Name = "K";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::CommitResponse_ID;
    //LSize
    sInf->Fields[2].Name = "LSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[2].ParentType = TpmTypeId::CommitResponse_ID;
    //L
    sInf->Fields[3].Name = "L";
    sInf->Fields[3].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::CommitResponse_ID;
    //ESize
    sInf->Fields[4].Name = "ESize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[4].ParentType = TpmTypeId::CommitResponse_ID;
    //E
    sInf->Fields[5].Name = "E";
    sInf->Fields[5].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::CommitResponse_ID;
    //counter
    sInf->Fields[6].Name = "counter";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::Normal;
    sInf->Fields[6].ParentType = TpmTypeId::CommitResponse_ID;
    
    // ======== TPM2_EC_Ephemeral_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_EC_Ephemeral_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EC_Ephemeral_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //curveID
    sInf->Fields[0].Name = "curveID";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ECC_CURVE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EC_Ephemeral_REQUEST_ID;
    
    // ======== EC_EphemeralResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::EC_EphemeralResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "EC_EphemeralResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EC_EphemeralResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //QSize
    sInf->Fields[0].Name = "QSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    //Q
    sInf->Fields[1].Name = "Q";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    //counter
    sInf->Fields[2].Name = "counter";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::EC_EphemeralResponse_ID;
    
    // ======== TPM2_VerifySignature_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_VerifySignature_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_VerifySignature_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_VerifySignature_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    //digestSize
    sInf->Fields[1].Name = "digestSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    //digest
    sInf->Fields[2].Name = "digest";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //signatureSigAlg
    sInf->Fields[3].Name = "signatureSigAlg";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 4;
    //signature
    sInf->Fields[4].Name = "signature";
    sInf->Fields[4].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionObject;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_VerifySignature_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== VerifySignatureResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::VerifySignatureResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "VerifySignatureResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new VerifySignatureResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //validation
    sInf->Fields[0].Name = "validation";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::VerifySignatureResponse_ID;
    
    // ======== TPM2_Sign_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Sign_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Sign_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Sign_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(6);
    //keyHandle
    sInf->Fields[0].Name = "keyHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    //digestSize
    sInf->Fields[1].Name = "digestSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    //digest
    sInf->Fields[2].Name = "digest";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //inSchemeScheme
    sInf->Fields[3].Name = "inSchemeScheme";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 4;
    //inScheme
    sInf->Fields[4].Name = "inScheme";
    sInf->Fields[4].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionObject;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //validation
    sInf->Fields[5].Name = "validation";
    sInf->Fields[5].TypeId = TpmTypeId::TPMT_TK_HASHCHECK_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Sign_REQUEST_ID;
    
    // ======== SignResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SignResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SignResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SignResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //signatureSigAlg
    sInf->Fields[0].Name = "signatureSigAlg";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::SignResponse_ID;
    sInf->Fields[0].AssociatedField = 1;
    //signature
    sInf->Fields[1].Name = "signature";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::SignResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_SetCommandCodeAuditStatus_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_SetCommandCodeAuditStatus_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SetCommandCodeAuditStatus_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(6);
    //auth
    sInf->Fields[0].Name = "auth";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //auditAlg
    sInf->Fields[1].Name = "auditAlg";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //setListCount
    sInf->Fields[2].Name = "setListCount";
    sInf->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //setList
    sInf->Fields[3].Name = "setList";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_CC_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //clearListCount
    sInf->Fields[4].Name = "clearListCount";
    sInf->Fields[4].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    //clearList
    sInf->Fields[5].Name = "clearList";
    sInf->Fields[5].TypeId = TpmTypeId::TPM_CC_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_SetCommandCodeAuditStatus_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== SetCommandCodeAuditStatusResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SetCommandCodeAuditStatusResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SetCommandCodeAuditStatusResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SetCommandCodeAuditStatusResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PCR_Extend_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Extend_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PCR_Extend_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Extend_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //pcrHandle
    sInf->Fields[0].Name = "pcrHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    //digestsCount
    sInf->Fields[1].Name = "digestsCount";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    //digests
    sInf->Fields[2].Name = "digests";
    sInf->Fields[2].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Extend_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PCR_ExtendResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PCR_ExtendResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PCR_ExtendResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_ExtendResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PCR_Event_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Event_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PCR_Event_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Event_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //pcrHandle
    sInf->Fields[0].Name = "pcrHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    //eventDataSize
    sInf->Fields[1].Name = "eventDataSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    //eventData
    sInf->Fields[2].Name = "eventData";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Event_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PCR_EventResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PCR_EventResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PCR_EventResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_EventResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //digestsCount
    sInf->Fields[0].Name = "digestsCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::PCR_EventResponse_ID;
    //digests
    sInf->Fields[1].Name = "digests";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::PCR_EventResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_PCR_Read_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Read_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PCR_Read_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Read_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //pcrSelectionInCount
    sInf->Fields[0].Name = "pcrSelectionInCount";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
    //pcrSelectionIn
    sInf->Fields[1].Name = "pcrSelectionIn";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Read_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== PCR_ReadResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PCR_ReadResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PCR_ReadResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_ReadResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //pcrUpdateCounter
    sInf->Fields[0].Name = "pcrUpdateCounter";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    //pcrSelectionOutCount
    sInf->Fields[1].Name = "pcrSelectionOutCount";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    //pcrSelectionOut
    sInf->Fields[2].Name = "pcrSelectionOut";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    sInf->Fields[2].AssociatedField = 1;
    //pcrValuesCount
    sInf->Fields[3].Name = "pcrValuesCount";
    sInf->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    //pcrValues
    sInf->Fields[4].Name = "pcrValues";
    sInf->Fields[4].TypeId = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::PCR_ReadResponse_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== TPM2_PCR_Allocate_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PCR_Allocate_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Allocate_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    //pcrAllocationCount
    sInf->Fields[1].Name = "pcrAllocationCount";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    //pcrAllocation
    sInf->Fields[2].Name = "pcrAllocation";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_Allocate_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PCR_AllocateResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PCR_AllocateResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PCR_AllocateResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_AllocateResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //allocationSuccess
    sInf->Fields[0].Name = "allocationSuccess";
    sInf->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    //maxPCR
    sInf->Fields[1].Name = "maxPCR";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    //sizeNeeded
    sInf->Fields[2].Name = "sizeNeeded";
    sInf->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    //sizeAvailable
    sInf->Fields[3].Name = "sizeAvailable";
    sInf->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::PCR_AllocateResponse_ID;
    
    // ======== TPM2_PCR_SetAuthPolicy_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PCR_SetAuthPolicy_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_SetAuthPolicy_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(5);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    //authPolicySize
    sInf->Fields[1].Name = "authPolicySize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    //authPolicy
    sInf->Fields[2].Name = "authPolicy";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //hashAlg
    sInf->Fields[3].Name = "hashAlg";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    //pcrNum
    sInf->Fields[4].Name = "pcrNum";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PCR_SetAuthPolicy_REQUEST_ID;
    
    // ======== PCR_SetAuthPolicyResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PCR_SetAuthPolicyResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PCR_SetAuthPolicyResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_SetAuthPolicyResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PCR_SetAuthValue_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PCR_SetAuthValue_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_SetAuthValue_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //pcrHandle
    sInf->Fields[0].Name = "pcrHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    //authSize
    sInf->Fields[1].Name = "authSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    //auth
    sInf->Fields[2].Name = "auth";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PCR_SetAuthValue_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PCR_SetAuthValueResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PCR_SetAuthValueResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PCR_SetAuthValueResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_SetAuthValueResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PCR_Reset_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PCR_Reset_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PCR_Reset_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PCR_Reset_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(1);
    //pcrHandle
    sInf->Fields[0].Name = "pcrHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PCR_Reset_REQUEST_ID;
    
    // ======== PCR_ResetResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PCR_ResetResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PCR_ResetResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PCR_ResetResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicySigned_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicySigned_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicySigned_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicySigned_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(11);
    //authObject
    sInf->Fields[0].Name = "authObject";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //policySession
    sInf->Fields[1].Name = "policySession";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //nonceTPMSize
    sInf->Fields[2].Name = "nonceTPMSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //nonceTPM
    sInf->Fields[3].Name = "nonceTPM";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //cpHashASize
    sInf->Fields[4].Name = "cpHashASize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //cpHashA
    sInf->Fields[5].Name = "cpHashA";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    //policyRefSize
    sInf->Fields[6].Name = "policyRefSize";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //policyRef
    sInf->Fields[7].Name = "policyRef";
    sInf->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[7].AssociatedField = 6;
    //expiration
    sInf->Fields[8].Name = "expiration";
    sInf->Fields[8].TypeId = TpmTypeId::INT32_ID;
    sInf->Fields[8].MarshalType = MarshalType::Normal;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    //authSigAlg
    sInf->Fields[9].Name = "authSigAlg";
    sInf->Fields[9].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[9].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[9].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[9].AssociatedField = 10;
    //auth
    sInf->Fields[10].Name = "auth";
    sInf->Fields[10].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[10].MarshalType = MarshalType::UnionObject;
    sInf->Fields[10].ParentType = TpmTypeId::TPM2_PolicySigned_REQUEST_ID;
    sInf->Fields[10].AssociatedField = 9;
    
    // ======== PolicySignedResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicySignedResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicySignedResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicySignedResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //timeoutSize
    sInf->Fields[0].Name = "timeoutSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::PolicySignedResponse_ID;
    //timeout
    sInf->Fields[1].Name = "timeout";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::PolicySignedResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //policyTicket
    sInf->Fields[2].Name = "policyTicket";
    sInf->Fields[2].TypeId = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::PolicySignedResponse_ID;
    
    // ======== TPM2_PolicySecret_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicySecret_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicySecret_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicySecret_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(9);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //policySession
    sInf->Fields[1].Name = "policySession";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //nonceTPMSize
    sInf->Fields[2].Name = "nonceTPMSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //nonceTPM
    sInf->Fields[3].Name = "nonceTPM";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //cpHashASize
    sInf->Fields[4].Name = "cpHashASize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //cpHashA
    sInf->Fields[5].Name = "cpHashA";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    //policyRefSize
    sInf->Fields[6].Name = "policyRefSize";
    sInf->Fields[6].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[6].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    //policyRef
    sInf->Fields[7].Name = "policyRef";
    sInf->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[7].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    sInf->Fields[7].AssociatedField = 6;
    //expiration
    sInf->Fields[8].Name = "expiration";
    sInf->Fields[8].TypeId = TpmTypeId::INT32_ID;
    sInf->Fields[8].MarshalType = MarshalType::Normal;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_PolicySecret_REQUEST_ID;
    
    // ======== PolicySecretResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicySecretResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicySecretResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicySecretResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //timeoutSize
    sInf->Fields[0].Name = "timeoutSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::PolicySecretResponse_ID;
    //timeout
    sInf->Fields[1].Name = "timeout";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::PolicySecretResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    //policyTicket
    sInf->Fields[2].Name = "policyTicket";
    sInf->Fields[2].TypeId = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::PolicySecretResponse_ID;
    
    // ======== TPM2_PolicyTicket_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyTicket_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyTicket_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyTicket_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(10);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //timeoutSize
    sInf->Fields[1].Name = "timeoutSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //timeout
    sInf->Fields[2].Name = "timeout";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //cpHashASize
    sInf->Fields[3].Name = "cpHashASize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //cpHashA
    sInf->Fields[4].Name = "cpHashA";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //policyRefSize
    sInf->Fields[5].Name = "policyRefSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //policyRef
    sInf->Fields[6].Name = "policyRef";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    //authNameSize
    sInf->Fields[7].Name = "authNameSize";
    sInf->Fields[7].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[7].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    //authName
    sInf->Fields[8].Name = "authName";
    sInf->Fields[8].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[8].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    sInf->Fields[8].AssociatedField = 7;
    //ticket
    sInf->Fields[9].Name = "ticket";
    sInf->Fields[9].TypeId = TpmTypeId::TPMT_TK_AUTH_ID;
    sInf->Fields[9].MarshalType = MarshalType::Normal;
    sInf->Fields[9].ParentType = TpmTypeId::TPM2_PolicyTicket_REQUEST_ID;
    
    // ======== PolicyTicketResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyTicketResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyTicketResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyTicketResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyOR_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyOR_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyOR_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyOR_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    //pHashListCount
    sInf->Fields[1].Name = "pHashListCount";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    //pHashList
    sInf->Fields[2].Name = "pHashList";
    sInf->Fields[2].TypeId = TpmTypeId::TPM2B_DIGEST_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyOR_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PolicyORResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyORResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyORResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyORResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyPCR_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyPCR_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyPCR_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyPCR_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    //pcrDigestSize
    sInf->Fields[1].Name = "pcrDigestSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    //pcrDigest
    sInf->Fields[2].Name = "pcrDigest";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //pcrsCount
    sInf->Fields[3].Name = "pcrsCount";
    sInf->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    //pcrs
    sInf->Fields[4].Name = "pcrs";
    sInf->Fields[4].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyPCR_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== PolicyPCRResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyPCRResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyPCRResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyPCRResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyLocality_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyLocality_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyLocality_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyLocality_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
    //locality
    sInf->Fields[1].Name = "locality";
    sInf->Fields[1].TypeId = TpmTypeId::TPMA_LOCALITY_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyLocality_REQUEST_ID;
    
    // ======== PolicyLocalityResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyLocalityResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyLocalityResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyLocalityResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyNV_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyNV_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyNV_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyNV_REQUEST()); };
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(7);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //policySession
    sInf->Fields[2].Name = "policySession";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //operandBSize
    sInf->Fields[3].Name = "operandBSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //operandB
    sInf->Fields[4].Name = "operandB";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //offset
    sInf->Fields[5].Name = "offset";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    //operation
    sInf->Fields[6].Name = "operation";
    sInf->Fields[6].TypeId = TpmTypeId::TPM_EO_ID;
    sInf->Fields[6].MarshalType = MarshalType::Normal;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicyNV_REQUEST_ID;
    
    // ======== PolicyNVResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyNVResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyNVResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyNVResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyCounterTimer_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyCounterTimer_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyCounterTimer_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    //operandBSize
    sInf->Fields[1].Name = "operandBSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    //operandB
    sInf->Fields[2].Name = "operandB";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //offset
    sInf->Fields[3].Name = "offset";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    //operation
    sInf->Fields[4].Name = "operation";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_EO_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyCounterTimer_REQUEST_ID;
    
    // ======== PolicyCounterTimerResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyCounterTimerResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyCounterTimerResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyCounterTimerResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyCommandCode_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyCommandCode_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyCommandCode_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
    //code
    sInf->Fields[1].Name = "code";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_CC_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCommandCode_REQUEST_ID;
    
    // ======== PolicyCommandCodeResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyCommandCodeResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyCommandCodeResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyCommandCodeResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyPhysicalPresence_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyPhysicalPresence_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyPhysicalPresence_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPhysicalPresence_REQUEST_ID;
    
    // ======== PolicyPhysicalPresenceResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyPhysicalPresenceResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyPhysicalPresenceResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyPhysicalPresenceResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyCpHash_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyCpHash_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyCpHash_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    //cpHashASize
    sInf->Fields[1].Name = "cpHashASize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    //cpHashA
    sInf->Fields[2].Name = "cpHashA";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyCpHash_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PolicyCpHashResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyCpHashResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyCpHashResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyCpHashResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyNameHash_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyNameHash_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyNameHash_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    //nameHashSize
    sInf->Fields[1].Name = "nameHashSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    //nameHash
    sInf->Fields[2].Name = "nameHash";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyNameHash_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PolicyNameHashResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyNameHashResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyNameHashResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyNameHashResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyDuplicationSelect_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyDuplicationSelect_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyDuplicationSelect_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    //objectNameSize
    sInf->Fields[1].Name = "objectNameSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    //objectName
    sInf->Fields[2].Name = "objectName";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //newParentNameSize
    sInf->Fields[3].Name = "newParentNameSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    //newParentName
    sInf->Fields[4].Name = "newParentName";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //includeObject
    sInf->Fields[5].Name = "includeObject";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::Normal;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyDuplicationSelect_REQUEST_ID;
    
    // ======== PolicyDuplicationSelectResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyDuplicationSelectResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyDuplicationSelectResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyDuplicationSelectResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyAuthorize_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyAuthorize_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyAuthorize_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(8);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //approvedPolicySize
    sInf->Fields[1].Name = "approvedPolicySize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //approvedPolicy
    sInf->Fields[2].Name = "approvedPolicy";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //policyRefSize
    sInf->Fields[3].Name = "policyRefSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //policyRef
    sInf->Fields[4].Name = "policyRef";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //keySignSize
    sInf->Fields[5].Name = "keySignSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    //keySign
    sInf->Fields[6].Name = "keySign";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    //checkTicket
    sInf->Fields[7].Name = "checkTicket";
    sInf->Fields[7].TypeId = TpmTypeId::TPMT_TK_VERIFIED_ID;
    sInf->Fields[7].MarshalType = MarshalType::Normal;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_PolicyAuthorize_REQUEST_ID;
    
    // ======== PolicyAuthorizeResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyAuthorizeResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyAuthorizeResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyAuthorizeResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyAuthValue_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyAuthValue_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyAuthValue_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthValue_REQUEST_ID;
    
    // ======== PolicyAuthValueResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyAuthValueResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyAuthValueResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyAuthValueResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyPassword_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyPassword_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyPassword_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyPassword_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyPassword_REQUEST_ID;
    
    // ======== PolicyPasswordResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyPasswordResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyPasswordResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyPasswordResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyGetDigest_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyGetDigest_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyGetDigest_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyGetDigest_REQUEST_ID;
    
    // ======== PolicyGetDigestResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyGetDigestResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyGetDigestResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyGetDigestResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //policyDigestSize
    sInf->Fields[0].Name = "policyDigestSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::PolicyGetDigestResponse_ID;
    //policyDigest
    sInf->Fields[1].Name = "policyDigest";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::PolicyGetDigestResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_PolicyNvWritten_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyNvWritten_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyNvWritten_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
    //writtenSet
    sInf->Fields[1].Name = "writtenSet";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyNvWritten_REQUEST_ID;
    
    // ======== PolicyNvWrittenResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyNvWrittenResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyNvWrittenResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyNvWrittenResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyTemplate_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyTemplate_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyTemplate_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    //templateHashSize
    sInf->Fields[1].Name = "templateHashSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    //templateHash
    sInf->Fields[2].Name = "templateHash";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyTemplate_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== PolicyTemplateResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyTemplateResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyTemplateResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyTemplateResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PolicyAuthorizeNV_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PolicyAuthorizeNV_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PolicyAuthorizeNV_REQUEST()); };
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    //policySession
    sInf->Fields[2].Name = "policySession";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PolicyAuthorizeNV_REQUEST_ID;
    
    // ======== PolicyAuthorizeNVResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PolicyAuthorizeNVResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PolicyAuthorizeNVResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PolicyAuthorizeNVResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_CreatePrimary_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_CreatePrimary_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_CreatePrimary_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_CreatePrimary_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(9);
    //primaryHandle
    sInf->Fields[0].Name = "primaryHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inSensitiveSize
    sInf->Fields[1].Name = "inSensitiveSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inSensitive
    sInf->Fields[2].Name = "inSensitive";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_SENSITIVE_CREATE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inPublicSize
    sInf->Fields[3].Name = "inPublicSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //inPublic
    sInf->Fields[4].Name = "inPublic";
    sInf->Fields[4].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //outsideInfoSize
    sInf->Fields[5].Name = "outsideInfoSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //outsideInfo
    sInf->Fields[6].Name = "outsideInfo";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    //creationPCRCount
    sInf->Fields[7].Name = "creationPCRCount";
    sInf->Fields[7].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[7].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    //creationPCR
    sInf->Fields[8].Name = "creationPCR";
    sInf->Fields[8].TypeId = TpmTypeId::TPMS_PCR_SELECTION_ID;
    sInf->Fields[8].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_CreatePrimary_REQUEST_ID;
    sInf->Fields[8].AssociatedField = 7;
    
    // ======== CreatePrimaryResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CreatePrimaryResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CreatePrimaryResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CreatePrimaryResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(10);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //outPublicSize
    sInf->Fields[1].Name = "outPublicSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[1].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //outPublic
    sInf->Fields[2].Name = "outPublic";
    sInf->Fields[2].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationDataSize
    sInf->Fields[3].Name = "creationDataSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationData
    sInf->Fields[4].Name = "creationData";
    sInf->Fields[4].TypeId = TpmTypeId::TPMS_CREATION_DATA_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationHashSize
    sInf->Fields[5].Name = "creationHashSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //creationHash
    sInf->Fields[6].Name = "creationHash";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[6].AssociatedField = 5;
    //creationTicket
    sInf->Fields[7].Name = "creationTicket";
    sInf->Fields[7].TypeId = TpmTypeId::TPMT_TK_CREATION_ID;
    sInf->Fields[7].MarshalType = MarshalType::Normal;
    sInf->Fields[7].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //nameSize
    sInf->Fields[8].Name = "nameSize";
    sInf->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[8].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[8].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    //name
    sInf->Fields[9].Name = "name";
    sInf->Fields[9].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[9].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[9].ParentType = TpmTypeId::CreatePrimaryResponse_ID;
    sInf->Fields[9].AssociatedField = 8;
    
    // ======== TPM2_HierarchyControl_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_HierarchyControl_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_HierarchyControl_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HierarchyControl_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    //enable
    sInf->Fields[1].Name = "enable";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    //state
    sInf->Fields[2].Name = "state";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HierarchyControl_REQUEST_ID;
    
    // ======== HierarchyControlResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::HierarchyControlResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "HierarchyControlResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HierarchyControlResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_SetPrimaryPolicy_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_SetPrimaryPolicy_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SetPrimaryPolicy_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    //authPolicySize
    sInf->Fields[1].Name = "authPolicySize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    //authPolicy
    sInf->Fields[2].Name = "authPolicy";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //hashAlg
    sInf->Fields[3].Name = "hashAlg";
    sInf->Fields[3].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_SetPrimaryPolicy_REQUEST_ID;
    
    // ======== SetPrimaryPolicyResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SetPrimaryPolicyResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SetPrimaryPolicyResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SetPrimaryPolicyResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_ChangePPS_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ChangePPS_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ChangePPS_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ChangePPS_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(1);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ChangePPS_REQUEST_ID;
    
    // ======== ChangePPSResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ChangePPSResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ChangePPSResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ChangePPSResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_ChangeEPS_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ChangeEPS_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ChangeEPS_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ChangeEPS_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(1);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ChangeEPS_REQUEST_ID;
    
    // ======== ChangeEPSResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ChangeEPSResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ChangeEPSResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ChangeEPSResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_Clear_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Clear_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Clear_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Clear_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(1);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Clear_REQUEST_ID;
    
    // ======== ClearResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ClearResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ClearResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ClearResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_ClearControl_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ClearControl_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ClearControl_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ClearControl_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //auth
    sInf->Fields[0].Name = "auth";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ClearControl_REQUEST_ID;
    //disable
    sInf->Fields[1].Name = "disable";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ClearControl_REQUEST_ID;
    
    // ======== ClearControlResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ClearControlResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ClearControlResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ClearControlResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_HierarchyChangeAuth_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_HierarchyChangeAuth_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_HierarchyChangeAuth_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    //newAuthSize
    sInf->Fields[1].Name = "newAuthSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    //newAuth
    sInf->Fields[2].Name = "newAuth";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_HierarchyChangeAuth_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== HierarchyChangeAuthResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::HierarchyChangeAuthResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "HierarchyChangeAuthResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new HierarchyChangeAuthResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_DictionaryAttackLockReset_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_DictionaryAttackLockReset_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_DictionaryAttackLockReset_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(1);
    //lockHandle
    sInf->Fields[0].Name = "lockHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_DictionaryAttackLockReset_REQUEST_ID;
    
    // ======== DictionaryAttackLockResetResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::DictionaryAttackLockResetResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "DictionaryAttackLockResetResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new DictionaryAttackLockResetResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_DictionaryAttackParameters_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_DictionaryAttackParameters_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_DictionaryAttackParameters_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //lockHandle
    sInf->Fields[0].Name = "lockHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    //newMaxTries
    sInf->Fields[1].Name = "newMaxTries";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    //newRecoveryTime
    sInf->Fields[2].Name = "newRecoveryTime";
    sInf->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    //lockoutRecovery
    sInf->Fields[3].Name = "lockoutRecovery";
    sInf->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_DictionaryAttackParameters_REQUEST_ID;
    
    // ======== DictionaryAttackParametersResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::DictionaryAttackParametersResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "DictionaryAttackParametersResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new DictionaryAttackParametersResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_PP_Commands_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_PP_Commands_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_PP_Commands_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_PP_Commands_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(5);
    //auth
    sInf->Fields[0].Name = "auth";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    //setListCount
    sInf->Fields[1].Name = "setListCount";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    //setList
    sInf->Fields[2].Name = "setList";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_CC_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //clearListCount
    sInf->Fields[3].Name = "clearListCount";
    sInf->Fields[3].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    //clearList
    sInf->Fields[4].Name = "clearList";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_CC_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_PP_Commands_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== PP_CommandsResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PP_CommandsResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PP_CommandsResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PP_CommandsResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_SetAlgorithmSet_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_SetAlgorithmSet_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_SetAlgorithmSet_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
    //algorithmSet
    sInf->Fields[1].Name = "algorithmSet";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_SetAlgorithmSet_REQUEST_ID;
    
    // ======== SetAlgorithmSetResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SetAlgorithmSetResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SetAlgorithmSetResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SetAlgorithmSetResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_FieldUpgradeStart_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_FieldUpgradeStart_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FieldUpgradeStart_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(6);
    //authorization
    sInf->Fields[0].Name = "authorization";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    //keyHandle
    sInf->Fields[1].Name = "keyHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    //fuDigestSize
    sInf->Fields[2].Name = "fuDigestSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    //fuDigest
    sInf->Fields[3].Name = "fuDigest";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //manifestSignatureSigAlg
    sInf->Fields[4].Name = "manifestSignatureSigAlg";
    sInf->Fields[4].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[4].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 5;
    //manifestSignature
    sInf->Fields[5].Name = "manifestSignature";
    sInf->Fields[5].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionObject;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_FieldUpgradeStart_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== FieldUpgradeStartResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::FieldUpgradeStartResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "FieldUpgradeStartResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new FieldUpgradeStartResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_FieldUpgradeData_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_FieldUpgradeData_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FieldUpgradeData_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //fuDataSize
    sInf->Fields[0].Name = "fuDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
    //fuData
    sInf->Fields[1].Name = "fuData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_FieldUpgradeData_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== FieldUpgradeDataResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::FieldUpgradeDataResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "FieldUpgradeDataResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new FieldUpgradeDataResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //nextDigest
    sInf->Fields[0].Name = "nextDigest";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::FieldUpgradeDataResponse_ID;
    //firstDigest
    sInf->Fields[1].Name = "firstDigest";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::FieldUpgradeDataResponse_ID;
    
    // ======== TPM2_FirmwareRead_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_FirmwareRead_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_FirmwareRead_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FirmwareRead_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //sequenceNumber
    sInf->Fields[0].Name = "sequenceNumber";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FirmwareRead_REQUEST_ID;
    
    // ======== FirmwareReadResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::FirmwareReadResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "FirmwareReadResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new FirmwareReadResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //fuDataSize
    sInf->Fields[0].Name = "fuDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::FirmwareReadResponse_ID;
    //fuData
    sInf->Fields[1].Name = "fuData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::FirmwareReadResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_ContextSave_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ContextSave_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ContextSave_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ContextSave_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //saveHandle
    sInf->Fields[0].Name = "saveHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ContextSave_REQUEST_ID;
    
    // ======== ContextSaveResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ContextSaveResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ContextSaveResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ContextSaveResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //context
    sInf->Fields[0].Name = "context";
    sInf->Fields[0].TypeId = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::ContextSaveResponse_ID;
    
    // ======== TPM2_ContextLoad_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ContextLoad_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ContextLoad_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ContextLoad_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //context
    sInf->Fields[0].Name = "context";
    sInf->Fields[0].TypeId = TpmTypeId::TPMS_CONTEXT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ContextLoad_REQUEST_ID;
    
    // ======== ContextLoadResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ContextLoadResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ContextLoadResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ContextLoadResponse()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::ContextLoadResponse_ID;
    
    // ======== TPM2_FlushContext_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_FlushContext_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_FlushContext_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_FlushContext_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //flushHandle
    sInf->Fields[0].Name = "flushHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_FlushContext_REQUEST_ID;
    
    // ======== FlushContextResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::FlushContextResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "FlushContextResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new FlushContextResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_EvictControl_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_EvictControl_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_EvictControl_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_EvictControl_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //auth
    sInf->Fields[0].Name = "auth";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    //objectHandle
    sInf->Fields[1].Name = "objectHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    //persistentHandle
    sInf->Fields[2].Name = "persistentHandle";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_EvictControl_REQUEST_ID;
    
    // ======== EvictControlResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::EvictControlResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "EvictControlResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new EvictControlResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_ReadClock_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ReadClock_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ReadClock_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ReadClock_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== ReadClockResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ReadClockResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ReadClockResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ReadClockResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //currentTime
    sInf->Fields[0].Name = "currentTime";
    sInf->Fields[0].TypeId = TpmTypeId::TPMS_TIME_INFO_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::ReadClockResponse_ID;
    
    // ======== TPM2_ClockSet_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ClockSet_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ClockSet_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ClockSet_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //auth
    sInf->Fields[0].Name = "auth";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ClockSet_REQUEST_ID;
    //newTime
    sInf->Fields[1].Name = "newTime";
    sInf->Fields[1].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ClockSet_REQUEST_ID;
    
    // ======== ClockSetResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ClockSetResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ClockSetResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ClockSetResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_ClockRateAdjust_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ClockRateAdjust_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ClockRateAdjust_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //auth
    sInf->Fields[0].Name = "auth";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
    //rateAdjust
    sInf->Fields[1].Name = "rateAdjust";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_CLOCK_ADJUST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ClockRateAdjust_REQUEST_ID;
    
    // ======== ClockRateAdjustResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ClockRateAdjustResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ClockRateAdjustResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ClockRateAdjustResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_GetCapability_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_GetCapability_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_GetCapability_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_GetCapability_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //capability
    sInf->Fields[0].Name = "capability";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_CAP_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    //property
    sInf->Fields[1].Name = "property";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    //propertyCount
    sInf->Fields[2].Name = "propertyCount";
    sInf->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_GetCapability_REQUEST_ID;
    
    // ======== GetCapabilityResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::GetCapabilityResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "GetCapabilityResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new GetCapabilityResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //moreData
    sInf->Fields[0].Name = "moreData";
    sInf->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    //capabilityDataCapability
    sInf->Fields[1].Name = "capabilityDataCapability";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_CAP_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[1].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    sInf->Fields[1].AssociatedField = 2;
    //capabilityData
    sInf->Fields[2].Name = "capabilityData";
    sInf->Fields[2].TypeId = TpmTypeId::TPMU_CAPABILITIES_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionObject;
    sInf->Fields[2].ParentType = TpmTypeId::GetCapabilityResponse_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_TestParms_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_TestParms_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_TestParms_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_TestParms_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //parametersType
    sInf->Fields[0].Name = "parametersType";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[0].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_TestParms_REQUEST_ID;
    sInf->Fields[0].AssociatedField = 1;
    //parameters
    sInf->Fields[1].Name = "parameters";
    sInf->Fields[1].TypeId = TpmTypeId::TPMU_PUBLIC_PARMS_ID;
    sInf->Fields[1].MarshalType = MarshalType::UnionObject;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_TestParms_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TestParmsResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TestParmsResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TestParmsResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TestParmsResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_DefineSpace_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_DefineSpace_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_DefineSpace_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(5);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    //authSize
    sInf->Fields[1].Name = "authSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    //auth
    sInf->Fields[2].Name = "auth";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //publicInfoSize
    sInf->Fields[3].Name = "publicInfoSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    //publicInfo
    sInf->Fields[4].Name = "publicInfo";
    sInf->Fields[4].TypeId = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_NV_DefineSpace_REQUEST_ID;
    
    // ======== NV_DefineSpaceResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_DefineSpaceResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_DefineSpaceResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_DefineSpaceResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_UndefineSpace_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_UndefineSpace_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_UndefineSpace_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_UndefineSpace_REQUEST_ID;
    
    // ======== NV_UndefineSpaceResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_UndefineSpaceResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_UndefineSpaceResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_UndefineSpaceResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_UndefineSpaceSpecial_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_UndefineSpaceSpecial_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_UndefineSpaceSpecial_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(2);
    //nvIndex
    sInf->Fields[0].Name = "nvIndex";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
    //platform
    sInf->Fields[1].Name = "platform";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_UndefineSpaceSpecial_REQUEST_ID;
    
    // ======== NV_UndefineSpaceSpecialResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_UndefineSpaceSpecialResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_UndefineSpaceSpecialResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_UndefineSpaceSpecialResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_ReadPublic_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_ReadPublic_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_ReadPublic_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //nvIndex
    sInf->Fields[0].Name = "nvIndex";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_ReadPublic_REQUEST_ID;
    
    // ======== NV_ReadPublicResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_ReadPublicResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_ReadPublicResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_ReadPublicResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //nvPublicSize
    sInf->Fields[0].Name = "nvPublicSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    //nvPublic
    sInf->Fields[1].Name = "nvPublic";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_NV_PUBLIC_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    //nvNameSize
    sInf->Fields[2].Name = "nvNameSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    //nvName
    sInf->Fields[3].Name = "nvName";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::NV_ReadPublicResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_NV_Write_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_Write_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_Write_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Write_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(5);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    //dataSize
    sInf->Fields[2].Name = "dataSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    //data
    sInf->Fields[3].Name = "data";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    //offset
    sInf->Fields[4].Name = "offset";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::Normal;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_NV_Write_REQUEST_ID;
    
    // ======== NV_WriteResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_WriteResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_WriteResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_WriteResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_Increment_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_Increment_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_Increment_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Increment_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Increment_REQUEST_ID;
    
    // ======== NV_IncrementResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_IncrementResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_IncrementResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_IncrementResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_Extend_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_Extend_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_Extend_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Extend_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    //dataSize
    sInf->Fields[2].Name = "dataSize";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    //data
    sInf->Fields[3].Name = "data";
    sInf->Fields[3].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[3].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Extend_REQUEST_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== NV_ExtendResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_ExtendResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_ExtendResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_ExtendResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_SetBits_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_SetBits_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_SetBits_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_SetBits_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    //bits
    sInf->Fields[2].Name = "bits";
    sInf->Fields[2].TypeId = TpmTypeId::UINT64_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_SetBits_REQUEST_ID;
    
    // ======== NV_SetBitsResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_SetBitsResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_SetBitsResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_SetBitsResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_WriteLock_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_WriteLock_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_WriteLock_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_WriteLock_REQUEST_ID;
    
    // ======== NV_WriteLockResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_WriteLockResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_WriteLockResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_WriteLockResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_GlobalWriteLock_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_GlobalWriteLock_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_GlobalWriteLock_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(1);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_GlobalWriteLock_REQUEST_ID;
    
    // ======== NV_GlobalWriteLockResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_GlobalWriteLockResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_GlobalWriteLockResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_GlobalWriteLockResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_Read_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_Read_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_Read_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Read_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(4);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    //size
    sInf->Fields[2].Name = "size";
    sInf->Fields[2].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    //offset
    sInf->Fields[3].Name = "offset";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Read_REQUEST_ID;
    
    // ======== NV_ReadResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_ReadResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_ReadResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_ReadResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //dataSize
    sInf->Fields[0].Name = "dataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::NV_ReadResponse_ID;
    //data
    sInf->Fields[1].Name = "data";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::NV_ReadResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2_NV_ReadLock_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_ReadLock_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_ReadLock_REQUEST()); };
    sInf->HandleCount = 2;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //authHandle
    sInf->Fields[0].Name = "authHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
    //nvIndex
    sInf->Fields[1].Name = "nvIndex";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_ReadLock_REQUEST_ID;
    
    // ======== NV_ReadLockResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_ReadLockResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_ReadLockResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_ReadLockResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_ChangeAuth_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_ChangeAuth_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_ChangeAuth_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(3);
    //nvIndex
    sInf->Fields[0].Name = "nvIndex";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    //newAuthSize
    sInf->Fields[1].Name = "newAuthSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    //newAuth
    sInf->Fields[2].Name = "newAuth";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_ChangeAuth_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== NV_ChangeAuthResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_ChangeAuthResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_ChangeAuthResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_ChangeAuthResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_NV_Certify_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_NV_Certify_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_NV_Certify_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_NV_Certify_REQUEST()); };
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(9);
    //signHandle
    sInf->Fields[0].Name = "signHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //authHandle
    sInf->Fields[1].Name = "authHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //nvIndex
    sInf->Fields[2].Name = "nvIndex";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //qualifyingDataSize
    sInf->Fields[3].Name = "qualifyingDataSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //qualifyingData
    sInf->Fields[4].Name = "qualifyingData";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //inSchemeScheme
    sInf->Fields[5].Name = "inSchemeScheme";
    sInf->Fields[5].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[5].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[5].AssociatedField = 6;
    //inScheme
    sInf->Fields[6].Name = "inScheme";
    sInf->Fields[6].TypeId = TpmTypeId::TPMU_SIG_SCHEME_ID;
    sInf->Fields[6].MarshalType = MarshalType::UnionObject;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    //size
    sInf->Fields[7].Name = "size";
    sInf->Fields[7].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[7].MarshalType = MarshalType::Normal;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    //offset
    sInf->Fields[8].Name = "offset";
    sInf->Fields[8].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[8].MarshalType = MarshalType::Normal;
    sInf->Fields[8].ParentType = TpmTypeId::TPM2_NV_Certify_REQUEST_ID;
    
    // ======== NV_CertifyResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NV_CertifyResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "NV_CertifyResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new NV_CertifyResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(4);
    //certifyInfoSize
    sInf->Fields[0].Name = "certifyInfoSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::LengthOfStruct;
    sInf->Fields[0].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    //certifyInfo
    sInf->Fields[1].Name = "certifyInfo";
    sInf->Fields[1].TypeId = TpmTypeId::TPMS_ATTEST_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    //signatureSigAlg
    sInf->Fields[2].Name = "signatureSigAlg";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_ALG_ID_ID;
    sInf->Fields[2].MarshalType = MarshalType::UnionSelector;
    sInf->Fields[2].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    sInf->Fields[2].AssociatedField = 3;
    //signature
    sInf->Fields[3].Name = "signature";
    sInf->Fields[3].TypeId = TpmTypeId::TPMU_SIGNATURE_ID;
    sInf->Fields[3].MarshalType = MarshalType::UnionObject;
    sInf->Fields[3].ParentType = TpmTypeId::NV_CertifyResponse_ID;
    sInf->Fields[3].AssociatedField = 2;
    
    // ======== TPM2_AC_GetCapability_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_AC_GetCapability_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_AC_GetCapability_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //ac
    sInf->Fields[0].Name = "ac";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    //capability
    sInf->Fields[1].Name = "capability";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_AT_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    //count
    sInf->Fields[2].Name = "count";
    sInf->Fields[2].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_AC_GetCapability_REQUEST_ID;
    
    // ======== AC_GetCapabilityResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::AC_GetCapabilityResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "AC_GetCapabilityResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new AC_GetCapabilityResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //moreData
    sInf->Fields[0].Name = "moreData";
    sInf->Fields[0].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    //capabilitiesDataCount
    sInf->Fields[1].Name = "capabilitiesDataCount";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    //capabilitiesData
    sInf->Fields[2].Name = "capabilitiesData";
    sInf->Fields[2].TypeId = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::AC_GetCapabilityResponse_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPM2_AC_Send_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_AC_Send_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_AC_Send_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_AC_Send_REQUEST()); };
    sInf->HandleCount = 3;
    sInf->AuthHandleCount = 2;
    sInf->Fields.resize(5);
    //sendObject
    sInf->Fields[0].Name = "sendObject";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //authHandle
    sInf->Fields[1].Name = "authHandle";
    sInf->Fields[1].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //ac
    sInf->Fields[2].Name = "ac";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //acDataInSize
    sInf->Fields[3].Name = "acDataInSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    //acDataIn
    sInf->Fields[4].Name = "acDataIn";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_AC_Send_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== AC_SendResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::AC_SendResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "AC_SendResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new AC_SendResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(1);
    //acDataOut
    sInf->Fields[0].Name = "acDataOut";
    sInf->Fields[0].TypeId = TpmTypeId::TPMS_AC_OUTPUT_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::AC_SendResponse_ID;
    
    // ======== TPM2_Policy_AC_SendSelect_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Policy_AC_SendSelect_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Policy_AC_SendSelect_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(8);
    //policySession
    sInf->Fields[0].Name = "policySession";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //objectNameSize
    sInf->Fields[1].Name = "objectNameSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //objectName
    sInf->Fields[2].Name = "objectName";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[2].AssociatedField = 1;
    //authHandleNameSize
    sInf->Fields[3].Name = "authHandleNameSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //authHandleName
    sInf->Fields[4].Name = "authHandleName";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[4].AssociatedField = 3;
    //acNameSize
    sInf->Fields[5].Name = "acNameSize";
    sInf->Fields[5].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[5].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[5].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    //acName
    sInf->Fields[6].Name = "acName";
    sInf->Fields[6].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[6].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[6].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    sInf->Fields[6].AssociatedField = 5;
    //includeObject
    sInf->Fields[7].Name = "includeObject";
    sInf->Fields[7].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[7].MarshalType = MarshalType::Normal;
    sInf->Fields[7].ParentType = TpmTypeId::TPM2_Policy_AC_SendSelect_REQUEST_ID;
    
    // ======== Policy_AC_SendSelectResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::Policy_AC_SendSelectResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "Policy_AC_SendSelectResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new Policy_AC_SendSelectResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_ACT_SetTimeout_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_ACT_SetTimeout_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_ACT_SetTimeout_REQUEST()); };
    sInf->HandleCount = 1;
    sInf->AuthHandleCount = 1;
    sInf->Fields.resize(2);
    //actHandle
    sInf->Fields[0].Name = "actHandle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID;
    //startTimeout
    sInf->Fields[1].Name = "startTimeout";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_ACT_SetTimeout_REQUEST_ID;
    
    // ======== ACT_SetTimeoutResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ACT_SetTimeoutResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "ACT_SetTimeoutResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new ACT_SetTimeoutResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(0);
    
    // ======== TPM2_Vendor_TCG_Test_REQUEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2_Vendor_TCG_Test_REQUEST";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2_Vendor_TCG_Test_REQUEST()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //inputDataSize
    sInf->Fields[0].Name = "inputDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
    //inputData
    sInf->Fields[1].Name = "inputData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2_Vendor_TCG_Test_REQUEST_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== Vendor_TCG_TestResponse ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::Vendor_TCG_TestResponse_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "Vendor_TCG_TestResponse";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new Vendor_TCG_TestResponse()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //outputDataSize
    sInf->Fields[0].Name = "outputDataSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::Vendor_TCG_TestResponse_ID;
    //outputData
    sInf->Fields[1].Name = "outputData";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::Vendor_TCG_TestResponse_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TssObject ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TssObject_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TssObject";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TssObject()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //Public
    sInf->Fields[0].Name = "Public";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TssObject_ID;
    //Sensitive
    sInf->Fields[1].Name = "Sensitive";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_SENSITIVE_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::TssObject_ID;
    //Private
    sInf->Fields[2].Name = "Private";
    sInf->Fields[2].TypeId = TpmTypeId::TPM2B_PRIVATE_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::TssObject_ID;
    
    // ======== PcrValue ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PcrValue_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "PcrValue";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new PcrValue()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //index
    sInf->Fields[0].Name = "index";
    sInf->Fields[0].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::PcrValue_ID;
    //value
    sInf->Fields[1].Name = "value";
    sInf->Fields[1].TypeId = TpmTypeId::TPMT_HA_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::PcrValue_ID;
    
    // ======== SessionIn ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SessionIn_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SessionIn";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SessionIn()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(6);
    //handle
    sInf->Fields[0].Name = "handle";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_HANDLE_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::SessionIn_ID;
    //nonceCallerSize
    sInf->Fields[1].Name = "nonceCallerSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::SessionIn_ID;
    //nonceCaller
    sInf->Fields[2].Name = "nonceCaller";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[2].AssociatedField = 1;
    //attributes
    sInf->Fields[3].Name = "attributes";
    sInf->Fields[3].TypeId = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[3].MarshalType = MarshalType::Normal;
    sInf->Fields[3].ParentType = TpmTypeId::SessionIn_ID;
    //authSize
    sInf->Fields[4].Name = "authSize";
    sInf->Fields[4].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[4].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[4].ParentType = TpmTypeId::SessionIn_ID;
    //auth
    sInf->Fields[5].Name = "auth";
    sInf->Fields[5].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[5].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[5].ParentType = TpmTypeId::SessionIn_ID;
    sInf->Fields[5].AssociatedField = 4;
    
    // ======== SessionOut ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SessionOut_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "SessionOut";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new SessionOut()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(5);
    //nonceTpmSize
    sInf->Fields[0].Name = "nonceTpmSize";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::SessionOut_ID;
    //nonceTpm
    sInf->Fields[1].Name = "nonceTpm";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::SessionOut_ID;
    sInf->Fields[1].AssociatedField = 0;
    //attributes
    sInf->Fields[2].Name = "attributes";
    sInf->Fields[2].TypeId = TpmTypeId::TPMA_SESSION_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::SessionOut_ID;
    //authSize
    sInf->Fields[3].Name = "authSize";
    sInf->Fields[3].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[3].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[3].ParentType = TpmTypeId::SessionOut_ID;
    //auth
    sInf->Fields[4].Name = "auth";
    sInf->Fields[4].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[4].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[4].ParentType = TpmTypeId::SessionOut_ID;
    sInf->Fields[4].AssociatedField = 3;
    
    // ======== CommandHeader ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CommandHeader_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "CommandHeader";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new CommandHeader()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //Tag
    sInf->Fields[0].Name = "Tag";
    sInf->Fields[0].TypeId = TpmTypeId::TPM_ST_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::CommandHeader_ID;
    //CommandSize
    sInf->Fields[1].Name = "CommandSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT32_ID;
    sInf->Fields[1].MarshalType = MarshalType::Normal;
    sInf->Fields[1].ParentType = TpmTypeId::CommandHeader_ID;
    //CommandCode
    sInf->Fields[2].Name = "CommandCode";
    sInf->Fields[2].TypeId = TpmTypeId::TPM_CC_ID;
    sInf->Fields[2].MarshalType = MarshalType::Normal;
    sInf->Fields[2].ParentType = TpmTypeId::CommandHeader_ID;
    
    // ======== TSS_KEY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TSS_KEY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TSS_KEY";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TSS_KEY()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(3);
    //publicPart
    sInf->Fields[0].Name = "publicPart";
    sInf->Fields[0].TypeId = TpmTypeId::TPMT_PUBLIC_ID;
    sInf->Fields[0].MarshalType = MarshalType::Normal;
    sInf->Fields[0].ParentType = TpmTypeId::TSS_KEY_ID;
    //privatePartSize
    sInf->Fields[1].Name = "privatePartSize";
    sInf->Fields[1].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[1].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[1].ParentType = TpmTypeId::TSS_KEY_ID;
    //privatePart
    sInf->Fields[2].Name = "privatePart";
    sInf->Fields[2].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[2].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[2].ParentType = TpmTypeId::TSS_KEY_ID;
    sInf->Fields[2].AssociatedField = 1;
    
    // ======== TPM2B_DIGEST_Symcipher ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_DIGEST_Symcipher_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_DIGEST_Symcipher";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DIGEST_Symcipher()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPM2B_DIGEST_Keyedhash ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM2B_DIGEST_Keyedhash_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmStruct;
    sInf->Name = "TPM2B_DIGEST_Keyedhash";
    sInf->Factory = []() { return dynamic_cast<TpmStructureBase*>(new TPM2B_DIGEST_Keyedhash()); };
    sInf->HandleCount = 0;
    sInf->AuthHandleCount = 0;
    sInf->Fields.resize(2);
    //size
    sInf->Fields[0].Name = "size";
    sInf->Fields[0].TypeId = TpmTypeId::UINT16_ID;
    sInf->Fields[0].MarshalType = MarshalType::ArrayCount;
    sInf->Fields[0].ParentType = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    //buffer
    sInf->Fields[1].Name = "buffer";
    sInf->Fields[1].TypeId = TpmTypeId::BYTE_ID;
    sInf->Fields[1].MarshalType = MarshalType::VariableLengthArray;
    sInf->Fields[1].ParentType = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    sInf->Fields[1].AssociatedField = 0;
    
    // ======== TPMU_HA ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_HA_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_HA";
    sInf->UnionSelector.resize(8);
    sInf->UnionType.resize(8);
    sInf->UnionSelector[0] = TPM_ALG_ID::SHA1;
    sInf->UnionType[0] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::SHA256;
    sInf->UnionType[1] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::SHA384;
    sInf->UnionType[2] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::SHA512;
    sInf->UnionType[3] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::SM3_256;
    sInf->UnionType[4] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::SHA3_256;
    sInf->UnionType[5] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[6] = TPM_ALG_ID::SHA3_384;
    sInf->UnionType[6] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[7] = TPM_ALG_ID::SHA3_512;
    sInf->UnionType[7] = TpmTypeId::BYTE_ID;
    
    // ======== TPMU_NAME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_NAME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_NAME";
    sInf->UnionSelector.resize(2);
    sInf->UnionType.resize(2);
    sInf->UnionSelector[0] = NameUnionTagValues::TAG_TPMU_NAME_TPMT_HA;
    sInf->UnionType[0] = TpmTypeId::TPMT_HA_ID;
    sInf->UnionSelector[1] = NameUnionTagValues::TAG_TPMU_NAME_TPM_HANDLE;
    sInf->UnionType[1] = TpmTypeId::TPM_HANDLE_ID;
    
    // ======== TPMU_CAPABILITIES ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_CAPABILITIES_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_CAPABILITIES";
    sInf->UnionSelector.resize(11);
    sInf->UnionType.resize(11);
    sInf->UnionSelector[0] = TPM_CAP::ALGS;
    sInf->UnionType[0] = TpmTypeId::TPML_ALG_PROPERTY_ID;
    sInf->UnionSelector[1] = TPM_CAP::HANDLES;
    sInf->UnionType[1] = TpmTypeId::TPML_HANDLE_ID;
    sInf->UnionSelector[2] = TPM_CAP::COMMANDS;
    sInf->UnionType[2] = TpmTypeId::TPML_CCA_ID;
    sInf->UnionSelector[3] = TPM_CAP::PP_COMMANDS;
    sInf->UnionType[3] = TpmTypeId::TPML_CC_ID;
    sInf->UnionSelector[4] = TPM_CAP::AUDIT_COMMANDS;
    sInf->UnionType[4] = TpmTypeId::TPML_CC_ID;
    sInf->UnionSelector[5] = TPM_CAP::PCRS;
    sInf->UnionType[5] = TpmTypeId::TPML_PCR_SELECTION_ID;
    sInf->UnionSelector[6] = TPM_CAP::TPM_PROPERTIES;
    sInf->UnionType[6] = TpmTypeId::TPML_TAGGED_TPM_PROPERTY_ID;
    sInf->UnionSelector[7] = TPM_CAP::PCR_PROPERTIES;
    sInf->UnionType[7] = TpmTypeId::TPML_TAGGED_PCR_PROPERTY_ID;
    sInf->UnionSelector[8] = TPM_CAP::ECC_CURVES;
    sInf->UnionType[8] = TpmTypeId::TPML_ECC_CURVE_ID;
    sInf->UnionSelector[9] = TPM_CAP::AUTH_POLICIES;
    sInf->UnionType[9] = TpmTypeId::TPML_TAGGED_POLICY_ID;
    sInf->UnionSelector[10] = TPM_CAP::ACT;
    sInf->UnionType[10] = TpmTypeId::TPML_ACT_DATA_ID;
    
    // ======== TPMU_ATTEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_ATTEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_ATTEST";
    sInf->UnionSelector.resize(8);
    sInf->UnionType.resize(8);
    sInf->UnionSelector[0] = TPM_ST::ATTEST_CERTIFY;
    sInf->UnionType[0] = TpmTypeId::TPMS_CERTIFY_INFO_ID;
    sInf->UnionSelector[1] = TPM_ST::ATTEST_CREATION;
    sInf->UnionType[1] = TpmTypeId::TPMS_CREATION_INFO_ID;
    sInf->UnionSelector[2] = TPM_ST::ATTEST_QUOTE;
    sInf->UnionType[2] = TpmTypeId::TPMS_QUOTE_INFO_ID;
    sInf->UnionSelector[3] = TPM_ST::ATTEST_COMMAND_AUDIT;
    sInf->UnionType[3] = TpmTypeId::TPMS_COMMAND_AUDIT_INFO_ID;
    sInf->UnionSelector[4] = TPM_ST::ATTEST_SESSION_AUDIT;
    sInf->UnionType[4] = TpmTypeId::TPMS_SESSION_AUDIT_INFO_ID;
    sInf->UnionSelector[5] = TPM_ST::ATTEST_TIME;
    sInf->UnionType[5] = TpmTypeId::TPMS_TIME_ATTEST_INFO_ID;
    sInf->UnionSelector[6] = TPM_ST::ATTEST_NV;
    sInf->UnionType[6] = TpmTypeId::TPMS_NV_CERTIFY_INFO_ID;
    sInf->UnionSelector[7] = TPM_ST::ATTEST_NV_DIGEST;
    sInf->UnionType[7] = TpmTypeId::TPMS_NV_DIGEST_CERTIFY_INFO_ID;
    
    // ======== TPMU_SYM_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SYM_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SYM_KEY_BITS";
    sInf->UnionSelector.resize(7);
    sInf->UnionType.resize(7);
    sInf->UnionSelector[0] = TPM_ALG_ID::TDES;
    sInf->UnionType[0] = TpmTypeId::TPMI_TDES_KEY_BITS_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::AES;
    sInf->UnionType[1] = TpmTypeId::TPMI_AES_KEY_BITS_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::SM4;
    sInf->UnionType[2] = TpmTypeId::TPMI_SM4_KEY_BITS_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::CAMELLIA;
    sInf->UnionType[3] = TpmTypeId::TPMI_CAMELLIA_KEY_BITS_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPM_KEY_BITS_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::XOR;
    sInf->UnionType[5] = TpmTypeId::TPMI_ALG_HASH_ID;
    sInf->UnionSelector[6] = TPM_ALG_ID::_NULL;
    sInf->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_KEY_BITS_ID;
    
    // ======== TPMU_SYM_MODE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SYM_MODE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SYM_MODE";
    sInf->UnionSelector.resize(7);
    sInf->UnionType.resize(7);
    sInf->UnionSelector[0] = TPM_ALG_ID::TDES;
    sInf->UnionType[0] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::AES;
    sInf->UnionType[1] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::SM4;
    sInf->UnionType[2] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::CAMELLIA;
    sInf->UnionType[3] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMI_ALG_SYM_MODE_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::XOR;
    sInf->UnionType[5] = TpmTypeId::TPMS_XOR_SYM_MODE_ID;
    sInf->UnionSelector[6] = TPM_ALG_ID::_NULL;
    sInf->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_MODE_ID;
    
    // ======== TPMU_SYM_DETAILS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SYM_DETAILS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SYM_DETAILS";
    sInf->UnionSelector.resize(7);
    sInf->UnionType.resize(7);
    sInf->UnionSelector[0] = TPM_ALG_ID::TDES;
    sInf->UnionType[0] = TpmTypeId::TPMS_TDES_SYM_DETAILS_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::AES;
    sInf->UnionType[1] = TpmTypeId::TPMS_AES_SYM_DETAILS_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::SM4;
    sInf->UnionType[2] = TpmTypeId::TPMS_SM4_SYM_DETAILS_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::CAMELLIA;
    sInf->UnionType[3] = TpmTypeId::TPMS_CAMELLIA_SYM_DETAILS_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMS_ANY_SYM_DETAILS_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::XOR;
    sInf->UnionType[5] = TpmTypeId::TPMS_XOR_SYM_DETAILS_ID;
    sInf->UnionSelector[6] = TPM_ALG_ID::_NULL;
    sInf->UnionType[6] = TpmTypeId::TPMS_NULL_SYM_DETAILS_ID;
    
    // ======== TPMU_SENSITIVE_CREATE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SENSITIVE_CREATE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SENSITIVE_CREATE";
    sInf->UnionSelector.resize(2);
    sInf->UnionType.resize(2);
    sInf->UnionSelector[0] = TPM_ALG_ID::ANY;
    sInf->UnionType[0] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::ANY2;
    sInf->UnionType[1] = TpmTypeId::TPMS_DERIVE_ID;
    
    // ======== TPMU_SCHEME_KEYEDHASH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SCHEME_KEYEDHASH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SCHEME_KEYEDHASH";
    sInf->UnionSelector.resize(3);
    sInf->UnionType.resize(3);
    sInf->UnionSelector[0] = TPM_ALG_ID::HMAC;
    sInf->UnionType[0] = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::XOR;
    sInf->UnionType[1] = TpmTypeId::TPMS_SCHEME_XOR_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::_NULL;
    sInf->UnionType[2] = TpmTypeId::TPMS_NULL_SCHEME_KEYEDHASH_ID;
    
    // ======== TPMU_SIG_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SIG_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SIG_SCHEME";
    sInf->UnionSelector.resize(9);
    sInf->UnionType.resize(9);
    sInf->UnionSelector[0] = TPM_ALG_ID::RSASSA;
    sInf->UnionType[0] = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::RSAPSS;
    sInf->UnionType[1] = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::ECDSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::ECDAA;
    sInf->UnionType[3] = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::SM2;
    sInf->UnionType[4] = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::ECSCHNORR;
    sInf->UnionType[5] = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    sInf->UnionSelector[6] = TPM_ALG_ID::HMAC;
    sInf->UnionType[6] = TpmTypeId::TPMS_SCHEME_HMAC_ID;
    sInf->UnionSelector[7] = TPM_ALG_ID::ANY;
    sInf->UnionType[7] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->UnionSelector[8] = TPM_ALG_ID::_NULL;
    sInf->UnionType[8] = TpmTypeId::TPMS_NULL_SIG_SCHEME_ID;
    
    // ======== TPMU_KDF_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_KDF_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_KDF_SCHEME";
    sInf->UnionSelector.resize(6);
    sInf->UnionType.resize(6);
    sInf->UnionSelector[0] = TPM_ALG_ID::MGF1;
    sInf->UnionType[0] = TpmTypeId::TPMS_KDF_SCHEME_MGF1_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::KDF1_SP800_56A;
    sInf->UnionType[1] = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_56A_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::KDF2;
    sInf->UnionType[2] = TpmTypeId::TPMS_KDF_SCHEME_KDF2_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::KDF1_SP800_108;
    sInf->UnionType[3] = TpmTypeId::TPMS_KDF_SCHEME_KDF1_SP800_108_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::_NULL;
    sInf->UnionType[5] = TpmTypeId::TPMS_NULL_KDF_SCHEME_ID;
    
    // ======== TPMU_ASYM_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_ASYM_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_ASYM_SCHEME";
    sInf->UnionSelector.resize(12);
    sInf->UnionType.resize(12);
    sInf->UnionSelector[0] = TPM_ALG_ID::ECDH;
    sInf->UnionType[0] = TpmTypeId::TPMS_KEY_SCHEME_ECDH_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::ECMQV;
    sInf->UnionType[1] = TpmTypeId::TPMS_KEY_SCHEME_ECMQV_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::RSASSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_SIG_SCHEME_RSASSA_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::RSAPSS;
    sInf->UnionType[3] = TpmTypeId::TPMS_SIG_SCHEME_RSAPSS_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ECDSA;
    sInf->UnionType[4] = TpmTypeId::TPMS_SIG_SCHEME_ECDSA_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::ECDAA;
    sInf->UnionType[5] = TpmTypeId::TPMS_SIG_SCHEME_ECDAA_ID;
    sInf->UnionSelector[6] = TPM_ALG_ID::SM2;
    sInf->UnionType[6] = TpmTypeId::TPMS_SIG_SCHEME_SM2_ID;
    sInf->UnionSelector[7] = TPM_ALG_ID::ECSCHNORR;
    sInf->UnionType[7] = TpmTypeId::TPMS_SIG_SCHEME_ECSCHNORR_ID;
    sInf->UnionSelector[8] = TPM_ALG_ID::RSAES;
    sInf->UnionType[8] = TpmTypeId::TPMS_ENC_SCHEME_RSAES_ID;
    sInf->UnionSelector[9] = TPM_ALG_ID::OAEP;
    sInf->UnionType[9] = TpmTypeId::TPMS_ENC_SCHEME_OAEP_ID;
    sInf->UnionSelector[10] = TPM_ALG_ID::ANY;
    sInf->UnionType[10] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->UnionSelector[11] = TPM_ALG_ID::_NULL;
    sInf->UnionType[11] = TpmTypeId::TPMS_NULL_ASYM_SCHEME_ID;
    
    // ======== TPMU_SIGNATURE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SIGNATURE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SIGNATURE";
    sInf->UnionSelector.resize(9);
    sInf->UnionType.resize(9);
    sInf->UnionSelector[0] = TPM_ALG_ID::RSASSA;
    sInf->UnionType[0] = TpmTypeId::TPMS_SIGNATURE_RSASSA_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::RSAPSS;
    sInf->UnionType[1] = TpmTypeId::TPMS_SIGNATURE_RSAPSS_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::ECDSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_SIGNATURE_ECDSA_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::ECDAA;
    sInf->UnionType[3] = TpmTypeId::TPMS_SIGNATURE_ECDAA_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::SM2;
    sInf->UnionType[4] = TpmTypeId::TPMS_SIGNATURE_SM2_ID;
    sInf->UnionSelector[5] = TPM_ALG_ID::ECSCHNORR;
    sInf->UnionType[5] = TpmTypeId::TPMS_SIGNATURE_ECSCHNORR_ID;
    sInf->UnionSelector[6] = TPM_ALG_ID::HMAC;
    sInf->UnionType[6] = TpmTypeId::TPMT_HA_ID;
    sInf->UnionSelector[7] = TPM_ALG_ID::ANY;
    sInf->UnionType[7] = TpmTypeId::TPMS_SCHEME_HASH_ID;
    sInf->UnionSelector[8] = TPM_ALG_ID::_NULL;
    sInf->UnionType[8] = TpmTypeId::TPMS_NULL_SIGNATURE_ID;
    
    // ======== TPMU_ENCRYPTED_SECRET ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_ENCRYPTED_SECRET_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_ENCRYPTED_SECRET";
    sInf->UnionSelector.resize(4);
    sInf->UnionType.resize(4);
    sInf->UnionSelector[0] = TPM_ALG_ID::ECC;
    sInf->UnionType[0] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::RSA;
    sInf->UnionType[1] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[2] = TpmTypeId::BYTE_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[3] = TpmTypeId::BYTE_ID;
    
    // ======== TPMU_PUBLIC_ID ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_PUBLIC_ID_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_PUBLIC_ID";
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    sInf->UnionSelector[0] = TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[0] = TpmTypeId::TPM2B_DIGEST_Keyedhash_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[1] = TpmTypeId::TPM2B_DIGEST_Symcipher_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::RSA;
    sInf->UnionType[2] = TpmTypeId::TPM2B_PUBLIC_KEY_RSA_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::ECC;
    sInf->UnionType[3] = TpmTypeId::TPMS_ECC_POINT_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMS_DERIVE_ID;
    
    // ======== TPMU_PUBLIC_PARMS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_PUBLIC_PARMS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_PUBLIC_PARMS";
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    sInf->UnionSelector[0] = TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[0] = TpmTypeId::TPMS_KEYEDHASH_PARMS_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[1] = TpmTypeId::TPMS_SYMCIPHER_PARMS_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::RSA;
    sInf->UnionType[2] = TpmTypeId::TPMS_RSA_PARMS_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::ECC;
    sInf->UnionType[3] = TpmTypeId::TPMS_ECC_PARMS_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPMS_ASYM_PARMS_ID;
    
    // ======== TPMU_SENSITIVE_COMPOSITE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMU_SENSITIVE_COMPOSITE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmUnion;
    sInf->Name = "TPMU_SENSITIVE_COMPOSITE";
    sInf->UnionSelector.resize(5);
    sInf->UnionType.resize(5);
    sInf->UnionSelector[0] = TPM_ALG_ID::RSA;
    sInf->UnionType[0] = TpmTypeId::TPM2B_PRIVATE_KEY_RSA_ID;
    sInf->UnionSelector[1] = TPM_ALG_ID::ECC;
    sInf->UnionType[1] = TpmTypeId::TPM2B_ECC_PARAMETER_ID;
    sInf->UnionSelector[2] = TPM_ALG_ID::KEYEDHASH;
    sInf->UnionType[2] = TpmTypeId::TPM2B_SENSITIVE_DATA_ID;
    sInf->UnionSelector[3] = TPM_ALG_ID::SYMCIPHER;
    sInf->UnionType[3] = TpmTypeId::TPM2B_SYM_KEY_ID;
    sInf->UnionSelector[4] = TPM_ALG_ID::ANY;
    sInf->UnionType[4] = TpmTypeId::TPM2B_PRIVATE_VENDOR_SPECIFIC_ID;
    
    // ======== TPMA_ALGORITHM ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_ALGORITHM_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_ALGORITHM";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "asymmetric";
    sInf->BitNames[1] = "symmetric";
    sInf->BitNames[2] = "hash";
    sInf->BitNames[3] = "object";
    sInf->BitNames[8] = "signing";
    sInf->BitNames[9] = "encrypting";
    sInf->BitNames[10] = "method";
    
    // ======== TPMA_OBJECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_OBJECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_OBJECT";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "Reserved";
    sInf->BitNames[1] = "fixedTPM";
    sInf->BitNames[2] = "stClear";
    sInf->BitNames[3] = "Reserved";
    sInf->BitNames[4] = "fixedParent";
    sInf->BitNames[5] = "sensitiveDataOrigin";
    sInf->BitNames[6] = "userWithAuth";
    sInf->BitNames[7] = "adminWithPolicy";
    sInf->BitNames[10] = "noDA";
    sInf->BitNames[11] = "encryptedDuplication";
    sInf->BitNames[16] = "restricted";
    sInf->BitNames[17] = "decrypt";
    sInf->BitNames[18] = "sign";
    sInf->BitNames[18] = "encrypt";
    sInf->BitNames[19] = "x509sign";
    
    // ======== TPMA_SESSION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_SESSION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_SESSION";
    sInf->Size = sizeof(BYTE);
    sInf->BitNames.resize(8);
    sInf->BitNames[0] = "continueSession";
    sInf->BitNames[1] = "auditExclusive";
    sInf->BitNames[2] = "auditReset";
    sInf->BitNames[5] = "decrypt";
    sInf->BitNames[6] = "encrypt";
    sInf->BitNames[7] = "audit";
    
    // ======== TPMA_LOCALITY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_LOCALITY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_LOCALITY";
    sInf->Size = sizeof(BYTE);
    sInf->BitNames.resize(8);
    sInf->BitNames[0] = "LOC_ZERO";
    sInf->BitNames[1] = "LOC_ONE";
    sInf->BitNames[2] = "LOC_TWO";
    sInf->BitNames[3] = "LOC_THREE";
    sInf->BitNames[4] = "LOC_FOUR";
    
    // ======== TPMA_PERMANENT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_PERMANENT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_PERMANENT";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "ownerAuthSet";
    sInf->BitNames[1] = "endorsementAuthSet";
    sInf->BitNames[2] = "lockoutAuthSet";
    sInf->BitNames[8] = "disableClear";
    sInf->BitNames[9] = "inLockout";
    sInf->BitNames[10] = "tpmGeneratedEPS";
    
    // ======== TPMA_STARTUP_CLEAR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_STARTUP_CLEAR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_STARTUP_CLEAR";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "phEnable";
    sInf->BitNames[1] = "shEnable";
    sInf->BitNames[2] = "ehEnable";
    sInf->BitNames[3] = "phEnableNV";
    sInf->BitNames[31] = "orderly";
    
    // ======== TPMA_MEMORY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_MEMORY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_MEMORY";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "sharedRAM";
    sInf->BitNames[1] = "sharedNV";
    sInf->BitNames[2] = "objectCopiedToRam";
    
    // ======== TPMA_CC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_CC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_CC";
    sInf->Size = sizeof(TPM_CC);
    sInf->BitNames.resize(32);
    sInf->BitNames[22] = "nv";
    sInf->BitNames[23] = "extensive";
    sInf->BitNames[24] = "flushed";
    sInf->BitNames[28] = "rHandle";
    sInf->BitNames[29] = "V";
    
    // ======== TPMA_MODES ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_MODES_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_MODES";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "FIPS_140_2";
    
    // ======== TPMA_X509_KEY_USAGE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_X509_KEY_USAGE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_X509_KEY_USAGE";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[23] = "decipherOnly";
    sInf->BitNames[24] = "encipherOnly";
    sInf->BitNames[25] = "cRLSign";
    sInf->BitNames[26] = "keyCertSign";
    sInf->BitNames[27] = "keyAgreement";
    sInf->BitNames[28] = "dataEncipherment";
    sInf->BitNames[29] = "keyEncipherment";
    sInf->BitNames[30] = "nonrepudiation";
    sInf->BitNames[30] = "contentCommitment";
    sInf->BitNames[31] = "digitalSignature";
    
    // ======== TPMA_ACT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_ACT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_ACT";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "signaled";
    sInf->BitNames[1] = "preserveSignaled";
    
    // ======== TPM_NV_INDEX ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_NV_INDEX_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPM_NV_INDEX";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    
    // ======== TPMA_NV ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMA_NV_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmBitfield;
    sInf->Name = "TPMA_NV";
    sInf->Size = sizeof(UINT32);
    sInf->BitNames.resize(32);
    sInf->BitNames[0] = "PPWRITE";
    sInf->BitNames[1] = "OWNERWRITE";
    sInf->BitNames[2] = "AUTHWRITE";
    sInf->BitNames[3] = "POLICYWRITE";
    sInf->BitNames[10] = "POLICY_DELETE";
    sInf->BitNames[11] = "WRITELOCKED";
    sInf->BitNames[12] = "WRITEALL";
    sInf->BitNames[13] = "WRITEDEFINE";
    sInf->BitNames[14] = "WRITE_STCLEAR";
    sInf->BitNames[15] = "GLOBALLOCK";
    sInf->BitNames[16] = "PPREAD";
    sInf->BitNames[17] = "OWNERREAD";
    sInf->BitNames[18] = "AUTHREAD";
    sInf->BitNames[19] = "POLICYREAD";
    sInf->BitNames[25] = "NO_DA";
    sInf->BitNames[26] = "ORDERLY";
    sInf->BitNames[27] = "CLEAR_STCLEAR";
    sInf->BitNames[28] = "READLOCKED";
    sInf->BitNames[29] = "WRITTEN";
    sInf->BitNames[30] = "PLATFORMCREATE";
    sInf->BitNames[31] = "READ_STCLEAR";
    
    // ======== NameUnionTagValues ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::NameUnionTagValues_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "NameUnionTagValues";
    sInf->Size = sizeof(BYTE);
    sInf->EnumNames.clear();
    sInf->EnumNames[0] = "TAG_TPMU_NAME_TPMT_HA";
    sInf->EnumNames[1] = "TAG_TPMU_NAME_TPM_HANDLE";
    
    // ======== TPM_ALG_ID ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_ALG_ID_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_ALG_ID";
    sInf->Size = sizeof(UINT16);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x0000] = "_ERROR";
    sInf->EnumNames[0x0001] = "FIRST";
    sInf->EnumNames[0x0001] = "RSA";
    sInf->EnumNames[0x0003] = "TDES";
    sInf->EnumNames[0x0004] = "SHA";
    sInf->EnumNames[0x0004] = "SHA1";
    sInf->EnumNames[0x0005] = "HMAC";
    sInf->EnumNames[0x0006] = "AES";
    sInf->EnumNames[0x0007] = "MGF1";
    sInf->EnumNames[0x0008] = "KEYEDHASH";
    sInf->EnumNames[0x000A] = "XOR";
    sInf->EnumNames[0x000B] = "SHA256";
    sInf->EnumNames[0x000C] = "SHA384";
    sInf->EnumNames[0x000D] = "SHA512";
    sInf->EnumNames[0x0010] = "_NULL";
    sInf->EnumNames[0x0012] = "SM3_256";
    sInf->EnumNames[0x0013] = "SM4";
    sInf->EnumNames[0x0014] = "RSASSA";
    sInf->EnumNames[0x0015] = "RSAES";
    sInf->EnumNames[0x0016] = "RSAPSS";
    sInf->EnumNames[0x0017] = "OAEP";
    sInf->EnumNames[0x0018] = "ECDSA";
    sInf->EnumNames[0x0019] = "ECDH";
    sInf->EnumNames[0x001A] = "ECDAA";
    sInf->EnumNames[0x001B] = "SM2";
    sInf->EnumNames[0x001C] = "ECSCHNORR";
    sInf->EnumNames[0x001D] = "ECMQV";
    sInf->EnumNames[0x0020] = "KDF1_SP800_56A";
    sInf->EnumNames[0x0021] = "KDF2";
    sInf->EnumNames[0x0022] = "KDF1_SP800_108";
    sInf->EnumNames[0x0023] = "ECC";
    sInf->EnumNames[0x0025] = "SYMCIPHER";
    sInf->EnumNames[0x0026] = "CAMELLIA";
    sInf->EnumNames[0x0027] = "SHA3_256";
    sInf->EnumNames[0x0028] = "SHA3_384";
    sInf->EnumNames[0x0029] = "SHA3_512";
    sInf->EnumNames[0x003F] = "CMAC";
    sInf->EnumNames[0x0040] = "CTR";
    sInf->EnumNames[0x0041] = "OFB";
    sInf->EnumNames[0x0042] = "CBC";
    sInf->EnumNames[0x0043] = "CFB";
    sInf->EnumNames[0x0044] = "ECB";
    sInf->EnumNames[0x0044] = "LAST";
    sInf->EnumNames[0x7FFF] = "ANY";
    sInf->EnumNames[0x7FFE] = "ANY2";
    
    // ======== TPM_ECC_CURVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_ECC_CURVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_ECC_CURVE";
    sInf->Size = sizeof(UINT16);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x0000] = "NONE";
    sInf->EnumNames[0x0001] = "NIST_P192";
    sInf->EnumNames[0x0002] = "NIST_P224";
    sInf->EnumNames[0x0003] = "NIST_P256";
    sInf->EnumNames[0x0004] = "NIST_P384";
    sInf->EnumNames[0x0005] = "NIST_P521";
    sInf->EnumNames[0x0010] = "BN_P256";
    sInf->EnumNames[0x0011] = "BN_P638";
    sInf->EnumNames[0x0020] = "SM2_P256";
    sInf->EnumNames[0x0021] = "TEST_P192";
    
    // ======== SHA1 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SHA1_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SHA1";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[20] = "DIGEST_SIZE";
    sInf->EnumNames[64] = "BLOCK_SIZE";
    
    // ======== SHA256 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SHA256_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SHA256";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[32] = "DIGEST_SIZE";
    sInf->EnumNames[64] = "BLOCK_SIZE";
    
    // ======== SHA384 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SHA384_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SHA384";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[48] = "DIGEST_SIZE";
    sInf->EnumNames[128] = "BLOCK_SIZE";
    
    // ======== SHA512 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SHA512_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SHA512";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[64] = "DIGEST_SIZE";
    sInf->EnumNames[128] = "BLOCK_SIZE";
    
    // ======== SM3_256 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SM3_256_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SM3_256";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[32] = "DIGEST_SIZE";
    sInf->EnumNames[64] = "BLOCK_SIZE";
    
    // ======== SHA3_256 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SHA3_256_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SHA3_256";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[32] = "DIGEST_SIZE";
    sInf->EnumNames[136] = "BLOCK_SIZE";
    
    // ======== SHA3_384 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SHA3_384_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SHA3_384";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[48] = "DIGEST_SIZE";
    sInf->EnumNames[104] = "BLOCK_SIZE";
    
    // ======== SHA3_512 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::SHA3_512_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "SHA3_512";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[64] = "DIGEST_SIZE";
    sInf->EnumNames[72] = "BLOCK_SIZE";
    
    // ======== ImplementationConstants ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ImplementationConstants_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "ImplementationConstants";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[1] = "Ossl";
    sInf->EnumNames[2] = "Ltc";
    sInf->EnumNames[3] = "Msbn";
    sInf->EnumNames[4] = "Symcrypt";
    sInf->EnumNames[3] = "HASH_COUNT";
    sInf->EnumNames[256] = "MAX_SYM_KEY_BITS";
    sInf->EnumNames[((ImplementationConstants::MAX_SYM_KEY_BITS + 7) / 8)] = "MAX_SYM_KEY_BYTES";
    sInf->EnumNames[16] = "MAX_SYM_BLOCK_SIZE";
    sInf->EnumNames[TPM_CC::LAST] = "MAX_CAP_CC";
    sInf->EnumNames[256] = "MAX_RSA_KEY_BYTES";
    sInf->EnumNames[32] = "MAX_AES_KEY_BYTES";
    sInf->EnumNames[48] = "MAX_ECC_KEY_BYTES";
    sInf->EnumNames[32] = "LABEL_MAX_BUFFER";
    sInf->EnumNames[sizeof(UINT32)] = "_TPM_CAP_SIZE";
    sInf->EnumNames[(Implementation::MAX_CAP_BUFFER-ImplementationConstants::_TPM_CAP_SIZE-sizeof(UINT32))] = "MAX_CAP_DATA";
    sInf->EnumNames[(ImplementationConstants::MAX_CAP_DATA / 0x6 /*sizeof(TPMS_ALG_PROPERTY)*/)] = "MAX_CAP_ALGS";
    sInf->EnumNames[(ImplementationConstants::MAX_CAP_DATA / 0x4 /*sizeof(TPM_HANDLE)*/)] = "MAX_CAP_HANDLES";
    sInf->EnumNames[(ImplementationConstants::MAX_CAP_DATA / 0x8 /*sizeof(TPMS_TAGGED_PROPERTY)*/)] = "MAX_TPM_PROPERTIES";
    sInf->EnumNames[(ImplementationConstants::MAX_CAP_DATA / 0x8 /*sizeof(TPMS_TAGGED_PCR_SELECT)*/)] = "MAX_PCR_PROPERTIES";
    sInf->EnumNames[(ImplementationConstants::MAX_CAP_DATA / sizeof(TPM_ECC_CURVE))] = "MAX_ECC_CURVES";
    sInf->EnumNames[(ImplementationConstants::MAX_CAP_DATA / 0x36 /*sizeof(TPMS_TAGGED_POLICY)*/)] = "MAX_TAGGED_POLICIES";
    sInf->EnumNames[(ImplementationConstants::MAX_CAP_DATA / 0x8 /*sizeof(TPMS_AC_OUTPUT)*/)] = "MAX_AC_CAPABILITIES";
    sInf->EnumNames[ImplementationConstants::MAX_CAP_DATA / 0xC /*sizeof(TPMS_ACT_DATA)*/] = "MAX_ACT_DATA";
    
    // ======== Logic ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::Logic_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "Logic";
    sInf->Size = sizeof(BYTE);
    sInf->EnumNames.clear();
    sInf->EnumNames[1] = "TRUE";
    sInf->EnumNames[0] = "FALSE";
    sInf->EnumNames[1] = "YES";
    sInf->EnumNames[0] = "NO";
    sInf->EnumNames[1] = "SET";
    sInf->EnumNames[0] = "CLEAR";
    
    // ======== TPM_SPEC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_SPEC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_SPEC";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x322E3000] = "FAMILY";
    sInf->EnumNames[00] = "LEVEL";
    sInf->EnumNames[161] = "VERSION";
    sInf->EnumNames[2019] = "YEAR";
    sInf->EnumNames[360] = "DAY_OF_YEAR";
    
    // ======== TPM_GENERATED ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_GENERATED_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_GENERATED";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0xff544347] = "VALUE";
    
    // ======== TPM_CC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_CC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_CC";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x0000011F] = "FIRST";
    sInf->EnumNames[0x0000011F] = "NV_UndefineSpaceSpecial";
    sInf->EnumNames[0x00000120] = "EvictControl";
    sInf->EnumNames[0x00000121] = "HierarchyControl";
    sInf->EnumNames[0x00000122] = "NV_UndefineSpace";
    sInf->EnumNames[0x00000124] = "ChangeEPS";
    sInf->EnumNames[0x00000125] = "ChangePPS";
    sInf->EnumNames[0x00000126] = "Clear";
    sInf->EnumNames[0x00000127] = "ClearControl";
    sInf->EnumNames[0x00000128] = "ClockSet";
    sInf->EnumNames[0x00000129] = "HierarchyChangeAuth";
    sInf->EnumNames[0x0000012A] = "NV_DefineSpace";
    sInf->EnumNames[0x0000012B] = "PCR_Allocate";
    sInf->EnumNames[0x0000012C] = "PCR_SetAuthPolicy";
    sInf->EnumNames[0x0000012D] = "PP_Commands";
    sInf->EnumNames[0x0000012E] = "SetPrimaryPolicy";
    sInf->EnumNames[0x0000012F] = "FieldUpgradeStart";
    sInf->EnumNames[0x00000130] = "ClockRateAdjust";
    sInf->EnumNames[0x00000131] = "CreatePrimary";
    sInf->EnumNames[0x00000132] = "NV_GlobalWriteLock";
    sInf->EnumNames[0x00000133] = "GetCommandAuditDigest";
    sInf->EnumNames[0x00000134] = "NV_Increment";
    sInf->EnumNames[0x00000135] = "NV_SetBits";
    sInf->EnumNames[0x00000136] = "NV_Extend";
    sInf->EnumNames[0x00000137] = "NV_Write";
    sInf->EnumNames[0x00000138] = "NV_WriteLock";
    sInf->EnumNames[0x00000139] = "DictionaryAttackLockReset";
    sInf->EnumNames[0x0000013A] = "DictionaryAttackParameters";
    sInf->EnumNames[0x0000013B] = "NV_ChangeAuth";
    sInf->EnumNames[0x0000013C] = "PCR_Event";
    sInf->EnumNames[0x0000013D] = "PCR_Reset";
    sInf->EnumNames[0x0000013E] = "SequenceComplete";
    sInf->EnumNames[0x0000013F] = "SetAlgorithmSet";
    sInf->EnumNames[0x00000140] = "SetCommandCodeAuditStatus";
    sInf->EnumNames[0x00000141] = "FieldUpgradeData";
    sInf->EnumNames[0x00000142] = "IncrementalSelfTest";
    sInf->EnumNames[0x00000143] = "SelfTest";
    sInf->EnumNames[0x00000144] = "Startup";
    sInf->EnumNames[0x00000145] = "Shutdown";
    sInf->EnumNames[0x00000146] = "StirRandom";
    sInf->EnumNames[0x00000147] = "ActivateCredential";
    sInf->EnumNames[0x00000148] = "Certify";
    sInf->EnumNames[0x00000149] = "PolicyNV";
    sInf->EnumNames[0x0000014A] = "CertifyCreation";
    sInf->EnumNames[0x0000014B] = "Duplicate";
    sInf->EnumNames[0x0000014C] = "GetTime";
    sInf->EnumNames[0x0000014D] = "GetSessionAuditDigest";
    sInf->EnumNames[0x0000014E] = "NV_Read";
    sInf->EnumNames[0x0000014F] = "NV_ReadLock";
    sInf->EnumNames[0x00000150] = "ObjectChangeAuth";
    sInf->EnumNames[0x00000151] = "PolicySecret";
    sInf->EnumNames[0x00000152] = "Rewrap";
    sInf->EnumNames[0x00000153] = "Create";
    sInf->EnumNames[0x00000154] = "ECDH_ZGen";
    sInf->EnumNames[0x00000155] = "HMAC";
    sInf->EnumNames[0x00000155] = "MAC";
    sInf->EnumNames[0x00000156] = "Import";
    sInf->EnumNames[0x00000157] = "Load";
    sInf->EnumNames[0x00000158] = "Quote";
    sInf->EnumNames[0x00000159] = "RSA_Decrypt";
    sInf->EnumNames[0x0000015B] = "HMAC_Start";
    sInf->EnumNames[0x0000015B] = "MAC_Start";
    sInf->EnumNames[0x0000015C] = "SequenceUpdate";
    sInf->EnumNames[0x0000015D] = "Sign";
    sInf->EnumNames[0x0000015E] = "Unseal";
    sInf->EnumNames[0x00000160] = "PolicySigned";
    sInf->EnumNames[0x00000161] = "ContextLoad";
    sInf->EnumNames[0x00000162] = "ContextSave";
    sInf->EnumNames[0x00000163] = "ECDH_KeyGen";
    sInf->EnumNames[0x00000164] = "EncryptDecrypt";
    sInf->EnumNames[0x00000165] = "FlushContext";
    sInf->EnumNames[0x00000167] = "LoadExternal";
    sInf->EnumNames[0x00000168] = "MakeCredential";
    sInf->EnumNames[0x00000169] = "NV_ReadPublic";
    sInf->EnumNames[0x0000016A] = "PolicyAuthorize";
    sInf->EnumNames[0x0000016B] = "PolicyAuthValue";
    sInf->EnumNames[0x0000016C] = "PolicyCommandCode";
    sInf->EnumNames[0x0000016D] = "PolicyCounterTimer";
    sInf->EnumNames[0x0000016E] = "PolicyCpHash";
    sInf->EnumNames[0x0000016F] = "PolicyLocality";
    sInf->EnumNames[0x00000170] = "PolicyNameHash";
    sInf->EnumNames[0x00000171] = "PolicyOR";
    sInf->EnumNames[0x00000172] = "PolicyTicket";
    sInf->EnumNames[0x00000173] = "ReadPublic";
    sInf->EnumNames[0x00000174] = "RSA_Encrypt";
    sInf->EnumNames[0x00000176] = "StartAuthSession";
    sInf->EnumNames[0x00000177] = "VerifySignature";
    sInf->EnumNames[0x00000178] = "ECC_Parameters";
    sInf->EnumNames[0x00000179] = "FirmwareRead";
    sInf->EnumNames[0x0000017A] = "GetCapability";
    sInf->EnumNames[0x0000017B] = "GetRandom";
    sInf->EnumNames[0x0000017C] = "GetTestResult";
    sInf->EnumNames[0x0000017D] = "Hash";
    sInf->EnumNames[0x0000017E] = "PCR_Read";
    sInf->EnumNames[0x0000017F] = "PolicyPCR";
    sInf->EnumNames[0x00000180] = "PolicyRestart";
    sInf->EnumNames[0x00000181] = "ReadClock";
    sInf->EnumNames[0x00000182] = "PCR_Extend";
    sInf->EnumNames[0x00000183] = "PCR_SetAuthValue";
    sInf->EnumNames[0x00000184] = "NV_Certify";
    sInf->EnumNames[0x00000185] = "EventSequenceComplete";
    sInf->EnumNames[0x00000186] = "HashSequenceStart";
    sInf->EnumNames[0x00000187] = "PolicyPhysicalPresence";
    sInf->EnumNames[0x00000188] = "PolicyDuplicationSelect";
    sInf->EnumNames[0x00000189] = "PolicyGetDigest";
    sInf->EnumNames[0x0000018A] = "TestParms";
    sInf->EnumNames[0x0000018B] = "Commit";
    sInf->EnumNames[0x0000018C] = "PolicyPassword";
    sInf->EnumNames[0x0000018D] = "ZGen_2Phase";
    sInf->EnumNames[0x0000018E] = "EC_Ephemeral";
    sInf->EnumNames[0x0000018F] = "PolicyNvWritten";
    sInf->EnumNames[0x00000190] = "PolicyTemplate";
    sInf->EnumNames[0x00000191] = "CreateLoaded";
    sInf->EnumNames[0x00000192] = "PolicyAuthorizeNV";
    sInf->EnumNames[0x00000193] = "EncryptDecrypt2";
    sInf->EnumNames[0x00000194] = "AC_GetCapability";
    sInf->EnumNames[0x00000195] = "AC_Send";
    sInf->EnumNames[0x00000196] = "Policy_AC_SendSelect";
    sInf->EnumNames[0x00000197] = "CertifyX509";
    sInf->EnumNames[0x00000198] = "ACT_SetTimeout";
    sInf->EnumNames[0x00000199] = "ECC_Encrypt";
    sInf->EnumNames[0x0000019A] = "ECC_Decrypt";
    sInf->EnumNames[0x0000019A] = "LAST";
    sInf->EnumNames[0x20000000] = "CC_VEND";
    sInf->EnumNames[TPM_CC::CC_VEND+0x0000] = "Vendor_TCG_Test";
    
    // ======== TPM_RC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_RC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_RC";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x000] = "SUCCESS";
    sInf->EnumNames[0x01E] = "BAD_TAG";
    sInf->EnumNames[0x100] = "RC_VER1";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x000] = "INITIALIZE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x001] = "FAILURE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x003] = "SEQUENCE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x00B] = "PRIVATE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x019] = "HMAC";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x020] = "DISABLED";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x021] = "EXCLUSIVE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x024] = "AUTH_TYPE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x025] = "AUTH_MISSING";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x026] = "POLICY";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x027] = "PCR";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x028] = "PCR_CHANGED";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x02D] = "UPGRADE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x02E] = "TOO_MANY_CONTEXTS";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x02F] = "AUTH_UNAVAILABLE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x030] = "REBOOT";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x031] = "UNBALANCED";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x042] = "COMMAND_SIZE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x043] = "COMMAND_CODE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x044] = "AUTHSIZE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x045] = "AUTH_CONTEXT";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x046] = "NV_RANGE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x047] = "NV_SIZE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x048] = "NV_LOCKED";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x049] = "NV_AUTHORIZATION";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x04A] = "NV_UNINITIALIZED";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x04B] = "NV_SPACE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x04C] = "NV_DEFINED";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x050] = "BAD_CONTEXT";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x051] = "CPHASH";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x052] = "PARENT";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x053] = "NEEDS_TEST";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x054] = "NO_RESULT";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x055] = "SENSITIVE";
    sInf->EnumNames[TPM_RC::RC_VER1 + 0x07F] = "RC_MAX_FM0";
    sInf->EnumNames[0x080] = "RC_FMT1";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x001] = "ASYMMETRIC";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x002] = "ATTRIBUTES";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x003] = "HASH";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x004] = "VALUE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x005] = "HIERARCHY";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x007] = "KEY_SIZE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x008] = "MGF";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x009] = "MODE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x00A] = "TYPE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x00B] = "HANDLE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x00C] = "KDF";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x00D] = "RANGE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x00E] = "AUTH_FAIL";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x00F] = "NONCE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x010] = "PP";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x012] = "SCHEME";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x015] = "SIZE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x016] = "SYMMETRIC";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x017] = "TAG";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x018] = "SELECTOR";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x01A] = "INSUFFICIENT";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x01B] = "SIGNATURE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x01C] = "KEY";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x01D] = "POLICY_FAIL";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x01F] = "INTEGRITY";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x020] = "TICKET";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x022] = "BAD_AUTH";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x023] = "EXPIRED";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x024] = "POLICY_CC";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x025] = "BINDING";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x026] = "CURVE";
    sInf->EnumNames[TPM_RC::RC_FMT1 + 0x027] = "ECC_POINT";
    sInf->EnumNames[0x900] = "RC_WARN";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x001] = "CONTEXT_GAP";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x002] = "OBJECT_MEMORY";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x003] = "SESSION_MEMORY";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x004] = "MEMORY";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x005] = "SESSION_HANDLES";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x006] = "OBJECT_HANDLES";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x007] = "LOCALITY";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x008] = "YIELDED";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x009] = "CANCELED";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x00A] = "TESTING";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x010] = "REFERENCE_H0";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x011] = "REFERENCE_H1";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x012] = "REFERENCE_H2";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x013] = "REFERENCE_H3";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x014] = "REFERENCE_H4";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x015] = "REFERENCE_H5";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x016] = "REFERENCE_H6";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x018] = "REFERENCE_S0";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x019] = "REFERENCE_S1";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x01A] = "REFERENCE_S2";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x01B] = "REFERENCE_S3";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x01C] = "REFERENCE_S4";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x01D] = "REFERENCE_S5";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x01E] = "REFERENCE_S6";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x020] = "NV_RATE";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x021] = "LOCKOUT";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x022] = "RETRY";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x023] = "NV_UNAVAILABLE";
    sInf->EnumNames[TPM_RC::RC_WARN + 0x7F] = "NOT_USED";
    sInf->EnumNames[0x040] = "P";
    sInf->EnumNames[0x800] = "S";
    sInf->EnumNames[0x100] = "_1";
    sInf->EnumNames[0x200] = "_2";
    sInf->EnumNames[0x300] = "_3";
    sInf->EnumNames[0x400] = "_4";
    sInf->EnumNames[0x500] = "_5";
    sInf->EnumNames[0x600] = "_6";
    sInf->EnumNames[0x700] = "_7";
    sInf->EnumNames[0x800] = "_8";
    sInf->EnumNames[0x900] = "_9";
    sInf->EnumNames[0xA00] = "A";
    sInf->EnumNames[0xB00] = "B";
    sInf->EnumNames[0xC00] = "C";
    sInf->EnumNames[0xD00] = "D";
    sInf->EnumNames[0xE00] = "E";
    sInf->EnumNames[0xF00] = "F";
    sInf->EnumNames[0xF00] = "N_MASK";
    sInf->EnumNames[0x40280001] = "TSS_TCP_BAD_HANDSHAKE_RESP";
    sInf->EnumNames[0x40280002] = "TSS_TCP_SERVER_TOO_OLD";
    sInf->EnumNames[0x40280003] = "TSS_TCP_BAD_ACK";
    sInf->EnumNames[0x40280004] = "TSS_TCP_BAD_RESP_LEN";
    sInf->EnumNames[0x40280005] = "TSS_TCP_UNEXPECTED_STARTUP_RESP";
    sInf->EnumNames[0x40280006] = "TSS_TCP_INVALID_SIZE_TAG";
    sInf->EnumNames[0x40280007] = "TSS_TCP_DISCONNECTED";
    sInf->EnumNames[0x40280010] = "TSS_DISPATCH_FAILED";
    sInf->EnumNames[0x40280011] = "TSS_SEND_OP_FAILED";
    sInf->EnumNames[0x40280021] = "TSS_RESP_BUF_TOO_SHORT";
    sInf->EnumNames[0x40280022] = "TSS_RESP_BUF_INVALID_SESSION_TAG";
    sInf->EnumNames[0x80280400] = "TBS_COMMAND_BLOCKED";
    sInf->EnumNames[0x80280401] = "TBS_INVALID_HANDLE";
    sInf->EnumNames[0x80280402] = "TBS_DUPLICATE_V_HANDLE";
    sInf->EnumNames[0x80280403] = "TBS_EMBEDDED_COMMAND_BLOCKED";
    sInf->EnumNames[0x80280404] = "TBS_EMBEDDED_COMMAND_UNSUPPORTED";
    sInf->EnumNames[0x80284000] = "TBS_UNKNOWN_ERROR";
    sInf->EnumNames[0x80284001] = "TBS_INTERNAL_ERROR";
    sInf->EnumNames[0x80284002] = "TBS_BAD_PARAMETER";
    sInf->EnumNames[0x80284003] = "TBS_INVALID_OUTPUT_POINTER";
    sInf->EnumNames[0x80284004] = "TBS_INVALID_CONTEXT";
    sInf->EnumNames[0x80284005] = "TBS_INSUFFICIENT_BUFFER";
    sInf->EnumNames[0x80284006] = "TBS_IO_ERROR";
    sInf->EnumNames[0x80284007] = "TBS_INVALID_CONTEXT_PARAM";
    sInf->EnumNames[0x80284008] = "TBS_SERVICE_NOT_RUNNING";
    sInf->EnumNames[0x80284009] = "TBS_TOO_MANY_CONTEXTS";
    sInf->EnumNames[0x8028400A] = "TBS_TOO_MANY_RESOURCES";
    sInf->EnumNames[0x8028400B] = "TBS_SERVICE_START_PENDING";
    sInf->EnumNames[0x8028400C] = "TBS_PPI_NOT_SUPPORTED";
    sInf->EnumNames[0x8028400D] = "TBS_COMMAND_CANCELED";
    sInf->EnumNames[0x8028400E] = "TBS_BUFFER_TOO_LARGE";
    sInf->EnumNames[0x8028400F] = "TBS_NOT_FOUND";
    sInf->EnumNames[0x80284010] = "TBS_SERVICE_DISABLED";
    sInf->EnumNames[0x80284012] = "TBS_ACCESS_DENIED";
    sInf->EnumNames[0x80284014] = "TBS_PPI_FUNCTION_NOT_SUPPORTED";
    sInf->EnumNames[0x80284015] = "TBS_OWNER_AUTH_NOT_FOUND";
    
    // ======== TPM_CLOCK_ADJUST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_CLOCK_ADJUST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_CLOCK_ADJUST";
    sInf->Size = sizeof(char);
    sInf->EnumNames.clear();
    sInf->EnumNames[-3] = "COARSE_SLOWER";
    sInf->EnumNames[-2] = "MEDIUM_SLOWER";
    sInf->EnumNames[-1] = "FINE_SLOWER";
    sInf->EnumNames[0] = "NO_CHANGE";
    sInf->EnumNames[1] = "FINE_FASTER";
    sInf->EnumNames[2] = "MEDIUM_FASTER";
    sInf->EnumNames[3] = "COARSE_FASTER";
    
    // ======== TPM_EO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_EO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_EO";
    sInf->Size = sizeof(UINT16);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x0000] = "EQ";
    sInf->EnumNames[0x0001] = "NEQ";
    sInf->EnumNames[0x0002] = "SIGNED_GT";
    sInf->EnumNames[0x0003] = "UNSIGNED_GT";
    sInf->EnumNames[0x0004] = "SIGNED_LT";
    sInf->EnumNames[0x0005] = "UNSIGNED_LT";
    sInf->EnumNames[0x0006] = "SIGNED_GE";
    sInf->EnumNames[0x0007] = "UNSIGNED_GE";
    sInf->EnumNames[0x0008] = "SIGNED_LE";
    sInf->EnumNames[0x0009] = "UNSIGNED_LE";
    sInf->EnumNames[0x000A] = "BITSET";
    sInf->EnumNames[0x000B] = "BITCLEAR";
    
    // ======== TPM_ST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_ST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_ST";
    sInf->Size = sizeof(UINT16);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00C4] = "RSP_COMMAND";
    sInf->EnumNames[0X8000] = "_NULL";
    sInf->EnumNames[0x8001] = "NO_SESSIONS";
    sInf->EnumNames[0x8002] = "SESSIONS";
    sInf->EnumNames[0x8014] = "ATTEST_NV";
    sInf->EnumNames[0x8015] = "ATTEST_COMMAND_AUDIT";
    sInf->EnumNames[0x8016] = "ATTEST_SESSION_AUDIT";
    sInf->EnumNames[0x8017] = "ATTEST_CERTIFY";
    sInf->EnumNames[0x8018] = "ATTEST_QUOTE";
    sInf->EnumNames[0x8019] = "ATTEST_TIME";
    sInf->EnumNames[0x801A] = "ATTEST_CREATION";
    sInf->EnumNames[0x801C] = "ATTEST_NV_DIGEST";
    sInf->EnumNames[0x8021] = "CREATION";
    sInf->EnumNames[0x8022] = "VERIFIED";
    sInf->EnumNames[0x8023] = "AUTH_SECRET";
    sInf->EnumNames[0x8024] = "HASHCHECK";
    sInf->EnumNames[0x8025] = "AUTH_SIGNED";
    sInf->EnumNames[0x8029] = "FU_MANIFEST";
    
    // ======== TPM_SU ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_SU_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_SU";
    sInf->Size = sizeof(UINT16);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x0000] = "CLEAR";
    sInf->EnumNames[0x0001] = "STATE";
    
    // ======== TPM_SE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_SE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_SE";
    sInf->Size = sizeof(BYTE);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00] = "HMAC";
    sInf->EnumNames[0x01] = "POLICY";
    sInf->EnumNames[0x03] = "TRIAL";
    
    // ======== TPM_CAP ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_CAP_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_CAP";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00000000] = "FIRST";
    sInf->EnumNames[0x00000000] = "ALGS";
    sInf->EnumNames[0x00000001] = "HANDLES";
    sInf->EnumNames[0x00000002] = "COMMANDS";
    sInf->EnumNames[0x00000003] = "PP_COMMANDS";
    sInf->EnumNames[0x00000004] = "AUDIT_COMMANDS";
    sInf->EnumNames[0x00000005] = "PCRS";
    sInf->EnumNames[0x00000006] = "TPM_PROPERTIES";
    sInf->EnumNames[0x00000007] = "PCR_PROPERTIES";
    sInf->EnumNames[0x00000008] = "ECC_CURVES";
    sInf->EnumNames[0x00000009] = "AUTH_POLICIES";
    sInf->EnumNames[0x0000000A] = "ACT";
    sInf->EnumNames[0x0000000A] = "LAST";
    sInf->EnumNames[0x00000100] = "VENDOR_PROPERTY";
    
    // ======== TPM_PT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_PT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_PT";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00000000] = "NONE";
    sInf->EnumNames[0x00000100] = "PT_GROUP";
    sInf->EnumNames[TPM_PT::PT_GROUP * 1] = "PT_FIXED";
    sInf->EnumNames[TPM_PT::PT_FIXED + 0] = "FAMILY_INDICATOR";
    sInf->EnumNames[TPM_PT::PT_FIXED + 1] = "LEVEL";
    sInf->EnumNames[TPM_PT::PT_FIXED + 2] = "REVISION";
    sInf->EnumNames[TPM_PT::PT_FIXED + 3] = "DAY_OF_YEAR";
    sInf->EnumNames[TPM_PT::PT_FIXED + 4] = "YEAR";
    sInf->EnumNames[TPM_PT::PT_FIXED + 5] = "MANUFACTURER";
    sInf->EnumNames[TPM_PT::PT_FIXED + 6] = "VENDOR_STRING_1";
    sInf->EnumNames[TPM_PT::PT_FIXED + 7] = "VENDOR_STRING_2";
    sInf->EnumNames[TPM_PT::PT_FIXED + 8] = "VENDOR_STRING_3";
    sInf->EnumNames[TPM_PT::PT_FIXED + 9] = "VENDOR_STRING_4";
    sInf->EnumNames[TPM_PT::PT_FIXED + 10] = "VENDOR_TPM_TYPE";
    sInf->EnumNames[TPM_PT::PT_FIXED + 11] = "FIRMWARE_VERSION_1";
    sInf->EnumNames[TPM_PT::PT_FIXED + 12] = "FIRMWARE_VERSION_2";
    sInf->EnumNames[TPM_PT::PT_FIXED + 13] = "INPUT_BUFFER";
    sInf->EnumNames[TPM_PT::PT_FIXED + 14] = "HR_TRANSIENT_MIN";
    sInf->EnumNames[TPM_PT::PT_FIXED + 15] = "HR_PERSISTENT_MIN";
    sInf->EnumNames[TPM_PT::PT_FIXED + 16] = "HR_LOADED_MIN";
    sInf->EnumNames[TPM_PT::PT_FIXED + 17] = "ACTIVE_SESSIONS_MAX";
    sInf->EnumNames[TPM_PT::PT_FIXED + 18] = "PCR_COUNT";
    sInf->EnumNames[TPM_PT::PT_FIXED + 19] = "PCR_SELECT_MIN";
    sInf->EnumNames[TPM_PT::PT_FIXED + 20] = "CONTEXT_GAP_MAX";
    sInf->EnumNames[TPM_PT::PT_FIXED + 22] = "NV_COUNTERS_MAX";
    sInf->EnumNames[TPM_PT::PT_FIXED + 23] = "NV_INDEX_MAX";
    sInf->EnumNames[TPM_PT::PT_FIXED + 24] = "MEMORY";
    sInf->EnumNames[TPM_PT::PT_FIXED + 25] = "CLOCK_UPDATE";
    sInf->EnumNames[TPM_PT::PT_FIXED + 26] = "CONTEXT_HASH";
    sInf->EnumNames[TPM_PT::PT_FIXED + 27] = "CONTEXT_SYM";
    sInf->EnumNames[TPM_PT::PT_FIXED + 28] = "CONTEXT_SYM_SIZE";
    sInf->EnumNames[TPM_PT::PT_FIXED + 29] = "ORDERLY_COUNT";
    sInf->EnumNames[TPM_PT::PT_FIXED + 30] = "MAX_COMMAND_SIZE";
    sInf->EnumNames[TPM_PT::PT_FIXED + 31] = "MAX_RESPONSE_SIZE";
    sInf->EnumNames[TPM_PT::PT_FIXED + 32] = "MAX_DIGEST";
    sInf->EnumNames[TPM_PT::PT_FIXED + 33] = "MAX_OBJECT_CONTEXT";
    sInf->EnumNames[TPM_PT::PT_FIXED + 34] = "MAX_SESSION_CONTEXT";
    sInf->EnumNames[TPM_PT::PT_FIXED + 35] = "PS_FAMILY_INDICATOR";
    sInf->EnumNames[TPM_PT::PT_FIXED + 36] = "PS_LEVEL";
    sInf->EnumNames[TPM_PT::PT_FIXED + 37] = "PS_REVISION";
    sInf->EnumNames[TPM_PT::PT_FIXED + 38] = "PS_DAY_OF_YEAR";
    sInf->EnumNames[TPM_PT::PT_FIXED + 39] = "PS_YEAR";
    sInf->EnumNames[TPM_PT::PT_FIXED + 40] = "SPLIT_MAX";
    sInf->EnumNames[TPM_PT::PT_FIXED + 41] = "TOTAL_COMMANDS";
    sInf->EnumNames[TPM_PT::PT_FIXED + 42] = "LIBRARY_COMMANDS";
    sInf->EnumNames[TPM_PT::PT_FIXED + 43] = "VENDOR_COMMANDS";
    sInf->EnumNames[TPM_PT::PT_FIXED + 44] = "NV_BUFFER_MAX";
    sInf->EnumNames[TPM_PT::PT_FIXED + 45] = "MODES";
    sInf->EnumNames[TPM_PT::PT_FIXED + 46] = "MAX_CAP_BUFFER";
    sInf->EnumNames[TPM_PT::PT_GROUP * 2] = "PT_VAR";
    sInf->EnumNames[TPM_PT::PT_VAR + 0] = "PERMANENT";
    sInf->EnumNames[TPM_PT::PT_VAR + 1] = "STARTUP_CLEAR";
    sInf->EnumNames[TPM_PT::PT_VAR + 2] = "HR_NV_INDEX";
    sInf->EnumNames[TPM_PT::PT_VAR + 3] = "HR_LOADED";
    sInf->EnumNames[TPM_PT::PT_VAR + 4] = "HR_LOADED_AVAIL";
    sInf->EnumNames[TPM_PT::PT_VAR + 5] = "HR_ACTIVE";
    sInf->EnumNames[TPM_PT::PT_VAR + 6] = "HR_ACTIVE_AVAIL";
    sInf->EnumNames[TPM_PT::PT_VAR + 7] = "HR_TRANSIENT_AVAIL";
    sInf->EnumNames[TPM_PT::PT_VAR + 8] = "HR_PERSISTENT";
    sInf->EnumNames[TPM_PT::PT_VAR + 9] = "HR_PERSISTENT_AVAIL";
    sInf->EnumNames[TPM_PT::PT_VAR + 10] = "NV_COUNTERS";
    sInf->EnumNames[TPM_PT::PT_VAR + 11] = "NV_COUNTERS_AVAIL";
    sInf->EnumNames[TPM_PT::PT_VAR + 12] = "ALGORITHM_SET";
    sInf->EnumNames[TPM_PT::PT_VAR + 13] = "LOADED_CURVES";
    sInf->EnumNames[TPM_PT::PT_VAR + 14] = "LOCKOUT_COUNTER";
    sInf->EnumNames[TPM_PT::PT_VAR + 15] = "MAX_AUTH_FAIL";
    sInf->EnumNames[TPM_PT::PT_VAR + 16] = "LOCKOUT_INTERVAL";
    sInf->EnumNames[TPM_PT::PT_VAR + 17] = "LOCKOUT_RECOVERY";
    sInf->EnumNames[TPM_PT::PT_VAR + 18] = "NV_WRITE_RECOVERY";
    sInf->EnumNames[TPM_PT::PT_VAR + 19] = "AUDIT_COUNTER_0";
    sInf->EnumNames[TPM_PT::PT_VAR + 20] = "AUDIT_COUNTER_1";
    
    // ======== TPM_PT_PCR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_PT_PCR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_PT_PCR";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00000000] = "FIRST";
    sInf->EnumNames[0x00000000] = "SAVE";
    sInf->EnumNames[0x00000001] = "EXTEND_L0";
    sInf->EnumNames[0x00000002] = "RESET_L0";
    sInf->EnumNames[0x00000003] = "EXTEND_L1";
    sInf->EnumNames[0x00000004] = "RESET_L1";
    sInf->EnumNames[0x00000005] = "EXTEND_L2";
    sInf->EnumNames[0x00000006] = "RESET_L2";
    sInf->EnumNames[0x00000007] = "EXTEND_L3";
    sInf->EnumNames[0x00000008] = "RESET_L3";
    sInf->EnumNames[0x00000009] = "EXTEND_L4";
    sInf->EnumNames[0x0000000A] = "RESET_L4";
    sInf->EnumNames[0x00000011] = "NO_INCREMENT";
    sInf->EnumNames[0x00000012] = "DRTM_RESET";
    sInf->EnumNames[0x00000013] = "POLICY";
    sInf->EnumNames[0x00000014] = "AUTH";
    sInf->EnumNames[0x00000014] = "LAST";
    
    // ======== TPM_PS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_PS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_PS";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00000000] = "MAIN";
    sInf->EnumNames[0x00000001] = "PC";
    sInf->EnumNames[0x00000002] = "PDA";
    sInf->EnumNames[0x00000003] = "CELL_PHONE";
    sInf->EnumNames[0x00000004] = "SERVER";
    sInf->EnumNames[0x00000005] = "PERIPHERAL";
    sInf->EnumNames[0x00000006] = "TSS";
    sInf->EnumNames[0x00000007] = "STORAGE";
    sInf->EnumNames[0x00000008] = "AUTHENTICATION";
    sInf->EnumNames[0x00000009] = "EMBEDDED";
    sInf->EnumNames[0x0000000A] = "HARDCOPY";
    sInf->EnumNames[0x0000000B] = "INFRASTRUCTURE";
    sInf->EnumNames[0x0000000C] = "VIRTUALIZATION";
    sInf->EnumNames[0x0000000D] = "TNC";
    sInf->EnumNames[0x0000000E] = "MULTI_TENANT";
    sInf->EnumNames[0x0000000F] = "TC";
    
    // ======== TPM_HT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_HT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_HT";
    sInf->Size = sizeof(BYTE);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00] = "PCR";
    sInf->EnumNames[0x01] = "NV_INDEX";
    sInf->EnumNames[0x02] = "HMAC_SESSION";
    sInf->EnumNames[0x02] = "LOADED_SESSION";
    sInf->EnumNames[0x03] = "POLICY_SESSION";
    sInf->EnumNames[0x03] = "SAVED_SESSION";
    sInf->EnumNames[0x40] = "PERMANENT";
    sInf->EnumNames[0x80] = "TRANSIENT";
    sInf->EnumNames[0x81] = "PERSISTENT";
    sInf->EnumNames[0x90] = "AC";
    
    // ======== TPM_RH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_RH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_RH";
    sInf->Size = sizeof(TPM_HANDLE);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x40000000] = "FIRST";
    sInf->EnumNames[0x40000000] = "SRK";
    sInf->EnumNames[0x40000001] = "OWNER";
    sInf->EnumNames[0x40000002] = "REVOKE";
    sInf->EnumNames[0x40000003] = "TRANSPORT";
    sInf->EnumNames[0x40000004] = "OPERATOR";
    sInf->EnumNames[0x40000005] = "ADMIN";
    sInf->EnumNames[0x40000006] = "EK";
    sInf->EnumNames[0x40000007] = "_NULL";
    sInf->EnumNames[0x40000008] = "UNASSIGNED";
    sInf->EnumNames[0x40000009] = "RS_PW";
    sInf->EnumNames[0x4000000A] = "LOCKOUT";
    sInf->EnumNames[0x4000000B] = "ENDORSEMENT";
    sInf->EnumNames[0x4000000C] = "PLATFORM";
    sInf->EnumNames[0x4000000D] = "PLATFORM_NV";
    sInf->EnumNames[0x40000010] = "AUTH_00";
    sInf->EnumNames[0x4000010F] = "AUTH_FF";
    sInf->EnumNames[0x40000110] = "ACT_0";
    sInf->EnumNames[0x4000011F] = "ACT_F";
    sInf->EnumNames[0x4000011F] = "LAST";
    
    // ======== TPM_NT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_NT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_NT";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x0] = "ORDINARY";
    sInf->EnumNames[0x1] = "COUNTER";
    sInf->EnumNames[0x2] = "BITS";
    sInf->EnumNames[0x4] = "EXTEND";
    sInf->EnumNames[0x8] = "PIN_FAIL";
    sInf->EnumNames[0x9] = "PIN_PASS";
    
    // ======== TPM_AT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_AT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_AT";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00000000] = "ANY";
    sInf->EnumNames[0x00000001] = "_ERROR";
    sInf->EnumNames[0x00000002] = "PV1";
    sInf->EnumNames[0x80000000] = "VEND";
    
    // ======== TPM_AE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_AE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_AE";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00000000] = "NONE";
    
    // ======== PLATFORM ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::PLATFORM_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "PLATFORM";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[TPM_SPEC::FAMILY] = "FAMILY";
    sInf->EnumNames[TPM_SPEC::LEVEL] = "LEVEL";
    sInf->EnumNames[TPM_SPEC::VERSION] = "VERSION";
    sInf->EnumNames[TPM_SPEC::YEAR] = "YEAR";
    sInf->EnumNames[TPM_SPEC::DAY_OF_YEAR] = "DAY_OF_YEAR";
    
    // ======== Implementation ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::Implementation_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "Implementation";
    sInf->Size = sizeof(UINT32);
    sInf->EnumNames.clear();
    sInf->EnumNames[Logic::NO] = "FIELD_UPGRADE_IMPLEMENTED";
    sInf->EnumNames[ImplementationConstants::Ossl] = "HASH_LIB";
    sInf->EnumNames[ImplementationConstants::Ossl] = "SYM_LIB";
    sInf->EnumNames[ImplementationConstants::Ossl] = "MATH_LIB";
    sInf->EnumNames[24] = "IMPLEMENTATION_PCR";
    sInf->EnumNames[((Implementation::IMPLEMENTATION_PCR+7)/8)] = "PCR_SELECT_MAX";
    sInf->EnumNames[24] = "PLATFORM_PCR";
    sInf->EnumNames[((Implementation::PLATFORM_PCR + 7) / 8)] = "PCR_SELECT_MIN";
    sInf->EnumNames[17] = "DRTM_PCR";
    sInf->EnumNames[0] = "HCRTM_PCR";
    sInf->EnumNames[5] = "NUM_LOCALITIES";
    sInf->EnumNames[3] = "MAX_HANDLE_NUM";
    sInf->EnumNames[64] = "MAX_ACTIVE_SESSIONS";
    sInf->EnumNames[3] = "MAX_LOADED_SESSIONS";
    sInf->EnumNames[3] = "MAX_SESSION_NUM";
    sInf->EnumNames[3] = "MAX_LOADED_OBJECTS";
    sInf->EnumNames[2] = "MIN_EVICT_OBJECTS";
    sInf->EnumNames[1] = "NUM_POLICY_PCR_GROUP";
    sInf->EnumNames[1] = "NUM_AUTHVALUE_PCR_GROUP";
    sInf->EnumNames[1264] = "MAX_CONTEXT_SIZE";
    sInf->EnumNames[1024] = "MAX_DIGEST_BUFFER";
    sInf->EnumNames[2048] = "MAX_NV_INDEX_SIZE";
    sInf->EnumNames[1024] = "MAX_NV_BUFFER_SIZE";
    sInf->EnumNames[1024] = "MAX_CAP_BUFFER";
    sInf->EnumNames[16384] = "NV_MEMORY_SIZE";
    sInf->EnumNames[8] = "MIN_COUNTER_INDICES";
    sInf->EnumNames[16] = "NUM_STATIC_PCR";
    sInf->EnumNames[64] = "MAX_ALG_LIST_SIZE";
    sInf->EnumNames[32] = "PRIMARY_SEED_SIZE";
    sInf->EnumNames[ALG_ID_VALUE::AES_VALUE] = "CONTEXT_ENCRYPT_ALGORITHM";
    sInf->EnumNames[12] = "NV_CLOCK_UPDATE_INTERVAL";
    sInf->EnumNames[1] = "NUM_POLICY_PCR";
    sInf->EnumNames[4096] = "MAX_COMMAND_SIZE";
    sInf->EnumNames[4096] = "MAX_RESPONSE_SIZE";
    sInf->EnumNames[8] = "ORDERLY_BITS";
    sInf->EnumNames[128] = "MAX_SYM_DATA";
    sInf->EnumNames[64] = "MAX_RNG_ENTROPY_SIZE";
    sInf->EnumNames[512] = "RAM_INDEX_SPACE";
    sInf->EnumNames[0x00010001] = "RSA_DEFAULT_PUBLIC_EXPONENT";
    sInf->EnumNames[Logic::YES] = "ENABLE_PCR_NO_INCREMENT";
    sInf->EnumNames[Logic::YES] = "CRT_FORMAT_RSA";
    sInf->EnumNames[0] = "VENDOR_COMMAND_COUNT";
    sInf->EnumNames[1024] = "MAX_VENDOR_BUFFER_SIZE";
    sInf->EnumNames[8192] = "MAX_DERIVATION_BITS";
    sInf->EnumNames[(ImplementationConstants::MAX_RSA_KEY_BYTES/2)] = "RSA_MAX_PRIME";
    sInf->EnumNames[(Implementation::RSA_MAX_PRIME * 5)] = "RSA_PRIVATE_SIZE";
    sInf->EnumNames[20] = "SIZE_OF_X509_SERIAL_NUMBER";
    sInf->EnumNames[Implementation::RSA_PRIVATE_SIZE] = "PRIVATE_VENDOR_SPECIFIC_BYTES";
    
    // ======== TPM_HC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_HC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "TPM_HC";
    sInf->Size = sizeof(TPM_HANDLE);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x00FFFFFF] = "HR_HANDLE_MASK";
    sInf->EnumNames[0xFF000000] = "HR_RANGE_MASK";
    sInf->EnumNames[24] = "HR_SHIFT";
    sInf->EnumNames[(TPM_HT::PCR << TPM_HC::HR_SHIFT)] = "HR_PCR";
    sInf->EnumNames[(TPM_HT::HMAC_SESSION << TPM_HC::HR_SHIFT)] = "HR_HMAC_SESSION";
    sInf->EnumNames[(TPM_HT::POLICY_SESSION << TPM_HC::HR_SHIFT)] = "HR_POLICY_SESSION";
    sInf->EnumNames[(TPM_HT::TRANSIENT << TPM_HC::HR_SHIFT)] = "HR_TRANSIENT";
    sInf->EnumNames[(TPM_HT::PERSISTENT << TPM_HC::HR_SHIFT)] = "HR_PERSISTENT";
    sInf->EnumNames[(TPM_HT::NV_INDEX << TPM_HC::HR_SHIFT)] = "HR_NV_INDEX";
    sInf->EnumNames[(TPM_HT::PERMANENT << TPM_HC::HR_SHIFT)] = "HR_PERMANENT";
    sInf->EnumNames[(TPM_HC::HR_PCR + 0)] = "PCR_FIRST";
    sInf->EnumNames[(TPM_HC::PCR_FIRST + Implementation::IMPLEMENTATION_PCR-1)] = "PCR_LAST";
    sInf->EnumNames[(TPM_HC::HR_HMAC_SESSION + 0)] = "HMAC_SESSION_FIRST";
    sInf->EnumNames[(TPM_HC::HMAC_SESSION_FIRST+Implementation::MAX_ACTIVE_SESSIONS-1)] = "HMAC_SESSION_LAST";
    sInf->EnumNames[TPM_HC::HMAC_SESSION_FIRST] = "LOADED_SESSION_FIRST";
    sInf->EnumNames[TPM_HC::HMAC_SESSION_LAST] = "LOADED_SESSION_LAST";
    sInf->EnumNames[(TPM_HC::HR_POLICY_SESSION + 0)] = "POLICY_SESSION_FIRST";
    sInf->EnumNames[(TPM_HC::POLICY_SESSION_FIRST + Implementation::MAX_ACTIVE_SESSIONS-1)] = "POLICY_SESSION_LAST";
    sInf->EnumNames[(TPM_HC::HR_TRANSIENT + 0)] = "TRANSIENT_FIRST";
    sInf->EnumNames[TPM_HC::POLICY_SESSION_FIRST] = "ACTIVE_SESSION_FIRST";
    sInf->EnumNames[TPM_HC::POLICY_SESSION_LAST] = "ACTIVE_SESSION_LAST";
    sInf->EnumNames[(TPM_HC::TRANSIENT_FIRST+Implementation::MAX_LOADED_OBJECTS-1)] = "TRANSIENT_LAST";
    sInf->EnumNames[(TPM_HC::HR_PERSISTENT + 0)] = "PERSISTENT_FIRST";
    sInf->EnumNames[(TPM_HC::PERSISTENT_FIRST + 0x00FFFFFF)] = "PERSISTENT_LAST";
    sInf->EnumNames[(TPM_HC::PERSISTENT_FIRST + 0x00800000)] = "PLATFORM_PERSISTENT";
    sInf->EnumNames[(TPM_HC::HR_NV_INDEX + 0)] = "NV_INDEX_FIRST";
    sInf->EnumNames[(TPM_HC::NV_INDEX_FIRST + 0x00FFFFFF)] = "NV_INDEX_LAST";
    sInf->EnumNames[TPM_RH::FIRST] = "PERMANENT_FIRST";
    sInf->EnumNames[TPM_RH::LAST] = "PERMANENT_LAST";
    sInf->EnumNames[((TPM_HT::NV_INDEX << TPM_HC::HR_SHIFT) + 0xD00000)] = "HR_NV_AC";
    sInf->EnumNames[(TPM_HC::HR_NV_AC + 0)] = "NV_AC_FIRST";
    sInf->EnumNames[(TPM_HC::HR_NV_AC + 0x0000FFFF)] = "NV_AC_LAST";
    sInf->EnumNames[(TPM_HT::AC << TPM_HC::HR_SHIFT)] = "HR_AC";
    sInf->EnumNames[(TPM_HC::HR_AC + 0)] = "AC_FIRST";
    sInf->EnumNames[(TPM_HC::HR_AC + 0x0000FFFF)] = "AC_LAST";
    
    // ======== ALG_ID_VALUE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::ALG_ID_VALUE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmEnum;
    sInf->Name = "ALG_ID_VALUE";
    sInf->Size = sizeof(UINT16);
    sInf->EnumNames.clear();
    sInf->EnumNames[0x0000] = "ERROR_VALUE";
    sInf->EnumNames[0x0001] = "FIRST_VALUE";
    sInf->EnumNames[0x0001] = "RSA_VALUE";
    sInf->EnumNames[0x0003] = "TDES_VALUE";
    sInf->EnumNames[0x0004] = "SHA_VALUE";
    sInf->EnumNames[0x0004] = "SHA1_VALUE";
    sInf->EnumNames[0x0005] = "HMAC_VALUE";
    sInf->EnumNames[0x0006] = "AES_VALUE";
    sInf->EnumNames[0x0007] = "MGF1_VALUE";
    sInf->EnumNames[0x0008] = "KEYEDHASH_VALUE";
    sInf->EnumNames[0x000A] = "XOR_VALUE";
    sInf->EnumNames[0x000B] = "SHA256_VALUE";
    sInf->EnumNames[0x000C] = "SHA384_VALUE";
    sInf->EnumNames[0x000D] = "SHA512_VALUE";
    sInf->EnumNames[0x0010] = "NULL_VALUE";
    sInf->EnumNames[0x0012] = "SM3_256_VALUE";
    sInf->EnumNames[0x0013] = "SM4_VALUE";
    sInf->EnumNames[0x0014] = "RSASSA_VALUE";
    sInf->EnumNames[0x0015] = "RSAES_VALUE";
    sInf->EnumNames[0x0016] = "RSAPSS_VALUE";
    sInf->EnumNames[0x0017] = "OAEP_VALUE";
    sInf->EnumNames[0x0018] = "ECDSA_VALUE";
    sInf->EnumNames[0x0019] = "ECDH_VALUE";
    sInf->EnumNames[0x001A] = "ECDAA_VALUE";
    sInf->EnumNames[0x001B] = "SM2_VALUE";
    sInf->EnumNames[0x001C] = "ECSCHNORR_VALUE";
    sInf->EnumNames[0x001D] = "ECMQV_VALUE";
    sInf->EnumNames[0x0020] = "KDF1_SP800_56A_VALUE";
    sInf->EnumNames[0x0021] = "KDF2_VALUE";
    sInf->EnumNames[0x0022] = "KDF1_SP800_108_VALUE";
    sInf->EnumNames[0x0023] = "ECC_VALUE";
    sInf->EnumNames[0x0025] = "SYMCIPHER_VALUE";
    sInf->EnumNames[0x0026] = "CAMELLIA_VALUE";
    sInf->EnumNames[0x0027] = "SHA3_256_VALUE";
    sInf->EnumNames[0x0028] = "SHA3_384_VALUE";
    sInf->EnumNames[0x0029] = "SHA3_512_VALUE";
    sInf->EnumNames[0x003F] = "CMAC_VALUE";
    sInf->EnumNames[0x0040] = "CTR_VALUE";
    sInf->EnumNames[0x0041] = "OFB_VALUE";
    sInf->EnumNames[0x0042] = "CBC_VALUE";
    sInf->EnumNames[0x0043] = "CFB_VALUE";
    sInf->EnumNames[0x0044] = "ECB_VALUE";
    sInf->EnumNames[0x0044] = "LAST_VALUE";
    sInf->EnumNames[0x7FFF] = "ANY_VALUE";
    sInf->EnumNames[0x7FFE] = "ANY2_VALUE";
    
    // ======== INT8 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::INT8_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "INT8";
    sInf->Size = sizeof(char);
    
    // ======== UINT8 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::UINT8_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "UINT8";
    sInf->Size = sizeof(BYTE);
    
    // ======== BYTE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::BYTE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "BYTE";
    sInf->Size = sizeof(BYTE);
    
    // ======== UINT16 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::UINT16_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "UINT16";
    sInf->Size = sizeof(UINT16);
    
    // ======== INT16 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::INT16_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "INT16";
    sInf->Size = sizeof(INT16);
    
    // ======== UINT32 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::UINT32_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "UINT32";
    sInf->Size = sizeof(UINT32);
    
    // ======== INT32 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::INT32_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "INT32";
    sInf->Size = sizeof(INT32);
    
    // ======== UINT64 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::UINT64_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "UINT64";
    sInf->Size = sizeof(UINT64);
    
    // ======== INT64 ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::INT64_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "INT64";
    sInf->Size = sizeof(INT64);
    
    // ======== BOOL ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::BOOL_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "BOOL";
    sInf->Size = sizeof(bool);
    
    // ======== TPM_ALGORITHM_ID ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_ALGORITHM_ID_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPM_ALGORITHM_ID";
    sInf->Size = sizeof(UINT32);
    
    // ======== TPM_MODIFIER_INDICATOR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_MODIFIER_INDICATOR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPM_MODIFIER_INDICATOR";
    sInf->Size = sizeof(UINT32);
    
    // ======== TPM_AUTHORIZATION_SIZE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_AUTHORIZATION_SIZE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPM_AUTHORIZATION_SIZE";
    sInf->Size = sizeof(UINT32);
    
    // ======== TPM_PARAMETER_SIZE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_PARAMETER_SIZE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPM_PARAMETER_SIZE";
    sInf->Size = sizeof(UINT32);
    
    // ======== TPM_KEY_SIZE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_KEY_SIZE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPM_KEY_SIZE";
    sInf->Size = sizeof(UINT16);
    
    // ======== TPM_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPM_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPM_KEY_BITS";
    sInf->Size = sizeof(UINT16);
    
    // ======== TPMI_YES_NO ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_YES_NO_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_YES_NO";
    sInf->Size = sizeof(BYTE);
    
    // ======== TPMI_DH_OBJECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_DH_OBJECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_DH_OBJECT";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_PARENT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_DH_PARENT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_DH_PARENT";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_PERSISTENT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_DH_PERSISTENT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_DH_PERSISTENT";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_ENTITY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_DH_ENTITY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_DH_ENTITY";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_PCR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_DH_PCR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_DH_PCR";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_SH_AUTH_SESSION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_SH_AUTH_SESSION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_SH_AUTH_SESSION";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_SH_HMAC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_SH_HMAC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_SH_HMAC";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_SH_POLICY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_SH_POLICY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_SH_POLICY";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_CONTEXT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_DH_CONTEXT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_DH_CONTEXT";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_DH_SAVED ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_DH_SAVED_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_DH_SAVED";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_HIERARCHY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_HIERARCHY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_HIERARCHY";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_ENABLES ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_ENABLES_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_ENABLES";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_HIERARCHY_AUTH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_HIERARCHY_AUTH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_HIERARCHY_AUTH";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_HIERARCHY_POLICY ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_HIERARCHY_POLICY_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_HIERARCHY_POLICY";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_PLATFORM ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_PLATFORM_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_PLATFORM";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_OWNER ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_OWNER_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_OWNER";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_ENDORSEMENT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_ENDORSEMENT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_ENDORSEMENT";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_PROVISION ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_PROVISION_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_PROVISION";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_CLEAR ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_CLEAR_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_CLEAR";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_NV_AUTH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_NV_AUTH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_NV_AUTH";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_LOCKOUT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_LOCKOUT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_LOCKOUT";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_NV_INDEX ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_NV_INDEX_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_NV_INDEX";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_AC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_AC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_AC";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_RH_ACT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RH_ACT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RH_ACT";
    sInf->Size = sizeof(TPM_HANDLE);
    
    // ======== TPMI_ALG_HASH ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_HASH_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_HASH";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_ASYM ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_ASYM_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_ASYM";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SYM ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SYM_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_SYM";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SYM_OBJECT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SYM_OBJECT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_SYM_OBJECT";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SYM_MODE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SYM_MODE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_SYM_MODE";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_KDF ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_KDF_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_KDF";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_SIG_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_SIG_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_SIG_SCHEME";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ECC_KEY_EXCHANGE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ECC_KEY_EXCHANGE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ECC_KEY_EXCHANGE";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ST_COMMAND_TAG ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ST_COMMAND_TAG_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ST_COMMAND_TAG";
    sInf->Size = sizeof(TPM_ST);
    
    // ======== TPMI_ALG_MAC_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_MAC_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_MAC_SCHEME";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_CIPHER_MODE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_CIPHER_MODE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_CIPHER_MODE";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ST_ATTEST ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ST_ATTEST_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ST_ATTEST";
    sInf->Size = sizeof(TPM_ST);
    
    // ======== TPMI_TDES_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_TDES_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_TDES_KEY_BITS";
    sInf->Size = sizeof(UINT16);
    
    // ======== TPMI_AES_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_AES_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_AES_KEY_BITS";
    sInf->Size = sizeof(UINT16);
    
    // ======== TPMI_SM4_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_SM4_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_SM4_KEY_BITS";
    sInf->Size = sizeof(UINT16);
    
    // ======== TPMI_CAMELLIA_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_CAMELLIA_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_CAMELLIA_KEY_BITS";
    sInf->Size = sizeof(UINT16);
    
    // ======== TPMI_ALG_KEYEDHASH_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_KEYEDHASH_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_KEYEDHASH_SCHEME";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_ASYM_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_ASYM_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_ASYM_SCHEME";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_RSA_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_RSA_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_RSA_SCHEME";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ALG_RSA_DECRYPT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_RSA_DECRYPT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_RSA_DECRYPT";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_RSA_KEY_BITS ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_RSA_KEY_BITS_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_RSA_KEY_BITS";
    sInf->Size = sizeof(UINT16);
    
    // ======== TPMI_ALG_ECC_SCHEME ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_ECC_SCHEME_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_ECC_SCHEME";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== TPMI_ECC_CURVE ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ECC_CURVE_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ECC_CURVE";
    sInf->Size = sizeof(TPM_ECC_CURVE);
    
    // ======== TPMI_ALG_PUBLIC ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::TPMI_ALG_PUBLIC_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "TPMI_ALG_PUBLIC";
    sInf->Size = sizeof(TPM_ALG_ID);
    
    // ======== CONTEXT_SLOT ========
    sInf = new TpmTypeInfo();
    TypeMap[TpmTypeId::CONTEXT_SLOT_ID] = sInf;
    sInf->Kind = TpmTypeKind::TpmValueType;
    sInf->Name = "CONTEXT_SLOT";
    sInf->Size = sizeof(UINT16);
}

