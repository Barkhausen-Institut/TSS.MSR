/*
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See the LICENSE file in the project root for full license information.
 */

/*
 * NOTE: this file is partially auto generated!
 *
 * All code after the point marked with the '// <<AUTOGEN_BEGIN>>' comment
 * is autogenerated from the TPM 2.0 Specification docs.
 *
 * DO NOT EDIT AUTOGENERATED PART - all manual changes will be lost!
 */

#pragma once
#include "TpmStructure.h"

#define TPM_ENUM_PROLOGUE(Enum) enum _##Enum {

#define TPM_ENUM_EPILOGUE(Enum)         \
    };                                  \
    Enum() {}                           \
    Enum(ValueType v) : TpmEnum(v) {}

// Windows SDK headers may define this symbol
#ifdef _C2
#undef _C2
#endif

_TPMCPP_BEGIN

class _DLLEXP_ Tpm2;

// <<AUTOGEN_BEGIN>>
// ------------------------------------------------------------------------------------------------
// DO NOT REMOVE the <<AUTOGEN_BEGIN>> comment!
// DO NOT MODIFY any code below this point - all manual changes will be lost!
// ------------------------------------------------------------------------------------------------

/** Table 2 is the list of algorithms to which the TCG has assigned an algorithm
 *  identifier along with its numeric identifier.
 */
struct TPM_ALG_ID : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_ALG_ID)
    
    /** Should not occur  */
    _ERROR = 0x0000, 
    
    /** An object type that contains an RSA key  */
    FIRST = 0x0001, 
    
    /** An object type that contains an RSA key  */
    RSA = 0x0001, 
    
    /** Block cipher with various key sizes (Triple Data Encryption Algorithm, commonly called
     *  Triple Data Encryption Standard)
     */
    TDES = 0x0003, 
    
    /** Hash algorithm producing a 160-bit digest  */
    SHA = 0x0004, 
    
    /** Redefinition for documentation consistency  */
    SHA1 = 0x0004, 
    
    /** Hash Message Authentication Code (HMAC) algorithm  */
    HMAC = 0x0005, 
    
    /** Block cipher with various key sizes  */
    AES = 0x0006, 
    
    /** Hash-based mask-generation function  */
    MGF1 = 0x0007, 
    
    /** An object type that may use XOR for encryption or an HMAC for signing and may also
     *  refer to a data object that is neither signing nor encrypting
     */
    KEYEDHASH = 0x0008, 
    
    /** Hash-based stream cipher  */
    XOR = 0x000A, 
    
    /** Hash algorithm producing a 256-bit digest  */
    SHA256 = 0x000B, 
    
    /** Hash algorithm producing a 384-bit digest  */
    SHA384 = 0x000C, 
    
    /** Hash algorithm producing a 512-bit digest  */
    SHA512 = 0x000D, 
    
    /** Indication that no algorithm is selected  */
    _NULL = 0x0010, 
    
    /** Hash algorithm producing a 256-bit digest  */
    SM3_256 = 0x0012, 
    
    /** Symmetric block cipher with 128 bit key  */
    SM4 = 0x0013, 
    
    /** A signature algorithm defined in section 8.2 (RSASSA-PKCS1-v1_5)  */
    RSASSA = 0x0014, 
    
    /** A padding algorithm defined in section 7.2 (RSAES-PKCS1-v1_5)  */
    RSAES = 0x0015, 
    
    /** A signature algorithm defined in section 8.1 (RSASSA-PSS)  */
    RSAPSS = 0x0016, 
    
    /** A padding algorithm defined in Section 7.1 (RSAES_OAEP)  */
    OAEP = 0x0017, 
    
    /** Signature algorithm using elliptic curve cryptography (ECC)  */
    ECDSA = 0x0018, 
    
    /** Secret sharing using ECC Based on context, this can be either One-Pass Diffie-Hellman,
     *  C(1, 1, ECC CDH) defined in 6.2.2.2 or Full Unified Model C(2, 2, ECC CDH) defined in 6.1.1.2
     */
    ECDH = 0x0019, 
    
    /** Elliptic-curve based, anonymous signing scheme  */
    ECDAA = 0x001A, 
    
    /** Depending on context, either an elliptic-curve-based signature algorithm, encryption
     *  algorithm, or key exchange protocol
     */
    SM2 = 0x001B, 
    
    /** Elliptic-curve based Schnorr signature  */
    ECSCHNORR = 0x001C, 
    
    /** Two-phase elliptic-curve key exchange C(2, 2, ECC MQV) Section 6.1.1.4  */
    ECMQV = 0x001D, 
    
    /** Concatenation key derivation function (approved alternative 1) Section 5.8.1  */
    KDF1_SP800_56A = 0x0020, 
    
    /** Key derivation function KDF2 Section 13.2  */
    KDF2 = 0x0021, 
    
    /** A key derivation method SP800-108, Section 5.1 KDF in Counter Mode  */
    KDF1_SP800_108 = 0x0022, 
    
    /** Prime field ECC  */
    ECC = 0x0023, 
    
    /** The object type for a symmetric block cipher key  */
    SYMCIPHER = 0x0025, 
    
    /** Symmetric block cipher with various key sizes  */
    CAMELLIA = 0x0026, 
    
    /** Hash algorithm producing a 256-bit digest  */
    SHA3_256 = 0x0027, 
    
    /** Hash algorithm producing a 384-bit digest  */
    SHA3_384 = 0x0028, 
    
    /** Hash algorithm producing a 512-bit digest  */
    SHA3_512 = 0x0029, 
    
    CMAC = 0x003F, 
    
    /** Counter mode if implemented, all symmetric block ciphers (S type) implemented shall be
     *  capable of using this mode.
     */
    CTR = 0x0040, 
    
    /** Output Feedback mode if implemented, all symmetric block ciphers (S type) implemented
     *  shall be capable of using this mode.
     */
    OFB = 0x0041, 
    
    /** Cipher Block Chaining mode if implemented, all symmetric block ciphers (S type)
     *  implemented shall be capable of using this mode.
     */
    CBC = 0x0042, 
    
    /** Cipher Feedback mode if implemented, all symmetric block ciphers (S type) implemented
     *  shall be capable of using this mode.
     */
    CFB = 0x0043, 
    
    /** Electronic Codebook mode if implemented, all implemented symmetric block ciphers (S
     *  type) shall be capable of using this mode.
     *  NOTE This mode is not recommended for uses unless the key is frequently rotated such
     *  as in video codecs
     */
    ECB = 0x0044, 
    
    LAST = 0x0044, 
    
    /** Phony alg ID to be used for the first union member with no selector  */
    ANY = 0x7FFF, 
    
    /** Phony alg ID to be used for the second union member with no selector  */
    ANY2 = 0x7FFE
    TPM_ENUM_EPILOGUE(TPM_ALG_ID)
};

/** Table 4 is the list of identifiers for TCG-registered curve ID values for elliptic
 *  curve cryptography.
 */
struct TPM_ECC_CURVE : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_ECC_CURVE)
    
    NONE = 0x0000, 
    
    NIST_P192 = 0x0001, 
    
    NIST_P224 = 0x0002, 
    
    NIST_P256 = 0x0003, 
    
    NIST_P384 = 0x0004, 
    
    NIST_P521 = 0x0005, 
    
    /** Curve to support ECDAA  */
    BN_P256 = 0x0010, 
    
    /** Curve to support ECDAA  */
    BN_P638 = 0x0011, 
    
    SM2_P256 = 0x0020, 
    
    TEST_P192 = 0x0021
    TPM_ENUM_EPILOGUE(TPM_ECC_CURVE)
};

/** Table 13 Defines for SHA1 Hash Values  */
struct SHA1 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA1)
    
    /** Size of digest in octets  */
    DIGEST_SIZE = 20, 
    
    /** Size of hash block in octets  */
    BLOCK_SIZE = 64
    TPM_ENUM_EPILOGUE(SHA1)
};

/** Table 14 Defines for SHA256 Hash Values  */
struct SHA256 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA256)
    
    /** Size of digest  */
    DIGEST_SIZE = 32, 
    
    /** Size of hash block  */
    BLOCK_SIZE = 64
    TPM_ENUM_EPILOGUE(SHA256)
};

/** Table 15 Defines for SHA384 Hash Values  */
struct SHA384 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA384)
    
    /** Size of digest in octets  */
    DIGEST_SIZE = 48, 
    
    /** Size of hash block in octets  */
    BLOCK_SIZE = 128
    TPM_ENUM_EPILOGUE(SHA384)
};

/** Table 16 Defines for SHA512 Hash Values  */
struct SHA512 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA512)
    
    /** Size of digest in octets  */
    DIGEST_SIZE = 64, 
    
    /** Size of hash block in octets  */
    BLOCK_SIZE = 128
    TPM_ENUM_EPILOGUE(SHA512)
};

/** Table 17 Defines for SM3_256 Hash Values  */
struct SM3_256 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SM3_256)
    
    /** Size of digest in octets  */
    DIGEST_SIZE = 32, 
    
    /** Size of hash block in octets  */
    BLOCK_SIZE = 64
    TPM_ENUM_EPILOGUE(SM3_256)
};

/** Table 18 Defines for SHA3_256 Hash Values  */
struct SHA3_256 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA3_256)
    
    /** Size of digest in octets  */
    DIGEST_SIZE = 32, 
    
    /** Size of hash block in octets  */
    BLOCK_SIZE = 136
    TPM_ENUM_EPILOGUE(SHA3_256)
};

/** Table 19 Defines for SHA3_384 Hash Values  */
struct SHA3_384 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA3_384)
    
    /** Size of digest in octets  */
    DIGEST_SIZE = 48, 
    
    /** Size of hash block in octets  */
    BLOCK_SIZE = 104
    TPM_ENUM_EPILOGUE(SHA3_384)
};

/** Table 20 Defines for SHA3_512 Hash Values  */
struct SHA3_512 : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(SHA3_512)
    
    /** Size of digest in octets  */
    DIGEST_SIZE = 64, 
    
    /** Size of hash block in octets  */
    BLOCK_SIZE = 72
    TPM_ENUM_EPILOGUE(SHA3_512)
};

/** Table 4 Defines for Logic Values  */
struct Logic : public TpmEnum<BYTE>
{
    TPM_ENUM_PROLOGUE(Logic)
    
    _TRUE = 1, 
    
    _FALSE = 0, 
    
    YES = 1, 
    
    NO = 0, 
    
    SET = 1, 
    
    CLEAR = 0
    TPM_ENUM_EPILOGUE(Logic)
};

/** These values are readable with TPM2_GetCapability() (see 6.13 for the format).  */
struct TPM_SPEC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_SPEC)
    
    /** ASCII 2.0 with null terminator  */
    FAMILY = 0x322E3000, 
    
    /** The level number for the specification  */
    LEVEL = 0, 
    
    /** The version number of the spec (001.62 * 100)  */
    VERSION = 162, 
    
    /** The year of the version  */
    YEAR = 2019, 
    
    /** The day of the year (December 26)  */
    DAY_OF_YEAR = 360
    TPM_ENUM_EPILOGUE(TPM_SPEC)
};

/** This constant value differentiates TPM-generated structures from non-TPM structures.  */
struct TPM_GENERATED : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_GENERATED)
    
    /** 0xFF TCG (FF 54 43 4716)  */
    VALUE = 0xff544347
    TPM_ENUM_EPILOGUE(TPM_GENERATED)
};

struct TPM_CC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_CC)
    
    /** Compile variable. May decrease based on implementation.  */
    FIRST = 0x0000011F, 
    
    NV_UndefineSpaceSpecial = 0x0000011F, 
    
    EvictControl = 0x00000120, 
    
    HierarchyControl = 0x00000121, 
    
    NV_UndefineSpace = 0x00000122, 
    
    ChangeEPS = 0x00000124, 
    
    ChangePPS = 0x00000125, 
    
    Clear = 0x00000126, 
    
    ClearControl = 0x00000127, 
    
    ClockSet = 0x00000128, 
    
    HierarchyChangeAuth = 0x00000129, 
    
    NV_DefineSpace = 0x0000012A, 
    
    PCR_Allocate = 0x0000012B, 
    
    PCR_SetAuthPolicy = 0x0000012C, 
    
    PP_Commands = 0x0000012D, 
    
    SetPrimaryPolicy = 0x0000012E, 
    
    FieldUpgradeStart = 0x0000012F, 
    
    ClockRateAdjust = 0x00000130, 
    
    CreatePrimary = 0x00000131, 
    
    NV_GlobalWriteLock = 0x00000132, 
    
    GetCommandAuditDigest = 0x00000133, 
    
    NV_Increment = 0x00000134, 
    
    NV_SetBits = 0x00000135, 
    
    NV_Extend = 0x00000136, 
    
    NV_Write = 0x00000137, 
    
    NV_WriteLock = 0x00000138, 
    
    DictionaryAttackLockReset = 0x00000139, 
    
    DictionaryAttackParameters = 0x0000013A, 
    
    NV_ChangeAuth = 0x0000013B, 
    
    /** PCR  */
    PCR_Event = 0x0000013C, 
    
    /** PCR  */
    PCR_Reset = 0x0000013D, 
    
    SequenceComplete = 0x0000013E, 
    
    SetAlgorithmSet = 0x0000013F, 
    
    SetCommandCodeAuditStatus = 0x00000140, 
    
    FieldUpgradeData = 0x00000141, 
    
    IncrementalSelfTest = 0x00000142, 
    
    SelfTest = 0x00000143, 
    
    Startup = 0x00000144, 
    
    Shutdown = 0x00000145, 
    
    StirRandom = 0x00000146, 
    
    ActivateCredential = 0x00000147, 
    
    Certify = 0x00000148, 
    
    /** Policy  */
    PolicyNV = 0x00000149, 
    
    CertifyCreation = 0x0000014A, 
    
    Duplicate = 0x0000014B, 
    
    GetTime = 0x0000014C, 
    
    GetSessionAuditDigest = 0x0000014D, 
    
    NV_Read = 0x0000014E, 
    
    NV_ReadLock = 0x0000014F, 
    
    ObjectChangeAuth = 0x00000150, 
    
    /** Policy  */
    PolicySecret = 0x00000151, 
    
    Rewrap = 0x00000152, 
    
    Create = 0x00000153, 
    
    ECDH_ZGen = 0x00000154, 
    
    /** See NOTE 1  */
    HMAC = 0x00000155, 
    
    /** See NOTE 1  */
    MAC = 0x00000155, 
    
    Import = 0x00000156, 
    
    Load = 0x00000157, 
    
    Quote = 0x00000158, 
    
    RSA_Decrypt = 0x00000159, 
    
    /** See NOTE 1  */
    HMAC_Start = 0x0000015B, 
    
    /** See NOTE 1  */
    MAC_Start = 0x0000015B, 
    
    SequenceUpdate = 0x0000015C, 
    
    Sign = 0x0000015D, 
    
    Unseal = 0x0000015E, 
    
    /** Policy  */
    PolicySigned = 0x00000160, 
    
    /** Context  */
    ContextLoad = 0x00000161, 
    
    /** Context  */
    ContextSave = 0x00000162, 
    
    ECDH_KeyGen = 0x00000163, 
    
    EncryptDecrypt = 0x00000164, 
    
    /** Context  */
    FlushContext = 0x00000165, 
    
    LoadExternal = 0x00000167, 
    
    MakeCredential = 0x00000168, 
    
    /** NV  */
    NV_ReadPublic = 0x00000169, 
    
    /** Policy  */
    PolicyAuthorize = 0x0000016A, 
    
    /** Policy  */
    PolicyAuthValue = 0x0000016B, 
    
    /** Policy  */
    PolicyCommandCode = 0x0000016C, 
    
    /** Policy  */
    PolicyCounterTimer = 0x0000016D, 
    
    /** Policy  */
    PolicyCpHash = 0x0000016E, 
    
    /** Policy  */
    PolicyLocality = 0x0000016F, 
    
    /** Policy  */
    PolicyNameHash = 0x00000170, 
    
    /** Policy  */
    PolicyOR = 0x00000171, 
    
    /** Policy  */
    PolicyTicket = 0x00000172, 
    
    ReadPublic = 0x00000173, 
    
    RSA_Encrypt = 0x00000174, 
    
    StartAuthSession = 0x00000176, 
    
    VerifySignature = 0x00000177, 
    
    ECC_Parameters = 0x00000178, 
    
    FirmwareRead = 0x00000179, 
    
    GetCapability = 0x0000017A, 
    
    GetRandom = 0x0000017B, 
    
    GetTestResult = 0x0000017C, 
    
    Hash = 0x0000017D, 
    
    /** PCR  */
    PCR_Read = 0x0000017E, 
    
    /** Policy  */
    PolicyPCR = 0x0000017F, 
    
    PolicyRestart = 0x00000180, 
    
    ReadClock = 0x00000181, 
    
    PCR_Extend = 0x00000182, 
    
    PCR_SetAuthValue = 0x00000183, 
    
    NV_Certify = 0x00000184, 
    
    EventSequenceComplete = 0x00000185, 
    
    HashSequenceStart = 0x00000186, 
    
    /** Policy  */
    PolicyPhysicalPresence = 0x00000187, 
    
    /** Policy  */
    PolicyDuplicationSelect = 0x00000188, 
    
    /** Policy  */
    PolicyGetDigest = 0x00000189, 
    
    TestParms = 0x0000018A, 
    
    Commit = 0x0000018B, 
    
    /** Policy  */
    PolicyPassword = 0x0000018C, 
    
    ZGen_2Phase = 0x0000018D, 
    
    EC_Ephemeral = 0x0000018E, 
    
    /** Policy  */
    PolicyNvWritten = 0x0000018F, 
    
    /** Policy  */
    PolicyTemplate = 0x00000190, 
    
    CreateLoaded = 0x00000191, 
    
    /** Policy  */
    PolicyAuthorizeNV = 0x00000192, 
    
    EncryptDecrypt2 = 0x00000193, 
    
    AC_GetCapability = 0x00000194, 
    
    AC_Send = 0x00000195, 
    
    /** Policy  */
    Policy_AC_SendSelect = 0x00000196, 
    
    CertifyX509 = 0x00000197, 
    
    ACT_SetTimeout = 0x00000198, 
    
    ECC_Encrypt = 0x00000199, 
    
    ECC_Decrypt = 0x0000019A, 
    
    /** Compile variable. May increase based on implementation.  */
    LAST = 0x0000019A, 
    
    CC_VEND = 0x20000000, 
    
    /** Used for testing of command dispatch  */
    Vendor_TCG_Test = CC_VEND+0x0000
    TPM_ENUM_EPILOGUE(TPM_CC)
};

/** Architecturally defined constants  */
struct ImplementationConstants : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(ImplementationConstants)
    
    Ossl = 1, 
    
    Ltc = 2, 
    
    Msbn = 3, 
    
    Symcrypt = 4, 
    
    HASH_COUNT = 3, 
    
    MAX_SYM_KEY_BITS = 256, 
    
    MAX_SYM_KEY_BYTES = ((MAX_SYM_KEY_BITS + 7) / 8), 
    
    MAX_SYM_BLOCK_SIZE = 16, 
    
    MAX_CAP_CC = TPM_CC::LAST, 
    
    MAX_RSA_KEY_BYTES = 256, 
    
    MAX_AES_KEY_BYTES = 32, 
    
    MAX_ECC_KEY_BYTES = 48, 
    
    LABEL_MAX_BUFFER = 32, 
    
    _TPM_CAP_SIZE = sizeof(UINT32), 
    
    MAX_CAP_DATA = (1024/*MAX_CAP_BUFFER*/-_TPM_CAP_SIZE-sizeof(UINT32)), 
    
    MAX_CAP_ALGS = (MAX_CAP_DATA / 0x6/*sizeof(TPMS_ALG_PROPERTY)*/), 
    
    MAX_CAP_HANDLES = (MAX_CAP_DATA / 0x4/*sizeof(TPM_HANDLE)*/), 
    
    MAX_TPM_PROPERTIES = (MAX_CAP_DATA / 0x8/*sizeof(TPMS_TAGGED_PROPERTY)*/), 
    
    MAX_PCR_PROPERTIES = (MAX_CAP_DATA / 0x5/*sizeof(TPMS_TAGGED_PCR_SELECT)*/), 
    
    MAX_ECC_CURVES = (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE)), 
    
    MAX_TAGGED_POLICIES = (MAX_CAP_DATA / 0x46/*sizeof(TPMS_TAGGED_POLICY)*/), 
    
    MAX_AC_CAPABILITIES = (MAX_CAP_DATA / 0x8/*sizeof(TPMS_AC_OUTPUT)*/), 
    
    MAX_ACT_DATA = MAX_CAP_DATA / 0xC/*sizeof(TPMS_ACT_DATA)*/
    TPM_ENUM_EPILOGUE(ImplementationConstants)
};

/** In general, response codes defined in TPM 2.0 Part 2 will be unmarshaling errors and
 *  will have the F (format) bit SET. Codes that are unique to TPM 2.0 Part 3 will have
 *  the F bit CLEAR but the V (version) attribute will be SET to indicate that it is a TPM
 *  2.0 response code. See Response Code Details in TPM 2.0 Part 1.
 */
struct TPM_RC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_RC)
    
    SUCCESS = 0x000, 
    
    /** Defined for compatibility with TPM 1.2  */
    BAD_TAG = 0x01E, 
    
    /** Set for all format 0 response codes  */
    RC_VER1 = 0x100, 
    
    /** TPM not initialized by TPM2_Startup or already initialized  */
    INITIALIZE = RC_VER1 + 0x000, 
    
    /** Commands not being accepted because of a TPM failure
     *  NOTE This may be returned by TPM2_GetTestResult() as the testResult parameter.
     */
    FAILURE = RC_VER1 + 0x001, 
    
    /** Improper use of a sequence handle  */
    SEQUENCE = RC_VER1 + 0x003, 
    
    /** Not currently used  */
    PRIVATE = RC_VER1 + 0x00B, 
    
    /** Not currently used  */
    HMAC = RC_VER1 + 0x019, 
    
    /** The command is disabled  */
    DISABLED = RC_VER1 + 0x020, 
    
    /** Command failed because audit sequence required exclusivity  */
    EXCLUSIVE = RC_VER1 + 0x021, 
    
    /** Authorization handle is not correct for command  */
    AUTH_TYPE = RC_VER1 + 0x024, 
    
    /** Command requires an authorization session for handle and it is not present.  */
    AUTH_MISSING = RC_VER1 + 0x025, 
    
    /** Policy failure in math operation or an invalid authPolicy value  */
    POLICY = RC_VER1 + 0x026, 
    
    /** PCR check fail  */
    PCR = RC_VER1 + 0x027, 
    
    /** PCR have changed since checked.  */
    PCR_CHANGED = RC_VER1 + 0x028, 
    
    /** For all commands other than TPM2_FieldUpgradeData(), this code indicates that the TPM
     *  is in field upgrade mode; for TPM2_FieldUpgradeData(), this code indicates that the
     *  TPM is not in field upgrade mode
     */
    UPGRADE = RC_VER1 + 0x02D, 
    
    /** Context ID counter is at maximum.  */
    TOO_MANY_CONTEXTS = RC_VER1 + 0x02E, 
    
    /** AuthValue or authPolicy is not available for selected entity.  */
    AUTH_UNAVAILABLE = RC_VER1 + 0x02F, 
    
    /** A _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.  */
    REBOOT = RC_VER1 + 0x030, 
    
    /** The protection algorithms (hash and symmetric) are not reasonably balanced. The digest
     *  size of the hash must be larger than the key size of the symmetric algorithm.
     */
    UNBALANCED = RC_VER1 + 0x031, 
    
    /** Command commandSize value is inconsistent with contents of the command buffer; either
     *  the size is not the same as the octets loaded by the hardware interface layer or the
     *  value is not large enough to hold a command header
     */
    COMMAND_SIZE = RC_VER1 + 0x042, 
    
    /** Command code not supported  */
    COMMAND_CODE = RC_VER1 + 0x043, 
    
    /** The value of authorizationSize is out of range or the number of octets in the
     *  Authorization Area is greater than required
     */
    AUTHSIZE = RC_VER1 + 0x044, 
    
    /** Use of an authorization session with a context command or another command that cannot
     *  have an authorization session.
     */
    AUTH_CONTEXT = RC_VER1 + 0x045, 
    
    /** NV offset+size is out of range.  */
    NV_RANGE = RC_VER1 + 0x046, 
    
    /** Requested allocation size is larger than allowed.  */
    NV_SIZE = RC_VER1 + 0x047, 
    
    /** NV access locked.  */
    NV_LOCKED = RC_VER1 + 0x048, 
    
    /** NV access authorization fails in command actions (this failure does not affect lockout.action)  */
    NV_AUTHORIZATION = RC_VER1 + 0x049, 
    
    /** An NV Index is used before being initialized or the state saved by
     *  TPM2_Shutdown(STATE) could not be restored
     */
    NV_UNINITIALIZED = RC_VER1 + 0x04A, 
    
    /** Insufficient space for NV allocation  */
    NV_SPACE = RC_VER1 + 0x04B, 
    
    /** NV Index or persistent object already defined  */
    NV_DEFINED = RC_VER1 + 0x04C, 
    
    /** Context in TPM2_ContextLoad() is not valid  */
    BAD_CONTEXT = RC_VER1 + 0x050, 
    
    /** CpHash value already set or not correct for use  */
    CPHASH = RC_VER1 + 0x051, 
    
    /** Handle for parent is not a valid parent  */
    PARENT = RC_VER1 + 0x052, 
    
    /** Some function needs testing.  */
    NEEDS_TEST = RC_VER1 + 0x053, 
    
    /** Returned when an internal function cannot process a request due to an unspecified
     *  problem. This code is usually related to invalid parameters that are not properly
     *  filtered by the input unmarshaling code.
     */
    NO_RESULT = RC_VER1 + 0x054, 
    
    /** The sensitive area did not unmarshal correctly after decryption this code is used in
     *  lieu of the other unmarshaling errors so that an attacker cannot determine where the
     *  unmarshaling error occurred
     */
    SENSITIVE = RC_VER1 + 0x055, 
    
    /** Largest version 1 code that is not a warning  */
    RC_MAX_FM0 = RC_VER1 + 0x07F, 
    
    /** This bit is SET in all format 1 response codes
     *  The codes in this group may have a value added to them to indicate the handle,
     *  session, or parameter to which they apply.
     */
    RC_FMT1 = 0x080, 
    
    /** Asymmetric algorithm not supported or not correct  */
    ASYMMETRIC = RC_FMT1 + 0x001, 
    
    /** Inconsistent attributes  */
    ATTRIBUTES = RC_FMT1 + 0x002, 
    
    /** Hash algorithm not supported or not appropriate  */
    HASH = RC_FMT1 + 0x003, 
    
    /** Value is out of range or is not correct for the context  */
    VALUE = RC_FMT1 + 0x004, 
    
    /** Hierarchy is not enabled or is not correct for the use  */
    HIERARCHY = RC_FMT1 + 0x005, 
    
    /** Key size is not supported  */
    KEY_SIZE = RC_FMT1 + 0x007, 
    
    /** Mask generation function not supported  */
    MGF = RC_FMT1 + 0x008, 
    
    /** Mode of operation not supported  */
    MODE = RC_FMT1 + 0x009, 
    
    /** The type of the value is not appropriate for the use  */
    TYPE = RC_FMT1 + 0x00A, 
    
    /** The handle is not correct for the use  */
    HANDLE = RC_FMT1 + 0x00B, 
    
    /** Unsupported key derivation function or function not appropriate for use  */
    KDF = RC_FMT1 + 0x00C, 
    
    /** Value was out of allowed range.  */
    RANGE = RC_FMT1 + 0x00D, 
    
    /** The authorization HMAC check failed and DA counter incremented  */
    AUTH_FAIL = RC_FMT1 + 0x00E, 
    
    /** Invalid nonce size or nonce value mismatch  */
    NONCE = RC_FMT1 + 0x00F, 
    
    /** Authorization requires assertion of PP  */
    PP = RC_FMT1 + 0x010, 
    
    /** Unsupported or incompatible scheme  */
    SCHEME = RC_FMT1 + 0x012, 
    
    /** Structure is the wrong size  */
    SIZE = RC_FMT1 + 0x015, 
    
    /** Unsupported symmetric algorithm or key size, or not appropriate for instance  */
    SYMMETRIC = RC_FMT1 + 0x016, 
    
    /** Incorrect structure tag  */
    TAG = RC_FMT1 + 0x017, 
    
    /** Union selector is incorrect  */
    SELECTOR = RC_FMT1 + 0x018, 
    
    /** The TPM was unable to unmarshal a value because there were not enough octets in the
     *  input buffer
     */
    INSUFFICIENT = RC_FMT1 + 0x01A, 
    
    /** The signature is not valid  */
    SIGNATURE = RC_FMT1 + 0x01B, 
    
    /** Key fields are not compatible with the selected use  */
    KEY = RC_FMT1 + 0x01C, 
    
    /** A policy check failed  */
    POLICY_FAIL = RC_FMT1 + 0x01D, 
    
    /** Integrity check failed  */
    INTEGRITY = RC_FMT1 + 0x01F, 
    
    /** Invalid ticket  */
    TICKET = RC_FMT1 + 0x020, 
    
    /** Reserved bits not set to zero as required  */
    RESERVED_BITS = RC_FMT1 + 0x021, 
    
    /** Authorization failure without DA implications  */
    BAD_AUTH = RC_FMT1 + 0x022, 
    
    /** The policy has expired  */
    EXPIRED = RC_FMT1 + 0x023, 
    
    /** The commandCode in the policy is not the commandCode of the command or the command
     *  code in a policy command references a command that is not implemented
     */
    POLICY_CC = RC_FMT1 + 0x024, 
    
    /** Public and sensitive portions of an object are not cryptographically bound  */
    BINDING = RC_FMT1 + 0x025, 
    
    /** Curve not supported  */
    CURVE = RC_FMT1 + 0x026, 
    
    /** Point is not on the required curve.  */
    ECC_POINT = RC_FMT1 + 0x027, 
    
    /** Set for warning response codes  */
    RC_WARN = 0x900, 
    
    /** Gap for context ID is too large  */
    CONTEXT_GAP = RC_WARN + 0x001, 
    
    /** Out of memory for object contexts  */
    OBJECT_MEMORY = RC_WARN + 0x002, 
    
    /** Out of memory for session contexts  */
    SESSION_MEMORY = RC_WARN + 0x003, 
    
    /** Out of shared object/session memory or need space for internal operations  */
    MEMORY = RC_WARN + 0x004, 
    
    /** Out of session handles a session must be flushed before a new session may be created  */
    SESSION_HANDLES = RC_WARN + 0x005, 
    
    /** Out of object handles the handle space for objects is depleted and a reboot is required
     *  NOTE 1 This cannot occur on the reference implementation.
     *  NOTE 2 There is no reason why an implementation would implement a design that would
     *  deplete handle space. Platform specifications are encouraged to forbid it.
     */
    OBJECT_HANDLES = RC_WARN + 0x006, 
    
    /** Bad locality  */
    LOCALITY = RC_WARN + 0x007, 
    
    /** The TPM has suspended operation on the command; forward progress was made and the
     *  command may be retried
     *  See TPM 2.0 Part 1, Multi-tasking.
     *  NOTE This cannot occur on the reference implementation.
     */
    YIELDED = RC_WARN + 0x008, 
    
    /** The command was canceled  */
    CANCELED = RC_WARN + 0x009, 
    
    /** TPM is performing self-tests  */
    TESTING = RC_WARN + 0x00A, 
    
    /** The 1st handle in the handle area references a transient object or session that is not
     *  loaded
     */
    REFERENCE_H0 = RC_WARN + 0x010, 
    
    /** The 2nd handle in the handle area references a transient object or session that is not
     *  loaded
     */
    REFERENCE_H1 = RC_WARN + 0x011, 
    
    /** The 3rd handle in the handle area references a transient object or session that is not
     *  loaded
     */
    REFERENCE_H2 = RC_WARN + 0x012, 
    
    /** The 4th handle in the handle area references a transient object or session that is not
     *  loaded
     */
    REFERENCE_H3 = RC_WARN + 0x013, 
    
    /** The 5th handle in the handle area references a transient object or session that is not
     *  loaded
     */
    REFERENCE_H4 = RC_WARN + 0x014, 
    
    /** The 6th handle in the handle area references a transient object or session that is not
     *  loaded
     */
    REFERENCE_H5 = RC_WARN + 0x015, 
    
    /** The 7th handle in the handle area references a transient object or session that is not
     *  loaded
     */
    REFERENCE_H6 = RC_WARN + 0x016, 
    
    /** The 1st authorization session handle references a session that is not loaded  */
    REFERENCE_S0 = RC_WARN + 0x018, 
    
    /** The 2nd authorization session handle references a session that is not loaded  */
    REFERENCE_S1 = RC_WARN + 0x019, 
    
    /** The 3rd authorization session handle references a session that is not loaded  */
    REFERENCE_S2 = RC_WARN + 0x01A, 
    
    /** The 4th authorization session handle references a session that is not loaded  */
    REFERENCE_S3 = RC_WARN + 0x01B, 
    
    /** The 5th session handle references a session that is not loaded  */
    REFERENCE_S4 = RC_WARN + 0x01C, 
    
    /** The 6th session handle references a session that is not loaded  */
    REFERENCE_S5 = RC_WARN + 0x01D, 
    
    /** The 7th authorization session handle references a session that is not loaded  */
    REFERENCE_S6 = RC_WARN + 0x01E, 
    
    /** The TPM is rate-limiting accesses to prevent wearout of NV  */
    NV_RATE = RC_WARN + 0x020, 
    
    /** Authorizations for objects subject to DA protection are not allowed at this time
     *  because the TPM is in DA lockout mode
     */
    LOCKOUT = RC_WARN + 0x021, 
    
    /** The TPM was not able to start the command  */
    RETRY = RC_WARN + 0x022, 
    
    /** The command may require writing of NV and NV is not current accessible  */
    NV_UNAVAILABLE = RC_WARN + 0x023, 
    
    /** This value is reserved and shall not be returned by the TPM  */
    NOT_USED = RC_WARN + 0x7F, 
    
    /** Add to a handle-related error  */
    H = 0x000, 
    
    /** Add to a parameter-related error  */
    P = 0x040, 
    
    /** Add to a session-related error  */
    S = 0x800, 
    
    /** Add to a parameter-, handle-, or session-related error  */
    _1 = 0x100, 
    
    /** Add to a parameter-, handle-, or session-related error  */
    _2 = 0x200, 
    
    /** Add to a parameter-, handle-, or session-related error  */
    _3 = 0x300, 
    
    /** Add to a parameter-, handle-, or session-related error  */
    _4 = 0x400, 
    
    /** Add to a parameter-, handle-, or session-related error  */
    _5 = 0x500, 
    
    /** Add to a parameter-, handle-, or session-related error  */
    _6 = 0x600, 
    
    /** Add to a parameter-, handle-, or session-related error  */
    _7 = 0x700, 
    
    /** Add to a parameter-related error  */
    _8 = 0x800, 
    
    /** Add to a parameter-related error  */
    _9 = 0x900, 
    
    /** Add to a parameter-related error  */
    A = 0xA00, 
    
    /** Add to a parameter-related error  */
    B = 0xB00, 
    
    /** Add to a parameter-related error  */
    C = 0xC00, 
    
    /** Add to a parameter-related error  */
    D = 0xD00, 
    
    /** Add to a parameter-related error  */
    E = 0xE00, 
    
    /** Add to a parameter-related error  */
    F = 0xF00, 
    
    /** Number mask  */
    N_MASK = 0xF00, 
    
    /** Response buffer returned by the TPM is too short  */
    TSS_TCP_BAD_HANDSHAKE_RESP = 0x40280001, 
    
    /** Too old TCP server version  */
    TSS_TCP_SERVER_TOO_OLD = 0x40280002, 
    
    /** Bad ack from the TCP end point  */
    TSS_TCP_BAD_ACK = 0x40280003, 
    
    /** Wrong length of the response buffer returned by the TPM  */
    TSS_TCP_BAD_RESP_LEN = 0x40280004, 
    
    /** TPM2_Startup returned unexpected response code  */
    TSS_TCP_UNEXPECTED_STARTUP_RESP = 0x40280005, 
    
    /** Invalid size tag in the TPM response TCP packet  */
    TSS_TCP_INVALID_SIZE_TAG = 0x40280006, 
    
    /** TPM over TCP device is not connected  */
    TSS_TCP_DISCONNECTED = 0x40280007, 
    
    /** General TPM command dispatch failure  */
    TSS_DISPATCH_FAILED = 0x40280010, 
    
    /** Sending data to TPM failed  */
    TSS_SEND_OP_FAILED = 0x40280011, 
    
    /** Response buffer returned by the TPM is too short  */
    TSS_RESP_BUF_TOO_SHORT = 0x40280021, 
    
    /** Invalid tag in the response buffer returned by the TPM  */
    TSS_RESP_BUF_INVALID_SESSION_TAG = 0x40280022, 
    
    /** Inconsistent TPM response parameters size  */
    TSS_RESP_BUF_INVALID_SIZE = 0x40280023, 
    
    /** Windows TBS error TPM_E_COMMAND_BLOCKED  */
    TBS_COMMAND_BLOCKED = 0x80280400, 
    
    /** Windows TBS error TPM_E_INVALID_HANDLE  */
    TBS_INVALID_HANDLE = 0x80280401, 
    
    /** Windows TBS error TPM_E_DUPLICATE_VHANDLE  */
    TBS_DUPLICATE_V_HANDLE = 0x80280402, 
    
    /** Windows TBS error TPM_E_EMBEDDED_COMMAND_BLOCKED  */
    TBS_EMBEDDED_COMMAND_BLOCKED = 0x80280403, 
    
    /** Windows TBS error TPM_E_EMBEDDED_COMMAND_UNSUPPORTED  */
    TBS_EMBEDDED_COMMAND_UNSUPPORTED = 0x80280404, 
    
    /** Windows TBS returned success but empty response buffer  */
    TBS_UNKNOWN_ERROR = 0x80284000, 
    
    /** Windows TBS error TBS_E_INTERNAL_ERROR  */
    TBS_INTERNAL_ERROR = 0x80284001, 
    
    /** Windows TBS error TBS_E_BAD_PARAMETER  */
    TBS_BAD_PARAMETER = 0x80284002, 
    
    /** Windows TBS error TBS_E_INVALID_OUTPUT_POINTER  */
    TBS_INVALID_OUTPUT_POINTER = 0x80284003, 
    
    /** Windows TBS error TBS_E_INVALID_CONTEXT  */
    TBS_INVALID_CONTEXT = 0x80284004, 
    
    /** Windows TBS error TBS_E_INSUFFICIENT_BUFFER  */
    TBS_INSUFFICIENT_BUFFER = 0x80284005, 
    
    /** Windows TBS error TBS_E_IOERROR  */
    TBS_IO_ERROR = 0x80284006, 
    
    /** Windows TBS error TBS_E_INVALID_CONTEXT_PARAM  */
    TBS_INVALID_CONTEXT_PARAM = 0x80284007, 
    
    /** Windows TBS error TBS_E_SERVICE_NOT_RUNNING  */
    TBS_SERVICE_NOT_RUNNING = 0x80284008, 
    
    /** Windows TBS error TBS_E_TOO_MANY_TBS_CONTEXTS  */
    TBS_TOO_MANY_CONTEXTS = 0x80284009, 
    
    /** Windows TBS error TBS_E_TOO_MANY_TBS_RESOURCES  */
    TBS_TOO_MANY_RESOURCES = 0x8028400A, 
    
    /** Windows TBS error TBS_E_SERVICE_START_PENDING  */
    TBS_SERVICE_START_PENDING = 0x8028400B, 
    
    /** Windows TBS error TBS_E_PPI_NOT_SUPPORTED  */
    TBS_PPI_NOT_SUPPORTED = 0x8028400C, 
    
    /** Windows TBS error TBS_E_COMMAND_CANCELED  */
    TBS_COMMAND_CANCELED = 0x8028400D, 
    
    /** Windows TBS error TBS_E_BUFFER_TOO_LARGE  */
    TBS_BUFFER_TOO_LARGE = 0x8028400E, 
    
    /** Windows TBS error TBS_E_TPM_NOT_FOUND  */
    TBS_TPM_NOT_FOUND = 0x8028400F, 
    
    /** Windows TBS error TBS_E_SERVICE_DISABLED  */
    TBS_SERVICE_DISABLED = 0x80284010, 
    
    /** Windows TBS error TBS_E_ACCESS_DENIED  */
    TBS_ACCESS_DENIED = 0x80284012, 
    
    /** Windows TBS error TBS_E_PPI_FUNCTION_UNSUPPORTED  */
    TBS_PPI_FUNCTION_NOT_SUPPORTED = 0x80284014, 
    
    /** Windows TBS error TBS_E_OWNERAUTH_NOT_FOUND  */
    TBS_OWNER_AUTH_NOT_FOUND = 0x80284015
    TPM_ENUM_EPILOGUE(TPM_RC)
};

/** A TPM_CLOCK_ADJUST value is used to change the rate at which the TPM internal
 *  oscillator is divided. A change to the divider will change the rate at which Clock and
 *  Time change.
 */
struct TPM_CLOCK_ADJUST : public TpmEnum<INT8>
{
    TPM_ENUM_PROLOGUE(TPM_CLOCK_ADJUST)
    
    /** Slow the Clock update rate by one coarse adjustment step.  */
    COARSE_SLOWER = -3, 
    
    /** Slow the Clock update rate by one medium adjustment step.  */
    MEDIUM_SLOWER = -2, 
    
    /** Slow the Clock update rate by one fine adjustment step.  */
    FINE_SLOWER = -1, 
    
    /** No change to the Clock update rate.  */
    NO_CHANGE = 0, 
    
    /** Speed the Clock update rate by one fine adjustment step.  */
    FINE_FASTER = 1, 
    
    /** Speed the Clock update rate by one medium adjustment step.  */
    MEDIUM_FASTER = 2, 
    
    /** Speed the Clock update rate by one coarse adjustment step.  */
    COARSE_FASTER = 3
    TPM_ENUM_EPILOGUE(TPM_CLOCK_ADJUST)
};

/** Table 18 Definition of (UINT16) TPM_EO Constants [IN/OUT]  */
struct TPM_EO : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_EO)
    
    /** A = B  */
    EQ = 0x0000, 
    
    /** A B  */
    NEQ = 0x0001, 
    
    /** A ˃ B signed  */
    SIGNED_GT = 0x0002, 
    
    /** A ˃ B unsigned  */
    UNSIGNED_GT = 0x0003, 
    
    /** A ˂ B signed  */
    SIGNED_LT = 0x0004, 
    
    /** A ˂ B unsigned  */
    UNSIGNED_LT = 0x0005, 
    
    /** A B signed  */
    SIGNED_GE = 0x0006, 
    
    /** A B unsigned  */
    UNSIGNED_GE = 0x0007, 
    
    /** A B signed  */
    SIGNED_LE = 0x0008, 
    
    /** A B unsigned  */
    UNSIGNED_LE = 0x0009, 
    
    /** All bits SET in B are SET in A. ((A∧B)=B)  */
    BITSET = 0x000A, 
    
    /** All bits SET in B are CLEAR in A. ((A∧B)=0)  */
    BITCLEAR = 0x000B
    TPM_ENUM_EPILOGUE(TPM_EO)
};

/** Structure tags are used to disambiguate structures. They are 16-bit values with the
 *  most significant bit SET so that they do not overlap TPM_ALG_ID values. A single
 *  exception is made for the value associated with TPM_ST_RSP_COMMAND (0x00C4), which has
 *  the same value as the TPM_TAG_RSP_COMMAND tag from earlier versions of this
 *  specification. This value is used when the TPM is compatible with a previous TPM
 *  specification and the TPM cannot determine which family of response code to return
 *  because the command tag is not valid.
 */
struct TPM_ST : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_ST)
    
    /** Tag value for a response; used when there is an error in the tag. This is also the
     *  value returned from a TPM 1.2 when an error occurs. This value is used in this
     *  specification because an error in the command tag may prevent determination of the
     *  family. When this tag is used in the response, the response code will be
     *  TPM_RC_BAD_TAG (0 1E16), which has the same numeric value as the TPM 1.2 response code
     *  for TPM_BADTAG.
     *  NOTE In a previously published version of this specification, TPM_RC_BAD_TAG was
     *  incorrectly assigned a value of 0x030 instead of 30 (0x01e). Some implementations my
     *  return the old value instead of the new value.
     */
    RSP_COMMAND = 0x00C4, 
    
    /** No structure type specified  */
    _NULL = 0X8000, 
    
    /** Tag value for a command/response for a command defined in this specification;
     *  indicating that the command/response has no attached sessions and no
     *  authorizationSize/parameterSize value is present
     *  If the responseCode from the TPM is not TPM_RC_SUCCESS, then the response tag shall
     *  have this value.
     */
    NO_SESSIONS = 0x8001, 
    
    /** Tag value for a command/response for a command defined in this specification;
     *  indicating that the command/response has one or more attached sessions and the
     *  authorizationSize/parameterSize field is present
     */
    SESSIONS = 0x8002, 
    
    /** Tag for an attestation structure  */
    ATTEST_NV = 0x8014, 
    
    /** Tag for an attestation structure  */
    ATTEST_COMMAND_AUDIT = 0x8015, 
    
    /** Tag for an attestation structure  */
    ATTEST_SESSION_AUDIT = 0x8016, 
    
    /** Tag for an attestation structure  */
    ATTEST_CERTIFY = 0x8017, 
    
    /** Tag for an attestation structure  */
    ATTEST_QUOTE = 0x8018, 
    
    /** Tag for an attestation structure  */
    ATTEST_TIME = 0x8019, 
    
    /** Tag for an attestation structure  */
    ATTEST_CREATION = 0x801A, 
    
    /** Tag for an attestation structure  */
    ATTEST_NV_DIGEST = 0x801C, 
    
    /** Tag for a ticket type  */
    CREATION = 0x8021, 
    
    /** Tag for a ticket type  */
    VERIFIED = 0x8022, 
    
    /** Tag for a ticket type  */
    AUTH_SECRET = 0x8023, 
    
    /** Tag for a ticket type  */
    HASHCHECK = 0x8024, 
    
    /** Tag for a ticket type  */
    AUTH_SIGNED = 0x8025, 
    
    /** Tag for a structure describing a Field Upgrade Policy  */
    FU_MANIFEST = 0x8029
    TPM_ENUM_EPILOGUE(TPM_ST)
};

/** These values are used in TPM2_Startup() to indicate the shutdown and startup mode. The
 *  defined startup sequences are:
 */
struct TPM_SU : public TpmEnum<UINT16>
{
    TPM_ENUM_PROLOGUE(TPM_SU)
    
    /** On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
     *  state required for an orderly startup (TPM Reset).
     *  on TPM2_Startup(), indicates that the TPM should perform TPM Reset or TPM Restart
     */
    CLEAR = 0x0000, 
    
    /** On TPM2_Shutdown(), indicates that the TPM should prepare for loss of power and save
     *  state required for an orderly startup (TPM Restart or TPM Resume)
     *  on TPM2_Startup(), indicates that the TPM should restore the state saved by
     *  TPM2_Shutdown(TPM_SU_STATE)
     */
    STATE = 0x0001
    TPM_ENUM_EPILOGUE(TPM_SU)
};

/** This type is used in TPM2_StartAuthSession() to indicate the type of the session to be
 *  created.
 */
struct TPM_SE : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPM_SE)
    
    HMAC = 0x00, 
    
    POLICY = 0x01, 
    
    /** The policy session is being used to compute the policyHash and not for command authorization.
     *  This setting modifies some policy commands and prevents session from being used to
     *  authorize a command.
     */
    TRIAL = 0x03
    TPM_ENUM_EPILOGUE(TPM_SE)
};

/** The TPM_CAP values are used in TPM2_GetCapability() to select the type of the value to
 *  be returned. The format of the response varies according to the type of the value.
 */
struct TPM_CAP : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_CAP)
    
    FIRST = 0x00000000, 
    
    /** TPML_ALG_PROPERTY  */
    ALGS = 0x00000000, 
    
    /** TPML_HANDLE  */
    HANDLES = 0x00000001, 
    
    /** TPML_CCA  */
    COMMANDS = 0x00000002, 
    
    /** TPML_CC  */
    PP_COMMANDS = 0x00000003, 
    
    /** TPML_CC  */
    AUDIT_COMMANDS = 0x00000004, 
    
    /** TPML_PCR_SELECTION  */
    PCRS = 0x00000005, 
    
    /** TPML_TAGGED_TPM_PROPERTY  */
    TPM_PROPERTIES = 0x00000006, 
    
    /** TPML_TAGGED_PCR_PROPERTY  */
    PCR_PROPERTIES = 0x00000007, 
    
    /** TPML_ECC_CURVE  */
    ECC_CURVES = 0x00000008, 
    
    /** TPML_TAGGED_POLICY  */
    AUTH_POLICIES = 0x00000009, 
    
    /** TPML_ACT_DATA  */
    ACT = 0x0000000A, 
    
    LAST = 0x0000000A, 
    
    /** Manufacturer-specific values  */
    VENDOR_PROPERTY = 0x00000100
    TPM_ENUM_EPILOGUE(TPM_CAP)
};

/** The TPM_PT constants are used in TPM2_GetCapability(capability =
 *  TPM_CAP_TPM_PROPERTIES) to indicate the property being selected or returned.
 */
struct TPM_PT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_PT)
    
    /** Indicates no property type  */
    NONE = 0x00000000, 
    
    /** The number of properties in each group.
     *  NOTE The first group with any properties is group 1 (PT_GROUP * 1). Group 0 is reserved.
     */
    PT_GROUP = 0x00000100, 
    
    /** The group of fixed properties returned as TPMS_TAGGED_PROPERTY
     *  The values in this group are only changed due to a firmware change in the TPM.
     */
    PT_FIXED = PT_GROUP * 1, 
    
    /** A 4-octet character string containing the TPM Family value (TPM_SPEC_FAMILY)  */
    FAMILY_INDICATOR = PT_FIXED + 0, 
    
    /** The level of the specification
     *  NOTE 1 For this specification, the level is zero.
     *  NOTE 2 The level is on the title page of the specification.
     */
    LEVEL = PT_FIXED + 1, 
    
    /** The specification Revision times 100
     *  EXAMPLE Revision 01.01 would have a value of 101.
     *  NOTE The Revision value is on the title page of the specification.
     */
    REVISION = PT_FIXED + 2, 
    
    /** The specification day of year using TCG calendar
     *  EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
     *  NOTE The specification date is on the title page of the specification or errata (see 6.1).
     */
    DAY_OF_YEAR = PT_FIXED + 3, 
    
    /** The specification year using the CE
     *  EXAMPLE The year 2010 has a value of 000007DA16.
     *  NOTE The specification date is on the title page of the specification or errata (see 6.1).
     */
    YEAR = PT_FIXED + 4, 
    
    /** The vendor ID unique to each TPM manufacturer  */
    MANUFACTURER = PT_FIXED + 5, 
    
    /** The first four characters of the vendor ID string
     *  NOTE When the vendor string is fewer than 16 octets, the additional property values do
     *  not have to be present. A vendor string of 4 octets can be represented in one 32-bit
     *  value and no null terminating character is required.
     */
    VENDOR_STRING_1 = PT_FIXED + 6, 
    
    /** The second four characters of the vendor ID string  */
    VENDOR_STRING_2 = PT_FIXED + 7, 
    
    /** The third four characters of the vendor ID string  */
    VENDOR_STRING_3 = PT_FIXED + 8, 
    
    /** The fourth four characters of the vendor ID sting  */
    VENDOR_STRING_4 = PT_FIXED + 9, 
    
    /** Vendor-defined value indicating the TPM model  */
    VENDOR_TPM_TYPE = PT_FIXED + 10, 
    
    /** The most-significant 32 bits of a TPM vendor-specific value indicating the version
     *  number of the firmware. See 10.12.2 and 10.12.12.
     */
    FIRMWARE_VERSION_1 = PT_FIXED + 11, 
    
    /** The least-significant 32 bits of a TPM vendor-specific value indicating the version
     *  number of the firmware. See 10.12.2 and 10.12.12.
     */
    FIRMWARE_VERSION_2 = PT_FIXED + 12, 
    
    /** The maximum size of a parameter (typically, a TPM2B_MAX_BUFFER)  */
    INPUT_BUFFER = PT_FIXED + 13, 
    
    /** The minimum number of transient objects that can be held in TPM RAM
     *  NOTE This minimum shall be no less than the minimum value required by the
     *  platform-specific specification to which the TPM is built.
     */
    HR_TRANSIENT_MIN = PT_FIXED + 14, 
    
    /** The minimum number of persistent objects that can be held in TPM NV memory
     *  NOTE This minimum shall be no less than the minimum value required by the
     *  platform-specific specification to which the TPM is built.
     */
    HR_PERSISTENT_MIN = PT_FIXED + 15, 
    
    /** The minimum number of authorization sessions that can be held in TPM RAM
     *  NOTE This minimum shall be no less than the minimum value required by the
     *  platform-specific specification to which the TPM is built.
     */
    HR_LOADED_MIN = PT_FIXED + 16, 
    
    /** The number of authorization sessions that may be active at a time
     *  A session is active when it has a context associated with its handle. The context may
     *  either be in TPM RAM or be context saved.
     *  NOTE This value shall be no less than the minimum value required by the
     *  platform-specific specification to which the TPM is built.
     */
    ACTIVE_SESSIONS_MAX = PT_FIXED + 17, 
    
    /** The number of PCR implemented
     *  NOTE This number is determined by the defined attributes, not the number of PCR that
     *  are populated.
     */
    PCR_COUNT = PT_FIXED + 18, 
    
    /** The minimum number of octets in a TPMS_PCR_SELECT.sizeOfSelect
     *  NOTE This value is not determined by the number of PCR implemented but by the number
     *  of PCR required by the platform-specific specification with which the TPM is compliant
     *  or by the implementer if not adhering to a platform-specific specification.
     */
    PCR_SELECT_MIN = PT_FIXED + 19, 
    
    /** The maximum allowed difference (unsigned) between the contextID values of two saved
     *  session contexts
     *  This value shall be 2n-1, where n is at least 16.
     */
    CONTEXT_GAP_MAX = PT_FIXED + 20, 
    
    /** The maximum number of NV Indexes that are allowed to have the TPM_NT_COUNTER attribute
     *  NOTE 1 It is allowed for this value to be larger than the number of NV Indexes that
     *  can be defined. This would be indicative of a TPM implementation that did not use
     *  different implementation technology for different NV Index types.
     *  NOTE 2 The value zero indicates that there is no fixed maximum. The number of counter
     *  indexes is determined by the available NV memory pool.
     */
    NV_COUNTERS_MAX = PT_FIXED + 22, 
    
    /** The maximum size of an NV Index data area  */
    NV_INDEX_MAX = PT_FIXED + 23, 
    
    /** A TPMA_MEMORY indicating the memory management method for the TPM  */
    MEMORY = PT_FIXED + 24, 
    
    /** Interval, in milliseconds, between updates to the copy of TPMS_CLOCK_INFO.clock in NV  */
    CLOCK_UPDATE = PT_FIXED + 25, 
    
    /** The algorithm used for the integrity HMAC on saved contexts and for hashing the fuData
     *  of TPM2_FirmwareRead()
     */
    CONTEXT_HASH = PT_FIXED + 26, 
    
    /** TPM_ALG_ID, the algorithm used for encryption of saved contexts  */
    CONTEXT_SYM = PT_FIXED + 27, 
    
    /** TPM_KEY_BITS, the size of the key used for encryption of saved contexts  */
    CONTEXT_SYM_SIZE = PT_FIXED + 28, 
    
    /** The modulus - 1 of the count for NV update of an orderly counter
     *  The returned value is MAX_ORDERLY_COUNT.
     *  This will have a value of 2N 1 where 1 N 32
     *  NOTE 1 An orderly counter is an NV Index with an TPM_NT of TPM_NV_COUNTER and
     *  TPMA_NV_ORDERLY SET.
     *  NOTE 2 When the low-order bits of a counter equal this value, an NV write occurs on
     *  the next increment.
     */
    ORDERLY_COUNT = PT_FIXED + 29, 
    
    /** The maximum value for commandSize in a command  */
    MAX_COMMAND_SIZE = PT_FIXED + 30, 
    
    /** The maximum value for responseSize in a response  */
    MAX_RESPONSE_SIZE = PT_FIXED + 31, 
    
    /** The maximum size of a digest that can be produced by the TPM  */
    MAX_DIGEST = PT_FIXED + 32, 
    
    /** The maximum size of an object context that will be returned by TPM2_ContextSave  */
    MAX_OBJECT_CONTEXT = PT_FIXED + 33, 
    
    /** The maximum size of a session context that will be returned by TPM2_ContextSave  */
    MAX_SESSION_CONTEXT = PT_FIXED + 34, 
    
    /** Platform-specific family (a TPM_PS value)(see Table 25)
     *  NOTE The platform-specific values for the TPM_PT_PS parameters are in the relevant
     *  platform-specific specification. In the reference implementation, all of these values
     *  are 0.
     */
    PS_FAMILY_INDICATOR = PT_FIXED + 35, 
    
    /** The level of the platform-specific specification  */
    PS_LEVEL = PT_FIXED + 36, 
    
    /** A platform specific value  */
    PS_REVISION = PT_FIXED + 37, 
    
    /** The platform-specific TPM specification day of year using TCG calendar
     *  EXAMPLE November 15, 2010, has a day of year value of 319 (0000013F16).
     */
    PS_DAY_OF_YEAR = PT_FIXED + 38, 
    
    /** The platform-specific TPM specification year using the CE
     *  EXAMPLE The year 2010 has a value of 000007DA16.
     */
    PS_YEAR = PT_FIXED + 39, 
    
    /** The number of split signing operations supported by the TPM  */
    SPLIT_MAX = PT_FIXED + 40, 
    
    /** Total number of commands implemented in the TPM  */
    TOTAL_COMMANDS = PT_FIXED + 41, 
    
    /** Number of commands from the TPM library that are implemented  */
    LIBRARY_COMMANDS = PT_FIXED + 42, 
    
    /** Number of vendor commands that are implemented  */
    VENDOR_COMMANDS = PT_FIXED + 43, 
    
    /** The maximum data size in one NV write, NV read, NV extend, or NV certify command  */
    NV_BUFFER_MAX = PT_FIXED + 44, 
    
    /** A TPMA_MODES value, indicating that the TPM is designed for these modes.  */
    MODES = PT_FIXED + 45, 
    
    /** The maximum size of a TPMS_CAPABILITY_DATA structure returned in TPM2_GetCapability().  */
    MAX_CAP_BUFFER = PT_FIXED + 46, 
    
    /** The group of variable properties returned as TPMS_TAGGED_PROPERTY
     *  The properties in this group change because of a Protected Capability other than a
     *  firmware update. The values are not necessarily persistent across all power transitions.
     */
    PT_VAR = PT_GROUP * 2, 
    
    /** TPMA_PERMANENT  */
    PERMANENT = PT_VAR + 0, 
    
    /** TPMA_STARTUP_CLEAR  */
    STARTUP_CLEAR = PT_VAR + 1, 
    
    /** The number of NV Indexes currently defined  */
    HR_NV_INDEX = PT_VAR + 2, 
    
    /** The number of authorization sessions currently loaded into TPM RAM  */
    HR_LOADED = PT_VAR + 3, 
    
    /** The number of additional authorization sessions, of any type, that could be loaded
     *  into TPM RAM
     *  This value is an estimate. If this value is at least 1, then at least one
     *  authorization session of any type may be loaded. Any command that changes the RAM
     *  memory allocation can make this estimate invalid.
     *  NOTE A valid implementation may return 1 even if more than one authorization session
     *  would fit into RAM.
     */
    HR_LOADED_AVAIL = PT_VAR + 4, 
    
    /** The number of active authorization sessions currently being tracked by the TPM
     *  This is the sum of the loaded and saved sessions.
     */
    HR_ACTIVE = PT_VAR + 5, 
    
    /** The number of additional authorization sessions, of any type, that could be created
     *  This value is an estimate. If this value is at least 1, then at least one
     *  authorization session of any type may be created. Any command that changes the RAM
     *  memory allocation can make this estimate invalid.
     *  NOTE A valid implementation may return 1 even if more than one authorization session
     *  could be created.
     */
    HR_ACTIVE_AVAIL = PT_VAR + 6, 
    
    /** Estimate of the number of additional transient objects that could be loaded into TPM RAM
     *  This value is an estimate. If this value is at least 1, then at least one object of
     *  any type may be loaded. Any command that changes the memory allocation can make this
     *  estimate invalid.
     *  NOTE A valid implementation may return 1 even if more than one transient object would
     *  fit into RAM.
     */
    HR_TRANSIENT_AVAIL = PT_VAR + 7, 
    
    /** The number of persistent objects currently loaded into TPM NV memory  */
    HR_PERSISTENT = PT_VAR + 8, 
    
    /** The number of additional persistent objects that could be loaded into NV memory
     *  This value is an estimate. If this value is at least 1, then at least one object of
     *  any type may be made persistent. Any command that changes the NV memory allocation can
     *  make this estimate invalid.
     *  NOTE A valid implementation may return 1 even if more than one persistent object would
     *  fit into NV memory.
     */
    HR_PERSISTENT_AVAIL = PT_VAR + 9, 
    
    /** The number of defined NV Indexes that have NV the TPM_NT_COUNTER attribute  */
    NV_COUNTERS = PT_VAR + 10, 
    
    /** The number of additional NV Indexes that can be defined with their TPM_NT of
     *  TPM_NV_COUNTER and the TPMA_NV_ORDERLY attribute SET
     *  This value is an estimate. If this value is at least 1, then at least one NV Index may
     *  be created with a TPM_NT of TPM_NV_COUNTER and the TPMA_NV_ORDERLY attributes. Any
     *  command that changes the NV memory allocation can make this estimate invalid.
     *  NOTE A valid implementation may return 1 even if more than one NV counter could be defined.
     */
    NV_COUNTERS_AVAIL = PT_VAR + 11, 
    
    /** Code that limits the algorithms that may be used with the TPM  */
    ALGORITHM_SET = PT_VAR + 12, 
    
    /** The number of loaded ECC curves  */
    LOADED_CURVES = PT_VAR + 13, 
    
    /** The current value of the lockout counter (failedTries)  */
    LOCKOUT_COUNTER = PT_VAR + 14, 
    
    /** The number of authorization failures before DA lockout is invoked  */
    MAX_AUTH_FAIL = PT_VAR + 15, 
    
    /** The number of seconds before the value reported by TPM_PT_LOCKOUT_COUNTER is decremented  */
    LOCKOUT_INTERVAL = PT_VAR + 16, 
    
    /** The number of seconds after a lockoutAuth failure before use of lockoutAuth may be
     *  attempted again
     */
    LOCKOUT_RECOVERY = PT_VAR + 17, 
    
    /** Number of milliseconds before the TPM will accept another command that will modify NV
     *  This value is an approximation and may go up or down over time.
     */
    NV_WRITE_RECOVERY = PT_VAR + 18, 
    
    /** The high-order 32 bits of the command audit counter  */
    AUDIT_COUNTER_0 = PT_VAR + 19, 
    
    /** The low-order 32 bits of the command audit counter  */
    AUDIT_COUNTER_1 = PT_VAR + 20
    TPM_ENUM_EPILOGUE(TPM_PT)
};

/** The TPM_PT_PCR constants are used in TPM2_GetCapability() to indicate the property
 *  being selected or returned. The PCR properties can be read when capability ==
 *  TPM_CAP_PCR_PROPERTIES. If there is no property that corresponds to the value of
 *  property, the next higher value is returned, if it exists.
 */
struct TPM_PT_PCR : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_PT_PCR)
    
    /** Bottom of the range of TPM_PT_PCR properties  */
    FIRST = 0x00000000, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR is saved and restored by TPM_SU_STATE  */
    SAVE = 0x00000000, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 0
     *  This property is only present if a locality other than 0 is implemented.
     */
    EXTEND_L0 = 0x00000001, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
     *  TPM2_PCR_Reset() from locality 0
     */
    RESET_L0 = 0x00000002, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 1
     *  This property is only present if locality 1 is implemented.
     */
    EXTEND_L1 = 0x00000003, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
     *  TPM2_PCR_Reset() from locality 1
     *  This property is only present if locality 1 is implemented.
     */
    RESET_L1 = 0x00000004, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 2
     *  This property is only present if localities 1 and 2 are implemented.
     */
    EXTEND_L2 = 0x00000005, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
     *  TPM2_PCR_Reset() from locality 2
     *  This property is only present if localities 1 and 2 are implemented.
     */
    RESET_L2 = 0x00000006, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 3
     *  This property is only present if localities 1, 2, and 3 are implemented.
     */
    EXTEND_L3 = 0x00000007, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
     *  TPM2_PCR_Reset() from locality 3
     *  This property is only present if localities 1, 2, and 3 are implemented.
     */
    RESET_L3 = 0x00000008, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be extended from locality 4
     *  This property is only present if localities 1, 2, 3, and 4 are implemented.
     */
    EXTEND_L4 = 0x00000009, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR may be reset by
     *  TPM2_PCR_Reset() from locality 4
     *  This property is only present if localities 1, 2, 3, and 4 are implemented.
     */
    RESET_L4 = 0x0000000A, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that modifications to this PCR (reset or
     *  Extend) will not increment the pcrUpdateCounter
     */
    NO_INCREMENT = 0x00000011, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR is reset by a D-RTM event
     *  These PCR are reset to -1 on TPM2_Startup() and reset to 0 on a _TPM_Hash_End event
     *  following a _TPM_Hash_Start event.
     */
    DRTM_RESET = 0x00000012, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by policy
     *  This property is only present if the TPM supports policy control of a PCR.
     */
    POLICY = 0x00000013, 
    
    /** A SET bit in the TPMS_PCR_SELECT indicates that the PCR is controlled by an
     *  authorization value
     *  This property is only present if the TPM supports authorization control of a PCR.
     */
    AUTH = 0x00000014, 
    
    /** Top of the range of TPM_PT_PCR properties of the implementation
     *  If the TPM receives a request for a PCR property with a value larger than this, the
     *  TPM will return a zero length list and set the moreData parameter to NO.
     *  NOTE This is an implementation-specific value. The value shown reflects the reference
     *  code implementation.
     */
    LAST = 0x00000014
    TPM_ENUM_EPILOGUE(TPM_PT_PCR)
};

/** The platform values in Table 25 are used for the TPM_PT_PS_FAMILY_INDICATOR.  */
struct TPM_PS : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_PS)
    
    /** Not platform specific  */
    MAIN = 0x00000000, 
    
    /** PC Client  */
    PC = 0x00000001, 
    
    /** PDA (includes all mobile devices that are not specifically cell phones)  */
    PDA = 0x00000002, 
    
    /** Cell Phone  */
    CELL_PHONE = 0x00000003, 
    
    /** Server WG  */
    SERVER = 0x00000004, 
    
    /** Peripheral WG  */
    PERIPHERAL = 0x00000005, 
    
    /** TSS WG (deprecated)  */
    TSS = 0x00000006, 
    
    /** Storage WG  */
    STORAGE = 0x00000007, 
    
    /** Authentication WG  */
    AUTHENTICATION = 0x00000008, 
    
    /** Embedded WG  */
    EMBEDDED = 0x00000009, 
    
    /** Hardcopy WG  */
    HARDCOPY = 0x0000000A, 
    
    /** Infrastructure WG (deprecated)  */
    INFRASTRUCTURE = 0x0000000B, 
    
    /** Virtualization WG  */
    VIRTUALIZATION = 0x0000000C, 
    
    /** Trusted Network Connect WG (deprecated)  */
    TNC = 0x0000000D, 
    
    /** Multi-tenant WG (deprecated)  */
    MULTI_TENANT = 0x0000000E, 
    
    /** Technical Committee (deprecated)  */
    TC = 0x0000000F
    TPM_ENUM_EPILOGUE(TPM_PS)
};

/** The 32-bit handle space is divided into 256 regions of equal size with 224 values in
 *  each. Each of these ranges represents a handle type.
 */
struct TPM_HT : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPM_HT)
    
    /** PCR consecutive numbers, starting at 0, that reference the PCR registers
     *  A platform-specific specification will set the minimum number of PCR and an
     *  implementation may have more.
     */
    PCR = 0x00, 
    
    /** NV Index assigned by the caller  */
    NV_INDEX = 0x01, 
    
    /** HMAC Authorization Session assigned by the TPM when the session is created  */
    HMAC_SESSION = 0x02, 
    
    /** Loaded Authorization Session used only in the context of TPM2_GetCapability
     *  This type references both loaded HMAC and loaded policy authorization sessions.
     */
    LOADED_SESSION = 0x02, 
    
    /** Policy Authorization Session assigned by the TPM when the session is created  */
    POLICY_SESSION = 0x03, 
    
    /** Saved Authorization Session used only in the context of TPM2_GetCapability
     *  This type references saved authorization session contexts for which the TPM is
     *  maintaining tracking information.
     */
    SAVED_SESSION = 0x03, 
    
    /** Permanent Values assigned by this specification in Table 28  */
    PERMANENT = 0x40, 
    
    /** Transient Objects assigned by the TPM when an object is loaded into transient-object
     *  memory or when a persistent object is converted to a transient object
     */
    TRANSIENT = 0x80, 
    
    /** Persistent Objects assigned by the TPM when a loaded transient object is made persistent  */
    PERSISTENT = 0x81, 
    
    /** Attached Component handle for an Attached Component.  */
    AC = 0x90
    TPM_ENUM_EPILOGUE(TPM_HT)
};

/** Table 28 lists the architecturally defined handles that cannot be changed. The handles
 *  include authorization handles, and special handles.
 */
struct TPM_RH : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_RH)
    
    FIRST = 0x40000000, 
    
    /** Not used1  */
    SRK = 0x40000000, 
    
    /** Handle references the Storage Primary Seed (SPS), the ownerAuth, and the ownerPolicy  */
    OWNER = 0x40000001, 
    
    /** Not used1  */
    REVOKE = 0x40000002, 
    
    /** Not used1  */
    TRANSPORT = 0x40000003, 
    
    /** Not used1  */
    OPERATOR = 0x40000004, 
    
    /** Not used1  */
    ADMIN = 0x40000005, 
    
    /** Not used1  */
    EK = 0x40000006, 
    
    /** A handle associated with the null hierarchy, an EmptyAuth authValue, and an Empty
     *  Policy authPolicy.
     */
    _NULL = 0x40000007, 
    
    /** Value reserved to the TPM to indicate a handle location that has not been initialized
     *  or assigned
     */
    UNASSIGNED = 0x40000008, 
    
    /** Authorization value used to indicate a password authorization session  */
    PW = 0x40000009, 
    
    /** Deprecated: use PW instead  */
    RS_PW [[deprecated("Use TPM_RH::PW instead")]] = 0x40000009,
    
    /** References the authorization associated with the dictionary attack lockout reset  */
    LOCKOUT = 0x4000000A, 
    
    /** References the Endorsement Primary Seed (EPS), endorsementAuth, and endorsementPolicy  */
    ENDORSEMENT = 0x4000000B, 
    
    /** References the Platform Primary Seed (PPS), platformAuth, and platformPolicy  */
    PLATFORM = 0x4000000C, 
    
    /** For phEnableNV  */
    PLATFORM_NV = 0x4000000D, 
    
    /** Start of a range of authorization values that are vendor-specific. A TPM may support
     *  any of the values in this range as are needed for vendor-specific purposes.
     *  Disabled if ehEnable is CLEAR.
     *  NOTE Any includes none.
     */
    AUTH_00 = 0x40000010, 
    
    /** End of the range of vendor-specific authorization values.  */
    AUTH_FF = 0x4000010F, 
    
    /** Start of the range of authenticated timers  */
    ACT_0 = 0x40000110, 
    
    /** End of the range of authenticated timers  */
    ACT_F = 0x4000011F, 
    
    /** The top of the reserved handle area
     *  This is set to allow TPM2_GetCapability() to know where to stop. It may vary as
     *  implementations add to the permanent handle area.
     */
    LAST = 0x4000011F
    TPM_ENUM_EPILOGUE(TPM_RH)
};

/** This table lists the values of the TPM_NT field of a TPMA_NV. See Table 215 for usage.  */
struct TPM_NT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_NT)
    
    /** Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().  */
    ORDINARY = 0x0, 
    
    /** Counter contains an 8-octet value that is to be used as a counter and can only be
     *  modified with TPM2_NV_Increment()
     */
    COUNTER = 0x1, 
    
    /** Bit Field contains an 8-octet value to be used as a bit field and can only be modified
     *  with TPM2_NV_SetBits().
     */
    BITS = 0x2, 
    
    /** Extend contains a digest-sized value used like a PCR. The Index can only be modified
     *  using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
     */
    EXTEND = 0x4, 
    
    /** PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit  */
    PIN_FAIL = 0x8, 
    
    /** PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit  */
    PIN_PASS = 0x9
    TPM_ENUM_EPILOGUE(TPM_NT)
};

/** These constants are used in TPM2_AC_GetCapability() to indicate the first tagged value
 *  returned from an attached component.
 */
struct TPM_AT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_AT)
    
    /** In a command, a non-specific request for AC information; in a response, indicates that
     *  outputData is not meaningful
     */
    ANY = 0x00000000, 
    
    /** Indicates a TCG defined, device-specific error  */
    _ERROR = 0x00000001, 
    
    /** Indicates the most significant 32 bits of a pairing value for the AC  */
    PV1 = 0x00000002, 
    
    /** Value added to a TPM_AT to indicate a vendor-specific tag value  */
    VEND = 0x80000000
    TPM_ENUM_EPILOGUE(TPM_AT)
};

/** These constants are the TCG-defined error values returned by an AC.  */
struct TPM_AE : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_AE)
    
    /** In a command, a non-specific request for AC information; in a response, indicates that
     *  outputData is not meaningful
     */
    NONE = 0x00000000
    TPM_ENUM_EPILOGUE(TPM_AE)
};

/** These values are readable with TPM2_GetCapability(). They are the TPM_PT_PS_xxx values.  */
struct PLATFORM : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(PLATFORM)
    
    FAMILY = TPM_SPEC::FAMILY, 
    
    LEVEL = TPM_SPEC::LEVEL, 
    
    VERSION = TPM_SPEC::VERSION, 
    
    YEAR = TPM_SPEC::YEAR, 
    
    DAY_OF_YEAR = TPM_SPEC::DAY_OF_YEAR
    TPM_ENUM_EPILOGUE(PLATFORM)
};

/** This table contains a collection of values used in various parts of the reference
 *  code. The values shown are illustrative.
 */
struct Implementation : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(Implementation)
    
    /** Temporary define  */
    FIELD_UPGRADE_IMPLEMENTED = Logic::NO, 
    
    /** Selection of the library that provides the basic hashing functions.  */
    HASH_LIB = ImplementationConstants::Ossl, 
    
    /** Selection of the library that provides the low-level symmetric cryptography. Choices
     *  are determined by the vendor (See LibSupport.h for implications).
     */
    SYM_LIB = ImplementationConstants::Ossl, 
    
    /** Selection of the library that provides the big number math including ECC. Choices are
     *  determined by the vendor (See LibSupport.h for implications).
     */
    MATH_LIB = ImplementationConstants::Ossl, 
    
    /** The number of PCR in the TPM  */
    IMPLEMENTATION_PCR = 24, 
    
    PCR_SELECT_MAX = ((IMPLEMENTATION_PCR+7)/8), 
    
    /** The number of PCR required by the relevant platform specification  */
    PLATFORM_PCR = 24, 
    
    PCR_SELECT_MIN = ((PLATFORM_PCR + 7) / 8), 
    
    /** The D-RTM PCR
     *  NOTE This value is not defined when the TPM does not implement D-RTM
     */
    DRTM_PCR = 17, 
    
    /** The PCR that will receive the H-CRTM value at TPM2_Startup. This value should not be changed.  */
    HCRTM_PCR = 0, 
    
    /** The number of localities supported by the TPM
     *  This is expected to be either 5 for a PC, or 1 for just about everything else.
     */
    NUM_LOCALITIES = 5, 
    
    /** The maximum number of handles in the handle area
     *  This should be produced by the Part 3 parser but is here for now.
     */
    MAX_HANDLE_NUM = 3, 
    
    /** The number of simultaneously active sessions that are supported by the TPM implementation  */
    MAX_ACTIVE_SESSIONS = 64, 
    
    /** The number of sessions that the TPM may have in memory  */
    MAX_LOADED_SESSIONS = 3, 
    
    /** This is the current maximum value  */
    MAX_SESSION_NUM = 3, 
    
    /** The number of simultaneously loaded objects that are supported by the TPM; this number
     *  does not include the objects that may be placed in NV memory by TPM2_EvictControl().
     */
    MAX_LOADED_OBJECTS = 3, 
    
    /** The minimum number of evict objects supported by the TPM  */
    MIN_EVICT_OBJECTS = 2, 
    
    /** Number of PCR groups that have individual policies  */
    NUM_POLICY_PCR_GROUP = 1, 
    
    /** Number of PCR groups that have individual authorization values  */
    NUM_AUTHVALUE_PCR_GROUP = 1, 
    
    MAX_CONTEXT_SIZE = 1264, 
    
    MAX_DIGEST_BUFFER = 1024, 
    
    /** Maximum data size allowed in an NV Index  */
    MAX_NV_INDEX_SIZE = 2048, 
    
    /** Maximum data size in one NV read or write command  */
    MAX_NV_BUFFER_SIZE = 1024, 
    
    /** Maximum size of a capability buffer  */
    MAX_CAP_BUFFER = 1024, 
    
    /** Size of NV memory in octets  */
    NV_MEMORY_SIZE = 16384, 
    
    /** The TPM will not allocate a non-counter index if it would prevent allocation of this
     *  number of indices.
     */
    MIN_COUNTER_INDICES = 8, 
    
    NUM_STATIC_PCR = 16, 
    
    /** Number of algorithms that can be in a list  */
    MAX_ALG_LIST_SIZE = 64, 
    
    /** Size of the Primary Seed in octets  */
    PRIMARY_SEED_SIZE = 32, 
    
    /** Context encryption algorithm
     *  Just use the root so that the macros in GpMacros.h will work correctly.
     */
    CONTEXT_ENCRYPT_ALGORITHM = TPM_ALG_ID::AES, 
    
    /** The update interval expressed as a power of 2 seconds
     *  A value of 12 is 4,096 seconds (~68 minutes).
     */
    NV_CLOCK_UPDATE_INTERVAL = 12, 
    
    /** Number of PCR groups that allow policy/auth  */
    NUM_POLICY_PCR = 1, 
    
    /** Maximum size of a command  */
    MAX_COMMAND_SIZE = 4096, 
    
    /** Maximum size of a response  */
    MAX_RESPONSE_SIZE = 4096, 
    
    /** Number between 1 and 32 inclusive  */
    ORDERLY_BITS = 8, 
    
    /** The maximum number of octets that may be in a sealed blob; 128 is the minimum allowed value  */
    MAX_SYM_DATA = 128, 
    
    MAX_RNG_ENTROPY_SIZE = 64, 
    
    /** Number of bytes used for the RAM index space. If this is not large enough, it might
     *  not be possible to allocate orderly indices.
     */
    RAM_INDEX_SPACE = 512, 
    
    /** 216 + 1  */
    RSA_DEFAULT_PUBLIC_EXPONENT = 0x00010001, 
    
    /** Indicates if the TPM_PT_PCR_NO_INCREMENT group is implemented  */
    ENABLE_PCR_NO_INCREMENT = Logic::YES, 
    
    CRT_FORMAT_RSA = Logic::YES, 
    
    VENDOR_COMMAND_COUNT = 0, 
    
    /** Maximum size of the vendor-specific buffer  */
    MAX_VENDOR_BUFFER_SIZE = 1024, 
    
    /** L value for a derivation. This is the
     *  maximum number of bits allowed from an instantiation of a KDF-DRBG. This is size is OK
     *  because RSA keys are never derived keys
     */
    MAX_DERIVATION_BITS = 8192, 
    
    RSA_MAX_PRIME = (ImplementationConstants::MAX_RSA_KEY_BYTES/2), 
    
    RSA_PRIVATE_SIZE = (RSA_MAX_PRIME * 5), 
    
    SIZE_OF_X509_SERIAL_NUMBER = 20, 
    
    /** This is a vendor-specific value so it is in this vendor-speific table. When this is
     *  used, RSA_PRIVATE_SIZE will have been defined
     */
    PRIVATE_VENDOR_SPECIFIC_BYTES = RSA_PRIVATE_SIZE
    TPM_ENUM_EPILOGUE(Implementation)
};

/** The definitions in Table 29 are used to define many of the interface data types.  */
struct TPM_HC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_HC)
    
    /** To mask off the HR  */
    HR_HANDLE_MASK = 0x00FFFFFF, 
    
    /** To mask off the variable part  */
    HR_RANGE_MASK = 0xFF000000, 
    
    HR_SHIFT = 24, 
    
    HR_PCR = (TPM_HT::PCR << HR_SHIFT), 
    
    HR_HMAC_SESSION = (TPM_HT::HMAC_SESSION << HR_SHIFT), 
    
    HR_POLICY_SESSION = (TPM_HT::POLICY_SESSION << HR_SHIFT), 
    
    HR_TRANSIENT = (TPM_HT::TRANSIENT << HR_SHIFT), 
    
    HR_PERSISTENT = (TPM_HT::PERSISTENT << HR_SHIFT), 
    
    HR_NV_INDEX = (TPM_HT::NV_INDEX << HR_SHIFT), 
    
    HR_PERMANENT = (TPM_HT::PERMANENT << HR_SHIFT), 
    
    /** First PCR  */
    PCR_FIRST = (HR_PCR + 0), 
    
    /** Last PCR  */
    PCR_LAST = (PCR_FIRST + Implementation::IMPLEMENTATION_PCR-1), 
    
    /** First HMAC session  */
    HMAC_SESSION_FIRST = (HR_HMAC_SESSION + 0), 
    
    /** Last HMAC session  */
    HMAC_SESSION_LAST = (HMAC_SESSION_FIRST+Implementation::MAX_ACTIVE_SESSIONS-1), 
    
    /** Used in GetCapability  */
    LOADED_SESSION_FIRST = HMAC_SESSION_FIRST, 
    
    /** Used in GetCapability  */
    LOADED_SESSION_LAST = HMAC_SESSION_LAST, 
    
    /** First policy session  */
    POLICY_SESSION_FIRST = (HR_POLICY_SESSION + 0), 
    
    /** Last policy session  */
    POLICY_SESSION_LAST = (POLICY_SESSION_FIRST + Implementation::MAX_ACTIVE_SESSIONS-1), 
    
    /** First transient object  */
    TRANSIENT_FIRST = (HR_TRANSIENT + 0), 
    
    /** Used in GetCapability  */
    ACTIVE_SESSION_FIRST = POLICY_SESSION_FIRST, 
    
    /** Used in GetCapability  */
    ACTIVE_SESSION_LAST = POLICY_SESSION_LAST, 
    
    /** Last transient object  */
    TRANSIENT_LAST = (TRANSIENT_FIRST+Implementation::MAX_LOADED_OBJECTS-1), 
    
    /** First persistent object  */
    PERSISTENT_FIRST = (HR_PERSISTENT + 0), 
    
    /** Last persistent object  */
    PERSISTENT_LAST = (PERSISTENT_FIRST + 0x00FFFFFF), 
    
    /** First platform persistent object  */
    PLATFORM_PERSISTENT = (PERSISTENT_FIRST + 0x00800000), 
    
    /** First allowed NV Index  */
    NV_INDEX_FIRST = (HR_NV_INDEX + 0), 
    
    /** Last allowed NV Index  */
    NV_INDEX_LAST = (NV_INDEX_FIRST + 0x00FFFFFF), 
    
    PERMANENT_FIRST = TPM_RH::FIRST, 
    
    PERMANENT_LAST = TPM_RH::LAST, 
    
    /** AC aliased NV Index  */
    HR_NV_AC = ((TPM_HT::NV_INDEX << HR_SHIFT) + 0xD00000), 
    
    /** First NV Index aliased to Attached Component  */
    NV_AC_FIRST = (HR_NV_AC + 0), 
    
    /** Last NV Index aliased to Attached Component  */
    NV_AC_LAST = (HR_NV_AC + 0x0000FFFF), 
    
    /** AC Handle  */
    HR_AC = (TPM_HT::AC << HR_SHIFT), 
    
    /** First Attached Component  */
    AC_FIRST = (HR_AC + 0), 
    
    /** Last Attached Component  */
    AC_LAST = (HR_AC + 0x0000FFFF)
    TPM_ENUM_EPILOGUE(TPM_HC)
};

/** This structure defines the attributes of an algorithm.  */
struct TPMA_ALGORITHM : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_ALGORITHM)
    
    /** SET (1): an asymmetric algorithm with public and private portions
     *  CLEAR (0): not an asymmetric algorithm
     */
    asymmetric = 0x1, 
    
    /** SET (1): a symmetric block cipher
     *  CLEAR (0): not a symmetric block cipher
     */
    symmetric = 0x2, 
    
    /** SET (1): a hash algorithm
     *  CLEAR (0): not a hash algorithm
     */
    hash = 0x4, 
    
    /** SET (1): an algorithm that may be used as an object type
     *  CLEAR (0): an algorithm that is not used as an object type
     */
    object = 0x8, 
    
    /** SET (1): a signing algorithm. The setting of asymmetric, symmetric, and hash will
     *  indicate the type of signing algorithm.
     *  CLEAR (0): not a signing algorithm
     */
    signing = 0x100, 
    
    /** SET (1): an encryption/decryption algorithm. The setting of asymmetric, symmetric, and
     *  hash will indicate the type of encryption/decryption algorithm.
     *  CLEAR (0): not an encryption/decryption algorithm
     */
    encrypting = 0x200, 
    
    /** SET (1): a method such as a key derivative function (KDF)
     *  CLEAR (0): not a method
     */
    method = 0x400
    TPM_ENUM_EPILOGUE(TPMA_ALGORITHM)
};

/** This attribute structure indicates an objects use, its authorization types, and its
 *  relationship to other objects.
 */
struct TPMA_OBJECT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_OBJECT)
    
    /** SET (1): The hierarchy of the object, as indicated by its Qualified Name, may not change.
     *  CLEAR (0): The hierarchy of the object may change as a result of this object or an
     *  ancestor key being duplicated for use in another hierarchy.
     *  NOTE fixedTPM does not indicate that key material resides on a single TPM (see
     *  sensitiveDataOrigin).
     */
    fixedTPM = 0x2, 
    
    /** SET (1): Previously saved contexts of this object may not be loaded after Startup(CLEAR).
     *  CLEAR (0): Saved contexts of this object may be used after a Shutdown(STATE) and
     *  subsequent Startup().
     */
    stClear = 0x4, 
    
    /** SET (1): The parent of the object may not change.
     *  CLEAR (0): The parent of the object may change as the result of a TPM2_Duplicate() of
     *  the object.
     */
    fixedParent = 0x10, 
    
    /** SET (1): Indicates that, when the object was created with TPM2_Create() or
     *  TPM2_CreatePrimary(), the TPM generated all of the sensitive data other than the authValue.
     *  CLEAR (0): A portion of the sensitive data, other than the authValue, was provided by
     *  the caller.
     */
    sensitiveDataOrigin = 0x20, 
    
    /** SET (1): Approval of USER role actions with this object may be with an HMAC session or
     *  with a password using the authValue of the object or a policy session.
     *  CLEAR (0): Approval of USER role actions with this object may only be done with a
     *  policy session.
     */
    userWithAuth = 0x40, 
    
    /** SET (1): Approval of ADMIN role actions with this object may only be done with a
     *  policy session.
     *  CLEAR (0): Approval of ADMIN role actions with this object may be with an HMAC session
     *  or with a password using the authValue of the object or a policy session.
     */
    adminWithPolicy = 0x80, 
    
    /** SET (1): The object is not subject to dictionary attack protections.
     *  CLEAR (0): The object is subject to dictionary attack protections.
     */
    noDA = 0x400, 
    
    /** SET (1): If the object is duplicated, then symmetricAlg shall not be TPM_ALG_NULL and
     *  newParentHandle shall not be TPM_RH_NULL.
     *  CLEAR (0): The object may be duplicated without an inner wrapper on the private
     *  portion of the object and the new parent may be TPM_RH_NULL.
     */
    encryptedDuplication = 0x800, 
    
    /** SET (1): Key usage is restricted to manipulate structures of known format; the parent
     *  of this key shall have restricted SET.
     *  CLEAR (0): Key usage is not restricted to use on special formats.
     */
    restricted = 0x10000, 
    
    /** SET (1): The private portion of the key may be used to decrypt.
     *  CLEAR (0): The private portion of the key may not be used to decrypt.
     */
    decrypt = 0x20000, 
    
    /** SET (1): For a symmetric cipher object, the private portion of the key may be used to
     *  encrypt. For other objects, the private portion of the key may be used to sign.
     *  CLEAR (0): The private portion of the key may not be used to sign or encrypt.
     */
    sign = 0x40000, 
    
    /** Alias to the sign value.  */
    encrypt = 0x40000, 
    
    /** SET (1): An asymmetric key that may not be used to sign with TPM2_Sign()
     *  CLEAR (0): A key that may be used with TPM2_Sign() if sign is SET
     *  NOTE: This attribute only has significance if sign is SET.
     */
    x509sign = 0x80000
    TPM_ENUM_EPILOGUE(TPMA_OBJECT)
};

/** This octet in each session is used to identify the session type, indicate its
 *  relationship to any handles in the command, and indicate its use in parameter encryption.
 */
struct TPMA_SESSION : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPMA_SESSION)
    
    /** SET (1): In a command, this setting indicates that the session is to remain active
     *  after successful completion of the command. In a response, it indicates that the
     *  session is still active. If SET in the command, this attribute shall be SET in the response.
     *  CLEAR (0): In a command, this setting indicates that the TPM should close the session
     *  and flush any related context when the command completes successfully. In a response,
     *  it indicates that the session is closed and the context is no longer active.
     *  This attribute has no meaning for a password authorization and the TPM will allow any
     *  setting of the attribute in the command and SET the attribute in the response.
     *  This attribute will only be CLEAR in one response for a logical session. If the
     *  attribute is CLEAR, the context associated with the session is no longer in use and
     *  the space is available. A session created after another session is ended may have the
     *  same handle but logically is not the same session.
     *  This attribute has no effect if the command does not complete successfully.
     */
    continueSession = 0x1, 
    
    /** SET (1): In a command, this setting indicates that the command should only be executed
     *  if the session is exclusive at the start of the command. In a response, it indicates
     *  that the session is exclusive. This setting is only allowed if the audit attribute is
     *  SET (TPM_RC_ATTRIBUTES).
     *  CLEAR (0): In a command, indicates that the session need not be exclusive at the start
     *  of the command. In a response, indicates that the session is not exclusive.
     */
    auditExclusive = 0x2, 
    
    /** SET (1): In a command, this setting indicates that the audit digest of the session
     *  should be initialized and the exclusive status of the session SET. This setting is
     *  only allowed if the audit attribute is SET (TPM_RC_ATTRIBUTES).
     *  CLEAR (0): In a command, indicates that the audit digest should not be initialized.
     *  This bit is always CLEAR in a response.
     */
    auditReset = 0x4, 
    
    /** SET (1): In a command, this setting indicates that the first parameter in the command
     *  is symmetrically encrypted using the parameter encryption scheme described in TPM 2.0
     *  Part 1. The TPM will decrypt the parameter after performing any HMAC computations and
     *  before unmarshaling the parameter. In a response, the attribute is copied from the
     *  request but has no effect on the response.
     *  CLEAR (0): Session not used for encryption.
     *  For a password authorization, this attribute will be CLEAR in both the command and response.
     *  This attribute may be SET in a session that is not associated with a command handle.
     *  Such a session is provided for purposes of encrypting a parameter and not for authorization.
     *  This attribute may be SET in combination with any other session attributes.
     */
    decrypt = 0x20, 
    
    /** SET (1): In a command, this setting indicates that the TPM should use this session to
     *  encrypt the first parameter in the response. In a response, it indicates that the
     *  attribute was set in the command and that the TPM used the session to encrypt the
     *  first parameter in the response using the parameter encryption scheme described in TPM
     *  2.0 Part 1.
     *  CLEAR (0): Session not used for encryption.
     *  For a password authorization, this attribute will be CLEAR in both the command and response.
     *  This attribute may be SET in a session that is not associated with a command handle.
     *  Such a session is provided for purposes of encrypting a parameter and not for authorization.
     */
    encrypt = 0x40, 
    
    /** SET (1): In a command or response, this setting indicates that the session is for
     *  audit and that auditExclusive and auditReset have meaning. This session may also be
     *  used for authorization, encryption, or decryption. The encrypted and encrypt fields
     *  may be SET or CLEAR.
     *  CLEAR (0): Session is not used for audit.
     *  If SET in the command, then this attribute will be SET in the response.
     */
    audit = 0x80
    TPM_ENUM_EPILOGUE(TPMA_SESSION)
};

/** In a TPMS_CREATION_DATA structure, this structure is used to indicate the locality of
 *  the command that created the object. No more than one of the locality attributes shall
 *  be set in the creation data.
 */
struct TPMA_LOCALITY : public TpmEnum<UINT8>
{
    TPM_ENUM_PROLOGUE(TPMA_LOCALITY)
    
    LOC_ZERO = 0x1, 
    
    LOC_ONE = 0x2, 
    
    LOC_TWO = 0x4, 
    
    LOC_THREE = 0x8, 
    
    LOC_FOUR = 0x10, 
    
    /** If any of these bits is set, an extended locality is indicated  */
    Extended_BIT_MASK = 0x000000E0,
    Extended_BIT_OFFSET = 5,
    Extended_BIT_LENGTH = 3,
    TPM_ENUM_EPILOGUE(TPMA_LOCALITY)
};

/** The attributes in this structure are persistent and are not changed as a result of
 *  _TPM_Init or any TPM2_Startup(). Some of the attributes in this structure may change
 *  as the result of specific Protected Capabilities. This structure may be read using
 *  TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_PERMANENT).
 */
struct TPMA_PERMANENT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_PERMANENT)
    
    /** SET (1): TPM2_HierarchyChangeAuth() with ownerAuth has been executed since the last TPM2_Clear().
     *  CLEAR (0): ownerAuth has not been changed since TPM2_Clear().
     */
    ownerAuthSet = 0x1, 
    
    /** SET (1): TPM2_HierarchyChangeAuth() with endorsementAuth has been executed since the
     *  last TPM2_Clear().
     *  CLEAR (0): endorsementAuth has not been changed since TPM2_Clear().
     */
    endorsementAuthSet = 0x2, 
    
    /** SET (1): TPM2_HierarchyChangeAuth() with lockoutAuth has been executed since the last
     *  TPM2_Clear().
     *  CLEAR (0): lockoutAuth has not been changed since TPM2_Clear().
     */
    lockoutAuthSet = 0x4, 
    
    /** SET (1): TPM2_Clear() is disabled.
     *  CLEAR (0): TPM2_Clear() is enabled.
     *  NOTE See TPM2_ClearControl in TPM 2.0 Part 3 for details on changing this attribute.
     */
    disableClear = 0x100, 
    
    /** SET (1): The TPM is in lockout, when failedTries is equal to maxTries.  */
    inLockout = 0x200, 
    
    /** SET (1): The EPS was created by the TPM.
     *  CLEAR (0): The EPS was created outside of the TPM using a manufacturer-specific process.
     */
    tpmGeneratedEPS = 0x400
    TPM_ENUM_EPILOGUE(TPMA_PERMANENT)
};

/** This structure may be read using TPM2_GetCapability(capability =
 *  TPM_CAP_TPM_PROPERTIES, property = TPM_PT_STARTUP_CLEAR).
 */
struct TPMA_STARTUP_CLEAR : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_STARTUP_CLEAR)
    
    /** SET (1): The platform hierarchy is enabled and platformAuth or platformPolicy may be
     *  used for authorization.
     *  CLEAR (0): platformAuth and platformPolicy may not be used for authorizations, and
     *  objects in the platform hierarchy, including persistent objects, cannot be used.
     *  NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
     */
    phEnable = 0x1, 
    
    /** SET (1): The Storage hierarchy is enabled and ownerAuth or ownerPolicy may be used for
     *  authorization. NV indices defined using owner authorization are accessible.
     *  CLEAR (0): ownerAuth and ownerPolicy may not be used for authorizations, and objects
     *  in the Storage hierarchy, persistent objects, and NV indices defined using owner
     *  authorization cannot be used.
     *  NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
     */
    shEnable = 0x2, 
    
    /** SET (1): The EPS hierarchy is enabled and Endorsement Authorization may be used to
     *  authorize commands.
     *  CLEAR (0): Endorsement Authorization may not be used for authorizations, and objects
     *  in the endorsement hierarchy, including persistent objects, cannot be used.
     *  NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
     */
    ehEnable = 0x4, 
    
    /** SET (1): NV indices that have TPMA_NV_PLATFORMCREATE SET may be read or written. The
     *  platform can create define and undefine indices.
     *  CLEAR (0): NV indices that have TPMA_NV_PLATFORMCREATE SET may not be read or written
     *  (TPM_RC_HANDLE). The platform cannot define (TPM_RC_HIERARCHY) or undefined
     *  (TPM_RC_HANDLE) indices.
     *  NOTE See TPM2_HierarchyControl in TPM 2.0 Part 3 for details on changing this attribute.
     *  NOTE
     *  read refers to these commands: TPM2_NV_Read, TPM2_NV_ReadPublic, TPM_NV_Certify, TPM2_PolicyNV
     *  write refers to these commands: TPM2_NV_Write, TPM2_NV_Increment, TPM2_NV_Extend, TPM2_NV_SetBits
     *  NOTE The TPM must query the index TPMA_NV_PLATFORMCREATE attribute to determine
     *  whether phEnableNV is applicable. Since the TPM will return TPM_RC_HANDLE if the index
     *  does not exist, it also returns this error code if the index is disabled. Otherwise,
     *  the TPM would leak the existence of an index even when disabled.
     */
    phEnableNV = 0x8, 
    
    /** SET (1): The TPM received a TPM2_Shutdown() and a matching TPM2_Startup().
     *  CLEAR (0): TPM2_Startup(TPM_SU_CLEAR) was not preceded by a TPM2_Shutdown() of any type.
     *  NOTE A shutdown is orderly if the TPM receives a TPM2_Shutdown() of any type followed
     *  by a TPM2_Startup() of any type. However, the TPM will return an error if
     *  TPM2_Startup(TPM_SU_STATE) was not preceded by TPM2_Shutdown(TPM_SU_STATE).
     */
    orderly = 0x80000000
    TPM_ENUM_EPILOGUE(TPMA_STARTUP_CLEAR)
};

/** This structure of this attribute is used to report the memory management method used
 *  by the TPM for transient objects and authorization sessions. This structure may be
 *  read using TPM2_GetCapability(capability = TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MEMORY).
 */
struct TPMA_MEMORY : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_MEMORY)
    
    /** SET (1): indicates that the RAM memory used for authorization session contexts is
     *  shared with the memory used for transient objects
     *  CLEAR (0): indicates that the memory used for authorization sessions is not shared
     *  with memory used for transient objects
     */
    sharedRAM = 0x1, 
    
    /** SET (1): indicates that the NV memory used for persistent objects is shared with the
     *  NV memory used for NV Index values
     *  CLEAR (0): indicates that the persistent objects and NV Index values are allocated
     *  from separate sections of NV
     */
    sharedNV = 0x2, 
    
    /** SET (1): indicates that the TPM copies persistent objects to a transient-object slot
     *  in RAM when the persistent object is referenced in a command. The TRM is required to
     *  make sure that an object slot is available.
     *  CLEAR (0): indicates that the TPM does not use transient-object slots when persistent
     *  objects are referenced
     */
    objectCopiedToRam = 0x4
    TPM_ENUM_EPILOGUE(TPMA_MEMORY)
};

/** This structure defines the attributes of a command from a context management
 *  perspective. The fields of the structure indicate to the TPM Resource Manager (TRM)
 *  the number of resources required by a command and how the command affects the TPMs resources.
 */
struct TPMA_CC : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_CC)
    
    /** Indicates the command being selected  */
    commandIndex_BIT_MASK = 0x0000FFFF,
    commandIndex_BIT_OFFSET = 0,
    commandIndex_BIT_LENGTH = 16,
    
    /** SET (1): indicates that the command may write to NV
     *  CLEAR (0): indicates that the command does not write to NV
     */
    nv = 0x400000, 
    
    /** SET (1): This command could flush any number of loaded contexts.
     *  CLEAR (0): no additional changes other than indicated by the flushed attribute
     */
    extensive = 0x800000, 
    
    /** SET (1): The context associated with any transient handle in the command will be
     *  flushed when this command completes.
     *  CLEAR (0): No context is flushed as a side effect of this command.
     */
    flushed = 0x1000000, 
    
    /** Indicates the number of the handles in the handle area for this command  */
    cHandles_BIT_MASK = 0x0E000000,
    cHandles_BIT_OFFSET = 25,
    cHandles_BIT_LENGTH = 3,
    
    /** SET (1): indicates the presence of the handle area in the response  */
    rHandle = 0x10000000, 
    
    /** SET (1): indicates that the command is vendor-specific
     *  CLEAR (0): indicates that the command is defined in a version of this specification
     */
    V = 0x20000000, 
    
    /** Allocated for software; shall be zero  */
    Res_BIT_MASK = 0xC0000000,
    Res_BIT_OFFSET = 30,
    Res_BIT_LENGTH = 2,
    TPM_ENUM_EPILOGUE(TPMA_CC)
};

/** This structure of this attribute is used to report that the TPM is designed for these
 *  modes. This structure may be read using TPM2_GetCapability(capability =
 *  TPM_CAP_TPM_PROPERTIES, property = TPM_PT_MODES).
 */
struct TPMA_MODES : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_MODES)
    
    /** SET (1): indicates that the TPM is designed to comply with all of the FIPS 140-2
     *  requirements at Level 1 or higher.
     */
    FIPS_140_2 = 0x1
    TPM_ENUM_EPILOGUE(TPMA_MODES)
};

/** These attributes are as specified in clause 4.2.1.3. of RFC 5280 Internet X.509 Public
 *  Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. For
 *  TPM2_CertifyX509, when a caller provides a DER encoded Key Usage in
 *  partialCertificate, the TPM will validate that the key to be certified meets the
 *  requirements of Key Usage.
 */
struct TPMA_X509_KEY_USAGE : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_X509_KEY_USAGE)
    
    /** Attributes.Decrypt SET  */
    decipherOnly = 0x800000, 
    
    /** Attributes.Decrypt SET  */
    encipherOnly = 0x1000000, 
    
    /** Attributes.sign SET  */
    cRLSign = 0x2000000, 
    
    /** Attributes.sign SET  */
    keyCertSign = 0x4000000, 
    
    /** Attributes.Decrypt SET  */
    keyAgreement = 0x8000000, 
    
    /** Attributes.Decrypt SET  */
    dataEncipherment = 0x10000000, 
    
    /** Asymmetric key with decrypt and restricted SET key has the attributes of a parent key  */
    keyEncipherment = 0x20000000, 
    
    /** FixedTPM SET in Subject Key (objectHandle)  */
    nonrepudiation = 0x40000000, 
    
    /** Alias to the nonrepudiation value.  */
    contentCommitment = 0x40000000, 
    
    /** Sign SET in Subject Key (objectHandle)  */
    digitalSignature = 0x80000000
    TPM_ENUM_EPILOGUE(TPMA_X509_KEY_USAGE)
};

/** This attribute is used to report the ACT state. This attribute may be read using
 *  TPM2_GetCapability(capability = TPM_CAP_ACT, property = TPM_RH_ACT_x where x is the
 *  ACT number (0-F)). The signaled value must be preserved across TPM Resume or if the
 *  TPM has not lost power. The signaled value may be preserved over a power cycle of a TPM.
 */
struct TPMA_ACT : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_ACT)
    
    /** SET (1): The ACT has signaled
     *  CLEAR (0): The ACT has not signaled
     */
    signaled = 0x1, 
    
    /** Preserves the state of signaled, depending on the power cycle  */
    preserveSignaled = 0x2
    TPM_ENUM_EPILOGUE(TPMA_ACT)
};

/** A TPM_NV_INDEX is used to reference a defined location in NV memory. The format of the
 *  Index is changed from TPM 1.2 in order to include the Index in the reserved handle
 *  space. Handles in this range use the digest of the public area of the Index as the
 *  Name of the entity in authorization computations
 */
struct TPM_NV_INDEX : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPM_NV_INDEX)
    
    /** The Index of the NV location  */
    index_BIT_MASK = 0x00FFFFFF,
    index_BIT_OFFSET = 0,
    index_BIT_LENGTH = 24,
    
    /** Constant value of TPM_HT_NV_INDEX indicating the NV Index range  */
    RhNv_BIT_MASK = 0xFF000000,
    RhNv_BIT_OFFSET = 24,
    RhNv_BIT_LENGTH = 8,
    TPM_ENUM_EPILOGUE(TPM_NV_INDEX)
};

/** This structure allows the TPM to keep track of the data and permissions to manipulate
 *  an NV Index.
 */
struct TPMA_NV : public TpmEnum<UINT32>
{
    TPM_ENUM_PROLOGUE(TPMA_NV)
    
    /** SET (1): The Index data can be written if Platform Authorization is provided.
     *  CLEAR (0): Writing of the Index data cannot be authorized with Platform Authorization.
     */
    PPWRITE = 0x1, 
    
    /** SET (1): The Index data can be written if Owner Authorization is provided.
     *  CLEAR (0): Writing of the Index data cannot be authorized with Owner Authorization.
     */
    OWNERWRITE = 0x2, 
    
    /** SET (1): Authorizations to change the Index contents that require USER role may be
     *  provided with an HMAC session or password.
     *  CLEAR (0): Authorizations to change the Index contents that require USER role may not
     *  be provided with an HMAC session or password.
     */
    AUTHWRITE = 0x4, 
    
    /** SET (1): Authorizations to change the Index contents that require USER role may be
     *  provided with a policy session.
     *  CLEAR (0): Authorizations to change the Index contents that require USER role may not
     *  be provided with a policy session.
     *  NOTE TPM2_NV_ChangeAuth() always requires that authorization be provided in a policy session.
     */
    POLICYWRITE = 0x8, 
    
    /** Ordinary contains data that is opaque to the TPM that can only be modified using TPM2_NV_Write().  */
    ORDINARY = 0x0,
    
    /** Counter contains an 8-octet value that is to be used as a counter and can only be
     *  modified with TPM2_NV_Increment()
     */
    COUNTER = 0x10,
    
    /** Bit Field contains an 8-octet value to be used as a bit field and can only be modified
     *  with TPM2_NV_SetBits().
     */
    BITS = 0x20,
    
    /** Extend contains a digest-sized value used like a PCR. The Index can only be modified
     *  using TPM2_NV_Extend(). The extend will use the nameAlg of the Index.
     */
    EXTEND = 0x40,
    
    /** PIN Fail - contains pinCount that increments on a PIN authorization failure and a pinLimit  */
    PIN_FAIL = 0x80,
    
    /** PIN Pass - contains pinCount that increments on a PIN authorization success and a pinLimit  */
    PIN_PASS = 0x90,
    
    /** The type of the index.
     *  NOTE A TPM is not required to support all TPM_NT values
     */
    TpmNt_BIT_MASK = 0x000000F0,
    TpmNt_BIT_OFFSET = 4,
    TpmNt_BIT_LENGTH = 4,
    
    /** SET (1): Index may not be deleted unless the authPolicy is satisfied using
     *  TPM2_NV_UndefineSpaceSpecial().
     *  CLEAR (0): Index may be deleted with proper platform or owner authorization using
     *  TPM2_NV_UndefineSpace().
     *  NOTE An Index with this attribute and a policy that cannot be satisfied (e.g., an
     *  Empty Policy) cannot be deleted.
     */
    POLICY_DELETE = 0x400, 
    
    /** SET (1): Index cannot be written.
     *  CLEAR (0): Index can be written.
     */
    WRITELOCKED = 0x800, 
    
    /** SET (1): A partial write of the Index data is not allowed. The write size shall match
     *  the defined space size.
     *  CLEAR (0): Partial writes are allowed. This setting is required if the .dataSize of
     *  the Index is larger than NV_MAX_BUFFER_SIZE for the implementation.
     */
    WRITEALL = 0x1000, 
    
    /** SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location.
     *  CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if
     *  TPMA_NV_WRITE_STCLEAR is also CLEAR.
     */
    WRITEDEFINE = 0x2000, 
    
    /** SET (1): TPM2_NV_WriteLock() may be used to prevent further writes to this location
     *  until the next TPM Reset or TPM Restart.
     *  CLEAR (0): TPM2_NV_WriteLock() does not block subsequent writes if TPMA_NV_WRITEDEFINE
     *  is also CLEAR.
     */
    WRITE_STCLEAR = 0x4000, 
    
    /** SET (1): If TPM2_NV_GlobalWriteLock() is successful, TPMA_NV_WRITELOCKED is set.
     *  CLEAR (0): TPM2_NV_GlobalWriteLock() has no effect on the writing of the data at this Index.
     */
    GLOBALLOCK = 0x8000, 
    
    /** SET (1): The Index data can be read if Platform Authorization is provided.
     *  CLEAR (0): Reading of the Index data cannot be authorized with Platform Authorization.
     */
    PPREAD = 0x10000, 
    
    /** SET (1): The Index data can be read if Owner Authorization is provided.
     *  CLEAR (0): Reading of the Index data cannot be authorized with Owner Authorization.
     */
    OWNERREAD = 0x20000, 
    
    /** SET (1): The Index data may be read if the authValue is provided.
     *  CLEAR (0): Reading of the Index data cannot be authorized with the Index authValue.
     */
    AUTHREAD = 0x40000, 
    
    /** SET (1): The Index data may be read if the authPolicy is satisfied.
     *  CLEAR (0): Reading of the Index data cannot be authorized with the Index authPolicy.
     */
    POLICYREAD = 0x80000, 
    
    /** SET (1): Authorization failures of the Index do not affect the DA logic and
     *  authorization of the Index is not blocked when the TPM is in Lockout mode.
     *  CLEAR (0): Authorization failures of the Index will increment the authorization
     *  failure counter and authorizations of this Index are not allowed when the TPM is in
     *  Lockout mode.
     */
    NO_DA = 0x2000000, 
    
    /** SET (1): NV Index state is only required to be saved when the TPM performs an orderly
     *  shutdown (TPM2_Shutdown()).
     *  CLEAR (0): NV Index state is required to be persistent after the command to update the
     *  Index completes successfully (that is, the NV update is synchronous with the update command).
     */
    ORDERLY = 0x4000000, 
    
    /** SET (1): TPMA_NV_WRITTEN for the Index is CLEAR by TPM Reset or TPM Restart.
     *  CLEAR (0): TPMA_NV_WRITTEN is not changed by TPM Restart.
     *  NOTE This attribute may only be SET if TPM_NT is not TPM_NT_COUNTER.
     */
    CLEAR_STCLEAR = 0x8000000, 
    
    /** SET (1): Reads of the Index are blocked until the next TPM Reset or TPM Restart.
     *  CLEAR (0): Reads of the Index are allowed if proper authorization is provided.
     */
    READLOCKED = 0x10000000, 
    
    /** SET (1): Index has been written.
     *  CLEAR (0): Index has not been written.
     */
    WRITTEN = 0x20000000, 
    
    /** SET (1): This Index may be undefined with Platform Authorization but not with Owner
     *  Authorization.
     *  CLEAR (0): This Index may be undefined using Owner Authorization but not with Platform
     *  Authorization.
     *  The TPM will validate that this attribute is SET when the Index is defined using
     *  Platform Authorization and will validate that this attribute is CLEAR when the Index
     *  is defined using Owner Authorization.
     */
    PLATFORMCREATE = 0x40000000, 
    
    /** SET (1): TPM2_NV_ReadLock() may be used to SET TPMA_NV_READLOCKED for this Index.
     *  CLEAR (0): TPM2_NV_ReadLock() has no effect on this Index.
     */
    READ_STCLEAR = 0x80000000
    TPM_ENUM_EPILOGUE(TPMA_NV)
};

/** Base class for TPM union interfaces  */
class _DLLEXP_ TpmUnion: public virtual TpmStructure {};

/** Table 119 Definition of TPMU_CAPABILITIES Union [OUT]
 *  (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
 *  TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
 *  TPML_TAGGED_POLICY, TPML_ACT_DATA])
 */
class _DLLEXP_ TPMU_CAPABILITIES: public virtual TpmUnion
{
    public: virtual TPM_CAP GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** Table 132 Definition of TPMU_ATTEST Union [OUT]
 *  (One of [TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
 *  TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
 *  TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO])
 */
class _DLLEXP_ TPMU_ATTEST: public virtual TpmUnion
{
    public: virtual TPM_ST GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** This union allows additional parameters to be added for a symmetric cipher. Currently,
 *  no additional parameters are required for any of the symmetric algorithms.
 *  (One of [TPMS_TDES_SYM_DETAILS, TPMS_AES_SYM_DETAILS, TPMS_SM4_SYM_DETAILS,
 *  TPMS_CAMELLIA_SYM_DETAILS, TPMS_ANY_SYM_DETAILS, TPMS_XOR_SYM_DETAILS, TPMS_NULL_SYM_DETAILS])
 */
class _DLLEXP_ TPMU_SYM_DETAILS: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** This structure allows a TPM2B_SENSITIVE_CREATE structure to carry either a
 *  TPM2B_SENSITVE_DATA or a TPM2B_DERIVE structure. The contents of the union are
 *  determined by context. When an object is being derived, the derivation values are present.
 *  (One of [BYTE, TPMS_DERIVE])
 */
class _DLLEXP_ TPMU_SENSITIVE_CREATE: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** Table 157 Definition of TPMU_SCHEME_KEYEDHASH Union [IN/OUT]
 *  (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
 */
class _DLLEXP_ TPMU_SCHEME_KEYEDHASH: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** This is the union of all of the signature schemes.
 *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
 *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
 *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
 */
class _DLLEXP_ TPMU_SIG_SCHEME: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** Table 166 Definition of TPMU_KDF_SCHEME Union [IN/OUT]
 *  (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
 *  TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
 */
class _DLLEXP_ TPMU_KDF_SCHEME: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** This union of all asymmetric schemes is used in each of the asymmetric scheme
 *  structures. The actual scheme structure is defined by the interface type used for the
 *  selector (TPMI_ALG_ASYM_SCHEME).
 *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
 *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
 *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
 *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
 */
class _DLLEXP_ TPMU_ASYM_SCHEME: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** A TPMU_SIGNATURE_COMPOSITE is a union of the various signatures that are supported by
 *  a particular TPM implementation. The union allows substitution of any signature
 *  algorithm wherever a signature is required in a structure.
 *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
 *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
 *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
 */
class _DLLEXP_ TPMU_SIGNATURE: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** This is the union of all values allowed in in the unique field of a TPMT_PUBLIC.
 *  (One of [TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
 *  TPMS_ECC_POINT, TPMS_DERIVE])
 */
class _DLLEXP_ TPMU_PUBLIC_ID: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** Table 199 defines the possible parameter definition structures that may be contained
 *  in the public portion of a key. If the Object can be a parent, the first field must be
 *  a TPMT_SYM_DEF_OBJECT. See 11.1.7.
 *  (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
 *  TPMS_ASYM_PARMS])
 */
class _DLLEXP_ TPMU_PUBLIC_PARMS: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** Table 205 Definition of TPMU_SENSITIVE_COMPOSITE Union [IN/OUT]
 *  (One of [TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
 *  TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC])
 */
class _DLLEXP_ TPMU_SENSITIVE_COMPOSITE: public virtual TpmUnion
{
    public: virtual TPM_ALG_ID GetUnionSelector() const = 0;
    public: virtual TpmStructure*  Clone() const { _ASSERT(FALSE); return NULL; };
};

/** Handle of a loaded TPM key or other object [TSS]  */
class _DLLEXP_ TPM_HANDLE : public TpmStructure
{
public:
    /** Handle value  */
    UINT32 handle;

public:
    TPM_HANDLE() { handle = TPM_RH::_NULL; }
    TPM_HANDLE(UINT32 _handle)
      : handle(_handle)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM_HANDLE fromTpm(TpmBuffer& buf) { return buf.createObj<TPM_HANDLE>(); }
    
    /** Static marshaling helper  */
    static TPM_HANDLE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM_HANDLE>(buf); }
    
    virtual const char* TypeName () const { return "TPM_HANDLE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM_HANDLE(*this); }
    
    operator UINT32() const { return handle; }
    
    /// <summary> Create a NULL TPM_HANDLE. </summary>
    static TPM_HANDLE Null() { return TPM_RH::_NULL; }
    
    /// <summary> Create a handle for a persistent object </summary>
    /// <param name="handleOffset"> Offset in the integer range reserved for persistent handles </param>
    static TPM_HANDLE Persistent(UINT32 handleOffset)
    {
        return (TPM_HT::PERSISTENT << 24) + handleOffset;
    }
    
    /// <summary> Create a TPM_HANDLE for a PCR with given-index. </summary>
    static TPM_HANDLE Pcr(UINT32 PcrIndex) { return PcrIndex; }
    
    /// <summary> Create a TPM_HANDLE for an NV-slot. </summary>
    static TPM_HANDLE NV(UINT32 NvSlot)
    {
        return (TPM_HT::NV_INDEX << 24) + NvSlot;
    }
    
    [[deprecated("Use default ctor, or TPM_RH_NULL, or TPM_HANDLE::Null() instead")]]
    static TPM_HANDLE NullHandle() { return Null(); }
    
    [[deprecated("Use ctor from UINT32 instead")]]
    static TPM_HANDLE FromReservedHandle(TPM_RH reservedHandle)
    {
        return TPM_HANDLE(reservedHandle);
    }
    
    [[deprecated("Use TPM_HANDLE::Persistent(UINT32) instead")]]
    static TPM_HANDLE PersistentHandle(UINT32 handleOffset)
    {
        return (TPM_HT::PERSISTENT << 24) + handleOffset;
    }
    
    [[deprecated("Use TPM_HANDLE::Pcr(UINT32) instead")]]
    static TPM_HANDLE PcrHandle(int PcrIndex) { return PcrIndex; }
    
    [[deprecated("Use TPM_HANDLE::NV(UINT32) instead")]]
    static TPM_HANDLE NVHandle(int NvSlot)
    {
        return (TPM_HT::NV_INDEX << 24) + NvSlot;
    }
    
    /// <summary> Set the authorization value for this TPM_HANDLE.  The default auth-value is NULL. </summary>
    TPM_HANDLE& SetAuth(const ByteVec& authVal)
    {
        AuthValue = authVal;
        return *this;
    };
    
    /// <summary> Get the auth-value </summary>
    const ByteVec& GetAuth() const { return AuthValue; };
    
    /// <summary> Set the name of the associated object (not for handles with architectural names. </summary>
    void SetName(const ByteVec& name);
    
    /// <summary> Get the current name (calculated or assigned) for this TPM_HANDLE. </summary>
    ByteVec GetName() const;
    
    /// <summary> Get the top-byte of the TPM_HANDLE. </summary>
    TPM_HT GetHandleType() const
    {
        return TPM_HT(handle >> 24);
    };
    
    protected:
    ByteVec AuthValue;
    mutable ByteVec Name;
    
}; // class TPM_HANDLE

/** Base class for empty union elements.
 *  An empty union element does not contain any data to marshal.
 *  This data structure can be used in place of any other union
 *  initialized with its own empty element.
 */
class _DLLEXP_ TPMS_NULL_UNION : public virtual TpmStructure, public TPMU_SYM_DETAILS, public TPMU_SCHEME_KEYEDHASH, public TPMU_SIG_SCHEME, public TPMU_KDF_SCHEME, public TPMU_ASYM_SCHEME, public TPMU_SIGNATURE
{
public:
public:
    TPMS_NULL_UNION() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    /** Static marshaling helper  */
    static TPMS_NULL_UNION fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NULL_UNION>(); }
    
    /** Static marshaling helper  */
    static TPMS_NULL_UNION fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NULL_UNION>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NULL_UNION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_NULL_UNION(*this); }
}; // class TPMS_NULL_UNION

/** This structure is used as a placeholder. In some cases, a union will have a selector
 *  value with no data to unmarshal when that type is selected. Rather than leave the
 *  entry empty, TPMS_EMPTY may be selected.
 */
class _DLLEXP_ TPMS_EMPTY : public virtual TpmStructure, public TPMU_ASYM_SCHEME
{
public:
public:
    TPMS_EMPTY() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAES; }
    
    /** Static marshaling helper  */
    static TPMS_EMPTY fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_EMPTY>(); }
    
    /** Static marshaling helper  */
    static TPMS_EMPTY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_EMPTY>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_EMPTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_EMPTY(*this); }
}; // class TPMS_EMPTY

/** This structure is a return value for a TPM2_GetCapability() that reads the installed algorithms.  */
class _DLLEXP_ TPMS_ALGORITHM_DESCRIPTION : public TpmStructure
{
public:
    /** An algorithm  */
    TPM_ALG_ID alg;
    
    /** The attributes of the algorithm  */
    TPMA_ALGORITHM attributes;

public:
    TPMS_ALGORITHM_DESCRIPTION() { alg = TPM_ALG_ID::_NULL; }
    TPMS_ALGORITHM_DESCRIPTION(TPM_ALG_ID _alg, TPMA_ALGORITHM _attributes)
      : alg(_alg), attributes(_attributes)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ALGORITHM_DESCRIPTION fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ALGORITHM_DESCRIPTION>(); }
    
    /** Static marshaling helper  */
    static TPMS_ALGORITHM_DESCRIPTION fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ALGORITHM_DESCRIPTION>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ALGORITHM_DESCRIPTION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ALGORITHM_DESCRIPTION(*this); }
}; // class TPMS_ALGORITHM_DESCRIPTION

/** Table 80 shows the basic hash-agile structure used in this specification. To handle
 *  hash agility, this structure uses the hashAlg parameter to indicate the algorithm used
 *  to compute the digest and, by implication, the size of the digest.
 */
class _DLLEXP_ TPMT_HA : public virtual TpmStructure, public TPMU_SIGNATURE
{
public:
    /** Selector of the hash contained in the digest that implies the size of the digest
     *  NOTE The leading + on the type indicates that this structure should pass an indication
     *  to the unmarshaling function for TPMI_ALG_HASH so that TPM_ALG_NULL will be allowed if
     *  a use of a TPMT_HA allows TPM_ALG_NULL.
     */
    TPM_ALG_ID hashAlg;
    
    /** Hash value  */
    ByteVec digest;

public:
    TPMT_HA() { hashAlg = TPM_ALG_ID::_NULL; }
    TPMT_HA(TPM_ALG_ID _hashAlg, const ByteVec& _digest)
      : hashAlg(_hashAlg), digest(_digest)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::HMAC; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_HA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_HA>(); }
    
    /** Static marshaling helper  */
    static TPMT_HA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_HA>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_HA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_HA(*this); }
    
    operator const ByteVec&() const { return digest; }
    operator const TPM_ALG_ID() const { return hashAlg; }
    
    bool operator==(const TPMT_HA& rhs) const
    {
        return this == &rhs
            || (hashAlg == rhs.hashAlg && digest == rhs.digest);
    }
    bool operator!=(const TPMT_HA& rhs) const { return !(*this == rhs); }
    
    bool operator==(const ByteVec& rhs) const { return digest == rhs; }
    bool operator!=(const ByteVec& rhs) const { return digest != rhs; }
    
    /// <summary> Create a zero-bytes TPMT_HASH with the indicated hash-algorithm. </summary>
    TPMT_HA(TPM_ALG_ID alg);
    
    /// <summary> Create a TPMT_HA from the named-hash of the _data parameter. </summary>
    static TPMT_HA FromHashOfData(TPM_ALG_ID hashAlg, const ByteVec& data);
    
    // TODO: Unicode, etc.
    /// <summary> Create a TPMT_HA from the hash of the supplied-string. </summary>
    static TPMT_HA FromHashOfString(TPM_ALG_ID hashAlg, const string& str);
    
    /// <summary> Returns the digest size in bytes for the current hash algorithm. </summary>
    UINT16 DigestSize();
    
    /// <summary> Returns the digest size in bytes for the given hash algoruthm. </summary>
    static UINT16 DigestSize(TPM_ALG_ID hashAlg);
    
    /// <summary> Perform a TPM-extend operation on the current hash-value.  Note
    /// the TPM only accepts hash-sized vector inputs: this function has no such limitations. </summary>
    TPMT_HA& Extend(const ByteVec& x);
    
    /// <summary> Perform a TPM-event operation on this PCR-value (an event "extends" the hash of _x). </summary>
    TPMT_HA Event(const ByteVec& _x);
    
    void Reset();
    
    /// <summary> Global equality operator overload for TPMT_HA </summary>
    friend bool operator==(const ByteVec& digest, const TPMT_HA& hash) { return digest == hash.digest; }
    
    /// <summary> Global equality operator overload for TPMT_HA </summary>
    friend bool operator!=(const ByteVec& digest, const TPMT_HA& hash) { return digest != hash.digest; }
    
}; // class TPMT_HA

/** This structure is used for a sized buffer that cannot be larger than the largest
 *  digest produced by any hash algorithm implemented on the TPM.
 */
class _DLLEXP_ TPM2B_DIGEST : public virtual TpmStructure, public TPMU_PUBLIC_ID
{
public:
    /** The buffer area that can be no larger than a digest  */
    ByteVec buffer;

public:
    TPM2B_DIGEST() {}
    TPM2B_DIGEST(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    operator ByteVec&() { return buffer; }
    operator const ByteVec&() const { return buffer; }
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_DIGEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_DIGEST>(); }
    
    /** Static marshaling helper  */
    static TPM2B_DIGEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_DIGEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_DIGEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_DIGEST(*this); }
}; // class TPM2B_DIGEST

/** This structure is used for a data buffer that is required to be no larger than the
 *  size of the Name of an object.
 */
class _DLLEXP_ TPM2B_DATA : public TpmStructure
{
public:
    ByteVec buffer;

public:
    TPM2B_DATA() {}
    TPM2B_DATA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_DATA>(); }
    
    /** Static marshaling helper  */
    static TPM2B_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_DATA(*this); }
}; // class TPM2B_DATA

/** Table 83 Definition of Types for TPM2B_NONCE  */
typedef TPM2B_DIGEST TPM2B_NONCE;

/** This structure is used for an authorization value and limits an authValue to being no
 *  larger than the largest digest produced by a TPM. In order to ensure consistency
 *  within an object, the authValue may be no larger than the size of the digest produced
 *  by the objects nameAlg. This ensures that any TPM that can load the object will be
 *  able to handle the authValue of the object.
 */
typedef TPM2B_DIGEST TPM2B_AUTH;

/** This type is a sized buffer that can hold an operand for a comparison with an NV Index
 *  location. The maximum size of the operand is implementation dependent but a TPM is
 *  required to support an operand size that is at least as big as the digest produced by
 *  any of the hash algorithms implemented on the TPM.
 */
typedef TPM2B_DIGEST TPM2B_OPERAND;

/** This type is a sized buffer that can hold event data.  */
class _DLLEXP_ TPM2B_EVENT : public TpmStructure
{
public:
    /** The operand  */
    ByteVec buffer;

public:
    TPM2B_EVENT() {}
    TPM2B_EVENT(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_EVENT fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_EVENT>(); }
    
    /** Static marshaling helper  */
    static TPM2B_EVENT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_EVENT>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_EVENT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_EVENT(*this); }
}; // class TPM2B_EVENT

/** This type is a sized buffer that can hold a maximally sized buffer for commands that
 *  use a large data buffer such as TPM2_Hash(), TPM2_SequenceUpdate(), or TPM2_FieldUpgradeData().
 */
class _DLLEXP_ TPM2B_MAX_BUFFER : public TpmStructure
{
public:
    /** The operand  */
    ByteVec buffer;

public:
    TPM2B_MAX_BUFFER() {}
    TPM2B_MAX_BUFFER(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_MAX_BUFFER fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_MAX_BUFFER>(); }
    
    /** Static marshaling helper  */
    static TPM2B_MAX_BUFFER fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_MAX_BUFFER>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_MAX_BUFFER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_MAX_BUFFER(*this); }
}; // class TPM2B_MAX_BUFFER

/** This type is a sized buffer that can hold a maximally sized buffer for NV data
 *  commands such as TPM2_NV_Read(), TPM2_NV_Write(), and TPM2_NV_Certify().
 */
class _DLLEXP_ TPM2B_MAX_NV_BUFFER : public TpmStructure
{
public:
    /** The operand
     *  NOTE MAX_NV_BUFFER_SIZE is TPM-dependent
     */
    ByteVec buffer;

public:
    TPM2B_MAX_NV_BUFFER() {}
    TPM2B_MAX_NV_BUFFER(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_MAX_NV_BUFFER fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_MAX_NV_BUFFER>(); }
    
    /** Static marshaling helper  */
    static TPM2B_MAX_NV_BUFFER fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_MAX_NV_BUFFER>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_MAX_NV_BUFFER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_MAX_NV_BUFFER(*this); }
}; // class TPM2B_MAX_NV_BUFFER

/** This TPM-dependent structure is used to provide the timeout value for an
 *  authorization. The size shall be 8 or less.
 */
class _DLLEXP_ TPM2B_TIMEOUT : public TpmStructure
{
public:
    /** The timeout value  */
    ByteVec buffer;

public:
    TPM2B_TIMEOUT() {}
    TPM2B_TIMEOUT(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_TIMEOUT fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_TIMEOUT>(); }
    
    /** Static marshaling helper  */
    static TPM2B_TIMEOUT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_TIMEOUT>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_TIMEOUT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_TIMEOUT(*this); }
}; // class TPM2B_TIMEOUT

/** This structure is used for passing an initial value for a symmetric block cipher to or
 *  from the TPM. The size is set to be the largest block size of any implemented
 *  symmetric cipher implemented on the TPM.
 */
class _DLLEXP_ TPM2B_IV : public TpmStructure
{
public:
    /** The IV value  */
    ByteVec buffer;

public:
    TPM2B_IV() {}
    TPM2B_IV(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_IV fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_IV>(); }
    
    /** Static marshaling helper  */
    static TPM2B_IV fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_IV>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_IV"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_IV(*this); }
}; // class TPM2B_IV

/** This buffer holds a Name for any entity type.  */
class _DLLEXP_ TPM2B_NAME : public TpmStructure
{
public:
    /** The Name structure  */
    ByteVec name;

public:
    TPM2B_NAME() {}
    TPM2B_NAME(const ByteVec& _name)
      : name(_name)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_NAME fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_NAME>(); }
    
    /** Static marshaling helper  */
    static TPM2B_NAME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_NAME>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_NAME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_NAME(*this); }
}; // class TPM2B_NAME

/** This structure provides a standard method of specifying a list of PCR.  */
class _DLLEXP_ TPMS_PCR_SELECT : public TpmStructure
{
public:
    /** The bit map of selected PCR  */
    ByteVec pcrSelect;

public:
    TPMS_PCR_SELECT() {}
    TPMS_PCR_SELECT(const ByteVec& _pcrSelect)
      : pcrSelect(_pcrSelect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_PCR_SELECT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_PCR_SELECT>(); }
    
    /** Static marshaling helper  */
    static TPMS_PCR_SELECT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_PCR_SELECT>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_PCR_SELECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_PCR_SELECT(*this); }
}; // class TPMS_PCR_SELECT

/** Table 94 Definition of TPMS_PCR_SELECTION Structure  */
class _DLLEXP_ TPMS_PCR_SELECTION : public TpmStructure
{
public:
    /** The hash algorithm associated with the selection  */
    TPM_ALG_ID hash;
    
    /** The bit map of selected PCR  */
    ByteVec pcrSelect;

public:
    TPMS_PCR_SELECTION() { hash = TPM_ALG_ID::_NULL; }
    TPMS_PCR_SELECTION(TPM_ALG_ID _hash, const ByteVec& _pcrSelect)
      : hash(_hash), pcrSelect(_pcrSelect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_PCR_SELECTION fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_PCR_SELECTION>(); }
    
    /** Static marshaling helper  */
    static TPMS_PCR_SELECTION fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_PCR_SELECTION>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_PCR_SELECTION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_PCR_SELECTION(*this); }
    
    /// <summary> Create a TPMS_PCR_SELECTION naming a single-PCR. </summary>
    TPMS_PCR_SELECTION(TPM_ALG_ID alg, UINT32 pcr);
    
    /// <summary> Create a TPMS_PCR_SELECTION for a set of PCR in a single bank. </summary>
    TPMS_PCR_SELECTION(TPM_ALG_ID hashAlg, const vector<UINT32>& pcrs);
    
    /// <summary> Get a PCR-selection array naming exactly one PCR in one bank. </summary>
    static vector<TPMS_PCR_SELECTION> GetSelectionArray(TPM_ALG_ID hashAlg, UINT32 pcr)
    {
        return vector<TPMS_PCR_SELECTION>{{hashAlg, pcr}};
    }
    
    /// <summary> Is the PCR with index _pcr selected in this TPMS_PCR_SELECTION. </summary>
    bool PcrIsSelected(UINT32 pcr)
    {
        return pcrSelect[pcr / 8] = (1 << (pcr % 8)) != 0;
    }
    
    /// <summary> Return the current PCR-selection as a UINT32 array. </summary>
    vector<UINT32> ToArray();
    
    [[deprecated("Use {} instead (creates a default-constructed empty vector)")]]
    static vector<TPMS_PCR_SELECTION> NullSelectionArray()
    {
        return vector<TPMS_PCR_SELECTION>();
    }
    
}; // class TPMS_PCR_SELECTION

/** This ticket is produced by TPM2_Create() or TPM2_CreatePrimary(). It is used to bind
 *  the creation data to the object to which it applies. The ticket is computed by
 */
class _DLLEXP_ TPMT_TK_CREATION : public TpmStructure
{
public:
    /** The hierarchy containing name  */
    TPM_HANDLE hierarchy;
    
    /** This shall be the HMAC produced using a proof value of hierarchy.  */
    ByteVec digest;

public:
    TPMT_TK_CREATION() {}
    TPMT_TK_CREATION(const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_TK_CREATION fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_TK_CREATION>(); }
    
    /** Static marshaling helper  */
    static TPMT_TK_CREATION fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_TK_CREATION>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_TK_CREATION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_TK_CREATION(*this); }
}; // class TPMT_TK_CREATION

/** This ticket is produced by TPM2_VerifySignature(). This formulation is used for
 *  multiple ticket uses. The ticket provides evidence that the TPM has validated that a
 *  digest was signed by a key with the Name of keyName. The ticket is computed by
 */
class _DLLEXP_ TPMT_TK_VERIFIED : public TpmStructure
{
public:
    /** The hierarchy containing keyName  */
    TPM_HANDLE hierarchy;
    
    /** This shall be the HMAC produced using a proof value of hierarchy.  */
    ByteVec digest;

public:
    TPMT_TK_VERIFIED() {}
    TPMT_TK_VERIFIED(const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_TK_VERIFIED fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_TK_VERIFIED>(); }
    
    /** Static marshaling helper  */
    static TPMT_TK_VERIFIED fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_TK_VERIFIED>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_TK_VERIFIED"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_TK_VERIFIED(*this); }
}; // class TPMT_TK_VERIFIED

/** This ticket is produced by TPM2_PolicySigned() and TPM2_PolicySecret() when the
 *  authorization has an expiration time. If nonceTPM was provided in the policy command,
 *  the ticket is computed by
 */
class _DLLEXP_ TPMT_TK_AUTH : public TpmStructure
{
public:
    /** Ticket structure tag  */
    TPM_ST tag;
    
    /** The hierarchy of the object used to produce the ticket  */
    TPM_HANDLE hierarchy;
    
    /** This shall be the HMAC produced using a proof value of hierarchy.  */
    ByteVec digest;

public:
    TPMT_TK_AUTH() {}
    TPMT_TK_AUTH(TPM_ST _tag, const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : tag(_tag), hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_TK_AUTH fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_TK_AUTH>(); }
    
    /** Static marshaling helper  */
    static TPMT_TK_AUTH fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_TK_AUTH>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_TK_AUTH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_TK_AUTH(*this); }
}; // class TPMT_TK_AUTH

/** This ticket is produced by TPM2_SequenceComplete() or TPM2_Hash() when the message
 *  that was digested did not start with TPM_GENERATED_VALUE. The ticket is computed by
 */
class _DLLEXP_ TPMT_TK_HASHCHECK : public TpmStructure
{
public:
    /** The hierarchy  */
    TPM_HANDLE hierarchy;
    
    /** This shall be the HMAC produced using a proof value of hierarchy.  */
    ByteVec digest;

public:
    TPMT_TK_HASHCHECK() {}
    TPMT_TK_HASHCHECK(const TPM_HANDLE& _hierarchy, const ByteVec& _digest)
      : hierarchy(_hierarchy), digest(_digest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_TK_HASHCHECK fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_TK_HASHCHECK>(); }
    
    /** Static marshaling helper  */
    static TPMT_TK_HASHCHECK fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_TK_HASHCHECK>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_TK_HASHCHECK"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_TK_HASHCHECK(*this); }
    
    [[deprecated("Use default ctor instead")]]
    static TPMT_TK_HASHCHECK NullTicket() { return TPMT_TK_HASHCHECK(); }
    
}; // class TPMT_TK_HASHCHECK

/** This structure is used to report the properties of an algorithm identifier. It is
 *  returned in response to a TPM2_GetCapability() with capability = TPM_CAP_ALG.
 */
class _DLLEXP_ TPMS_ALG_PROPERTY : public TpmStructure
{
public:
    /** An algorithm identifier  */
    TPM_ALG_ID alg;
    
    /** The attributes of the algorithm  */
    TPMA_ALGORITHM algProperties;

public:
    TPMS_ALG_PROPERTY() { alg = TPM_ALG_ID::_NULL; }
    TPMS_ALG_PROPERTY(TPM_ALG_ID _alg, TPMA_ALGORITHM _algProperties)
      : alg(_alg), algProperties(_algProperties)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ALG_PROPERTY fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ALG_PROPERTY>(); }
    
    /** Static marshaling helper  */
    static TPMS_ALG_PROPERTY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ALG_PROPERTY>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ALG_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ALG_PROPERTY(*this); }
}; // class TPMS_ALG_PROPERTY

/** This structure is used to report the properties that are UINT32 values. It is returned
 *  in response to a TPM2_GetCapability().
 */
class _DLLEXP_ TPMS_TAGGED_PROPERTY : public TpmStructure
{
public:
    /** A property identifier  */
    TPM_PT property;
    
    /** The value of the property  */
    UINT32 value;

public:
    TPMS_TAGGED_PROPERTY() {}
    TPMS_TAGGED_PROPERTY(TPM_PT _property, UINT32 _value)
      : property(_property), value(_value)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_TAGGED_PROPERTY fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_TAGGED_PROPERTY>(); }
    
    /** Static marshaling helper  */
    static TPMS_TAGGED_PROPERTY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_TAGGED_PROPERTY>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_TAGGED_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_TAGGED_PROPERTY(*this); }
}; // class TPMS_TAGGED_PROPERTY

/** This structure is used in TPM2_GetCapability() to return the attributes of the PCR.  */
class _DLLEXP_ TPMS_TAGGED_PCR_SELECT : public TpmStructure
{
public:
    /** The property identifier  */
    TPM_PT_PCR tag;
    
    /** The bit map of PCR with the identified property  */
    ByteVec pcrSelect;

public:
    TPMS_TAGGED_PCR_SELECT() {}
    TPMS_TAGGED_PCR_SELECT(TPM_PT_PCR _tag, const ByteVec& _pcrSelect)
      : tag(_tag), pcrSelect(_pcrSelect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_TAGGED_PCR_SELECT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_TAGGED_PCR_SELECT>(); }
    
    /** Static marshaling helper  */
    static TPMS_TAGGED_PCR_SELECT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_TAGGED_PCR_SELECT>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_TAGGED_PCR_SELECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_TAGGED_PCR_SELECT(*this); }
}; // class TPMS_TAGGED_PCR_SELECT

/** This structure is used in TPM2_GetCapability() to return the policy associated with a
 *  permanent handle.
 */
class _DLLEXP_ TPMS_TAGGED_POLICY : public TpmStructure
{
public:
    /** A permanent handle  */
    TPM_HANDLE handle;
    
    /** The policy algorithm and hash  */
    TPMT_HA policyHash;

public:
    TPMS_TAGGED_POLICY() {}
    TPMS_TAGGED_POLICY(const TPM_HANDLE& _handle, const TPMT_HA& _policyHash)
      : handle(_handle), policyHash(_policyHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_TAGGED_POLICY fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_TAGGED_POLICY>(); }
    
    /** Static marshaling helper  */
    static TPMS_TAGGED_POLICY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_TAGGED_POLICY>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_TAGGED_POLICY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_TAGGED_POLICY(*this); }
}; // class TPMS_TAGGED_POLICY

/** This structure is used in TPM2_GetCapability() to return the ACT data.  */
class _DLLEXP_ TPMS_ACT_DATA : public TpmStructure
{
public:
    /** A permanent handle  */
    TPM_HANDLE handle;
    
    /** The current timeout of the ACT  */
    UINT32 timeout;
    
    /** The state of the ACT  */
    TPMA_ACT attributes;

public:
    TPMS_ACT_DATA() {}
    TPMS_ACT_DATA(const TPM_HANDLE& _handle, UINT32 _timeout, TPMA_ACT _attributes)
      : handle(_handle), timeout(_timeout), attributes(_attributes)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ACT_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ACT_DATA>(); }
    
    /** Static marshaling helper  */
    static TPMS_ACT_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ACT_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ACT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ACT_DATA(*this); }
}; // class TPMS_ACT_DATA

/** A list of command codes may be input to the TPM or returned by the TPM depending on
 *  the command.
 */
class _DLLEXP_ TPML_CC : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** A list of command codes
     *  The maximum only applies to a command code list in a command. The response size is
     *  limited only by the size of the parameter buffer.
     */
    vector<TPM_CC> commandCodes;

public:
    TPML_CC() {}
    TPML_CC(const vector<TPM_CC>& _commandCodes)
      : commandCodes(_commandCodes)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::PP_COMMANDS; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_CC fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_CC>(); }
    
    /** Static marshaling helper  */
    static TPML_CC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_CC>(buf); }
    
    virtual const char* TypeName () const { return "TPML_CC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_CC(*this); }
}; // class TPML_CC

/** This list is only used in TPM2_GetCapability(capability = TPM_CAP_COMMANDS).  */
class _DLLEXP_ TPML_CCA : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** A list of command codes attributes  */
    vector<TPMA_CC> commandAttributes;

public:
    TPML_CCA() {}
    TPML_CCA(const vector<TPMA_CC>& _commandAttributes)
      : commandAttributes(_commandAttributes)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::COMMANDS; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_CCA fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_CCA>(); }
    
    /** Static marshaling helper  */
    static TPML_CCA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_CCA>(buf); }
    
    virtual const char* TypeName () const { return "TPML_CCA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_CCA(*this); }
}; // class TPML_CCA

/** This list is returned by TPM2_IncrementalSelfTest().  */
class _DLLEXP_ TPML_ALG : public TpmStructure
{
public:
    /** A list of algorithm IDs
     *  The maximum only applies to an algorithm list in a command. The response size is
     *  limited only by the size of the parameter buffer.
     */
    vector<TPM_ALG_ID> algorithms;

public:
    TPML_ALG() {}
    TPML_ALG(const vector<TPM_ALG_ID>& _algorithms)
      : algorithms(_algorithms)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_ALG fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_ALG>(); }
    
    /** Static marshaling helper  */
    static TPML_ALG fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_ALG>(buf); }
    
    virtual const char* TypeName () const { return "TPML_ALG"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_ALG(*this); }
}; // class TPML_ALG

/** This structure is used when the TPM returns a list of loaded handles when the
 *  capability in TPM2_GetCapability() is TPM_CAP_HANDLE.
 */
class _DLLEXP_ TPML_HANDLE : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** An array of handles  */
    vector<TPM_HANDLE> handle;

public:
    TPML_HANDLE() {}
    TPML_HANDLE(const vector<TPM_HANDLE>& _handle)
      : handle(_handle)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::HANDLES; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_HANDLE fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_HANDLE>(); }
    
    /** Static marshaling helper  */
    static TPML_HANDLE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_HANDLE>(buf); }
    
    virtual const char* TypeName () const { return "TPML_HANDLE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_HANDLE(*this); }
}; // class TPML_HANDLE

/** This list is used to convey a list of digest values. This type is used in
 *  TPM2_PolicyOR() and in TPM2_PCR_Read().
 */
class _DLLEXP_ TPML_DIGEST : public TpmStructure
{
public:
    /** A list of digests
     *  For TPM2_PolicyOR(), all digests will have been computed using the digest of the
     *  policy session. For TPM2_PCR_Read(), each digest will be the size of the digest for
     *  the bank containing the PCR.
     */
    vector<TPM2B_DIGEST> digests;

public:
    TPML_DIGEST() {}
    TPML_DIGEST(const vector<TPM2B_DIGEST>& _digests)
      : digests(_digests)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_DIGEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_DIGEST>(); }
    
    /** Static marshaling helper  */
    static TPML_DIGEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_DIGEST>(buf); }
    
    virtual const char* TypeName () const { return "TPML_DIGEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_DIGEST(*this); }
}; // class TPML_DIGEST

/** This list is used to convey a list of digest values. This type is returned by
 *  TPM2_PCR_Event() and TPM2_EventSequenceComplete() and is an input for TPM2_PCR_Extend().
 */
class _DLLEXP_ TPML_DIGEST_VALUES : public TpmStructure
{
public:
    /** A list of tagged digests  */
    vector<TPMT_HA> digests;

public:
    TPML_DIGEST_VALUES() {}
    TPML_DIGEST_VALUES(const vector<TPMT_HA>& _digests)
      : digests(_digests)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_DIGEST_VALUES fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_DIGEST_VALUES>(); }
    
    /** Static marshaling helper  */
    static TPML_DIGEST_VALUES fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_DIGEST_VALUES>(buf); }
    
    virtual const char* TypeName () const { return "TPML_DIGEST_VALUES"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_DIGEST_VALUES(*this); }
}; // class TPML_DIGEST_VALUES

/** This list is used to indicate the PCR that are included in a selection when more than
 *  one PCR value may be selected.
 */
class _DLLEXP_ TPML_PCR_SELECTION : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** List of selections  */
    vector<TPMS_PCR_SELECTION> pcrSelections;

public:
    TPML_PCR_SELECTION() {}
    TPML_PCR_SELECTION(const vector<TPMS_PCR_SELECTION>& _pcrSelections)
      : pcrSelections(_pcrSelections)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::PCRS; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_PCR_SELECTION fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_PCR_SELECTION>(); }
    
    /** Static marshaling helper  */
    static TPML_PCR_SELECTION fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_PCR_SELECTION>(buf); }
    
    virtual const char* TypeName () const { return "TPML_PCR_SELECTION"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_PCR_SELECTION(*this); }
}; // class TPML_PCR_SELECTION

/** This list is used to report on a list of algorithm attributes. It is returned in a
 *  TPM2_GetCapability().
 */
class _DLLEXP_ TPML_ALG_PROPERTY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** List of properties  */
    vector<TPMS_ALG_PROPERTY> algProperties;

public:
    TPML_ALG_PROPERTY() {}
    TPML_ALG_PROPERTY(const vector<TPMS_ALG_PROPERTY>& _algProperties)
      : algProperties(_algProperties)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::ALGS; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_ALG_PROPERTY fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_ALG_PROPERTY>(); }
    
    /** Static marshaling helper  */
    static TPML_ALG_PROPERTY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_ALG_PROPERTY>(buf); }
    
    virtual const char* TypeName () const { return "TPML_ALG_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_ALG_PROPERTY(*this); }
}; // class TPML_ALG_PROPERTY

/** This list is used to report on a list of properties that are TPMS_TAGGED_PROPERTY
 *  values. It is returned by a TPM2_GetCapability().
 */
class _DLLEXP_ TPML_TAGGED_TPM_PROPERTY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** An array of tagged properties  */
    vector<TPMS_TAGGED_PROPERTY> tpmProperty;

public:
    TPML_TAGGED_TPM_PROPERTY() {}
    TPML_TAGGED_TPM_PROPERTY(const vector<TPMS_TAGGED_PROPERTY>& _tpmProperty)
      : tpmProperty(_tpmProperty)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::TPM_PROPERTIES; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_TAGGED_TPM_PROPERTY fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_TAGGED_TPM_PROPERTY>(); }
    
    /** Static marshaling helper  */
    static TPML_TAGGED_TPM_PROPERTY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_TAGGED_TPM_PROPERTY>(buf); }
    
    virtual const char* TypeName () const { return "TPML_TAGGED_TPM_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_TAGGED_TPM_PROPERTY(*this); }
}; // class TPML_TAGGED_TPM_PROPERTY

/** This list is used to report on a list of properties that are TPMS_PCR_SELECT values.
 *  It is returned by a TPM2_GetCapability().
 */
class _DLLEXP_ TPML_TAGGED_PCR_PROPERTY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** A tagged PCR selection  */
    vector<TPMS_TAGGED_PCR_SELECT> pcrProperty;

public:
    TPML_TAGGED_PCR_PROPERTY() {}
    TPML_TAGGED_PCR_PROPERTY(const vector<TPMS_TAGGED_PCR_SELECT>& _pcrProperty)
      : pcrProperty(_pcrProperty)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::PCR_PROPERTIES; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_TAGGED_PCR_PROPERTY fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_TAGGED_PCR_PROPERTY>(); }
    
    /** Static marshaling helper  */
    static TPML_TAGGED_PCR_PROPERTY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_TAGGED_PCR_PROPERTY>(buf); }
    
    virtual const char* TypeName () const { return "TPML_TAGGED_PCR_PROPERTY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_TAGGED_PCR_PROPERTY(*this); }
}; // class TPML_TAGGED_PCR_PROPERTY

/** This list is used to report the ECC curve ID values supported by the TPM. It is
 *  returned by a TPM2_GetCapability().
 */
class _DLLEXP_ TPML_ECC_CURVE : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** Array of ECC curve identifiers  */
    vector<TPM_ECC_CURVE> eccCurves;

public:
    TPML_ECC_CURVE() {}
    TPML_ECC_CURVE(const vector<TPM_ECC_CURVE>& _eccCurves)
      : eccCurves(_eccCurves)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::ECC_CURVES; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_ECC_CURVE fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_ECC_CURVE>(); }
    
    /** Static marshaling helper  */
    static TPML_ECC_CURVE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_ECC_CURVE>(buf); }
    
    virtual const char* TypeName () const { return "TPML_ECC_CURVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_ECC_CURVE(*this); }
}; // class TPML_ECC_CURVE

/** This list is used to report the authorization policy values for permanent handles.
 *  This is list may be generated by TPM2_GetCapabiltiy(). A permanent handle that cannot
 *  have a policy is not included in the list.
 */
class _DLLEXP_ TPML_TAGGED_POLICY : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** Array of tagged policies  */
    vector<TPMS_TAGGED_POLICY> policies;

public:
    TPML_TAGGED_POLICY() {}
    TPML_TAGGED_POLICY(const vector<TPMS_TAGGED_POLICY>& _policies)
      : policies(_policies)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::AUTH_POLICIES; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_TAGGED_POLICY fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_TAGGED_POLICY>(); }
    
    /** Static marshaling helper  */
    static TPML_TAGGED_POLICY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_TAGGED_POLICY>(buf); }
    
    virtual const char* TypeName () const { return "TPML_TAGGED_POLICY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_TAGGED_POLICY(*this); }
}; // class TPML_TAGGED_POLICY

/** This list is used to report the timeout and state for the ACT. This list may be
 *  generated by TPM2_GetCapabilty(). Only implemented ACT are present in the list
 */
class _DLLEXP_ TPML_ACT_DATA : public virtual TpmStructure, public TPMU_CAPABILITIES
{
public:
    /** Array of ACT data  */
    vector<TPMS_ACT_DATA> actData;

public:
    TPML_ACT_DATA() {}
    TPML_ACT_DATA(const vector<TPMS_ACT_DATA>& _actData)
      : actData(_actData)
    {}
    
    /** TpmUnion method  */
    TPM_CAP GetUnionSelector() const { return TPM_CAP::ACT; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_ACT_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_ACT_DATA>(); }
    
    /** Static marshaling helper  */
    static TPML_ACT_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_ACT_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPML_ACT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_ACT_DATA(*this); }
}; // class TPML_ACT_DATA

/** This data area is returned in response to a TPM2_GetCapability().  */
class _DLLEXP_ TPMS_CAPABILITY_DATA : public TpmStructure
{
public:
    /** The capability  */
    public: TPM_CAP capability() const { return data->GetUnionSelector(); }
    
    /** The capability data
     *  (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
     *  TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
     *  TPML_TAGGED_POLICY, TPML_ACT_DATA])
     */
    shared_ptr<TPMU_CAPABILITIES> data;

public:
    TPMS_CAPABILITY_DATA() {}
    TPMS_CAPABILITY_DATA(const TPMU_CAPABILITIES& _data)
      : data(dynamic_cast<TPMU_CAPABILITIES*>(_data.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_CAPABILITY_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CAPABILITY_DATA>(); }
    
    /** Static marshaling helper  */
    static TPMS_CAPABILITY_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CAPABILITY_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CAPABILITY_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_CAPABILITY_DATA(*this); }
}; // class TPMS_CAPABILITY_DATA

/** This structure is used in each of the attestation commands.  */
class _DLLEXP_ TPMS_CLOCK_INFO : public TpmStructure
{
public:
    /** Time value in milliseconds that advances while the TPM is powered
     *  NOTE The interpretation of the time-origin (clock=0) is out of the scope of this
     *  specification, although Coordinated Universal Time (UTC) is expected to be a common
     *  convention. This structure element is used to report on the TPM's Clock value.
     *  This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()).
     *  This value may be advanced by TPM2_ClockSet().
     */
    UINT64 clock;
    
    /** Number of occurrences of TPM Reset since the last TPM2_Clear()  */
    UINT32 resetCount;
    
    /** Number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last
     *  TPM Reset or TPM2_Clear().
     */
    UINT32 restartCount;
    
    /** No value of Clock greater than the current value of Clock has been previously reported
     *  by the TPM. Set to YES on TPM2_Clear().
     */
    BYTE safe;

public:
    TPMS_CLOCK_INFO() {}
    TPMS_CLOCK_INFO(UINT64 _clock, UINT32 _resetCount, UINT32 _restartCount, BYTE _safe)
      : clock(_clock), resetCount(_resetCount), restartCount(_restartCount), safe(_safe)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_CLOCK_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CLOCK_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_CLOCK_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CLOCK_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CLOCK_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_CLOCK_INFO(*this); }
}; // class TPMS_CLOCK_INFO

/** This structure is used in, e.g., the TPM2_GetTime() attestation and TPM2_ReadClock().  */
class _DLLEXP_ TPMS_TIME_INFO : public TpmStructure
{
public:
    /** Time in milliseconds since the TIme circuit was last reset
     *  This structure element is used to report on the TPM's Time value.
     */
    UINT64 time;
    
    /** A structure containing the clock information  */
    TPMS_CLOCK_INFO clockInfo;

public:
    TPMS_TIME_INFO() {}
    TPMS_TIME_INFO(UINT64 _time, const TPMS_CLOCK_INFO& _clockInfo)
      : time(_time), clockInfo(_clockInfo)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_TIME_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_TIME_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_TIME_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_TIME_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_TIME_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_TIME_INFO(*this); }
}; // class TPMS_TIME_INFO

/** This structure is used when the TPM performs TPM2_GetTime.  */
class _DLLEXP_ TPMS_TIME_ATTEST_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** The Time, Clock, resetCount, restartCount, and Safe indicator  */
    TPMS_TIME_INFO time;
    
    /** A TPM vendor-specific value indicating the version number of the firmware  */
    UINT64 firmwareVersion;

public:
    TPMS_TIME_ATTEST_INFO() {}
    TPMS_TIME_ATTEST_INFO(const TPMS_TIME_INFO& _time, UINT64 _firmwareVersion)
      : time(_time), firmwareVersion(_firmwareVersion)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_TIME; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_TIME_ATTEST_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_TIME_ATTEST_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_TIME_ATTEST_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_TIME_ATTEST_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_TIME_ATTEST_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_TIME_ATTEST_INFO(*this); }
}; // class TPMS_TIME_ATTEST_INFO

/** This is the attested data for TPM2_Certify().  */
class _DLLEXP_ TPMS_CERTIFY_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** Name of the certified object  */
    ByteVec name;
    
    /** Qualified Name of the certified object  */
    ByteVec qualifiedName;

public:
    TPMS_CERTIFY_INFO() {}
    TPMS_CERTIFY_INFO(const ByteVec& _name, const ByteVec& _qualifiedName)
      : name(_name), qualifiedName(_qualifiedName)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_CERTIFY; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_CERTIFY_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CERTIFY_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_CERTIFY_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CERTIFY_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CERTIFY_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_CERTIFY_INFO(*this); }
}; // class TPMS_CERTIFY_INFO

/** This is the attested data for TPM2_Quote().  */
class _DLLEXP_ TPMS_QUOTE_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** Information on algID, PCR selected and digest  */
    vector<TPMS_PCR_SELECTION> pcrSelect;
    
    /** Digest of the selected PCR using the hash of the signing key  */
    ByteVec pcrDigest;

public:
    TPMS_QUOTE_INFO() {}
    TPMS_QUOTE_INFO(const vector<TPMS_PCR_SELECTION>& _pcrSelect, const ByteVec& _pcrDigest)
      : pcrSelect(_pcrSelect), pcrDigest(_pcrDigest)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_QUOTE; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_QUOTE_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_QUOTE_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_QUOTE_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_QUOTE_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_QUOTE_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_QUOTE_INFO(*this); }
}; // class TPMS_QUOTE_INFO

/** This is the attested data for TPM2_GetCommandAuditDigest().  */
class _DLLEXP_ TPMS_COMMAND_AUDIT_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** The monotonic audit counter  */
    UINT64 auditCounter;
    
    /** Hash algorithm used for the command audit  */
    TPM_ALG_ID digestAlg;
    
    /** The current value of the audit digest  */
    ByteVec auditDigest;
    
    /** Digest of the command codes being audited using digestAlg  */
    ByteVec commandDigest;

public:
    TPMS_COMMAND_AUDIT_INFO() { digestAlg = TPM_ALG_ID::_NULL; }
    TPMS_COMMAND_AUDIT_INFO(UINT64 _auditCounter, TPM_ALG_ID _digestAlg, const ByteVec& _auditDigest, const ByteVec& _commandDigest)
      : auditCounter(_auditCounter), digestAlg(_digestAlg), auditDigest(_auditDigest), commandDigest(_commandDigest)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_COMMAND_AUDIT; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_COMMAND_AUDIT_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_COMMAND_AUDIT_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_COMMAND_AUDIT_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_COMMAND_AUDIT_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_COMMAND_AUDIT_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_COMMAND_AUDIT_INFO(*this); }
}; // class TPMS_COMMAND_AUDIT_INFO

/** This is the attested data for TPM2_GetSessionAuditDigest().  */
class _DLLEXP_ TPMS_SESSION_AUDIT_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** Current exclusive status of the session
     *  TRUE if all of the commands recorded in the sessionDigest were executed without any
     *  intervening TPM command that did not use this audit session
     */
    BYTE exclusiveSession;
    
    /** The current value of the session audit digest  */
    ByteVec sessionDigest;

public:
    TPMS_SESSION_AUDIT_INFO() {}
    TPMS_SESSION_AUDIT_INFO(BYTE _exclusiveSession, const ByteVec& _sessionDigest)
      : exclusiveSession(_exclusiveSession), sessionDigest(_sessionDigest)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_SESSION_AUDIT; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SESSION_AUDIT_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SESSION_AUDIT_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_SESSION_AUDIT_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SESSION_AUDIT_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SESSION_AUDIT_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SESSION_AUDIT_INFO(*this); }
}; // class TPMS_SESSION_AUDIT_INFO

/** This is the attested data for TPM2_CertifyCreation().  */
class _DLLEXP_ TPMS_CREATION_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** Name of the object  */
    ByteVec objectName;
    
    /** CreationHash  */
    ByteVec creationHash;

public:
    TPMS_CREATION_INFO() {}
    TPMS_CREATION_INFO(const ByteVec& _objectName, const ByteVec& _creationHash)
      : objectName(_objectName), creationHash(_creationHash)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_CREATION; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_CREATION_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CREATION_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_CREATION_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CREATION_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CREATION_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_CREATION_INFO(*this); }
}; // class TPMS_CREATION_INFO

/** This structure contains the Name and contents of the selected NV Index that is
 *  certified by TPM2_NV_Certify().
 */
class _DLLEXP_ TPMS_NV_CERTIFY_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** Name of the NV Index  */
    ByteVec indexName;
    
    /** The offset parameter of TPM2_NV_Certify()  */
    UINT16 offset;
    
    /** Contents of the NV Index  */
    ByteVec nvContents;

public:
    TPMS_NV_CERTIFY_INFO() {}
    TPMS_NV_CERTIFY_INFO(const ByteVec& _indexName, UINT16 _offset, const ByteVec& _nvContents)
      : indexName(_indexName), offset(_offset), nvContents(_nvContents)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_NV; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_NV_CERTIFY_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NV_CERTIFY_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_NV_CERTIFY_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NV_CERTIFY_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NV_CERTIFY_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_NV_CERTIFY_INFO(*this); }
}; // class TPMS_NV_CERTIFY_INFO

/** This structure contains the Name and hash of the contents of the selected NV Index
 *  that is certified by TPM2_NV_Certify(). The data is hashed using hash of the signing scheme.
 */
class _DLLEXP_ TPMS_NV_DIGEST_CERTIFY_INFO : public virtual TpmStructure, public TPMU_ATTEST
{
public:
    /** Name of the NV Index  */
    ByteVec indexName;
    
    /** Hash of the contents of the index  */
    ByteVec nvDigest;

public:
    TPMS_NV_DIGEST_CERTIFY_INFO() {}
    TPMS_NV_DIGEST_CERTIFY_INFO(const ByteVec& _indexName, const ByteVec& _nvDigest)
      : indexName(_indexName), nvDigest(_nvDigest)
    {}
    
    /** TpmUnion method  */
    TPM_ST GetUnionSelector() const { return TPM_ST::ATTEST_NV_DIGEST; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_NV_DIGEST_CERTIFY_INFO fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NV_DIGEST_CERTIFY_INFO>(); }
    
    /** Static marshaling helper  */
    static TPMS_NV_DIGEST_CERTIFY_INFO fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NV_DIGEST_CERTIFY_INFO>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NV_DIGEST_CERTIFY_INFO"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_NV_DIGEST_CERTIFY_INFO(*this); }
}; // class TPMS_NV_DIGEST_CERTIFY_INFO

/** This structure is used on each TPM-generated signed structure. The signature is over
 *  this structure.
 */
class _DLLEXP_ TPMS_ATTEST : public TpmStructure
{
public:
    /** The indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)  */
    TPM_GENERATED magic;
    
    /** Type of the attestation structure  */
    public: TPM_ST type() const { return attested->GetUnionSelector(); }
    
    /** Qualified Name of the signing key  */
    ByteVec qualifiedSigner;
    
    /** External information supplied by caller
     *  NOTE A TPM2B_DATA structure provides room for a digest and a method indicator to
     *  indicate the components of the digest. The definition of this method indicator is
     *  outside the scope of this specification.
     */
    ByteVec extraData;
    
    /** Clock, resetCount, restartCount, and Safe  */
    TPMS_CLOCK_INFO clockInfo;
    
    /** TPM-vendor-specific value identifying the version number of the firmware  */
    UINT64 firmwareVersion;
    
    /** The type-specific attestation information
     *  (One of [TPMS_CERTIFY_INFO, TPMS_CREATION_INFO, TPMS_QUOTE_INFO,
     *  TPMS_COMMAND_AUDIT_INFO, TPMS_SESSION_AUDIT_INFO, TPMS_TIME_ATTEST_INFO,
     *  TPMS_NV_CERTIFY_INFO, TPMS_NV_DIGEST_CERTIFY_INFO])
     */
    shared_ptr<TPMU_ATTEST> attested;

public:
    TPMS_ATTEST() {}
    TPMS_ATTEST(TPM_GENERATED _magic, const ByteVec& _qualifiedSigner, const ByteVec& _extraData, const TPMS_CLOCK_INFO& _clockInfo, UINT64 _firmwareVersion, const TPMU_ATTEST& _attested)
      : magic(_magic), qualifiedSigner(_qualifiedSigner), extraData(_extraData), clockInfo(_clockInfo), firmwareVersion(_firmwareVersion), attested(dynamic_cast<TPMU_ATTEST*>(_attested.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ATTEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ATTEST>(); }
    
    /** Static marshaling helper  */
    static TPMS_ATTEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ATTEST>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ATTEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ATTEST(*this); }
}; // class TPMS_ATTEST

/** This sized buffer to contain the signed structure. The attestationData is the signed
 *  portion of the structure. The size parameter is not signed.
 */
class _DLLEXP_ TPM2B_ATTEST : public TpmStructure
{
public:
    /** The signed structure  */
    TPMS_ATTEST attestationData;

public:
    TPM2B_ATTEST() {}
    TPM2B_ATTEST(const TPMS_ATTEST& _attestationData)
      : attestationData(_attestationData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_ATTEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_ATTEST>(); }
    
    /** Static marshaling helper  */
    static TPM2B_ATTEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_ATTEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_ATTEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_ATTEST(*this); }
}; // class TPM2B_ATTEST

/** This is the format used for each of the authorizations in the session area of a command.  */
class _DLLEXP_ TPMS_AUTH_COMMAND : public TpmStructure
{
public:
    /** The session handle  */
    TPM_HANDLE sessionHandle;
    
    /** The session nonce, may be the Empty Buffer  */
    ByteVec nonce;
    
    /** The session attributes  */
    TPMA_SESSION sessionAttributes;
    
    /** Either an HMAC, a password, or an EmptyAuth  */
    ByteVec hmac;

public:
    TPMS_AUTH_COMMAND() {}
    TPMS_AUTH_COMMAND(const TPM_HANDLE& _sessionHandle, const ByteVec& _nonce, TPMA_SESSION _sessionAttributes, const ByteVec& _hmac)
      : sessionHandle(_sessionHandle), nonce(_nonce), sessionAttributes(_sessionAttributes), hmac(_hmac)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_AUTH_COMMAND fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_AUTH_COMMAND>(); }
    
    /** Static marshaling helper  */
    static TPMS_AUTH_COMMAND fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_AUTH_COMMAND>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_AUTH_COMMAND"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_AUTH_COMMAND(*this); }
}; // class TPMS_AUTH_COMMAND

/** This is the format for each of the authorizations in the session area of the response.
 *  If the TPM returns TPM_RC_SUCCESS, then the session area of the response contains the
 *  same number of authorizations as the command and the authorizations are in the same order.
 */
class _DLLEXP_ TPMS_AUTH_RESPONSE : public TpmStructure
{
public:
    /** The session nonce, may be the Empty Buffer  */
    ByteVec nonce;
    
    /** The session attributes  */
    TPMA_SESSION sessionAttributes;
    
    /** Either an HMAC or an EmptyAuth  */
    ByteVec hmac;

public:
    TPMS_AUTH_RESPONSE() {}
    TPMS_AUTH_RESPONSE(const ByteVec& _nonce, TPMA_SESSION _sessionAttributes, const ByteVec& _hmac)
      : nonce(_nonce), sessionAttributes(_sessionAttributes), hmac(_hmac)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_AUTH_RESPONSE fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_AUTH_RESPONSE>(); }
    
    /** Static marshaling helper  */
    static TPMS_AUTH_RESPONSE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_AUTH_RESPONSE>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_AUTH_RESPONSE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_AUTH_RESPONSE(*this); }
}; // class TPMS_AUTH_RESPONSE

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_TDES for the union TPMU_SYM_DETAILS
 */
class _DLLEXP_ TPMS_TDES_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
public:
    TPMS_TDES_SYM_DETAILS() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::TDES; }
    
    /** Static marshaling helper  */
    static TPMS_TDES_SYM_DETAILS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_TDES_SYM_DETAILS>(); }
    
    /** Static marshaling helper  */
    static TPMS_TDES_SYM_DETAILS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_TDES_SYM_DETAILS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_TDES_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_TDES_SYM_DETAILS(*this); }
}; // class TPMS_TDES_SYM_DETAILS

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_AES for the union TPMU_SYM_DETAILS
 */
class _DLLEXP_ TPMS_AES_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
public:
    TPMS_AES_SYM_DETAILS() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::AES; }
    
    /** Static marshaling helper  */
    static TPMS_AES_SYM_DETAILS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_AES_SYM_DETAILS>(); }
    
    /** Static marshaling helper  */
    static TPMS_AES_SYM_DETAILS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_AES_SYM_DETAILS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_AES_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_AES_SYM_DETAILS(*this); }
}; // class TPMS_AES_SYM_DETAILS

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_SM4 for the union TPMU_SYM_DETAILS
 */
class _DLLEXP_ TPMS_SM4_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
public:
    TPMS_SM4_SYM_DETAILS() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SM4; }
    
    /** Static marshaling helper  */
    static TPMS_SM4_SYM_DETAILS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SM4_SYM_DETAILS>(); }
    
    /** Static marshaling helper  */
    static TPMS_SM4_SYM_DETAILS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SM4_SYM_DETAILS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SM4_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SM4_SYM_DETAILS(*this); }
}; // class TPMS_SM4_SYM_DETAILS

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_CAMELLIA for the union TPMU_SYM_DETAILS
 */
class _DLLEXP_ TPMS_CAMELLIA_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
public:
    TPMS_CAMELLIA_SYM_DETAILS() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::CAMELLIA; }
    
    /** Static marshaling helper  */
    static TPMS_CAMELLIA_SYM_DETAILS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CAMELLIA_SYM_DETAILS>(); }
    
    /** Static marshaling helper  */
    static TPMS_CAMELLIA_SYM_DETAILS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CAMELLIA_SYM_DETAILS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CAMELLIA_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_CAMELLIA_SYM_DETAILS(*this); }
}; // class TPMS_CAMELLIA_SYM_DETAILS

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_ANY for the union TPMU_SYM_DETAILS
 */
class _DLLEXP_ TPMS_ANY_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
public:
    TPMS_ANY_SYM_DETAILS() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY; }
    
    /** Static marshaling helper  */
    static TPMS_ANY_SYM_DETAILS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ANY_SYM_DETAILS>(); }
    
    /** Static marshaling helper  */
    static TPMS_ANY_SYM_DETAILS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ANY_SYM_DETAILS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ANY_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_ANY_SYM_DETAILS(*this); }
}; // class TPMS_ANY_SYM_DETAILS

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_XOR for the union TPMU_SYM_DETAILS
 */
class _DLLEXP_ TPMS_XOR_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
public:
    TPMS_XOR_SYM_DETAILS() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::XOR; }
    
    /** Static marshaling helper  */
    static TPMS_XOR_SYM_DETAILS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_XOR_SYM_DETAILS>(); }
    
    /** Static marshaling helper  */
    static TPMS_XOR_SYM_DETAILS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_XOR_SYM_DETAILS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_XOR_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_XOR_SYM_DETAILS(*this); }
}; // class TPMS_XOR_SYM_DETAILS

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SYM_DETAILS
 */
class _DLLEXP_ TPMS_NULL_SYM_DETAILS : public TPMS_NULL_UNION
{
public:
public:
    TPMS_NULL_SYM_DETAILS() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SYM_DETAILS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NULL_SYM_DETAILS>(); }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SYM_DETAILS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NULL_SYM_DETAILS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SYM_DETAILS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_NULL_SYM_DETAILS(*this); }
}; // class TPMS_NULL_SYM_DETAILS

/** The TPMT_SYM_DEF structure is used to select an algorithm to be used for parameter
 *  encryption in those cases when different symmetric algorithms may be selected.
 */
class _DLLEXP_ TPMT_SYM_DEF : public TpmStructure
{
public:
    /** symmetric algorithm  */
    TPM_ALG_ID algorithm;
    
    /** key size in bits  */
    UINT16 keyBits;
    
    /** encryption mode  */
    TPM_ALG_ID mode;

public:
    TPMT_SYM_DEF()
    {
        algorithm = TPM_ALG_ID::_NULL;
        mode = TPM_ALG_ID::_NULL;
    }
    
    TPMT_SYM_DEF(TPM_ALG_ID _algorithm, UINT16 _keyBits, TPM_ALG_ID _mode)
      : algorithm(_algorithm), keyBits(_keyBits), mode(_mode)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_SYM_DEF fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_SYM_DEF>(); }
    
    /** Static marshaling helper  */
    static TPMT_SYM_DEF fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_SYM_DEF>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_SYM_DEF"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_SYM_DEF(*this); }
    
    [[deprecated("Use default ctor instead")]]
    static TPMT_SYM_DEF NullObject() { return TPMT_SYM_DEF(); }
    
}; // class TPMT_SYM_DEF

/** This structure is used when different symmetric block cipher (not XOR) algorithms may
 *  be selected. If the Object can be an ordinary parent (not a derivation parent), this
 *  must be the first field in the Object's parameter (see 12.2.3.7) field.
 */
class _DLLEXP_ TPMT_SYM_DEF_OBJECT : public TpmStructure
{
public:
    /** symmetric algorithm  */
    TPM_ALG_ID algorithm;
    
    /** key size in bits  */
    UINT16 keyBits;
    
    /** encryption mode  */
    TPM_ALG_ID mode;

public:
    TPMT_SYM_DEF_OBJECT()
    {
        algorithm = TPM_ALG_ID::_NULL;
        mode = TPM_ALG_ID::_NULL;
    }
    
    TPMT_SYM_DEF_OBJECT(TPM_ALG_ID _algorithm, UINT16 _keyBits, TPM_ALG_ID _mode)
      : algorithm(_algorithm), keyBits(_keyBits), mode(_mode)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_SYM_DEF_OBJECT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_SYM_DEF_OBJECT>(); }
    
    /** Static marshaling helper  */
    static TPMT_SYM_DEF_OBJECT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_SYM_DEF_OBJECT>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_SYM_DEF_OBJECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_SYM_DEF_OBJECT(*this); }
    
    [[deprecated("Use default ctor instead")]]
    static TPMT_SYM_DEF_OBJECT NullObject() { return TPMT_SYM_DEF_OBJECT(); }
    
}; // class TPMT_SYM_DEF_OBJECT

/** This structure is used to hold a symmetric key in the sensitive area of an asymmetric object.  */
class _DLLEXP_ TPM2B_SYM_KEY : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
public:
    /** The key  */
    ByteVec buffer;

public:
    TPM2B_SYM_KEY() {}
    TPM2B_SYM_KEY(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SYMCIPHER; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_SYM_KEY fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_SYM_KEY>(); }
    
    /** Static marshaling helper  */
    static TPM2B_SYM_KEY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_SYM_KEY>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_SYM_KEY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_SYM_KEY(*this); }
}; // class TPM2B_SYM_KEY

/** This structure contains the parameters for a symmetric block cipher object.  */
class _DLLEXP_ TPMS_SYMCIPHER_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
public:
    /** A symmetric block cipher  */
    TPMT_SYM_DEF_OBJECT sym;

public:
    TPMS_SYMCIPHER_PARMS() {}
    TPMS_SYMCIPHER_PARMS(const TPMT_SYM_DEF_OBJECT& _sym)
      : sym(_sym)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SYMCIPHER; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SYMCIPHER_PARMS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SYMCIPHER_PARMS>(); }
    
    /** Static marshaling helper  */
    static TPMS_SYMCIPHER_PARMS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SYMCIPHER_PARMS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SYMCIPHER_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SYMCIPHER_PARMS(*this); }
}; // class TPMS_SYMCIPHER_PARMS

/** This buffer holds a label or context value. For interoperability and backwards
 *  compatibility, LABEL_MAX_BUFFER is the minimum of the largest digest on the device and
 *  the largest ECC parameter (MAX_ECC_KEY_BYTES) but no more than 32 bytes.
 */
class _DLLEXP_ TPM2B_LABEL : public TpmStructure
{
public:
    /** Symmetric data for a created object or the label and context for a derived object  */
    ByteVec buffer;

public:
    TPM2B_LABEL() {}
    TPM2B_LABEL(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_LABEL fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_LABEL>(); }
    
    /** Static marshaling helper  */
    static TPM2B_LABEL fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_LABEL>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_LABEL"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_LABEL(*this); }
}; // class TPM2B_LABEL

/** This structure contains the label and context fields for a derived object. These
 *  values are used in the derivation KDF. The values in the unique field of inPublic area
 *  template take precedence over the values in the inSensitive parameter.
 */
class _DLLEXP_ TPMS_DERIVE : public virtual TpmStructure, public TPMU_SENSITIVE_CREATE, public TPMU_PUBLIC_ID
{
public:
    ByteVec label;
    
    ByteVec context;

public:
    TPMS_DERIVE() {}
    TPMS_DERIVE(const ByteVec& _label, const ByteVec& _context)
      : label(_label), context(_context)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY2; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_DERIVE fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_DERIVE>(); }
    
    /** Static marshaling helper  */
    static TPMS_DERIVE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_DERIVE>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_DERIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_DERIVE(*this); }
}; // class TPMS_DERIVE

/** Table 147 Definition of TPM2B_DERIVE Structure  */
class _DLLEXP_ TPM2B_DERIVE : public TpmStructure
{
public:
    /** Symmetric data for a created object or the label and context for a derived object  */
    TPMS_DERIVE buffer;

public:
    TPM2B_DERIVE() {}
    TPM2B_DERIVE(const TPMS_DERIVE& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_DERIVE fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_DERIVE>(); }
    
    /** Static marshaling helper  */
    static TPM2B_DERIVE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_DERIVE>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_DERIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_DERIVE(*this); }
}; // class TPM2B_DERIVE

/** This buffer wraps the TPMU_SENSITIVE_CREATE structure.  */
class _DLLEXP_ TPM2B_SENSITIVE_DATA : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
public:
    /** Symmetric data for a created object or the label and context for a derived object  */
    ByteVec buffer;

public:
    TPM2B_SENSITIVE_DATA() {}
    TPM2B_SENSITIVE_DATA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_SENSITIVE_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_SENSITIVE_DATA>(); }
    
    /** Static marshaling helper  */
    static TPM2B_SENSITIVE_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_SENSITIVE_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_SENSITIVE_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_SENSITIVE_DATA(*this); }
}; // class TPM2B_SENSITIVE_DATA

/** This structure defines the values to be placed in the sensitive area of a created
 *  object. This structure is only used within a TPM2B_SENSITIVE_CREATE structure.
 */
class _DLLEXP_ TPMS_SENSITIVE_CREATE : public TpmStructure
{
public:
    /** The USER auth secret value  */
    ByteVec userAuth;
    
    /** Data to be sealed, a key, or derivation values  */
    ByteVec data;

public:
    TPMS_SENSITIVE_CREATE() {}
    TPMS_SENSITIVE_CREATE(const ByteVec& _userAuth, const ByteVec& _data)
      : userAuth(_userAuth), data(_data)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SENSITIVE_CREATE fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SENSITIVE_CREATE>(); }
    
    /** Static marshaling helper  */
    static TPMS_SENSITIVE_CREATE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SENSITIVE_CREATE>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SENSITIVE_CREATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SENSITIVE_CREATE(*this); }
}; // class TPMS_SENSITIVE_CREATE

/** This structure contains the sensitive creation data in a sized buffer. This structure
 *  is defined so that both the userAuth and data values of the TPMS_SENSITIVE_CREATE may
 *  be passed as a single parameter for parameter encryption purposes.
 */
class _DLLEXP_ TPM2B_SENSITIVE_CREATE : public TpmStructure
{
public:
    /** Data to be sealed or a symmetric key value.  */
    TPMS_SENSITIVE_CREATE sensitive;

public:
    TPM2B_SENSITIVE_CREATE() {}
    TPM2B_SENSITIVE_CREATE(const TPMS_SENSITIVE_CREATE& _sensitive)
      : sensitive(_sensitive)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_SENSITIVE_CREATE fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_SENSITIVE_CREATE>(); }
    
    /** Static marshaling helper  */
    static TPM2B_SENSITIVE_CREATE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_SENSITIVE_CREATE>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_SENSITIVE_CREATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_SENSITIVE_CREATE(*this); }
}; // class TPM2B_SENSITIVE_CREATE

/** This structure is the scheme data for schemes that only require a hash to complete
 *  their definition.
 */
class _DLLEXP_ TPMS_SCHEME_HASH : public virtual TpmStructure, public TPMU_SCHEME_KEYEDHASH, public TPMU_SIG_SCHEME, public TPMU_KDF_SCHEME, public TPMU_ASYM_SCHEME, public TPMU_SIGNATURE
{
public:
    /** The hash algorithm used to digest the message  */
    TPM_ALG_ID hashAlg;

public:
    TPMS_SCHEME_HASH() { hashAlg = TPM_ALG_ID::_NULL; }
    TPMS_SCHEME_HASH(TPM_ALG_ID _hashAlg)
      : hashAlg(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::HMAC; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_HASH fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SCHEME_HASH>(); }
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_HASH fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SCHEME_HASH>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_HASH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SCHEME_HASH(*this); }
}; // class TPMS_SCHEME_HASH

/** This definition is for split signing schemes that require a commit count.  */
class _DLLEXP_ TPMS_SCHEME_ECDAA : public virtual TpmStructure, public TPMU_SIG_SCHEME, public TPMU_ASYM_SCHEME
{
public:
    /** The hash algorithm used to digest the message  */
    TPM_ALG_ID hashAlg;
    
    /** The counter value that is used between TPM2_Commit() and the sign operation  */
    UINT16 count;

public:
    TPMS_SCHEME_ECDAA() { hashAlg = TPM_ALG_ID::_NULL; }
    TPMS_SCHEME_ECDAA(TPM_ALG_ID _hashAlg, UINT16 _count)
      : hashAlg(_hashAlg), count(_count)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDAA; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_ECDAA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SCHEME_ECDAA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_ECDAA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SCHEME_ECDAA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_ECDAA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SCHEME_ECDAA(*this); }
}; // class TPMS_SCHEME_ECDAA

/** Table 155 Definition of Types for HMAC_SIG_SCHEME  */
class _DLLEXP_ TPMS_SCHEME_HMAC : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_SCHEME_HMAC() {}
    TPMS_SCHEME_HMAC(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::HMAC; }
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_HMAC fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SCHEME_HMAC>(); }
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_HMAC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SCHEME_HMAC>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_HMAC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SCHEME_HMAC(*this); }
}; // class TPMS_SCHEME_HMAC

/** This structure is for the XOR encryption scheme.  */
class _DLLEXP_ TPMS_SCHEME_XOR : public virtual TpmStructure, public TPMU_SCHEME_KEYEDHASH
{
public:
    /** The hash algorithm used to digest the message  */
    TPM_ALG_ID hashAlg;
    
    /** The key derivation function  */
    TPM_ALG_ID kdf;

public:
    TPMS_SCHEME_XOR()
    {
        hashAlg = TPM_ALG_ID::_NULL;
        kdf = TPM_ALG_ID::_NULL;
    }
    
    TPMS_SCHEME_XOR(TPM_ALG_ID _hashAlg, TPM_ALG_ID _kdf)
      : hashAlg(_hashAlg), kdf(_kdf)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::XOR; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_XOR fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SCHEME_XOR>(); }
    
    /** Static marshaling helper  */
    static TPMS_SCHEME_XOR fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SCHEME_XOR>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SCHEME_XOR"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SCHEME_XOR(*this); }
}; // class TPMS_SCHEME_XOR

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SCHEME_KEYEDHASH
 */
class _DLLEXP_ TPMS_NULL_SCHEME_KEYEDHASH : public TPMS_NULL_UNION
{
public:
public:
    TPMS_NULL_SCHEME_KEYEDHASH() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SCHEME_KEYEDHASH fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NULL_SCHEME_KEYEDHASH>(); }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SCHEME_KEYEDHASH fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NULL_SCHEME_KEYEDHASH>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SCHEME_KEYEDHASH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_NULL_SCHEME_KEYEDHASH(*this); }
}; // class TPMS_NULL_SCHEME_KEYEDHASH

/** This structure is used for a hash signing object.  */
class _DLLEXP_ TPMT_KEYEDHASH_SCHEME : public TpmStructure
{
public:
    /** Selects the scheme  */
    public: TPM_ALG_ID scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The scheme parameters
     *  (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
     */
    shared_ptr<TPMU_SCHEME_KEYEDHASH> details;

public:
    TPMT_KEYEDHASH_SCHEME() {}
    TPMT_KEYEDHASH_SCHEME(const TPMU_SCHEME_KEYEDHASH& _details)
      : details(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_KEYEDHASH_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_KEYEDHASH_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMT_KEYEDHASH_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_KEYEDHASH_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_KEYEDHASH_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_KEYEDHASH_SCHEME(*this); }
}; // class TPMT_KEYEDHASH_SCHEME

/** These are the RSA schemes that only need a hash algorithm as a scheme parameter.  */
class _DLLEXP_ TPMS_SIG_SCHEME_RSASSA : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_SIG_SCHEME_RSASSA() {}
    TPMS_SIG_SCHEME_RSASSA(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSASSA; }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_RSASSA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIG_SCHEME_RSASSA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_RSASSA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIG_SCHEME_RSASSA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_RSASSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIG_SCHEME_RSASSA(*this); }
}; // class TPMS_SIG_SCHEME_RSASSA

/** These are the RSA schemes that only need a hash algorithm as a scheme parameter.  */
class _DLLEXP_ TPMS_SIG_SCHEME_RSAPSS : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_SIG_SCHEME_RSAPSS() {}
    TPMS_SIG_SCHEME_RSAPSS(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAPSS; }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_RSAPSS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIG_SCHEME_RSAPSS>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_RSAPSS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIG_SCHEME_RSAPSS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_RSAPSS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIG_SCHEME_RSAPSS(*this); }
}; // class TPMS_SIG_SCHEME_RSAPSS

/** Most of the ECC signature schemes only require a hash algorithm to complete the
 *  definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
 *  count value so they are typed to be TPMS_SCHEME_ECDAA.
 */
class _DLLEXP_ TPMS_SIG_SCHEME_ECDSA : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_SIG_SCHEME_ECDSA() {}
    TPMS_SIG_SCHEME_ECDSA(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDSA; }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_ECDSA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIG_SCHEME_ECDSA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_ECDSA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIG_SCHEME_ECDSA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_ECDSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIG_SCHEME_ECDSA(*this); }
}; // class TPMS_SIG_SCHEME_ECDSA

/** Most of the ECC signature schemes only require a hash algorithm to complete the
 *  definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
 *  count value so they are typed to be TPMS_SCHEME_ECDAA.
 */
class _DLLEXP_ TPMS_SIG_SCHEME_SM2 : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_SIG_SCHEME_SM2() {}
    TPMS_SIG_SCHEME_SM2(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SM2; }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_SM2 fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIG_SCHEME_SM2>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_SM2 fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIG_SCHEME_SM2>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_SM2"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIG_SCHEME_SM2(*this); }
}; // class TPMS_SIG_SCHEME_SM2

/** Most of the ECC signature schemes only require a hash algorithm to complete the
 *  definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
 *  count value so they are typed to be TPMS_SCHEME_ECDAA.
 */
class _DLLEXP_ TPMS_SIG_SCHEME_ECSCHNORR : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_SIG_SCHEME_ECSCHNORR() {}
    TPMS_SIG_SCHEME_ECSCHNORR(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECSCHNORR; }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_ECSCHNORR fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIG_SCHEME_ECSCHNORR>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_ECSCHNORR fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIG_SCHEME_ECSCHNORR>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_ECSCHNORR"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIG_SCHEME_ECSCHNORR(*this); }
}; // class TPMS_SIG_SCHEME_ECSCHNORR

/** Most of the ECC signature schemes only require a hash algorithm to complete the
 *  definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
 *  count value so they are typed to be TPMS_SCHEME_ECDAA.
 */
class _DLLEXP_ TPMS_SIG_SCHEME_ECDAA : public TPMS_SCHEME_ECDAA
{
public:
public:
    TPMS_SIG_SCHEME_ECDAA() {}
    TPMS_SIG_SCHEME_ECDAA(TPM_ALG_ID _hashAlg, UINT16 _count)
      : TPMS_SCHEME_ECDAA(_hashAlg, _count)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDAA; }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_ECDAA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIG_SCHEME_ECDAA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIG_SCHEME_ECDAA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIG_SCHEME_ECDAA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIG_SCHEME_ECDAA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIG_SCHEME_ECDAA(*this); }
}; // class TPMS_SIG_SCHEME_ECDAA

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIG_SCHEME
 */
class _DLLEXP_ TPMS_NULL_SIG_SCHEME : public TPMS_NULL_UNION
{
public:
public:
    TPMS_NULL_SIG_SCHEME() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SIG_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NULL_SIG_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SIG_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NULL_SIG_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SIG_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_NULL_SIG_SCHEME(*this); }
}; // class TPMS_NULL_SIG_SCHEME

/** Table 162 Definition of TPMT_SIG_SCHEME Structure  */
class _DLLEXP_ TPMT_SIG_SCHEME : public TpmStructure
{
public:
    /** Scheme selector  */
    public: TPM_ALG_ID scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Scheme parameters
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> details;

public:
    TPMT_SIG_SCHEME() {}
    TPMT_SIG_SCHEME(const TPMU_SIG_SCHEME& _details)
      : details(dynamic_cast<TPMU_SIG_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_SIG_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_SIG_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMT_SIG_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_SIG_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_SIG_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_SIG_SCHEME(*this); }
}; // class TPMT_SIG_SCHEME

/** These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.  */
class _DLLEXP_ TPMS_ENC_SCHEME_OAEP : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_ENC_SCHEME_OAEP() {}
    TPMS_ENC_SCHEME_OAEP(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::OAEP; }
    
    /** Static marshaling helper  */
    static TPMS_ENC_SCHEME_OAEP fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ENC_SCHEME_OAEP>(); }
    
    /** Static marshaling helper  */
    static TPMS_ENC_SCHEME_OAEP fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ENC_SCHEME_OAEP>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ENC_SCHEME_OAEP"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_ENC_SCHEME_OAEP(*this); }
}; // class TPMS_ENC_SCHEME_OAEP

/** These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.  */
class _DLLEXP_ TPMS_ENC_SCHEME_RSAES : public TPMS_EMPTY
{
public:
public:
    TPMS_ENC_SCHEME_RSAES() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAES; }
    
    /** Static marshaling helper  */
    static TPMS_ENC_SCHEME_RSAES fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ENC_SCHEME_RSAES>(); }
    
    /** Static marshaling helper  */
    static TPMS_ENC_SCHEME_RSAES fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ENC_SCHEME_RSAES>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ENC_SCHEME_RSAES"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_ENC_SCHEME_RSAES(*this); }
}; // class TPMS_ENC_SCHEME_RSAES

/** These are the ECC schemes that only need a hash algorithm as a controlling parameter.  */
class _DLLEXP_ TPMS_KEY_SCHEME_ECDH : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_KEY_SCHEME_ECDH() {}
    TPMS_KEY_SCHEME_ECDH(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDH; }
    
    /** Static marshaling helper  */
    static TPMS_KEY_SCHEME_ECDH fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_KEY_SCHEME_ECDH>(); }
    
    /** Static marshaling helper  */
    static TPMS_KEY_SCHEME_ECDH fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_KEY_SCHEME_ECDH>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_KEY_SCHEME_ECDH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_KEY_SCHEME_ECDH(*this); }
}; // class TPMS_KEY_SCHEME_ECDH

/** These are the ECC schemes that only need a hash algorithm as a controlling parameter.  */
class _DLLEXP_ TPMS_KEY_SCHEME_ECMQV : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_KEY_SCHEME_ECMQV() {}
    TPMS_KEY_SCHEME_ECMQV(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECMQV; }
    
    /** Static marshaling helper  */
    static TPMS_KEY_SCHEME_ECMQV fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_KEY_SCHEME_ECMQV>(); }
    
    /** Static marshaling helper  */
    static TPMS_KEY_SCHEME_ECMQV fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_KEY_SCHEME_ECMQV>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_KEY_SCHEME_ECMQV"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_KEY_SCHEME_ECMQV(*this); }
}; // class TPMS_KEY_SCHEME_ECMQV

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
class _DLLEXP_ TPMS_KDF_SCHEME_MGF1 : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_KDF_SCHEME_MGF1() {}
    TPMS_KDF_SCHEME_MGF1(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::MGF1; }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_MGF1 fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_KDF_SCHEME_MGF1>(); }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_MGF1 fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_KDF_SCHEME_MGF1>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_MGF1"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_KDF_SCHEME_MGF1(*this); }
}; // class TPMS_KDF_SCHEME_MGF1

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
class _DLLEXP_ TPMS_KDF_SCHEME_KDF1_SP800_56A : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_KDF_SCHEME_KDF1_SP800_56A() {}
    TPMS_KDF_SCHEME_KDF1_SP800_56A(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KDF1_SP800_56A; }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_KDF1_SP800_56A fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_KDF_SCHEME_KDF1_SP800_56A>(); }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_KDF1_SP800_56A fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_KDF_SCHEME_KDF1_SP800_56A>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_KDF1_SP800_56A"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_KDF_SCHEME_KDF1_SP800_56A(*this); }
}; // class TPMS_KDF_SCHEME_KDF1_SP800_56A

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
class _DLLEXP_ TPMS_KDF_SCHEME_KDF2 : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_KDF_SCHEME_KDF2() {}
    TPMS_KDF_SCHEME_KDF2(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KDF2; }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_KDF2 fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_KDF_SCHEME_KDF2>(); }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_KDF2 fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_KDF_SCHEME_KDF2>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_KDF2"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_KDF_SCHEME_KDF2(*this); }
}; // class TPMS_KDF_SCHEME_KDF2

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
class _DLLEXP_ TPMS_KDF_SCHEME_KDF1_SP800_108 : public TPMS_SCHEME_HASH
{
public:
public:
    TPMS_KDF_SCHEME_KDF1_SP800_108() {}
    TPMS_KDF_SCHEME_KDF1_SP800_108(TPM_ALG_ID _hashAlg)
      : TPMS_SCHEME_HASH(_hashAlg)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KDF1_SP800_108; }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_KDF1_SP800_108 fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_KDF_SCHEME_KDF1_SP800_108>(); }
    
    /** Static marshaling helper  */
    static TPMS_KDF_SCHEME_KDF1_SP800_108 fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_KDF_SCHEME_KDF1_SP800_108>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_KDF_SCHEME_KDF1_SP800_108"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_KDF_SCHEME_KDF1_SP800_108(*this); }
}; // class TPMS_KDF_SCHEME_KDF1_SP800_108

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_KDF_SCHEME
 */
class _DLLEXP_ TPMS_NULL_KDF_SCHEME : public TPMS_NULL_UNION
{
public:
public:
    TPMS_NULL_KDF_SCHEME() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    /** Static marshaling helper  */
    static TPMS_NULL_KDF_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NULL_KDF_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMS_NULL_KDF_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NULL_KDF_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NULL_KDF_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_NULL_KDF_SCHEME(*this); }
}; // class TPMS_NULL_KDF_SCHEME

/** Table 167 Definition of TPMT_KDF_SCHEME Structure  */
class _DLLEXP_ TPMT_KDF_SCHEME : public TpmStructure
{
public:
    /** Scheme selector  */
    public: TPM_ALG_ID scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Scheme parameters
     *  (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
     *  TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
     */
    shared_ptr<TPMU_KDF_SCHEME> details;

public:
    TPMT_KDF_SCHEME() {}
    TPMT_KDF_SCHEME(const TPMU_KDF_SCHEME& _details)
      : details(dynamic_cast<TPMU_KDF_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_KDF_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_KDF_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMT_KDF_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_KDF_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_KDF_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_KDF_SCHEME(*this); }
}; // class TPMT_KDF_SCHEME

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_ASYM_SCHEME
 */
class _DLLEXP_ TPMS_NULL_ASYM_SCHEME : public TPMS_NULL_UNION
{
public:
public:
    TPMS_NULL_ASYM_SCHEME() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    /** Static marshaling helper  */
    static TPMS_NULL_ASYM_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NULL_ASYM_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMS_NULL_ASYM_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NULL_ASYM_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NULL_ASYM_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_NULL_ASYM_SCHEME(*this); }
}; // class TPMS_NULL_ASYM_SCHEME

/** This structure is defined to allow overlay of all of the schemes for any asymmetric
 *  object. This structure is not sent on the interface. It is defined so that common
 *  functions may operate on any similar scheme structure.
 */
class _DLLEXP_ TPMT_ASYM_SCHEME : public TpmStructure
{
public:
    /** Scheme selector  */
    public: TPM_ALG_ID scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Scheme parameters
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_ASYM_SCHEME() {}
    TPMT_ASYM_SCHEME(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_ASYM_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_ASYM_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMT_ASYM_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_ASYM_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_ASYM_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_ASYM_SCHEME(*this); }
}; // class TPMT_ASYM_SCHEME

/** Table 172 Definition of {RSA} TPMT_RSA_SCHEME Structure  */
class _DLLEXP_ TPMT_RSA_SCHEME : public TpmStructure
{
public:
    /** Scheme selector  */
    public: TPM_ALG_ID scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Scheme parameters
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_RSA_SCHEME() {}
    TPMT_RSA_SCHEME(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_RSA_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_RSA_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMT_RSA_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_RSA_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_RSA_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_RSA_SCHEME(*this); }
}; // class TPMT_RSA_SCHEME

/** Table 174 Definition of {RSA} TPMT_RSA_DECRYPT Structure  */
class _DLLEXP_ TPMT_RSA_DECRYPT : public TpmStructure
{
public:
    /** Scheme selector  */
    public: TPM_ALG_ID scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Scheme parameters
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_RSA_DECRYPT() {}
    TPMT_RSA_DECRYPT(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_RSA_DECRYPT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_RSA_DECRYPT>(); }
    
    /** Static marshaling helper  */
    static TPMT_RSA_DECRYPT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_RSA_DECRYPT>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_RSA_DECRYPT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_RSA_DECRYPT(*this); }
}; // class TPMT_RSA_DECRYPT

/** This sized buffer holds the largest RSA public key supported by the TPM.  */
class _DLLEXP_ TPM2B_PUBLIC_KEY_RSA : public virtual TpmStructure, public TPMU_PUBLIC_ID
{
public:
    /** Value  */
    ByteVec buffer;

public:
    TPM2B_PUBLIC_KEY_RSA() {}
    TPM2B_PUBLIC_KEY_RSA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_PUBLIC_KEY_RSA fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_PUBLIC_KEY_RSA>(); }
    
    /** Static marshaling helper  */
    static TPM2B_PUBLIC_KEY_RSA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_PUBLIC_KEY_RSA>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_PUBLIC_KEY_RSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_PUBLIC_KEY_RSA(*this); }
}; // class TPM2B_PUBLIC_KEY_RSA

/** This sized buffer holds the largest RSA prime number supported by the TPM.  */
class _DLLEXP_ TPM2B_PRIVATE_KEY_RSA : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
public:
    ByteVec buffer;

public:
    TPM2B_PRIVATE_KEY_RSA() {}
    TPM2B_PRIVATE_KEY_RSA(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_PRIVATE_KEY_RSA fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_PRIVATE_KEY_RSA>(); }
    
    /** Static marshaling helper  */
    static TPM2B_PRIVATE_KEY_RSA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_PRIVATE_KEY_RSA>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_PRIVATE_KEY_RSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_PRIVATE_KEY_RSA(*this); }
}; // class TPM2B_PRIVATE_KEY_RSA

/** This sized buffer holds the largest ECC parameter (coordinate) supported by the TPM.  */
class _DLLEXP_ TPM2B_ECC_PARAMETER : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
public:
    /** The parameter data  */
    ByteVec buffer;

public:
    TPM2B_ECC_PARAMETER() {}
    TPM2B_ECC_PARAMETER(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECC; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_ECC_PARAMETER fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_ECC_PARAMETER>(); }
    
    /** Static marshaling helper  */
    static TPM2B_ECC_PARAMETER fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_ECC_PARAMETER>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_ECC_PARAMETER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_ECC_PARAMETER(*this); }
}; // class TPM2B_ECC_PARAMETER

/** This structure holds two ECC coordinates that, together, make up an ECC point.  */
class _DLLEXP_ TPMS_ECC_POINT : public virtual TpmStructure, public TPMU_PUBLIC_ID
{
public:
    /** X coordinate  */
    ByteVec x;
    
    /** Y coordinate  */
    ByteVec y;

public:
    TPMS_ECC_POINT() {}
    TPMS_ECC_POINT(const ByteVec& _x, const ByteVec& _y)
      : x(_x), y(_y)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECC; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ECC_POINT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ECC_POINT>(); }
    
    /** Static marshaling helper  */
    static TPMS_ECC_POINT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ECC_POINT>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ECC_POINT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ECC_POINT(*this); }
}; // class TPMS_ECC_POINT

/** This structure is defined to allow a point to be a single sized parameter so that it
 *  may be encrypted.
 */
class _DLLEXP_ TPM2B_ECC_POINT : public TpmStructure
{
public:
    /** Coordinates  */
    TPMS_ECC_POINT point;

public:
    TPM2B_ECC_POINT() {}
    TPM2B_ECC_POINT(const TPMS_ECC_POINT& _point)
      : point(_point)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_ECC_POINT fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_ECC_POINT>(); }
    
    /** Static marshaling helper  */
    static TPM2B_ECC_POINT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_ECC_POINT>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_ECC_POINT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_ECC_POINT(*this); }
}; // class TPM2B_ECC_POINT

/** Table 183 Definition of (TPMT_SIG_SCHEME) {ECC} TPMT_ECC_SCHEME Structure  */
class _DLLEXP_ TPMT_ECC_SCHEME : public TpmStructure
{
public:
    /** Scheme selector  */
    public: TPM_ALG_ID scheme() const { return details ? details->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Scheme parameters
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> details;

public:
    TPMT_ECC_SCHEME() {}
    TPMT_ECC_SCHEME(const TPMU_ASYM_SCHEME& _details)
      : details(dynamic_cast<TPMU_ASYM_SCHEME*>(_details.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_ECC_SCHEME fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_ECC_SCHEME>(); }
    
    /** Static marshaling helper  */
    static TPMT_ECC_SCHEME fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_ECC_SCHEME>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_ECC_SCHEME"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_ECC_SCHEME(*this); }
}; // class TPMT_ECC_SCHEME

/** This structure is used to report on the curve parameters of an ECC curve. It is
 *  returned by TPM2_ECC_Parameters().
 */
class _DLLEXP_ TPMS_ALGORITHM_DETAIL_ECC : public TpmStructure
{
public:
    /** Identifier for the curve  */
    TPM_ECC_CURVE curveID;
    
    /** Size in bits of the key  */
    UINT16 keySize;
    
    /** Scheme selector  */
    public: TPM_ALG_ID kdfScheme() const { return kdf ? kdf->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** If not TPM_ALG_NULL, the required KDF and hash algorithm used in secret sharing operations
     *  (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
     *  TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
     */
    shared_ptr<TPMU_KDF_SCHEME> kdf;
    
    /** Scheme selector  */
    public: TPM_ALG_ID signScheme() const { return sign ? sign->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** If not TPM_ALG_NULL, this is the mandatory signature scheme that is required to be
     *  used with this curve.
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> sign;
    
    /** Fp (the modulus)  */
    ByteVec p;
    
    /** Coefficient of the linear term in the curve equation  */
    ByteVec a;
    
    /** Constant term for curve equation  */
    ByteVec b;
    
    /** X coordinate of base point G  */
    ByteVec gX;
    
    /** Y coordinate of base point G  */
    ByteVec gY;
    
    /** Order of G  */
    ByteVec n;
    
    /** Cofactor (a size of zero indicates a cofactor of 1)  */
    ByteVec h;

public:
    TPMS_ALGORITHM_DETAIL_ECC() {}
    TPMS_ALGORITHM_DETAIL_ECC(TPM_ECC_CURVE _curveID, UINT16 _keySize, const TPMU_KDF_SCHEME& _kdf, const TPMU_ASYM_SCHEME& _sign, const ByteVec& _p, const ByteVec& _a, const ByteVec& _b, const ByteVec& _gX, const ByteVec& _gY, const ByteVec& _n, const ByteVec& _h)
      : curveID(_curveID), keySize(_keySize), kdf(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone())), sign(dynamic_cast<TPMU_ASYM_SCHEME*>(_sign.Clone())), p(_p), a(_a), b(_b), gX(_gX), gY(_gY), n(_n), h(_h)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ALGORITHM_DETAIL_ECC fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ALGORITHM_DETAIL_ECC>(); }
    
    /** Static marshaling helper  */
    static TPMS_ALGORITHM_DETAIL_ECC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ALGORITHM_DETAIL_ECC>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ALGORITHM_DETAIL_ECC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ALGORITHM_DETAIL_ECC(*this); }
}; // class TPMS_ALGORITHM_DETAIL_ECC

/** Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure  */
class _DLLEXP_ TPMS_SIGNATURE_RSA : public virtual TpmStructure, public TPMU_SIGNATURE
{
public:
    /** The hash algorithm used to digest the message
     *  TPM_ALG_NULL is not allowed.
     */
    TPM_ALG_ID hash;
    
    /** The signature is the size of a public key.  */
    ByteVec sig;

public:
    TPMS_SIGNATURE_RSA() { hash = TPM_ALG_ID::_NULL; }
    TPMS_SIGNATURE_RSA(TPM_ALG_ID _hash, const ByteVec& _sig)
      : hash(_hash), sig(_sig)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSASSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_RSA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_RSA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_RSA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_RSA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_RSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_RSA(*this); }
}; // class TPMS_SIGNATURE_RSA

/** Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure  */
class _DLLEXP_ TPMS_SIGNATURE_RSASSA : public TPMS_SIGNATURE_RSA
{
public:
public:
    TPMS_SIGNATURE_RSASSA() {}
    TPMS_SIGNATURE_RSASSA(TPM_ALG_ID _hash, const ByteVec& _sig)
      : TPMS_SIGNATURE_RSA(_hash, _sig)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSASSA; }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_RSASSA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_RSASSA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_RSASSA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_RSASSA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_RSASSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_RSASSA(*this); }
}; // class TPMS_SIGNATURE_RSASSA

/** Table 185 Definition of {RSA} TPMS_SIGNATURE_RSA Structure  */
class _DLLEXP_ TPMS_SIGNATURE_RSAPSS : public TPMS_SIGNATURE_RSA
{
public:
public:
    TPMS_SIGNATURE_RSAPSS() {}
    TPMS_SIGNATURE_RSAPSS(TPM_ALG_ID _hash, const ByteVec& _sig)
      : TPMS_SIGNATURE_RSA(_hash, _sig)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSAPSS; }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_RSAPSS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_RSAPSS>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_RSAPSS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_RSAPSS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_RSAPSS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_RSAPSS(*this); }
}; // class TPMS_SIGNATURE_RSAPSS

/** Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure  */
class _DLLEXP_ TPMS_SIGNATURE_ECC : public virtual TpmStructure, public TPMU_SIGNATURE
{
public:
    /** The hash algorithm used in the signature process
     *  TPM_ALG_NULL is not allowed.
     */
    TPM_ALG_ID hash;
    
    ByteVec signatureR;
    
    ByteVec signatureS;

public:
    TPMS_SIGNATURE_ECC() { hash = TPM_ALG_ID::_NULL; }
    TPMS_SIGNATURE_ECC(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : hash(_hash), signatureR(_signatureR), signatureS(_signatureS)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECC fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_ECC>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_ECC>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_ECC(*this); }
}; // class TPMS_SIGNATURE_ECC

/** Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure  */
class _DLLEXP_ TPMS_SIGNATURE_ECDSA : public TPMS_SIGNATURE_ECC
{
public:
public:
    TPMS_SIGNATURE_ECDSA() {}
    TPMS_SIGNATURE_ECDSA(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDSA; }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECDSA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_ECDSA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECDSA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_ECDSA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECDSA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_ECDSA(*this); }
}; // class TPMS_SIGNATURE_ECDSA

/** Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure  */
class _DLLEXP_ TPMS_SIGNATURE_ECDAA : public TPMS_SIGNATURE_ECC
{
public:
public:
    TPMS_SIGNATURE_ECDAA() {}
    TPMS_SIGNATURE_ECDAA(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECDAA; }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECDAA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_ECDAA>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECDAA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_ECDAA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECDAA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_ECDAA(*this); }
}; // class TPMS_SIGNATURE_ECDAA

/** Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure  */
class _DLLEXP_ TPMS_SIGNATURE_SM2 : public TPMS_SIGNATURE_ECC
{
public:
public:
    TPMS_SIGNATURE_SM2() {}
    TPMS_SIGNATURE_SM2(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SM2; }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_SM2 fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_SM2>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_SM2 fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_SM2>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_SM2"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_SM2(*this); }
}; // class TPMS_SIGNATURE_SM2

/** Table 187 Definition of {ECC} TPMS_SIGNATURE_ECC Structure  */
class _DLLEXP_ TPMS_SIGNATURE_ECSCHNORR : public TPMS_SIGNATURE_ECC
{
public:
public:
    TPMS_SIGNATURE_ECSCHNORR() {}
    TPMS_SIGNATURE_ECSCHNORR(TPM_ALG_ID _hash, const ByteVec& _signatureR, const ByteVec& _signatureS)
      : TPMS_SIGNATURE_ECC(_hash, _signatureR, _signatureS)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECSCHNORR; }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECSCHNORR fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_SIGNATURE_ECSCHNORR>(); }
    
    /** Static marshaling helper  */
    static TPMS_SIGNATURE_ECSCHNORR fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_SIGNATURE_ECSCHNORR>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_SIGNATURE_ECSCHNORR"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_SIGNATURE_ECSCHNORR(*this); }
}; // class TPMS_SIGNATURE_ECSCHNORR

/** Custom data structure representing an empty element (i.e. the one with 
 *  no data to marshal) for selector algorithm TPM_ALG_NULL for the union TPMU_SIGNATURE
 */
class _DLLEXP_ TPMS_NULL_SIGNATURE : public TPMS_NULL_UNION
{
public:
public:
    TPMS_NULL_SIGNATURE() {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::_NULL; }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SIGNATURE fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NULL_SIGNATURE>(); }
    
    /** Static marshaling helper  */
    static TPMS_NULL_SIGNATURE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NULL_SIGNATURE>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NULL_SIGNATURE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPMS_NULL_SIGNATURE(*this); }
}; // class TPMS_NULL_SIGNATURE

/** Table 190 shows the basic algorithm-agile structure when a symmetric or asymmetric
 *  signature is indicated. The sigAlg parameter indicates the algorithm used for the
 *  signature. This structure is output from commands such as the attestation commands and
 *  TPM2_Sign, and is an input to commands such as TPM2_VerifySignature(),
 *  TPM2_PolicySigned(), and TPM2_FieldUpgradeStart().
 */
class _DLLEXP_ TPMT_SIGNATURE : public TpmStructure
{
public:
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID sigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** This shall be the actual signature information.
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    TPMT_SIGNATURE() {}
    TPMT_SIGNATURE(const TPMU_SIGNATURE& _signature)
      : signature(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_SIGNATURE fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_SIGNATURE>(); }
    
    /** Static marshaling helper  */
    static TPMT_SIGNATURE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_SIGNATURE>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_SIGNATURE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_SIGNATURE(*this); }
}; // class TPMT_SIGNATURE

/** Table 192 Definition of TPM2B_ENCRYPTED_SECRET Structure  */
class _DLLEXP_ TPM2B_ENCRYPTED_SECRET : public TpmStructure
{
public:
    /** Secret  */
    ByteVec secret;

public:
    TPM2B_ENCRYPTED_SECRET() {}
    TPM2B_ENCRYPTED_SECRET(const ByteVec& _secret)
      : secret(_secret)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_ENCRYPTED_SECRET fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_ENCRYPTED_SECRET>(); }
    
    /** Static marshaling helper  */
    static TPM2B_ENCRYPTED_SECRET fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_ENCRYPTED_SECRET>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_ENCRYPTED_SECRET"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_ENCRYPTED_SECRET(*this); }
}; // class TPM2B_ENCRYPTED_SECRET

/** This structure describes the parameters that would appear in the public area of a
 *  KEYEDHASH object.
 */
class _DLLEXP_ TPMS_KEYEDHASH_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
public:
    /** Selects the scheme  */
    public: TPM_ALG_ID schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Indicates the signing method used for a keyedHash signing object. This field also
     *  determines the size of the data field for a data object created with TPM2_Create() or
     *  TPM2_CreatePrimary().
     *  (One of [TPMS_SCHEME_HMAC, TPMS_SCHEME_XOR, TPMS_NULL_SCHEME_KEYEDHASH])
     */
    shared_ptr<TPMU_SCHEME_KEYEDHASH> scheme;

public:
    TPMS_KEYEDHASH_PARMS() {}
    TPMS_KEYEDHASH_PARMS(const TPMU_SCHEME_KEYEDHASH& _scheme)
      : scheme(dynamic_cast<TPMU_SCHEME_KEYEDHASH*>(_scheme.Clone()))
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_KEYEDHASH_PARMS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_KEYEDHASH_PARMS>(); }
    
    /** Static marshaling helper  */
    static TPMS_KEYEDHASH_PARMS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_KEYEDHASH_PARMS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_KEYEDHASH_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_KEYEDHASH_PARMS(*this); }
}; // class TPMS_KEYEDHASH_PARMS

/** This structure contains the common public area parameters for an asymmetric key. The
 *  first two parameters of the parameter definition structures of an asymmetric key shall
 *  have the same two first components.
 */
class _DLLEXP_ TPMS_ASYM_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
public:
    /** The companion symmetric algorithm for a restricted decryption key and shall be set to
     *  a supported symmetric algorithm
     *  This field is optional for keys that are not decryption keys and shall be set to
     *  TPM_ALG_NULL if not used.
     */
    TPMT_SYM_DEF_OBJECT symmetric;
    
    /** Scheme selector  */
    public: TPM_ALG_ID schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** For a key with the sign attribute SET, a valid signing scheme for the key type
     *  for a key with the decrypt attribute SET, a valid key exchange protocol
     *  for a key with sign and decrypt attributes, shall be TPM_ALG_NULL
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> scheme;

public:
    TPMS_ASYM_PARMS() {}
    TPMS_ASYM_PARMS(const TPMT_SYM_DEF_OBJECT& _symmetric, const TPMU_ASYM_SCHEME& _scheme)
      : symmetric(_symmetric), scheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone()))
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ASYM_PARMS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ASYM_PARMS>(); }
    
    /** Static marshaling helper  */
    static TPMS_ASYM_PARMS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ASYM_PARMS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ASYM_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ASYM_PARMS(*this); }
}; // class TPMS_ASYM_PARMS

/** A TPM compatible with this specification and supporting RSA shall support two primes
 *  and an exponent of zero. An exponent of zero indicates that the exponent is the
 *  default of 216 + 1. Support for other values is optional. Use of other exponents in
 *  duplicated keys is not recommended because the resulting keys would not be
 *  interoperable with other TPMs.
 */
class _DLLEXP_ TPMS_RSA_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
public:
    /** For a restricted decryption key, shall be set to a supported symmetric algorithm, key
     *  size, and mode.
     *  if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
     */
    TPMT_SYM_DEF_OBJECT symmetric;
    
    /** Scheme selector  */
    public: TPM_ALG_ID schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Scheme.scheme shall be:
     *  for an unrestricted signing key, either TPM_ALG_RSAPSS TPM_ALG_RSASSA or TPM_ALG_NULL
     *  for a restricted signing key, either TPM_ALG_RSAPSS or TPM_ALG_RSASSA
     *  for an unrestricted decryption key, TPM_ALG_RSAES, TPM_ALG_OAEP, or TPM_ALG_NULL
     *  unless the object also has the sign attribute
     *  for a restricted decryption key, TPM_ALG_NULL
     *  NOTE When both sign and decrypt are SET, restricted shall be CLEAR and scheme shall be
     *  TPM_ALG_NULL.
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> scheme;
    
    /** Number of bits in the public modulus  */
    UINT16 keyBits;
    
    /** The public exponent
     *  A prime number greater than 2.
     */
    UINT32 exponent;

public:
    TPMS_RSA_PARMS() {}
    TPMS_RSA_PARMS(const TPMT_SYM_DEF_OBJECT& _symmetric, const TPMU_ASYM_SCHEME& _scheme, UINT16 _keyBits, UINT32 _exponent)
      : symmetric(_symmetric), scheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone())), keyBits(_keyBits), exponent(_exponent)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::RSA; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_RSA_PARMS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_RSA_PARMS>(); }
    
    /** Static marshaling helper  */
    static TPMS_RSA_PARMS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_RSA_PARMS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_RSA_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_RSA_PARMS(*this); }
}; // class TPMS_RSA_PARMS

/** This structure contains the parameters for prime modulus ECC.  */
class _DLLEXP_ TPMS_ECC_PARMS : public virtual TpmStructure, public TPMU_PUBLIC_PARMS
{
public:
    /** For a restricted decryption key, shall be set to a supported symmetric algorithm, key
     *  size. and mode.
     *  if the key is not a restricted decryption key, this field shall be set to TPM_ALG_NULL.
     */
    TPMT_SYM_DEF_OBJECT symmetric;
    
    /** Scheme selector  */
    public: TPM_ALG_ID schemeScheme() const { return scheme ? scheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** If the sign attribute of the key is SET, then this shall be a valid signing scheme.
     *  NOTE If the sign parameter in curveID indicates a mandatory scheme, then this field
     *  shall have the same value.
     *  If the decrypt attribute of the key is SET, then this shall be a valid key exchange
     *  scheme or TPM_ALG_NULL.
     *  If the key is a Storage Key, then this field shall be TPM_ALG_NULL.
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> scheme;
    
    /** ECC curve ID  */
    TPM_ECC_CURVE curveID;
    
    /** Scheme selector  */
    public: TPM_ALG_ID kdfScheme() const { return kdf ? kdf->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** An optional key derivation scheme for generating a symmetric key from a Z value
     *  If the kdf parameter associated with curveID is not TPM_ALG_NULL then this is required
     *  to be NULL.
     *  NOTE There are currently no commands where this parameter has effect and, in the
     *  reference code, this field needs to be set to TPM_ALG_NULL.
     *  (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
     *  TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
     */
    shared_ptr<TPMU_KDF_SCHEME> kdf;

public:
    TPMS_ECC_PARMS() {}
    TPMS_ECC_PARMS(const TPMT_SYM_DEF_OBJECT& _symmetric, const TPMU_ASYM_SCHEME& _scheme, TPM_ECC_CURVE _curveID, const TPMU_KDF_SCHEME& _kdf)
      : symmetric(_symmetric), scheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_scheme.Clone())), curveID(_curveID), kdf(dynamic_cast<TPMU_KDF_SCHEME*>(_kdf.Clone()))
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ECC; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ECC_PARMS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ECC_PARMS>(); }
    
    /** Static marshaling helper  */
    static TPMS_ECC_PARMS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ECC_PARMS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ECC_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ECC_PARMS(*this); }
}; // class TPMS_ECC_PARMS

/** This structure is used in TPM2_TestParms() to validate that a set of algorithm
 *  parameters is supported by the TPM.
 */
class _DLLEXP_ TPMT_PUBLIC_PARMS : public TpmStructure
{
public:
    /** The algorithm to be tested  */
    public: TPM_ALG_ID type() const { return parameters->GetUnionSelector(); }
    
    /** The algorithm details
     *  (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
     *  TPMS_ASYM_PARMS])
     */
    shared_ptr<TPMU_PUBLIC_PARMS> parameters;

public:
    TPMT_PUBLIC_PARMS() {}
    TPMT_PUBLIC_PARMS(const TPMU_PUBLIC_PARMS& _parameters)
      : parameters(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_PUBLIC_PARMS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_PUBLIC_PARMS>(); }
    
    /** Static marshaling helper  */
    static TPMT_PUBLIC_PARMS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_PUBLIC_PARMS>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_PUBLIC_PARMS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_PUBLIC_PARMS(*this); }
}; // class TPMT_PUBLIC_PARMS

/** Table 201 defines the public area structure. The Name of the object is nameAlg
 *  concatenated with the digest of this structure using nameAlg.
 */
class _DLLEXP_ TPMT_PUBLIC : public TpmStructure
{
public:
    /** Algorithm associated with this object  */
    public: TPM_ALG_ID type() const { return parameters->GetUnionSelector(); }
    
    /** Algorithm used for computing the Name of the object
     *  NOTE The "+" indicates that the instance of a TPMT_PUBLIC may have a "+" to indicate
     *  that the nameAlg may be TPM_ALG_NULL.
     */
    TPM_ALG_ID nameAlg;
    
    /** Attributes that, along with type, determine the manipulations of this object  */
    TPMA_OBJECT objectAttributes;
    
    /** Optional policy for using this key
     *  The policy is computed using the nameAlg of the object.
     *  NOTE Shall be the Empty Policy if no authorization policy is present.
     */
    ByteVec authPolicy;
    
    /** The algorithm or structure details
     *  (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
     *  TPMS_ASYM_PARMS])
     */
    shared_ptr<TPMU_PUBLIC_PARMS> parameters;
    
    /** The unique identifier of the structure
     *  For an asymmetric key, this would be the public key.
     *  (One of [TPM2B_DIGEST_KEYEDHASH, TPM2B_DIGEST_SYMCIPHER, TPM2B_PUBLIC_KEY_RSA,
     *  TPMS_ECC_POINT, TPMS_DERIVE])
     */
    shared_ptr<TPMU_PUBLIC_ID> unique;

public:
    TPMT_PUBLIC() { nameAlg = TPM_ALG_ID::_NULL; }
    TPMT_PUBLIC(TPM_ALG_ID _nameAlg, TPMA_OBJECT _objectAttributes, const ByteVec& _authPolicy, const TPMU_PUBLIC_PARMS& _parameters, const TPMU_PUBLIC_ID& _unique)
      : nameAlg(_nameAlg), objectAttributes(_objectAttributes), authPolicy(_authPolicy), parameters(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone())), unique(dynamic_cast<TPMU_PUBLIC_ID*>(_unique.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_PUBLIC fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_PUBLIC>(); }
    
    /** Static marshaling helper  */
    static TPMT_PUBLIC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_PUBLIC>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_PUBLIC(*this); }
    
    /// <summary> Return the name of this TPMT_PUBLIC object (the hash-alg-prepended hash of the public area). </summary>
    ByteVec GetName() const;
    
    /// <summary> Validate a TPM-created signature. </summary>
    bool ValidateSignature(const ByteVec& signedData, const TPMU_SIGNATURE& sig);
    
    /// <summary> Validate a TPM-created quote-attestaion. </summary>
    bool ValidateQuote(const class PCR_ReadResponse& expectedPcrVals,
                       const ByteVec& Nonce, class QuoteResponse& quote) const;
    
    /// <summary> Validate a TPM-created key-certification. </summary>
    bool ValidateCertify(const TPMT_PUBLIC& certifiedKey, const ByteVec& Nonce,
                         class CertifyResponse& quote) const;
    
    /// <summary> Validate a TPM-created time-quote. </summary>
    bool ValidateGetTime(const ByteVec& Nonce, class GetTimeResponse& timeQuote) const;
    
    /// <summary> Validate a TPM-created key-certification. </summary>
    bool ValidateCommandAudit(const TPMT_HA& expectedHash, const ByteVec& Nonce,
                              class GetCommandAuditDigestResponse& quote) const;
    
    /// <summary> Validate a session-audit signature. </summary>
    bool ValidateSessionAudit(const TPMT_HA& expectedHash, const ByteVec& Nonce,
                              class GetSessionAuditDigestResponse& quote) const;
    
    /// <summary> Validate a key creation signature. </summary>
    bool ValidateCertifyCreation(const ByteVec& Nonce, const ByteVec& creationHash,
                                 class CertifyCreationResponse& quote) const;
    
    /// <summary> Validate a key creation signature. </summary>
    bool ValidateCertifyNV(const ByteVec& Nonce, const ByteVec& expectedContents,
                           UINT16 startOffset, class NV_CertifyResponse& quote) const;
    
    /// <summary> Encrypt: currently only RSA/OAEP. </summary>
    ByteVec Encrypt(const ByteVec& secret, const ByteVec& encodingParms) const;
    
    /// <summary> Creates an activation blob suitable for TPM2_ActivateCredential() on the TPM
    /// with the corresponding private key. </summary>
    class ActivationData CreateActivation(const ByteVec& secret, const ByteVec& activatedName) const;
    
    /// <summary> Encrypt session salt: currently only RSA/OAEP </summary>
    ByteVec EncryptSessionSalt(const ByteVec& _secret) const;
    
    /// <summary> Create an object that we can Import() to the storage key associated with this public key. </summary>
    class DuplicationBlob GetDuplicationBlob(Tpm2& tpm, const TPMT_PUBLIC& pub, const TPMT_SENSITIVE& sensitive,
                                             const TPMT_SYM_DEF_OBJECT& innerWrapper) const;
    
    [[deprecated("Use GetDuplicationBlob() instead")]]
    class DuplicationBlob CreateImportableObject(Tpm2& tpm, const TPMT_PUBLIC& pub, const TPMT_SENSITIVE& sensitive,
                                                 const TPMT_SYM_DEF_OBJECT& innerWrapper);
    
    /// <summary> Gets the algorithm of this key. </summary>
    [[deprecated("Use type() instead")]]
    TPM_ALG_ID GetAlg() const { return type(); }
    
}; // class TPMT_PUBLIC

/** This sized buffer is used to embed a TPMT_PUBLIC in a load command and in any response
 *  that returns a public area.
 */
class _DLLEXP_ TPM2B_PUBLIC : public TpmStructure
{
public:
    /** The public area
     *  NOTE The + indicates that the caller may specify that use of TPM_ALG_NULL is allowed
     *  for nameAlg.
     */
    TPMT_PUBLIC publicArea;

public:
    TPM2B_PUBLIC() {}
    TPM2B_PUBLIC(const TPMT_PUBLIC& _publicArea)
      : publicArea(_publicArea)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_PUBLIC fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_PUBLIC>(); }
    
    /** Static marshaling helper  */
    static TPM2B_PUBLIC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_PUBLIC>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_PUBLIC(*this); }
}; // class TPM2B_PUBLIC

/** This sized buffer is used to embed a TPMT_TEMPLATE for TPM2_CreateLoaded().  */
class _DLLEXP_ TPM2B_TEMPLATE : public TpmStructure
{
public:
    /** The public area  */
    ByteVec buffer;

public:
    TPM2B_TEMPLATE() {}
    TPM2B_TEMPLATE(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_TEMPLATE fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_TEMPLATE>(); }
    
    /** Static marshaling helper  */
    static TPM2B_TEMPLATE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_TEMPLATE>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_TEMPLATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_TEMPLATE(*this); }
}; // class TPM2B_TEMPLATE

/** This structure is defined for coding purposes. For IO to the TPM, the sensitive
 *  portion of the key will be in a canonical form. For an RSA key, this will be one of
 *  the prime factors of the public modulus. After loading, it is typical that other
 *  values will be computed so that computations using the private key will not need to
 *  start with just one prime factor. This structure can be used to store the results of
 *  such vendor-specific calculations.
 */
class _DLLEXP_ TPM2B_PRIVATE_VENDOR_SPECIFIC : public virtual TpmStructure, public TPMU_SENSITIVE_COMPOSITE
{
public:
    ByteVec buffer;

public:
    TPM2B_PRIVATE_VENDOR_SPECIFIC() {}
    TPM2B_PRIVATE_VENDOR_SPECIFIC(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::ANY; }
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_PRIVATE_VENDOR_SPECIFIC fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_PRIVATE_VENDOR_SPECIFIC>(); }
    
    /** Static marshaling helper  */
    static TPM2B_PRIVATE_VENDOR_SPECIFIC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_PRIVATE_VENDOR_SPECIFIC>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_PRIVATE_VENDOR_SPECIFIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_PRIVATE_VENDOR_SPECIFIC(*this); }
}; // class TPM2B_PRIVATE_VENDOR_SPECIFIC

/** AuthValue shall not be larger than the size of the digest produced by the nameAlg of
 *  the object. seedValue shall be the size of the digest produced by the nameAlg of the object.
 */
class _DLLEXP_ TPMT_SENSITIVE : public TpmStructure
{
public:
    /** Identifier for the sensitive area
     *  This shall be the same as the type parameter of the associated public area.
     */
    public: TPM_ALG_ID sensitiveType() const { return sensitive->GetUnionSelector(); }
    
    /** User authorization data
     *  The authValue may be a zero-length string.
     */
    ByteVec authValue;
    
    /** For a parent object, the optional protection seed; for other objects, the obfuscation value  */
    ByteVec seedValue;
    
    /** The type-specific private data
     *  (One of [TPM2B_PRIVATE_KEY_RSA, TPM2B_ECC_PARAMETER, TPM2B_SENSITIVE_DATA,
     *  TPM2B_SYM_KEY, TPM2B_PRIVATE_VENDOR_SPECIFIC])
     */
    shared_ptr<TPMU_SENSITIVE_COMPOSITE> sensitive;

public:
    TPMT_SENSITIVE() {}
    TPMT_SENSITIVE(const ByteVec& _authValue, const ByteVec& _seedValue, const TPMU_SENSITIVE_COMPOSITE& _sensitive)
      : authValue(_authValue), seedValue(_seedValue), sensitive(dynamic_cast<TPMU_SENSITIVE_COMPOSITE*>(_sensitive.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMT_SENSITIVE fromTpm(TpmBuffer& buf) { return buf.createObj<TPMT_SENSITIVE>(); }
    
    /** Static marshaling helper  */
    static TPMT_SENSITIVE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMT_SENSITIVE>(buf); }
    
    virtual const char* TypeName () const { return "TPMT_SENSITIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMT_SENSITIVE(*this); }
    
    /// <summary> Create an object suitable when the TPM needs a NULL-object input. </summary>
    [[deprecated("Use default ctor instead")]]
    static TPMT_SENSITIVE NullObject() { return TPMT_SENSITIVE(); };
    
}; // class TPMT_SENSITIVE

/** The TPM2B_SENSITIVE structure is used as a parameter in TPM2_LoadExternal(). It is an
 *  unencrypted sensitive area but it may be encrypted using parameter encryption.
 */
class _DLLEXP_ TPM2B_SENSITIVE : public TpmStructure
{
public:
    /** An unencrypted sensitive area  */
    TPMT_SENSITIVE sensitiveArea;

public:
    TPM2B_SENSITIVE() {}
    TPM2B_SENSITIVE(const TPMT_SENSITIVE& _sensitiveArea)
      : sensitiveArea(_sensitiveArea)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_SENSITIVE fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_SENSITIVE>(); }
    
    /** Static marshaling helper  */
    static TPM2B_SENSITIVE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_SENSITIVE>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_SENSITIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_SENSITIVE(*this); }
}; // class TPM2B_SENSITIVE

/** This structure is defined to size the contents of a TPM2B_PRIVATE. This structure is
 *  not directly marshaled or unmarshaled.
 */
class _DLLEXP_ _PRIVATE : public TpmStructure
{
public:
    ByteVec integrityOuter;
    
    /** Could also be a TPM2B_IV  */
    ByteVec integrityInner;
    
    /** The sensitive area  */
    TPMT_SENSITIVE sensitive;

public:
    _PRIVATE() {}
    _PRIVATE(const ByteVec& _integrityOuter, const ByteVec& _integrityInner, const TPMT_SENSITIVE& _sensitive)
      : integrityOuter(_integrityOuter), integrityInner(_integrityInner), sensitive(_sensitive)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static _PRIVATE fromTpm(TpmBuffer& buf) { return buf.createObj<_PRIVATE>(); }
    
    /** Static marshaling helper  */
    static _PRIVATE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<_PRIVATE>(buf); }
    
    virtual const char* TypeName () const { return "_PRIVATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new _PRIVATE(*this); }
}; // class _PRIVATE

/** The TPM2B_PRIVATE structure is used as a parameter in multiple commands that create,
 *  load, and modify the sensitive area of an object.
 */
class _DLLEXP_ TPM2B_PRIVATE : public TpmStructure
{
public:
    /** An encrypted private area  */
    ByteVec buffer;

public:
    TPM2B_PRIVATE() {}
    TPM2B_PRIVATE(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_PRIVATE fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_PRIVATE>(); }
    
    /** Static marshaling helper  */
    static TPM2B_PRIVATE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_PRIVATE>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_PRIVATE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_PRIVATE(*this); }
}; // class TPM2B_PRIVATE

/** This structure is used for sizing the TPM2B_ID_OBJECT.  */
class _DLLEXP_ TPMS_ID_OBJECT : public TpmStructure
{
public:
    /** HMAC using the nameAlg of the storage key on the target TPM  */
    ByteVec integrityHMAC;
    
    /** Credential protector information returned if name matches the referenced object
     *  All of the encIdentity is encrypted, including the size field.
     *  NOTE The TPM is not required to check that the size is not larger than the digest of
     *  the nameAlg. However, if the size is larger, the ID object may not be usable on a TPM
     *  that has no digest larger than produced by nameAlg.
     */
    ByteVec encIdentity;

public:
    TPMS_ID_OBJECT() {}
    TPMS_ID_OBJECT(const ByteVec& _integrityHMAC, const ByteVec& _encIdentity)
      : integrityHMAC(_integrityHMAC), encIdentity(_encIdentity)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_ID_OBJECT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_ID_OBJECT>(); }
    
    /** Static marshaling helper  */
    static TPMS_ID_OBJECT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_ID_OBJECT>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_ID_OBJECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_ID_OBJECT(*this); }
}; // class TPMS_ID_OBJECT

/** This structure is an output from TPM2_MakeCredential() and is an input to
 *  TPM2_ActivateCredential().
 */
class _DLLEXP_ TPM2B_ID_OBJECT : public TpmStructure
{
public:
    /** An encrypted credential area  */
    TPMS_ID_OBJECT credential;

public:
    TPM2B_ID_OBJECT() {}
    TPM2B_ID_OBJECT(const TPMS_ID_OBJECT& _credential)
      : credential(_credential)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_ID_OBJECT fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_ID_OBJECT>(); }
    
    /** Static marshaling helper  */
    static TPM2B_ID_OBJECT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_ID_OBJECT>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_ID_OBJECT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_ID_OBJECT(*this); }
}; // class TPM2B_ID_OBJECT

/** This is the data that can be written to and read from a TPM_NT_PIN_PASS or
 *  TPM_NT_PIN_FAIL non-volatile index. pinCount is the most significant octets. pinLimit
 *  is the least significant octets.
 */
class _DLLEXP_ TPMS_NV_PIN_COUNTER_PARAMETERS : public TpmStructure
{
public:
    /** This counter shows the current number of successful authValue authorization attempts
     *  to access a TPM_NT_PIN_PASS index or the current number of unsuccessful authValue
     *  authorization attempts to access a TPM_NT_PIN_FAIL index.
     */
    UINT32 pinCount;
    
    /** This threshold is the value of pinCount at which the authValue authorization of the
     *  host TPM_NT_PIN_PASS or TPM_NT_PIN_FAIL index is locked out.
     */
    UINT32 pinLimit;

public:
    TPMS_NV_PIN_COUNTER_PARAMETERS() {}
    TPMS_NV_PIN_COUNTER_PARAMETERS(UINT32 _pinCount, UINT32 _pinLimit)
      : pinCount(_pinCount), pinLimit(_pinLimit)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_NV_PIN_COUNTER_PARAMETERS fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NV_PIN_COUNTER_PARAMETERS>(); }
    
    /** Static marshaling helper  */
    static TPMS_NV_PIN_COUNTER_PARAMETERS fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NV_PIN_COUNTER_PARAMETERS>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NV_PIN_COUNTER_PARAMETERS"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_NV_PIN_COUNTER_PARAMETERS(*this); }
}; // class TPMS_NV_PIN_COUNTER_PARAMETERS

/** This structure describes an NV Index.  */
class _DLLEXP_ TPMS_NV_PUBLIC : public TpmStructure
{
public:
    /** The handle of the data area  */
    TPM_HANDLE nvIndex;
    
    /** Hash algorithm used to compute the name of the Index and used for the authPolicy. For
     *  an extend index, the hash algorithm used for the extend.
     */
    TPM_ALG_ID nameAlg;
    
    /** The Index attributes  */
    TPMA_NV attributes;
    
    /** Optional access policy for the Index
     *  The policy is computed using the nameAlg
     *  NOTE Shall be the Empty Policy if no authorization policy is present.
     */
    ByteVec authPolicy;
    
    /** The size of the data area
     *  The maximum size is implementation-dependent. The minimum maximum size is platform-specific.
     */
    UINT16 dataSize;

public:
    TPMS_NV_PUBLIC() { nameAlg = TPM_ALG_ID::_NULL; }
    TPMS_NV_PUBLIC(const TPM_HANDLE& _nvIndex, TPM_ALG_ID _nameAlg, TPMA_NV _attributes, const ByteVec& _authPolicy, UINT16 _dataSize)
      : nvIndex(_nvIndex), nameAlg(_nameAlg), attributes(_attributes), authPolicy(_authPolicy), dataSize(_dataSize)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_NV_PUBLIC fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_NV_PUBLIC>(); }
    
    /** Static marshaling helper  */
    static TPMS_NV_PUBLIC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_NV_PUBLIC>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_NV_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_NV_PUBLIC(*this); }
}; // class TPMS_NV_PUBLIC

/** This structure is used when a TPMS_NV_PUBLIC is sent on the TPM interface.  */
class _DLLEXP_ TPM2B_NV_PUBLIC : public TpmStructure
{
public:
    /** The public area  */
    TPMS_NV_PUBLIC nvPublic;

public:
    TPM2B_NV_PUBLIC() {}
    TPM2B_NV_PUBLIC(const TPMS_NV_PUBLIC& _nvPublic)
      : nvPublic(_nvPublic)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_NV_PUBLIC fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_NV_PUBLIC>(); }
    
    /** Static marshaling helper  */
    static TPM2B_NV_PUBLIC fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_NV_PUBLIC>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_NV_PUBLIC"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_NV_PUBLIC(*this); }
}; // class TPM2B_NV_PUBLIC

/** This structure holds the object or session context data. When saved, the full
 *  structure is encrypted.
 */
class _DLLEXP_ TPM2B_CONTEXT_SENSITIVE : public TpmStructure
{
public:
    /** The sensitive data  */
    ByteVec buffer;

public:
    TPM2B_CONTEXT_SENSITIVE() {}
    TPM2B_CONTEXT_SENSITIVE(const ByteVec& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_CONTEXT_SENSITIVE fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_CONTEXT_SENSITIVE>(); }
    
    /** Static marshaling helper  */
    static TPM2B_CONTEXT_SENSITIVE fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_CONTEXT_SENSITIVE>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_CONTEXT_SENSITIVE"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_CONTEXT_SENSITIVE(*this); }
}; // class TPM2B_CONTEXT_SENSITIVE

/** This structure holds the integrity value and the encrypted data for a context.  */
class _DLLEXP_ TPMS_CONTEXT_DATA : public TpmStructure
{
public:
    /** The integrity value  */
    ByteVec integrity;
    
    /** The sensitive area  */
    ByteVec encrypted;

public:
    TPMS_CONTEXT_DATA() {}
    TPMS_CONTEXT_DATA(const ByteVec& _integrity, const ByteVec& _encrypted)
      : integrity(_integrity), encrypted(_encrypted)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_CONTEXT_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CONTEXT_DATA>(); }
    
    /** Static marshaling helper  */
    static TPMS_CONTEXT_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CONTEXT_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CONTEXT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_CONTEXT_DATA(*this); }
}; // class TPMS_CONTEXT_DATA

/** This structure is used in a TPMS_CONTEXT.  */
class _DLLEXP_ TPM2B_CONTEXT_DATA : public TpmStructure
{
public:
    TPMS_CONTEXT_DATA buffer;

public:
    TPM2B_CONTEXT_DATA() {}
    TPM2B_CONTEXT_DATA(const TPMS_CONTEXT_DATA& _buffer)
      : buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_CONTEXT_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_CONTEXT_DATA>(); }
    
    /** Static marshaling helper  */
    static TPM2B_CONTEXT_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_CONTEXT_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_CONTEXT_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_CONTEXT_DATA(*this); }
}; // class TPM2B_CONTEXT_DATA

/** This structure is used in TPM2_ContextLoad() and TPM2_ContextSave(). If the values of
 *  the TPMS_CONTEXT structure in TPM2_ContextLoad() are not the same as the values when
 *  the context was saved (TPM2_ContextSave()), then the TPM shall not load the context.
 */
class _DLLEXP_ TPMS_CONTEXT : public TpmStructure
{
public:
    /** The sequence number of the context
     *  NOTE Transient object contexts and session contexts used different counters.
     */
    UINT64 sequence;
    
    /** A handle indicating if the context is a session, object, or sequence object (see Table
     *  222 Context Handle Values
     */
    TPM_HANDLE savedHandle;
    
    /** The hierarchy of the context  */
    TPM_HANDLE hierarchy;
    
    /** The context data and integrity HMAC  */
    TPMS_CONTEXT_DATA contextBlob;

public:
    TPMS_CONTEXT() {}
    TPMS_CONTEXT(UINT64 _sequence, const TPM_HANDLE& _savedHandle, const TPM_HANDLE& _hierarchy, const TPMS_CONTEXT_DATA& _contextBlob)
      : sequence(_sequence), savedHandle(_savedHandle), hierarchy(_hierarchy), contextBlob(_contextBlob)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_CONTEXT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CONTEXT>(); }
    
    /** Static marshaling helper  */
    static TPMS_CONTEXT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CONTEXT>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CONTEXT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_CONTEXT(*this); }
}; // class TPMS_CONTEXT

/** This structure provides information relating to the creation environment for the
 *  object. The creation data includes the parent Name, parent Qualified Name, and the
 *  digest of selected PCR. These values represent the environment in which the object was
 *  created. Creation data allows a relying party to determine if an object was created
 *  when some appropriate protections were present.
 */
class _DLLEXP_ TPMS_CREATION_DATA : public TpmStructure
{
public:
    /** List indicating the PCR included in pcrDigest  */
    vector<TPMS_PCR_SELECTION> pcrSelect;
    
    /** Digest of the selected PCR using nameAlg of the object for which this structure is
     *  being created
     *  pcrDigest.size shall be zero if the pcrSelect list is empty.
     */
    ByteVec pcrDigest;
    
    /** The locality at which the object was created  */
    TPMA_LOCALITY locality;
    
    /** NameAlg of the parent  */
    TPM_ALG_ID parentNameAlg;
    
    /** Name of the parent at time of creation
     *  The size will match digest size associated with parentNameAlg unless it is
     *  TPM_ALG_NULL, in which case the size will be 4 and parentName will be the hierarchy handle.
     */
    ByteVec parentName;
    
    /** Qualified Name of the parent at the time of creation
     *  Size is the same as parentName.
     */
    ByteVec parentQualifiedName;
    
    /** Association with additional information added by the key creator
     *  This will be the contents of the outsideInfo parameter in TPM2_Create() or TPM2_CreatePrimary().
     */
    ByteVec outsideInfo;

public:
    TPMS_CREATION_DATA() { parentNameAlg = TPM_ALG_ID::_NULL; }
    TPMS_CREATION_DATA(const vector<TPMS_PCR_SELECTION>& _pcrSelect, const ByteVec& _pcrDigest, TPMA_LOCALITY _locality, TPM_ALG_ID _parentNameAlg, const ByteVec& _parentName, const ByteVec& _parentQualifiedName, const ByteVec& _outsideInfo)
      : pcrSelect(_pcrSelect), pcrDigest(_pcrDigest), locality(_locality), parentNameAlg(_parentNameAlg), parentName(_parentName), parentQualifiedName(_parentQualifiedName), outsideInfo(_outsideInfo)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_CREATION_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_CREATION_DATA>(); }
    
    /** Static marshaling helper  */
    static TPMS_CREATION_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_CREATION_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_CREATION_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_CREATION_DATA(*this); }
}; // class TPMS_CREATION_DATA

/** This structure is created by TPM2_Create() and TPM2_CreatePrimary(). It is never
 *  entered into the TPM and never has a size of zero.
 */
class _DLLEXP_ TPM2B_CREATION_DATA : public TpmStructure
{
public:
    TPMS_CREATION_DATA creationData;

public:
    TPM2B_CREATION_DATA() {}
    TPM2B_CREATION_DATA(const TPMS_CREATION_DATA& _creationData)
      : creationData(_creationData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2B_CREATION_DATA fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_CREATION_DATA>(); }
    
    /** Static marshaling helper  */
    static TPM2B_CREATION_DATA fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_CREATION_DATA>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_CREATION_DATA"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2B_CREATION_DATA(*this); }
}; // class TPM2B_CREATION_DATA

/** TPMS_AC_OUTPUT is used to return information about an AC. The tag structure parameter
 *  indicates the type of the data value.
 */
class _DLLEXP_ TPMS_AC_OUTPUT : public TpmStructure
{
public:
    /** Tag indicating the contents of data  */
    TPM_AT tag;
    
    /** The data returned from the AC  */
    UINT32 data;

public:
    TPMS_AC_OUTPUT() {}
    TPMS_AC_OUTPUT(TPM_AT _tag, UINT32 _data)
      : tag(_tag), data(_data)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPMS_AC_OUTPUT fromTpm(TpmBuffer& buf) { return buf.createObj<TPMS_AC_OUTPUT>(); }
    
    /** Static marshaling helper  */
    static TPMS_AC_OUTPUT fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPMS_AC_OUTPUT>(buf); }
    
    virtual const char* TypeName () const { return "TPMS_AC_OUTPUT"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPMS_AC_OUTPUT(*this); }
}; // class TPMS_AC_OUTPUT

/** This list is only used in TPM2_AC_GetCapability().  */
class _DLLEXP_ TPML_AC_CAPABILITIES : public TpmStructure
{
public:
    /** A list of AC values  */
    vector<TPMS_AC_OUTPUT> acCapabilities;

public:
    TPML_AC_CAPABILITIES() {}
    TPML_AC_CAPABILITIES(const vector<TPMS_AC_OUTPUT>& _acCapabilities)
      : acCapabilities(_acCapabilities)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPML_AC_CAPABILITIES fromTpm(TpmBuffer& buf) { return buf.createObj<TPML_AC_CAPABILITIES>(); }
    
    /** Static marshaling helper  */
    static TPML_AC_CAPABILITIES fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPML_AC_CAPABILITIES>(buf); }
    
    virtual const char* TypeName () const { return "TPML_AC_CAPABILITIES"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPML_AC_CAPABILITIES(*this); }
}; // class TPML_AC_CAPABILITIES

/** TPM2_Startup() is always preceded by _TPM_Init, which is the physical indication that
 *  TPM initialization is necessary because of a system-wide reset. TPM2_Startup() is only
 *  valid after _TPM_Init. Additional TPM2_Startup() commands are not allowed after it has
 *  completed successfully. If a TPM requires TPM2_Startup() and another command is
 *  received, or if the TPM receives TPM2_Startup() when it is not required, the TPM shall
 *  return TPM_RC_INITIALIZE.
 */
class _DLLEXP_ TPM2_Startup_REQUEST : public ReqStructure
{
public:
    /** TPM_SU_CLEAR or TPM_SU_STATE  */
    TPM_SU startupType;

public:
    TPM2_Startup_REQUEST() {}
    TPM2_Startup_REQUEST(TPM_SU _startupType)
      : startupType(_startupType)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Startup_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Startup_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Startup_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Startup_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Startup_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Startup_REQUEST(*this); }
}; // class TPM2_Startup_REQUEST

/** This command is used to prepare the TPM for a power cycle. The shutdownType parameter
 *  indicates how the subsequent TPM2_Startup() will be processed.
 */
class _DLLEXP_ TPM2_Shutdown_REQUEST : public ReqStructure
{
public:
    /** TPM_SU_CLEAR or TPM_SU_STATE  */
    TPM_SU shutdownType;

public:
    TPM2_Shutdown_REQUEST() {}
    TPM2_Shutdown_REQUEST(TPM_SU _shutdownType)
      : shutdownType(_shutdownType)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Shutdown_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Shutdown_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Shutdown_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Shutdown_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Shutdown_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Shutdown_REQUEST(*this); }
}; // class TPM2_Shutdown_REQUEST

/** This command causes the TPM to perform a test of its capabilities. If the fullTest is
 *  YES, the TPM will test all functions. If fullTest = NO, the TPM will only test those
 *  functions that have not previously been tested.
 */
class _DLLEXP_ TPM2_SelfTest_REQUEST : public ReqStructure
{
public:
    /** YES if full test to be performed
     *  NO if only test of untested functions required
     */
    BYTE fullTest;

public:
    TPM2_SelfTest_REQUEST() {}
    TPM2_SelfTest_REQUEST(BYTE _fullTest)
      : fullTest(_fullTest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_SelfTest_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_SelfTest_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_SelfTest_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_SelfTest_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_SelfTest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_SelfTest_REQUEST(*this); }
}; // class TPM2_SelfTest_REQUEST

/** This command causes the TPM to perform a test of the selected algorithms.  */
class _DLLEXP_ TPM2_IncrementalSelfTest_REQUEST : public ReqStructure
{
public:
    /** List of algorithms that should be tested  */
    vector<TPM_ALG_ID> toTest;

public:
    TPM2_IncrementalSelfTest_REQUEST() {}
    TPM2_IncrementalSelfTest_REQUEST(const vector<TPM_ALG_ID>& _toTest)
      : toTest(_toTest)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_IncrementalSelfTest_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_IncrementalSelfTest_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_IncrementalSelfTest_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_IncrementalSelfTest_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_IncrementalSelfTest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_IncrementalSelfTest_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {4, 2}; }
}; // class TPM2_IncrementalSelfTest_REQUEST

/** This command causes the TPM to perform a test of the selected algorithms.  */
class _DLLEXP_ IncrementalSelfTestResponse : public RespStructure
{
public:
    /** List of algorithms that need testing  */
    vector<TPM_ALG_ID> toDoList;

public:
    IncrementalSelfTestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static IncrementalSelfTestResponse fromTpm(TpmBuffer& buf) { return buf.createObj<IncrementalSelfTestResponse>(); }
    
    /** Static marshaling helper  */
    static IncrementalSelfTestResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<IncrementalSelfTestResponse>(buf); }
    
    virtual const char* TypeName () const { return "IncrementalSelfTestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new IncrementalSelfTestResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {4, 2}; }
}; // class IncrementalSelfTestResponse

/** This command returns manufacturer-specific information regarding the results of a
 *  self-test and an indication of the test status.
 */
class _DLLEXP_ TPM2_GetTestResult_REQUEST : public ReqStructure
{
public:
public:
    TPM2_GetTestResult_REQUEST() {}
    
    /** Static marshaling helper  */
    static TPM2_GetTestResult_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_GetTestResult_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_GetTestResult_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_GetTestResult_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_GetTestResult_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPM2_GetTestResult_REQUEST(*this); }
}; // class TPM2_GetTestResult_REQUEST

/** This command returns manufacturer-specific information regarding the results of a
 *  self-test and an indication of the test status.
 */
class _DLLEXP_ GetTestResultResponse : public RespStructure
{
public:
    /** Test result data
     *  contains manufacturer-specific information
     */
    ByteVec outData;
    
    TPM_RC testResult;

public:
    GetTestResultResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static GetTestResultResponse fromTpm(TpmBuffer& buf) { return buf.createObj<GetTestResultResponse>(); }
    
    /** Static marshaling helper  */
    static GetTestResultResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<GetTestResultResponse>(buf); }
    
    virtual const char* TypeName () const { return "GetTestResultResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new GetTestResultResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetTestResultResponse

/** This command is used to start an authorization session using alternative methods of
 *  establishing the session key (sessionKey). The session key is then used to derive
 *  values used for authorization and for encrypting parameters.
 */
class _DLLEXP_ TPM2_StartAuthSession_REQUEST : public ReqStructure
{
public:
    /** Handle of a loaded decrypt key used to encrypt salt
     *  may be TPM_RH_NULL
     *  Auth Index: None
     */
    TPM_HANDLE tpmKey;
    
    /** Entity providing the authValue
     *  may be TPM_RH_NULL
     *  Auth Index: None
     */
    TPM_HANDLE bind;
    
    /** Initial nonceCaller, sets nonceTPM size for the session
     *  shall be at least 16 octets
     */
    ByteVec nonceCaller;
    
    /** Value encrypted according to the type of tpmKey
     *  If tpmKey is TPM_RH_NULL, this shall be the Empty Buffer.
     */
    ByteVec encryptedSalt;
    
    /** Indicates the type of the session; simple HMAC or policy (including a trial policy)  */
    TPM_SE sessionType;
    
    /** The algorithm and key size for parameter encryption
     *  may select TPM_ALG_NULL
     */
    TPMT_SYM_DEF symmetric;
    
    /** Hash algorithm to use for the session
     *  Shall be a hash algorithm supported by the TPM and not TPM_ALG_NULL
     */
    TPM_ALG_ID authHash;

public:
    TPM2_StartAuthSession_REQUEST() { authHash = TPM_ALG_ID::_NULL; }
    TPM2_StartAuthSession_REQUEST(const TPM_HANDLE& _tpmKey, const TPM_HANDLE& _bind, const ByteVec& _nonceCaller, const ByteVec& _encryptedSalt, TPM_SE _sessionType, const TPMT_SYM_DEF& _symmetric, TPM_ALG_ID _authHash)
      : tpmKey(_tpmKey), bind(_bind), nonceCaller(_nonceCaller), encryptedSalt(_encryptedSalt), sessionType(_sessionType), symmetric(_symmetric), authHash(_authHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_StartAuthSession_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_StartAuthSession_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_StartAuthSession_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_StartAuthSession_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_StartAuthSession_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_StartAuthSession_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {tpmKey, bind}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_StartAuthSession_REQUEST

/** This command is used to start an authorization session using alternative methods of
 *  establishing the session key (sessionKey). The session key is then used to derive
 *  values used for authorization and for encrypting parameters.
 */
class _DLLEXP_ StartAuthSessionResponse : public RespStructure
{
public:
    /** Handle for the newly created session  */
    TPM_HANDLE handle;
    
    /** The initial nonce from the TPM, used in the computation of the sessionKey  */
    ByteVec nonceTPM;

public:
    StartAuthSessionResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static StartAuthSessionResponse fromTpm(TpmBuffer& buf) { return buf.createObj<StartAuthSessionResponse>(); }
    
    /** Static marshaling helper  */
    static StartAuthSessionResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<StartAuthSessionResponse>(buf); }
    
    virtual const char* TypeName () const { return "StartAuthSessionResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new StartAuthSessionResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class StartAuthSessionResponse

/** This command allows a policy authorization session to be returned to its initial
 *  state. This command is used after the TPM returns TPM_RC_PCR_CHANGED. That response
 *  code indicates that a policy will fail because the PCR have changed after
 *  TPM2_PolicyPCR() was executed. Restarting the session allows the authorizations to be
 *  replayed because the session restarts with the same nonceTPM. If the PCR are valid for
 *  the policy, the policy may then succeed.
 */
class _DLLEXP_ TPM2_PolicyRestart_REQUEST : public ReqStructure
{
public:
    /** The handle for the policy session  */
    TPM_HANDLE sessionHandle;

public:
    TPM2_PolicyRestart_REQUEST() {}
    TPM2_PolicyRestart_REQUEST(const TPM_HANDLE& _sessionHandle)
      : sessionHandle(_sessionHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_PolicyRestart_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyRestart_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyRestart_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyRestart_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyRestart_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyRestart_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {sessionHandle}; }
}; // class TPM2_PolicyRestart_REQUEST

/** This command is used to create an object that can be loaded into a TPM using
 *  TPM2_Load(). If the command completes successfully, the TPM will create the new object
 *  and return the objects creation data (creationData), its public area (outPublic), and
 *  its encrypted sensitive area (outPrivate). Preservation of the returned data is the
 *  responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
 *  it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
 *  outPublic TPMT_PUBLIC object is in the unique field.
 */
class _DLLEXP_ TPM2_Create_REQUEST : public ReqStructure
{
public:
    /** Handle of parent for new object
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE parentHandle;
    
    /** The sensitive data  */
    TPMS_SENSITIVE_CREATE inSensitive;
    
    /** The public template  */
    TPMT_PUBLIC inPublic;
    
    /** Data that will be included in the creation data for this object to provide permanent,
     *  verifiable linkage between this object and some object owner data
     */
    ByteVec outsideInfo;
    
    /** PCR that will be used in creation data  */
    vector<TPMS_PCR_SELECTION> creationPCR;

public:
    TPM2_Create_REQUEST() {}
    TPM2_Create_REQUEST(const TPM_HANDLE& _parentHandle, const TPMS_SENSITIVE_CREATE& _inSensitive, const TPMT_PUBLIC& _inPublic, const ByteVec& _outsideInfo, const vector<TPMS_PCR_SELECTION>& _creationPCR)
      : parentHandle(_parentHandle), inSensitive(_inSensitive), inPublic(_inPublic), outsideInfo(_outsideInfo), creationPCR(_creationPCR)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Create_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Create_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Create_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Create_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Create_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Create_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Create_REQUEST

/** This command is used to create an object that can be loaded into a TPM using
 *  TPM2_Load(). If the command completes successfully, the TPM will create the new object
 *  and return the objects creation data (creationData), its public area (outPublic), and
 *  its encrypted sensitive area (outPrivate). Preservation of the returned data is the
 *  responsibility of the caller. The object will need to be loaded (TPM2_Load()) before
 *  it may be used. The only difference between the inPublic TPMT_PUBLIC template and the
 *  outPublic TPMT_PUBLIC object is in the unique field.
 */
class _DLLEXP_ CreateResponse : public RespStructure
{
public:
    /** The private portion of the object  */
    TPM2B_PRIVATE outPrivate;
    
    /** The public portion of the created object  */
    TPMT_PUBLIC outPublic;
    
    /** Contains a TPMS_CREATION_DATA  */
    TPMS_CREATION_DATA creationData;
    
    /** Digest of creationData using nameAlg of outPublic  */
    ByteVec creationHash;
    
    /** Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
     *  by the TPM
     */
    TPMT_TK_CREATION creationTicket;

public:
    CreateResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CreateResponse fromTpm(TpmBuffer& buf) { return buf.createObj<CreateResponse>(); }
    
    /** Static marshaling helper  */
    static CreateResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CreateResponse>(buf); }
    
    virtual const char* TypeName () const { return "CreateResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CreateResponse(*this); }
}; // class CreateResponse

/** This command is used to load objects into the TPM. This command is used when both a
 *  TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
 *  loaded, the TPM2_LoadExternal command is used.
 */
class _DLLEXP_ TPM2_Load_REQUEST : public ReqStructure
{
public:
    /** TPM handle of parent key; shall not be a reserved handle
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE parentHandle;
    
    /** The private portion of the object  */
    TPM2B_PRIVATE inPrivate;
    
    /** The public portion of the object  */
    TPMT_PUBLIC inPublic;

public:
    TPM2_Load_REQUEST() {}
    TPM2_Load_REQUEST(const TPM_HANDLE& _parentHandle, const TPM2B_PRIVATE& _inPrivate, const TPMT_PUBLIC& _inPublic)
      : parentHandle(_parentHandle), inPrivate(_inPrivate), inPublic(_inPublic)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Load_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Load_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Load_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Load_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Load_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Load_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
}; // class TPM2_Load_REQUEST

/** This command is used to load objects into the TPM. This command is used when both a
 *  TPM2B_PUBLIC and TPM2B_PRIVATE are to be loaded. If only a TPM2B_PUBLIC is to be
 *  loaded, the TPM2_LoadExternal command is used.
 */
class _DLLEXP_ LoadResponse : public RespStructure
{
public:
    /** Handle of type TPM_HT_TRANSIENT for the loaded object  */
    TPM_HANDLE handle;
    
    /** Name of the loaded object  */
    ByteVec name;

public:
    LoadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static LoadResponse fromTpm(TpmBuffer& buf) { return buf.createObj<LoadResponse>(); }
    
    /** Static marshaling helper  */
    static LoadResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<LoadResponse>(buf); }
    
    virtual const char* TypeName () const { return "LoadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new LoadResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class LoadResponse

/** This command is used to load an object that is not a Protected Object into the TPM.
 *  The command allows loading of a public area or both a public and sensitive area.
 */
class _DLLEXP_ TPM2_LoadExternal_REQUEST : public ReqStructure
{
public:
    /** The sensitive portion of the object (optional)  */
    TPMT_SENSITIVE inPrivate;
    
    /** The public portion of the object  */
    TPMT_PUBLIC inPublic;
    
    /** Hierarchy with which the object area is associated  */
    TPM_HANDLE hierarchy;

public:
    TPM2_LoadExternal_REQUEST() {}
    TPM2_LoadExternal_REQUEST(const TPMT_SENSITIVE& _inPrivate, const TPMT_PUBLIC& _inPublic, const TPM_HANDLE& _hierarchy)
      : inPrivate(_inPrivate), inPublic(_inPublic), hierarchy(_hierarchy)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_LoadExternal_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_LoadExternal_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_LoadExternal_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_LoadExternal_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_LoadExternal_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_LoadExternal_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_LoadExternal_REQUEST

/** This command is used to load an object that is not a Protected Object into the TPM.
 *  The command allows loading of a public area or both a public and sensitive area.
 */
class _DLLEXP_ LoadExternalResponse : public RespStructure
{
public:
    /** Handle of type TPM_HT_TRANSIENT for the loaded object  */
    TPM_HANDLE handle;
    
    /** Name of the loaded object  */
    ByteVec name;

public:
    LoadExternalResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static LoadExternalResponse fromTpm(TpmBuffer& buf) { return buf.createObj<LoadExternalResponse>(); }
    
    /** Static marshaling helper  */
    static LoadExternalResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<LoadExternalResponse>(buf); }
    
    virtual const char* TypeName () const { return "LoadExternalResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new LoadExternalResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class LoadExternalResponse

/** This command allows access to the public area of a loaded object.  */
class _DLLEXP_ TPM2_ReadPublic_REQUEST : public ReqStructure
{
public:
    /** TPM handle of an object
     *  Auth Index: None
     */
    TPM_HANDLE objectHandle;

public:
    TPM2_ReadPublic_REQUEST() {}
    TPM2_ReadPublic_REQUEST(const TPM_HANDLE& _objectHandle)
      : objectHandle(_objectHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_ReadPublic_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ReadPublic_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ReadPublic_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ReadPublic_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ReadPublic_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ReadPublic_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {objectHandle}; }
}; // class TPM2_ReadPublic_REQUEST

/** This command allows access to the public area of a loaded object.  */
class _DLLEXP_ ReadPublicResponse : public RespStructure
{
public:
    /** Structure containing the public area of an object  */
    TPMT_PUBLIC outPublic;
    
    /** Name of the object  */
    ByteVec name;
    
    /** The Qualified Name of the object  */
    ByteVec qualifiedName;

public:
    ReadPublicResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ReadPublicResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ReadPublicResponse>(); }
    
    /** Static marshaling helper  */
    static ReadPublicResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ReadPublicResponse>(buf); }
    
    virtual const char* TypeName () const { return "ReadPublicResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ReadPublicResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ReadPublicResponse

/** This command enables the association of a credential with an object in a way that
 *  ensures that the TPM has validated the parameters of the credentialed object.
 */
class _DLLEXP_ TPM2_ActivateCredential_REQUEST : public ReqStructure
{
public:
    /** Handle of the object associated with certificate in credentialBlob
     *  Auth Index: 1
     *  Auth Role: ADMIN
     */
    TPM_HANDLE activateHandle;
    
    /** Loaded key used to decrypt the TPMS_SENSITIVE in credentialBlob
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE keyHandle;
    
    /** The credential  */
    TPMS_ID_OBJECT credentialBlob;
    
    /** KeyHandle algorithm-dependent encrypted seed that protects credentialBlob  */
    ByteVec secret;

public:
    TPM2_ActivateCredential_REQUEST() {}
    TPM2_ActivateCredential_REQUEST(const TPM_HANDLE& _activateHandle, const TPM_HANDLE& _keyHandle, const TPMS_ID_OBJECT& _credentialBlob, const ByteVec& _secret)
      : activateHandle(_activateHandle), keyHandle(_keyHandle), credentialBlob(_credentialBlob), secret(_secret)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ActivateCredential_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ActivateCredential_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ActivateCredential_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ActivateCredential_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ActivateCredential_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ActivateCredential_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {activateHandle, keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ActivateCredential_REQUEST

/** This command enables the association of a credential with an object in a way that
 *  ensures that the TPM has validated the parameters of the credentialed object.
 */
class _DLLEXP_ ActivateCredentialResponse : public RespStructure
{
public:
    /** The decrypted certificate information
     *  the data should be no larger than the size of the digest of the nameAlg associated
     *  with keyHandle
     */
    ByteVec certInfo;

public:
    ActivateCredentialResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ActivateCredentialResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ActivateCredentialResponse>(); }
    
    /** Static marshaling helper  */
    static ActivateCredentialResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ActivateCredentialResponse>(buf); }
    
    virtual const char* TypeName () const { return "ActivateCredentialResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ActivateCredentialResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ActivateCredentialResponse

/** This command allows the TPM to perform the actions required of a Certificate Authority
 *  (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
 */
class _DLLEXP_ TPM2_MakeCredential_REQUEST : public ReqStructure
{
public:
    /** Loaded public area, used to encrypt the sensitive area containing the credential key
     *  Auth Index: None
     */
    TPM_HANDLE handle;
    
    /** The credential information  */
    ByteVec credential;
    
    /** Name of the object to which the credential applies  */
    ByteVec objectName;

public:
    TPM2_MakeCredential_REQUEST() {}
    TPM2_MakeCredential_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _credential, const ByteVec& _objectName)
      : handle(_handle), credential(_credential), objectName(_objectName)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_MakeCredential_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_MakeCredential_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_MakeCredential_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_MakeCredential_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_MakeCredential_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_MakeCredential_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_MakeCredential_REQUEST

/** This command allows the TPM to perform the actions required of a Certificate Authority
 *  (CA) in creating a TPM2B_ID_OBJECT containing an activation credential.
 */
class _DLLEXP_ MakeCredentialResponse : public RespStructure
{
public:
    /** The credential  */
    TPMS_ID_OBJECT credentialBlob;
    
    /** Handle algorithm-dependent data that wraps the key that encrypts credentialBlob  */
    ByteVec secret;

public:
    MakeCredentialResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static MakeCredentialResponse fromTpm(TpmBuffer& buf) { return buf.createObj<MakeCredentialResponse>(); }
    
    /** Static marshaling helper  */
    static MakeCredentialResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<MakeCredentialResponse>(buf); }
    
    virtual const char* TypeName () const { return "MakeCredentialResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new MakeCredentialResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class MakeCredentialResponse

/** This command returns the data in a loaded Sealed Data Object.  */
class _DLLEXP_ TPM2_Unseal_REQUEST : public ReqStructure
{
public:
    /** Handle of a loaded data object
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE itemHandle;

public:
    TPM2_Unseal_REQUEST() {}
    TPM2_Unseal_REQUEST(const TPM_HANDLE& _itemHandle)
      : itemHandle(_itemHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_Unseal_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Unseal_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Unseal_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Unseal_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Unseal_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Unseal_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {itemHandle}; }
}; // class TPM2_Unseal_REQUEST

/** This command returns the data in a loaded Sealed Data Object.  */
class _DLLEXP_ UnsealResponse : public RespStructure
{
public:
    /** Unsealed data
     *  Size of outData is limited to be no more than 128 octets.
     */
    ByteVec outData;

public:
    UnsealResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static UnsealResponse fromTpm(TpmBuffer& buf) { return buf.createObj<UnsealResponse>(); }
    
    /** Static marshaling helper  */
    static UnsealResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<UnsealResponse>(buf); }
    
    virtual const char* TypeName () const { return "UnsealResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new UnsealResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class UnsealResponse

/** This command is used to change the authorization secret for a TPM-resident object.  */
class _DLLEXP_ TPM2_ObjectChangeAuth_REQUEST : public ReqStructure
{
public:
    /** Handle of the object
     *  Auth Index: 1
     *  Auth Role: ADMIN
     */
    TPM_HANDLE objectHandle;
    
    /** Handle of the parent
     *  Auth Index: None
     */
    TPM_HANDLE parentHandle;
    
    /** New authorization value  */
    ByteVec newAuth;

public:
    TPM2_ObjectChangeAuth_REQUEST() {}
    TPM2_ObjectChangeAuth_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _parentHandle, const ByteVec& _newAuth)
      : objectHandle(_objectHandle), parentHandle(_parentHandle), newAuth(_newAuth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ObjectChangeAuth_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ObjectChangeAuth_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ObjectChangeAuth_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ObjectChangeAuth_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ObjectChangeAuth_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ObjectChangeAuth_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {objectHandle, parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ObjectChangeAuth_REQUEST

/** This command is used to change the authorization secret for a TPM-resident object.  */
class _DLLEXP_ ObjectChangeAuthResponse : public RespStructure
{
public:
    /** Private area containing the new authorization value  */
    TPM2B_PRIVATE outPrivate;

public:
    ObjectChangeAuthResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ObjectChangeAuthResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ObjectChangeAuthResponse>(); }
    
    /** Static marshaling helper  */
    static ObjectChangeAuthResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ObjectChangeAuthResponse>(buf); }
    
    virtual const char* TypeName () const { return "ObjectChangeAuthResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ObjectChangeAuthResponse(*this); }
}; // class ObjectChangeAuthResponse

/** This command creates an object and loads it in the TPM. This command allows creation
 *  of any type of object (Primary, Ordinary, or Derived) depending on the type of
 *  parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
 *  created; if parentHandle references a Storage Parent, then an Ordinary Object is
 *  created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
 */
class _DLLEXP_ TPM2_CreateLoaded_REQUEST : public ReqStructure
{
public:
    /** Handle of a transient storage key, a persistent storage key, TPM_RH_ENDORSEMENT,
     *  TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE parentHandle;
    
    /** The sensitive data, see TPM 2.0 Part 1 Sensitive Values  */
    TPMS_SENSITIVE_CREATE inSensitive;
    
    /** The public template  */
    ByteVec inPublic;

public:
    TPM2_CreateLoaded_REQUEST() {}
    TPM2_CreateLoaded_REQUEST(const TPM_HANDLE& _parentHandle, const TPMS_SENSITIVE_CREATE& _inSensitive, const ByteVec& _inPublic)
      : parentHandle(_parentHandle), inSensitive(_inSensitive), inPublic(_inPublic)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_CreateLoaded_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_CreateLoaded_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_CreateLoaded_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_CreateLoaded_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_CreateLoaded_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_CreateLoaded_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CreateLoaded_REQUEST

/** This command creates an object and loads it in the TPM. This command allows creation
 *  of any type of object (Primary, Ordinary, or Derived) depending on the type of
 *  parentHandle. If parentHandle references a Primary Seed, then a Primary Object is
 *  created; if parentHandle references a Storage Parent, then an Ordinary Object is
 *  created; and if parentHandle references a Derivation Parent, then a Derived Object is generated.
 */
class _DLLEXP_ CreateLoadedResponse : public RespStructure
{
public:
    /** Handle of type TPM_HT_TRANSIENT for created object  */
    TPM_HANDLE handle;
    
    /** The sensitive area of the object (optional)  */
    TPM2B_PRIVATE outPrivate;
    
    /** The public portion of the created object  */
    TPMT_PUBLIC outPublic;
    
    /** The name of the created object  */
    ByteVec name;

public:
    CreateLoadedResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CreateLoadedResponse fromTpm(TpmBuffer& buf) { return buf.createObj<CreateLoadedResponse>(); }
    
    /** Static marshaling helper  */
    static CreateLoadedResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CreateLoadedResponse>(buf); }
    
    virtual const char* TypeName () const { return "CreateLoadedResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CreateLoadedResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class CreateLoadedResponse

/** This command duplicates a loaded object so that it may be used in a different
 *  hierarchy. The new parent key for the duplicate may be on the same or different TPM or
 *  TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
 */
class _DLLEXP_ TPM2_Duplicate_REQUEST : public ReqStructure
{
public:
    /** Loaded object to duplicate
     *  Auth Index: 1
     *  Auth Role: DUP
     */
    TPM_HANDLE objectHandle;
    
    /** Shall reference the public area of an asymmetric key
     *  Auth Index: None
     */
    TPM_HANDLE newParentHandle;
    
    /** Optional symmetric encryption key
     *  The size for this key is set to zero when the TPM is to generate the key. This
     *  parameter may be encrypted.
     */
    ByteVec encryptionKeyIn;
    
    /** Definition for the symmetric algorithm to be used for the inner wrapper
     *  may be TPM_ALG_NULL if no inner wrapper is applied
     */
    TPMT_SYM_DEF_OBJECT symmetricAlg;

public:
    TPM2_Duplicate_REQUEST() {}
    TPM2_Duplicate_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _newParentHandle, const ByteVec& _encryptionKeyIn, const TPMT_SYM_DEF_OBJECT& _symmetricAlg)
      : objectHandle(_objectHandle), newParentHandle(_newParentHandle), encryptionKeyIn(_encryptionKeyIn), symmetricAlg(_symmetricAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Duplicate_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Duplicate_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Duplicate_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Duplicate_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Duplicate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Duplicate_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {objectHandle, newParentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Duplicate_REQUEST

/** This command duplicates a loaded object so that it may be used in a different
 *  hierarchy. The new parent key for the duplicate may be on the same or different TPM or
 *  TPM_RH_NULL. Only the public area of newParentHandle is required to be loaded.
 */
class _DLLEXP_ DuplicateResponse : public RespStructure
{
public:
    /** If the caller provided an encryption key or if symmetricAlg was TPM_ALG_NULL, then
     *  this will be the Empty Buffer; otherwise, it shall contain the TPM-generated,
     *  symmetric encryption key for the inner wrapper.
     */
    ByteVec encryptionKeyOut;
    
    /** Private area that may be encrypted by encryptionKeyIn; and may be doubly encrypted  */
    TPM2B_PRIVATE duplicate;
    
    /** Seed protected by the asymmetric algorithms of new parent (NP)  */
    ByteVec outSymSeed;

public:
    DuplicateResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static DuplicateResponse fromTpm(TpmBuffer& buf) { return buf.createObj<DuplicateResponse>(); }
    
    /** Static marshaling helper  */
    static DuplicateResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<DuplicateResponse>(buf); }
    
    virtual const char* TypeName () const { return "DuplicateResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new DuplicateResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class DuplicateResponse

/** This command allows the TPM to serve in the role as a Duplication Authority. If proper
 *  authorization for use of the oldParent is provided, then an HMAC key and a symmetric
 *  key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
 *  A new protection seed value is generated according to the methods appropriate for
 *  newParent and the blob is re-encrypted and a new integrity value is computed. The
 *  re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
 */
class _DLLEXP_ TPM2_Rewrap_REQUEST : public ReqStructure
{
public:
    /** Parent of object
     *  Auth Index: 1
     *  Auth Role: User
     */
    TPM_HANDLE oldParent;
    
    /** New parent of the object
     *  Auth Index: None
     */
    TPM_HANDLE newParent;
    
    /** An object encrypted using symmetric key derived from inSymSeed  */
    TPM2B_PRIVATE inDuplicate;
    
    /** The Name of the object being rewrapped  */
    ByteVec name;
    
    /** The seed for the symmetric key and HMAC key
     *  needs oldParent private key to recover the seed and generate the symmetric key
     */
    ByteVec inSymSeed;

public:
    TPM2_Rewrap_REQUEST() {}
    TPM2_Rewrap_REQUEST(const TPM_HANDLE& _oldParent, const TPM_HANDLE& _newParent, const TPM2B_PRIVATE& _inDuplicate, const ByteVec& _name, const ByteVec& _inSymSeed)
      : oldParent(_oldParent), newParent(_newParent), inDuplicate(_inDuplicate), name(_name), inSymSeed(_inSymSeed)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Rewrap_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Rewrap_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Rewrap_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Rewrap_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Rewrap_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Rewrap_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {oldParent, newParent}; }
}; // class TPM2_Rewrap_REQUEST

/** This command allows the TPM to serve in the role as a Duplication Authority. If proper
 *  authorization for use of the oldParent is provided, then an HMAC key and a symmetric
 *  key are recovered from inSymSeed and used to integrity check and decrypt inDuplicate.
 *  A new protection seed value is generated according to the methods appropriate for
 *  newParent and the blob is re-encrypted and a new integrity value is computed. The
 *  re-encrypted blob is returned in outDuplicate and the symmetric key returned in outSymKey.
 */
class _DLLEXP_ RewrapResponse : public RespStructure
{
public:
    /** An object encrypted using symmetric key derived from outSymSeed  */
    TPM2B_PRIVATE outDuplicate;
    
    /** Seed for a symmetric key protected by newParent asymmetric key  */
    ByteVec outSymSeed;

public:
    RewrapResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static RewrapResponse fromTpm(TpmBuffer& buf) { return buf.createObj<RewrapResponse>(); }
    
    /** Static marshaling helper  */
    static RewrapResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<RewrapResponse>(buf); }
    
    virtual const char* TypeName () const { return "RewrapResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new RewrapResponse(*this); }
}; // class RewrapResponse

/** This command allows an object to be encrypted using the symmetric encryption values of
 *  a Storage Key. After encryption, the object may be loaded and used in the new
 *  hierarchy. The imported object (duplicate) may be singly encrypted, multiply
 *  encrypted, or unencrypted.
 */
class _DLLEXP_ TPM2_Import_REQUEST : public ReqStructure
{
public:
    /** The handle of the new parent for the object
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE parentHandle;
    
    /** The optional symmetric encryption key used as the inner wrapper for duplicate
     *  If symmetricAlg is TPM_ALG_NULL, then this parameter shall be the Empty Buffer.
     */
    ByteVec encryptionKey;
    
    /** The public area of the object to be imported
     *  This is provided so that the integrity value for duplicate and the object attributes
     *  can be checked.
     *  NOTE Even if the integrity value of the object is not checked on input, the object
     *  Name is required to create the integrity value for the imported object.
     */
    TPMT_PUBLIC objectPublic;
    
    /** The symmetrically encrypted duplicate object that may contain an inner symmetric wrapper  */
    TPM2B_PRIVATE duplicate;
    
    /** The seed for the symmetric key and HMAC key
     *  inSymSeed is encrypted/encoded using the algorithms of newParent.
     */
    ByteVec inSymSeed;
    
    /** Definition for the symmetric algorithm to use for the inner wrapper
     *  If this algorithm is TPM_ALG_NULL, no inner wrapper is present and encryptionKey shall
     *  be the Empty Buffer.
     */
    TPMT_SYM_DEF_OBJECT symmetricAlg;

public:
    TPM2_Import_REQUEST() {}
    TPM2_Import_REQUEST(const TPM_HANDLE& _parentHandle, const ByteVec& _encryptionKey, const TPMT_PUBLIC& _objectPublic, const TPM2B_PRIVATE& _duplicate, const ByteVec& _inSymSeed, const TPMT_SYM_DEF_OBJECT& _symmetricAlg)
      : parentHandle(_parentHandle), encryptionKey(_encryptionKey), objectPublic(_objectPublic), duplicate(_duplicate), inSymSeed(_inSymSeed), symmetricAlg(_symmetricAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Import_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Import_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Import_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Import_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Import_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Import_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {parentHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Import_REQUEST

/** This command allows an object to be encrypted using the symmetric encryption values of
 *  a Storage Key. After encryption, the object may be loaded and used in the new
 *  hierarchy. The imported object (duplicate) may be singly encrypted, multiply
 *  encrypted, or unencrypted.
 */
class _DLLEXP_ ImportResponse : public RespStructure
{
public:
    /** The sensitive area encrypted with the symmetric key of parentHandle  */
    TPM2B_PRIVATE outPrivate;

public:
    ImportResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ImportResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ImportResponse>(); }
    
    /** Static marshaling helper  */
    static ImportResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ImportResponse>(buf); }
    
    virtual const char* TypeName () const { return "ImportResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ImportResponse(*this); }
}; // class ImportResponse

/** This command performs RSA encryption using the indicated padding scheme according to
 *  IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
 *  inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
 *  then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
 */
class _DLLEXP_ TPM2_RSA_Encrypt_REQUEST : public ReqStructure
{
public:
    /** Reference to public portion of RSA key to use for encryption
     *  Auth Index: None
     */
    TPM_HANDLE keyHandle;
    
    /** Message to be encrypted
     *  NOTE 1 The data type was chosen because it limits the overall size of the input to no
     *  greater than the size of the largest RSA public key. This may be larger than allowed
     *  for keyHandle.
     */
    ByteVec message;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> inScheme;
    
    /** Optional label L to be associated with the message
     *  Size of the buffer is zero if no label is present
     *  NOTE 2 See description of label above.
     */
    ByteVec label;

public:
    TPM2_RSA_Encrypt_REQUEST() {}
    TPM2_RSA_Encrypt_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _message, const TPMU_ASYM_SCHEME& _inScheme, const ByteVec& _label)
      : keyHandle(_keyHandle), message(_message), inScheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone())), label(_label)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_RSA_Encrypt_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_RSA_Encrypt_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_RSA_Encrypt_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_RSA_Encrypt_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_RSA_Encrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_RSA_Encrypt_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_RSA_Encrypt_REQUEST

/** This command performs RSA encryption using the indicated padding scheme according to
 *  IETF RFC 8017. If the scheme of keyHandle is TPM_ALG_NULL, then the caller may use
 *  inScheme to specify the padding scheme. If scheme of keyHandle is not TPM_ALG_NULL,
 *  then inScheme shall either be TPM_ALG_NULL or be the same as scheme (TPM_RC_SCHEME).
 */
class _DLLEXP_ RSA_EncryptResponse : public RespStructure
{
public:
    /** Encrypted output  */
    ByteVec outData;

public:
    RSA_EncryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static RSA_EncryptResponse fromTpm(TpmBuffer& buf) { return buf.createObj<RSA_EncryptResponse>(); }
    
    /** Static marshaling helper  */
    static RSA_EncryptResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<RSA_EncryptResponse>(buf); }
    
    virtual const char* TypeName () const { return "RSA_EncryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new RSA_EncryptResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class RSA_EncryptResponse

/** This command performs RSA decryption using the indicated padding scheme according to
 *  IETF RFC 8017 ((PKCS#1).
 */
class _DLLEXP_ TPM2_RSA_Decrypt_REQUEST : public ReqStructure
{
public:
    /** RSA key to use for decryption
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE keyHandle;
    
    /** Cipher text to be decrypted
     *  NOTE An encrypted RSA data block is the size of the public modulus.
     */
    ByteVec cipherText;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The padding scheme to use if scheme associated with keyHandle is TPM_ALG_NULL
     *  (One of [TPMS_KEY_SCHEME_ECDH, TPMS_KEY_SCHEME_ECMQV, TPMS_SIG_SCHEME_RSASSA,
     *  TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA, TPMS_SIG_SCHEME_ECDAA,
     *  TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR, TPMS_ENC_SCHEME_RSAES,
     *  TPMS_ENC_SCHEME_OAEP, TPMS_SCHEME_HASH, TPMS_NULL_ASYM_SCHEME])
     */
    shared_ptr<TPMU_ASYM_SCHEME> inScheme;
    
    /** Label whose association with the message is to be verified  */
    ByteVec label;

public:
    TPM2_RSA_Decrypt_REQUEST() {}
    TPM2_RSA_Decrypt_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _cipherText, const TPMU_ASYM_SCHEME& _inScheme, const ByteVec& _label)
      : keyHandle(_keyHandle), cipherText(_cipherText), inScheme(dynamic_cast<TPMU_ASYM_SCHEME*>(_inScheme.Clone())), label(_label)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_RSA_Decrypt_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_RSA_Decrypt_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_RSA_Decrypt_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_RSA_Decrypt_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_RSA_Decrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_RSA_Decrypt_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_RSA_Decrypt_REQUEST

/** This command performs RSA decryption using the indicated padding scheme according to
 *  IETF RFC 8017 ((PKCS#1).
 */
class _DLLEXP_ RSA_DecryptResponse : public RespStructure
{
public:
    /** Decrypted output  */
    ByteVec message;

public:
    RSA_DecryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static RSA_DecryptResponse fromTpm(TpmBuffer& buf) { return buf.createObj<RSA_DecryptResponse>(); }
    
    /** Static marshaling helper  */
    static RSA_DecryptResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<RSA_DecryptResponse>(buf); }
    
    virtual const char* TypeName () const { return "RSA_DecryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new RSA_DecryptResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class RSA_DecryptResponse

/** This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
 *  It uses the private ephemeral key and a loaded public key (QS) to compute the shared
 *  secret value (P [hde]QS).
 */
class _DLLEXP_ TPM2_ECDH_KeyGen_REQUEST : public ReqStructure
{
public:
    /** Handle of a loaded ECC key public area.
     *  Auth Index: None
     */
    TPM_HANDLE keyHandle;

public:
    TPM2_ECDH_KeyGen_REQUEST() {}
    TPM2_ECDH_KeyGen_REQUEST(const TPM_HANDLE& _keyHandle)
      : keyHandle(_keyHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_ECDH_KeyGen_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ECDH_KeyGen_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ECDH_KeyGen_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ECDH_KeyGen_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ECDH_KeyGen_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ECDH_KeyGen_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
}; // class TPM2_ECDH_KeyGen_REQUEST

/** This command uses the TPM to generate an ephemeral key pair (de, Qe where Qe [de]G).
 *  It uses the private ephemeral key and a loaded public key (QS) to compute the shared
 *  secret value (P [hde]QS).
 */
class _DLLEXP_ ECDH_KeyGenResponse : public RespStructure
{
public:
    /** Results of P h[de]Qs  */
    TPMS_ECC_POINT zPoint;
    
    /** Generated ephemeral public point (Qe)  */
    TPMS_ECC_POINT pubPoint;

public:
    ECDH_KeyGenResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ECDH_KeyGenResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ECDH_KeyGenResponse>(); }
    
    /** Static marshaling helper  */
    static ECDH_KeyGenResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ECDH_KeyGenResponse>(buf); }
    
    virtual const char* TypeName () const { return "ECDH_KeyGenResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ECDH_KeyGenResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECDH_KeyGenResponse

/** This command uses the TPM to recover the Z value from a public point (QB) and a
 *  private key (ds). It will perform the multiplication of the provided inPoint (QB) with
 *  the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
 *  [hds]QB; where h is the cofactor of the curve).
 */
class _DLLEXP_ TPM2_ECDH_ZGen_REQUEST : public ReqStructure
{
public:
    /** Handle of a loaded ECC key
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE keyHandle;
    
    /** A public key  */
    TPMS_ECC_POINT inPoint;

public:
    TPM2_ECDH_ZGen_REQUEST() {}
    TPM2_ECDH_ZGen_REQUEST(const TPM_HANDLE& _keyHandle, const TPMS_ECC_POINT& _inPoint)
      : keyHandle(_keyHandle), inPoint(_inPoint)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ECDH_ZGen_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ECDH_ZGen_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ECDH_ZGen_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ECDH_ZGen_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ECDH_ZGen_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ECDH_ZGen_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ECDH_ZGen_REQUEST

/** This command uses the TPM to recover the Z value from a public point (QB) and a
 *  private key (ds). It will perform the multiplication of the provided inPoint (QB) with
 *  the private key (ds) and return the coordinates of the resultant point (Z = (xZ , yZ)
 *  [hds]QB; where h is the cofactor of the curve).
 */
class _DLLEXP_ ECDH_ZGenResponse : public RespStructure
{
public:
    /** X and Y coordinates of the product of the multiplication Z = (xZ , yZ) [hdS]QB  */
    TPMS_ECC_POINT outPoint;

public:
    ECDH_ZGenResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ECDH_ZGenResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ECDH_ZGenResponse>(); }
    
    /** Static marshaling helper  */
    static ECDH_ZGenResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ECDH_ZGenResponse>(buf); }
    
    virtual const char* TypeName () const { return "ECDH_ZGenResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ECDH_ZGenResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECDH_ZGenResponse

/** This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.  */
class _DLLEXP_ TPM2_ECC_Parameters_REQUEST : public ReqStructure
{
public:
    /** Parameter set selector  */
    TPM_ECC_CURVE curveID;

public:
    TPM2_ECC_Parameters_REQUEST() {}
    TPM2_ECC_Parameters_REQUEST(TPM_ECC_CURVE _curveID)
      : curveID(_curveID)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ECC_Parameters_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ECC_Parameters_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ECC_Parameters_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ECC_Parameters_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ECC_Parameters_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ECC_Parameters_REQUEST(*this); }
}; // class TPM2_ECC_Parameters_REQUEST

/** This command returns the parameters of an ECC curve identified by its TCG-assigned curveID.  */
class _DLLEXP_ ECC_ParametersResponse : public RespStructure
{
public:
    /** ECC parameters for the selected curve  */
    TPMS_ALGORITHM_DETAIL_ECC parameters;

public:
    ECC_ParametersResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ECC_ParametersResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ECC_ParametersResponse>(); }
    
    /** Static marshaling helper  */
    static ECC_ParametersResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ECC_ParametersResponse>(buf); }
    
    virtual const char* TypeName () const { return "ECC_ParametersResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ECC_ParametersResponse(*this); }
}; // class ECC_ParametersResponse

/** This command supports two-phase key exchange protocols. The command is used in
 *  combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
 *  and returns the public point of that ephemeral key along with a numeric value that
 *  allows the TPM to regenerate the associated private key.
 */
class _DLLEXP_ TPM2_ZGen_2Phase_REQUEST : public ReqStructure
{
public:
    /** Handle of an unrestricted decryption key ECC
     *  The private key referenced by this handle is used as dS,A
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE keyA;
    
    /** Other partys static public key (Qs,B = (Xs,B, Ys,B))  */
    TPMS_ECC_POINT inQsB;
    
    /** Other party's ephemeral public key (Qe,B = (Xe,B, Ye,B))  */
    TPMS_ECC_POINT inQeB;
    
    /** The key exchange scheme  */
    TPM_ALG_ID inScheme;
    
    /** Value returned by TPM2_EC_Ephemeral()  */
    UINT16 counter;

public:
    TPM2_ZGen_2Phase_REQUEST() { inScheme = TPM_ALG_ID::_NULL; }
    TPM2_ZGen_2Phase_REQUEST(const TPM_HANDLE& _keyA, const TPMS_ECC_POINT& _inQsB, const TPMS_ECC_POINT& _inQeB, TPM_ALG_ID _inScheme, UINT16 _counter)
      : keyA(_keyA), inQsB(_inQsB), inQeB(_inQeB), inScheme(_inScheme), counter(_counter)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ZGen_2Phase_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ZGen_2Phase_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ZGen_2Phase_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ZGen_2Phase_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ZGen_2Phase_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ZGen_2Phase_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyA}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ZGen_2Phase_REQUEST

/** This command supports two-phase key exchange protocols. The command is used in
 *  combination with TPM2_EC_Ephemeral(). TPM2_EC_Ephemeral() generates an ephemeral key
 *  and returns the public point of that ephemeral key along with a numeric value that
 *  allows the TPM to regenerate the associated private key.
 */
class _DLLEXP_ ZGen_2PhaseResponse : public RespStructure
{
public:
    /** X and Y coordinates of the computed value (scheme dependent)  */
    TPMS_ECC_POINT outZ1;
    
    /** X and Y coordinates of the second computed value (scheme dependent)  */
    TPMS_ECC_POINT outZ2;

public:
    ZGen_2PhaseResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ZGen_2PhaseResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ZGen_2PhaseResponse>(); }
    
    /** Static marshaling helper  */
    static ZGen_2PhaseResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ZGen_2PhaseResponse>(buf); }
    
    virtual const char* TypeName () const { return "ZGen_2PhaseResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ZGen_2PhaseResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ZGen_2PhaseResponse

/** This command performs ECC encryption as described in Part 1, Annex D.  */
class _DLLEXP_ TPM2_ECC_Encrypt_REQUEST : public ReqStructure
{
public:
    /** Reference to public portion of ECC key to use for encryption
     *  Auth Index: None
     */
    TPM_HANDLE keyHandle;
    
    /** Plaintext to be encrypted  */
    ByteVec plainText;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
     *  (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
     *  TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
     */
    shared_ptr<TPMU_KDF_SCHEME> inScheme;

public:
    TPM2_ECC_Encrypt_REQUEST() {}
    TPM2_ECC_Encrypt_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _plainText, const TPMU_KDF_SCHEME& _inScheme)
      : keyHandle(_keyHandle), plainText(_plainText), inScheme(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ECC_Encrypt_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ECC_Encrypt_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ECC_Encrypt_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ECC_Encrypt_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ECC_Encrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ECC_Encrypt_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ECC_Encrypt_REQUEST

/** This command performs ECC encryption as described in Part 1, Annex D.  */
class _DLLEXP_ ECC_EncryptResponse : public RespStructure
{
public:
    /** The public ephemeral key used for ECDH  */
    TPMS_ECC_POINT C1;
    
    /** The data block produced by the XOR process  */
    ByteVec C2;
    
    /** The integrity value  */
    ByteVec C3;

public:
    ECC_EncryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ECC_EncryptResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ECC_EncryptResponse>(); }
    
    /** Static marshaling helper  */
    static ECC_EncryptResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ECC_EncryptResponse>(buf); }
    
    virtual const char* TypeName () const { return "ECC_EncryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ECC_EncryptResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECC_EncryptResponse

/** This command performs ECC decryption.  */
class _DLLEXP_ TPM2_ECC_Decrypt_REQUEST : public ReqStructure
{
public:
    /** ECC key to use for decryption
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE keyHandle;
    
    /** The public ephemeral key used for ECDH  */
    TPMS_ECC_POINT C1;
    
    /** The data block produced by the XOR process  */
    ByteVec C2;
    
    /** The integrity value  */
    ByteVec C3;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The KDF to use if scheme associated with keyHandle is TPM_ALG_NULL
     *  (One of [TPMS_KDF_SCHEME_MGF1, TPMS_KDF_SCHEME_KDF1_SP800_56A, TPMS_KDF_SCHEME_KDF2,
     *  TPMS_KDF_SCHEME_KDF1_SP800_108, TPMS_SCHEME_HASH, TPMS_NULL_KDF_SCHEME])
     */
    shared_ptr<TPMU_KDF_SCHEME> inScheme;

public:
    TPM2_ECC_Decrypt_REQUEST() {}
    TPM2_ECC_Decrypt_REQUEST(const TPM_HANDLE& _keyHandle, const TPMS_ECC_POINT& _C1, const ByteVec& _C2, const ByteVec& _C3, const TPMU_KDF_SCHEME& _inScheme)
      : keyHandle(_keyHandle), C1(_C1), C2(_C2), C3(_C3), inScheme(dynamic_cast<TPMU_KDF_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ECC_Decrypt_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ECC_Decrypt_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ECC_Decrypt_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ECC_Decrypt_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ECC_Decrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ECC_Decrypt_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_ECC_Decrypt_REQUEST

/** This command performs ECC decryption.  */
class _DLLEXP_ ECC_DecryptResponse : public RespStructure
{
public:
    /** Decrypted output  */
    ByteVec plainText;

public:
    ECC_DecryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ECC_DecryptResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ECC_DecryptResponse>(); }
    
    /** Static marshaling helper  */
    static ECC_DecryptResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ECC_DecryptResponse>(buf); }
    
    virtual const char* TypeName () const { return "ECC_DecryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ECC_DecryptResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class ECC_DecryptResponse

/** NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
 *  should be reflected in platform-specific specifications.
 */
class _DLLEXP_ TPM2_EncryptDecrypt_REQUEST : public ReqStructure
{
public:
    /** The symmetric key used for the operation
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE keyHandle;
    
    /** If YES, then the operation is decryption; if NO, the operation is encryption  */
    BYTE decrypt;
    
    /** Symmetric encryption/decryption mode
     *  this field shall match the default mode of the key or be TPM_ALG_NULL.
     */
    TPM_ALG_ID mode;
    
    /** An initial value as required by the algorithm  */
    ByteVec ivIn;
    
    /** The data to be encrypted/decrypted  */
    ByteVec inData;

public:
    TPM2_EncryptDecrypt_REQUEST() { mode = TPM_ALG_ID::_NULL; }
    TPM2_EncryptDecrypt_REQUEST(const TPM_HANDLE& _keyHandle, BYTE _decrypt, TPM_ALG_ID _mode, const ByteVec& _ivIn, const ByteVec& _inData)
      : keyHandle(_keyHandle), decrypt(_decrypt), mode(_mode), ivIn(_ivIn), inData(_inData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_EncryptDecrypt_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_EncryptDecrypt_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_EncryptDecrypt_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_EncryptDecrypt_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_EncryptDecrypt_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_EncryptDecrypt_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
}; // class TPM2_EncryptDecrypt_REQUEST

/** NOTE 1 This command is deprecated, and TPM2_EncryptDecrypt2() is preferred. This
 *  should be reflected in platform-specific specifications.
 */
class _DLLEXP_ EncryptDecryptResponse : public RespStructure
{
public:
    /** Encrypted or decrypted output  */
    ByteVec outData;
    
    /** Chaining value to use for IV in next round  */
    ByteVec ivOut;

public:
    EncryptDecryptResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static EncryptDecryptResponse fromTpm(TpmBuffer& buf) { return buf.createObj<EncryptDecryptResponse>(); }
    
    /** Static marshaling helper  */
    static EncryptDecryptResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<EncryptDecryptResponse>(buf); }
    
    virtual const char* TypeName () const { return "EncryptDecryptResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new EncryptDecryptResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class EncryptDecryptResponse

/** This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
 *  is the first parameter. This permits inData to be parameter encrypted.
 */
class _DLLEXP_ TPM2_EncryptDecrypt2_REQUEST : public ReqStructure
{
public:
    /** The symmetric key used for the operation
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE keyHandle;
    
    /** The data to be encrypted/decrypted  */
    ByteVec inData;
    
    /** If YES, then the operation is decryption; if NO, the operation is encryption  */
    BYTE decrypt;
    
    /** Symmetric mode
     *  this field shall match the default mode of the key or be TPM_ALG_NULL.
     */
    TPM_ALG_ID mode;
    
    /** An initial value as required by the algorithm  */
    ByteVec ivIn;

public:
    TPM2_EncryptDecrypt2_REQUEST() { mode = TPM_ALG_ID::_NULL; }
    TPM2_EncryptDecrypt2_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _inData, BYTE _decrypt, TPM_ALG_ID _mode, const ByteVec& _ivIn)
      : keyHandle(_keyHandle), inData(_inData), decrypt(_decrypt), mode(_mode), ivIn(_ivIn)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_EncryptDecrypt2_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_EncryptDecrypt2_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_EncryptDecrypt2_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_EncryptDecrypt2_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_EncryptDecrypt2_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_EncryptDecrypt2_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_EncryptDecrypt2_REQUEST

/** This command is identical to TPM2_EncryptDecrypt(), except that the inData parameter
 *  is the first parameter. This permits inData to be parameter encrypted.
 */
class _DLLEXP_ EncryptDecrypt2Response : public RespStructure
{
public:
    /** Encrypted or decrypted output  */
    ByteVec outData;
    
    /** Chaining value to use for IV in next round  */
    ByteVec ivOut;

public:
    EncryptDecrypt2Response() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static EncryptDecrypt2Response fromTpm(TpmBuffer& buf) { return buf.createObj<EncryptDecrypt2Response>(); }
    
    /** Static marshaling helper  */
    static EncryptDecrypt2Response fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<EncryptDecrypt2Response>(buf); }
    
    virtual const char* TypeName () const { return "EncryptDecrypt2Response"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new EncryptDecrypt2Response(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class EncryptDecrypt2Response

/** This command performs a hash operation on a data buffer and returns the results.  */
class _DLLEXP_ TPM2_Hash_REQUEST : public ReqStructure
{
public:
    /** Data to be hashed  */
    ByteVec data;
    
    /** Algorithm for the hash being computed shall not be TPM_ALG_NULL  */
    TPM_ALG_ID hashAlg;
    
    /** Hierarchy to use for the ticket (TPM_RH_NULL allowed)  */
    TPM_HANDLE hierarchy;

public:
    TPM2_Hash_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_Hash_REQUEST(const ByteVec& _data, TPM_ALG_ID _hashAlg, const TPM_HANDLE& _hierarchy)
      : data(_data), hashAlg(_hashAlg), hierarchy(_hierarchy)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Hash_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Hash_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Hash_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Hash_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Hash_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Hash_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Hash_REQUEST

/** This command performs a hash operation on a data buffer and returns the results.  */
class _DLLEXP_ HashResponse : public RespStructure
{
public:
    /** Results  */
    ByteVec outHash;
    
    /** Ticket indicating that the sequence of octets used to compute outDigest did not start
     *  with TPM_GENERATED_VALUE
     *  will be a NULL ticket if the digest may not be signed with a restricted key
     */
    TPMT_TK_HASHCHECK validation;

public:
    HashResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static HashResponse fromTpm(TpmBuffer& buf) { return buf.createObj<HashResponse>(); }
    
    /** Static marshaling helper  */
    static HashResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<HashResponse>(buf); }
    
    virtual const char* TypeName () const { return "HashResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new HashResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class HashResponse

/** This command performs an HMAC on the supplied data using the indicated hash algorithm.  */
class _DLLEXP_ TPM2_HMAC_REQUEST : public ReqStructure
{
public:
    /** Handle for the symmetric signing key providing the HMAC key
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE handle;
    
    /** HMAC data  */
    ByteVec buffer;
    
    /** Algorithm to use for HMAC  */
    TPM_ALG_ID hashAlg;

public:
    TPM2_HMAC_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_HMAC_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _buffer, TPM_ALG_ID _hashAlg)
      : handle(_handle), buffer(_buffer), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_HMAC_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_HMAC_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_HMAC_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_HMAC_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_HMAC_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_HMAC_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HMAC_REQUEST

/** This command performs an HMAC on the supplied data using the indicated hash algorithm.  */
class _DLLEXP_ HMACResponse : public RespStructure
{
public:
    /** The returned HMAC in a sized buffer  */
    ByteVec outHMAC;

public:
    HMACResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static HMACResponse fromTpm(TpmBuffer& buf) { return buf.createObj<HMACResponse>(); }
    
    /** Static marshaling helper  */
    static HMACResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<HMACResponse>(buf); }
    
    virtual const char* TypeName () const { return "HMACResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new HMACResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class HMACResponse

/** This command performs an HMAC or a block cipher MAC on the supplied data using the
 *  indicated algorithm.
 */
class _DLLEXP_ TPM2_MAC_REQUEST : public ReqStructure
{
public:
    /** Handle for the symmetric signing key providing the MAC key
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE handle;
    
    /** MAC data  */
    ByteVec buffer;
    
    /** Algorithm to use for MAC  */
    TPM_ALG_ID inScheme;

public:
    TPM2_MAC_REQUEST() { inScheme = TPM_ALG_ID::_NULL; }
    TPM2_MAC_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _buffer, TPM_ALG_ID _inScheme)
      : handle(_handle), buffer(_buffer), inScheme(_inScheme)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_MAC_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_MAC_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_MAC_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_MAC_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_MAC_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_MAC_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_MAC_REQUEST

/** This command performs an HMAC or a block cipher MAC on the supplied data using the
 *  indicated algorithm.
 */
class _DLLEXP_ MACResponse : public RespStructure
{
public:
    /** The returned MAC in a sized buffer  */
    ByteVec outMAC;

public:
    MACResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static MACResponse fromTpm(TpmBuffer& buf) { return buf.createObj<MACResponse>(); }
    
    /** Static marshaling helper  */
    static MACResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<MACResponse>(buf); }
    
    virtual const char* TypeName () const { return "MACResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new MACResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class MACResponse

/** This command returns the next bytesRequested octets from the random number generator (RNG).  */
class _DLLEXP_ TPM2_GetRandom_REQUEST : public ReqStructure
{
public:
    /** Number of octets to return  */
    UINT16 bytesRequested;

public:
    TPM2_GetRandom_REQUEST() {}
    TPM2_GetRandom_REQUEST(UINT16 _bytesRequested)
      : bytesRequested(_bytesRequested)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_GetRandom_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_GetRandom_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_GetRandom_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_GetRandom_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_GetRandom_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_GetRandom_REQUEST(*this); }
}; // class TPM2_GetRandom_REQUEST

/** This command returns the next bytesRequested octets from the random number generator (RNG).  */
class _DLLEXP_ GetRandomResponse : public RespStructure
{
public:
    /** The random octets  */
    ByteVec randomBytes;

public:
    GetRandomResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static GetRandomResponse fromTpm(TpmBuffer& buf) { return buf.createObj<GetRandomResponse>(); }
    
    /** Static marshaling helper  */
    static GetRandomResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<GetRandomResponse>(buf); }
    
    virtual const char* TypeName () const { return "GetRandomResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new GetRandomResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetRandomResponse

/** This command is used to add "additional information" to the RNG state.  */
class _DLLEXP_ TPM2_StirRandom_REQUEST : public ReqStructure
{
public:
    /** Additional information  */
    ByteVec inData;

public:
    TPM2_StirRandom_REQUEST() {}
    TPM2_StirRandom_REQUEST(const ByteVec& _inData)
      : inData(_inData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_StirRandom_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_StirRandom_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_StirRandom_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_StirRandom_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_StirRandom_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_StirRandom_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_StirRandom_REQUEST

/** This command starts an HMAC sequence. The TPM will create and initialize an HMAC
 *  sequence structure, assign a handle to the sequence, and set the authValue of the
 *  sequence object to the value in auth.
 */
class _DLLEXP_ TPM2_HMAC_Start_REQUEST : public ReqStructure
{
public:
    /** Handle of an HMAC key
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE handle;
    
    /** Authorization value for subsequent use of the sequence  */
    ByteVec auth;
    
    /** The hash algorithm to use for the HMAC  */
    TPM_ALG_ID hashAlg;

public:
    TPM2_HMAC_Start_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_HMAC_Start_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _auth, TPM_ALG_ID _hashAlg)
      : handle(_handle), auth(_auth), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_HMAC_Start_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_HMAC_Start_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_HMAC_Start_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_HMAC_Start_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_HMAC_Start_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_HMAC_Start_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HMAC_Start_REQUEST

/** This command starts an HMAC sequence. The TPM will create and initialize an HMAC
 *  sequence structure, assign a handle to the sequence, and set the authValue of the
 *  sequence object to the value in auth.
 */
class _DLLEXP_ HMAC_StartResponse : public RespStructure
{
public:
    /** A handle to reference the sequence  */
    TPM_HANDLE handle;

public:
    HMAC_StartResponse() {}
    
    /** Static marshaling helper  */
    static HMAC_StartResponse fromTpm(TpmBuffer& buf) { return buf.createObj<HMAC_StartResponse>(); }
    
    /** Static marshaling helper  */
    static HMAC_StartResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<HMAC_StartResponse>(buf); }
    
    virtual const char* TypeName () const { return "HMAC_StartResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new HMAC_StartResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class HMAC_StartResponse

/** This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
 *  structure, assign a handle to the sequence, and set the authValue of the sequence
 *  object to the value in auth.
 */
class _DLLEXP_ TPM2_MAC_Start_REQUEST : public ReqStructure
{
public:
    /** Handle of a MAC key
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE handle;
    
    /** Authorization value for subsequent use of the sequence  */
    ByteVec auth;
    
    /** The algorithm to use for the MAC  */
    TPM_ALG_ID inScheme;

public:
    TPM2_MAC_Start_REQUEST() { inScheme = TPM_ALG_ID::_NULL; }
    TPM2_MAC_Start_REQUEST(const TPM_HANDLE& _handle, const ByteVec& _auth, TPM_ALG_ID _inScheme)
      : handle(_handle), auth(_auth), inScheme(_inScheme)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_MAC_Start_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_MAC_Start_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_MAC_Start_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_MAC_Start_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_MAC_Start_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_MAC_Start_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {handle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_MAC_Start_REQUEST

/** This command starts a MAC sequence. The TPM will create and initialize a MAC sequence
 *  structure, assign a handle to the sequence, and set the authValue of the sequence
 *  object to the value in auth.
 */
class _DLLEXP_ MAC_StartResponse : public RespStructure
{
public:
    /** A handle to reference the sequence  */
    TPM_HANDLE handle;

public:
    MAC_StartResponse() {}
    
    /** Static marshaling helper  */
    static MAC_StartResponse fromTpm(TpmBuffer& buf) { return buf.createObj<MAC_StartResponse>(); }
    
    /** Static marshaling helper  */
    static MAC_StartResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<MAC_StartResponse>(buf); }
    
    virtual const char* TypeName () const { return "MAC_StartResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new MAC_StartResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class MAC_StartResponse

/** This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
 *  then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
 *  started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
 *  shall return TPM_RC_HASH.
 */
class _DLLEXP_ TPM2_HashSequenceStart_REQUEST : public ReqStructure
{
public:
    /** Authorization value for subsequent use of the sequence  */
    ByteVec auth;
    
    /** The hash algorithm to use for the hash sequence
     *  An Event Sequence starts if this is TPM_ALG_NULL.
     */
    TPM_ALG_ID hashAlg;

public:
    TPM2_HashSequenceStart_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_HashSequenceStart_REQUEST(const ByteVec& _auth, TPM_ALG_ID _hashAlg)
      : auth(_auth), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_HashSequenceStart_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_HashSequenceStart_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_HashSequenceStart_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_HashSequenceStart_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_HashSequenceStart_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_HashSequenceStart_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HashSequenceStart_REQUEST

/** This command starts a hash or an Event Sequence. If hashAlg is an implemented hash,
 *  then a hash sequence is started. If hashAlg is TPM_ALG_NULL, then an Event Sequence is
 *  started. If hashAlg is neither an implemented algorithm nor TPM_ALG_NULL, then the TPM
 *  shall return TPM_RC_HASH.
 */
class _DLLEXP_ HashSequenceStartResponse : public RespStructure
{
public:
    /** A handle to reference the sequence  */
    TPM_HANDLE handle;

public:
    HashSequenceStartResponse() {}
    
    /** Static marshaling helper  */
    static HashSequenceStartResponse fromTpm(TpmBuffer& buf) { return buf.createObj<HashSequenceStartResponse>(); }
    
    /** Static marshaling helper  */
    static HashSequenceStartResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<HashSequenceStartResponse>(buf); }
    
    virtual const char* TypeName () const { return "HashSequenceStartResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new HashSequenceStartResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class HashSequenceStartResponse

/** This command is used to add data to a hash or HMAC sequence. The amount of data in
 *  buffer may be any size up to the limits of the TPM.
 */
class _DLLEXP_ TPM2_SequenceUpdate_REQUEST : public ReqStructure
{
public:
    /** Handle for the sequence object
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE sequenceHandle;
    
    /** Data to be added to hash  */
    ByteVec buffer;

public:
    TPM2_SequenceUpdate_REQUEST() {}
    TPM2_SequenceUpdate_REQUEST(const TPM_HANDLE& _sequenceHandle, const ByteVec& _buffer)
      : sequenceHandle(_sequenceHandle), buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_SequenceUpdate_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_SequenceUpdate_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_SequenceUpdate_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_SequenceUpdate_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_SequenceUpdate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_SequenceUpdate_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {sequenceHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_SequenceUpdate_REQUEST

/** This command adds the last part of data, if any, to a hash/HMAC sequence and returns
 *  the result.
 */
class _DLLEXP_ TPM2_SequenceComplete_REQUEST : public ReqStructure
{
public:
    /** Authorization for the sequence
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE sequenceHandle;
    
    /** Data to be added to the hash/HMAC  */
    ByteVec buffer;
    
    /** Hierarchy of the ticket for a hash  */
    TPM_HANDLE hierarchy;

public:
    TPM2_SequenceComplete_REQUEST() {}
    TPM2_SequenceComplete_REQUEST(const TPM_HANDLE& _sequenceHandle, const ByteVec& _buffer, const TPM_HANDLE& _hierarchy)
      : sequenceHandle(_sequenceHandle), buffer(_buffer), hierarchy(_hierarchy)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_SequenceComplete_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_SequenceComplete_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_SequenceComplete_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_SequenceComplete_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_SequenceComplete_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_SequenceComplete_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {sequenceHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_SequenceComplete_REQUEST

/** This command adds the last part of data, if any, to a hash/HMAC sequence and returns
 *  the result.
 */
class _DLLEXP_ SequenceCompleteResponse : public RespStructure
{
public:
    /** The returned HMAC or digest in a sized buffer  */
    ByteVec result;
    
    /** Ticket indicating that the sequence of octets used to compute outDigest did not start
     *  with TPM_GENERATED_VALUE
     *  This is a NULL Ticket when the sequence is HMAC.
     */
    TPMT_TK_HASHCHECK validation;

public:
    SequenceCompleteResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static SequenceCompleteResponse fromTpm(TpmBuffer& buf) { return buf.createObj<SequenceCompleteResponse>(); }
    
    /** Static marshaling helper  */
    static SequenceCompleteResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<SequenceCompleteResponse>(buf); }
    
    virtual const char* TypeName () const { return "SequenceCompleteResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new SequenceCompleteResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class SequenceCompleteResponse

/** This command adds the last part of data, if any, to an Event Sequence and returns the
 *  result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
 *  returned digest list is processed in the same manner as the digest list input
 *  parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
 *  pcrHandle, it is extended with the associated digest value from the list.
 */
class _DLLEXP_ TPM2_EventSequenceComplete_REQUEST : public ReqStructure
{
public:
    /** PCR to be extended with the Event data
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE pcrHandle;
    
    /** Authorization for the sequence
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE sequenceHandle;
    
    /** Data to be added to the Event  */
    ByteVec buffer;

public:
    TPM2_EventSequenceComplete_REQUEST() {}
    TPM2_EventSequenceComplete_REQUEST(const TPM_HANDLE& _pcrHandle, const TPM_HANDLE& _sequenceHandle, const ByteVec& _buffer)
      : pcrHandle(_pcrHandle), sequenceHandle(_sequenceHandle), buffer(_buffer)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_EventSequenceComplete_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_EventSequenceComplete_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_EventSequenceComplete_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_EventSequenceComplete_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_EventSequenceComplete_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_EventSequenceComplete_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {pcrHandle, sequenceHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_EventSequenceComplete_REQUEST

/** This command adds the last part of data, if any, to an Event Sequence and returns the
 *  result in a digest list. If pcrHandle references a PCR and not TPM_RH_NULL, then the
 *  returned digest list is processed in the same manner as the digest list input
 *  parameter to TPM2_PCR_Extend(). That is, if a bank contains a PCR associated with
 *  pcrHandle, it is extended with the associated digest value from the list.
 */
class _DLLEXP_ EventSequenceCompleteResponse : public RespStructure
{
public:
    /** List of digests computed for the PCR  */
    vector<TPMT_HA> results;

public:
    EventSequenceCompleteResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static EventSequenceCompleteResponse fromTpm(TpmBuffer& buf) { return buf.createObj<EventSequenceCompleteResponse>(); }
    
    /** Static marshaling helper  */
    static EventSequenceCompleteResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<EventSequenceCompleteResponse>(buf); }
    
    virtual const char* TypeName () const { return "EventSequenceCompleteResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new EventSequenceCompleteResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {4, 66}; }
}; // class EventSequenceCompleteResponse

/** The purpose of this command is to prove that an object with a specific Name is loaded
 *  in the TPM. By certifying that the object is loaded, the TPM warrants that a public
 *  area with a given Name is self-consistent and associated with a valid sensitive area.
 *  If a relying party has a public area that has the same Name as a Name certified with
 *  this command, then the values in that public area are correct.
 */
class _DLLEXP_ TPM2_Certify_REQUEST : public ReqStructure
{
public:
    /** Handle of the object to be certified
     *  Auth Index: 1
     *  Auth Role: ADMIN
     */
    TPM_HANDLE objectHandle;
    
    /** Handle of the key used to sign the attestation structure
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** User provided qualifying data  */
    ByteVec qualifyingData;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_Certify_REQUEST() {}
    TPM2_Certify_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : objectHandle(_objectHandle), signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Certify_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Certify_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Certify_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Certify_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Certify_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Certify_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {objectHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Certify_REQUEST

/** The purpose of this command is to prove that an object with a specific Name is loaded
 *  in the TPM. By certifying that the object is loaded, the TPM warrants that a public
 *  area with a given Name is self-consistent and associated with a valid sensitive area.
 *  If a relying party has a public area that has the same Name as a Name certified with
 *  this command, then the values in that public area are correct.
 */
class _DLLEXP_ CertifyResponse : public RespStructure
{
public:
    /** The structure that was signed  */
    TPMS_ATTEST certifyInfo;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The asymmetric signature over certifyInfo using the key referenced by signHandle
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    CertifyResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CertifyResponse fromTpm(TpmBuffer& buf) { return buf.createObj<CertifyResponse>(); }
    
    /** Static marshaling helper  */
    static CertifyResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CertifyResponse>(buf); }
    
    virtual const char* TypeName () const { return "CertifyResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CertifyResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CertifyResponse

/** This command is used to prove the association between an object and its creation data.
 *  The TPM will validate that the ticket was produced by the TPM and that the ticket
 *  validates the association between a loaded public area and the provided hash of the
 *  creation data (creationHash).
 */
class _DLLEXP_ TPM2_CertifyCreation_REQUEST : public ReqStructure
{
public:
    /** Handle of the key that will sign the attestation block
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** The object associated with the creation data
     *  Auth Index: None
     */
    TPM_HANDLE objectHandle;
    
    /** User-provided qualifying data  */
    ByteVec qualifyingData;
    
    /** Hash of the creation data produced by TPM2_Create() or TPM2_CreatePrimary()  */
    ByteVec creationHash;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /** Ticket produced by TPM2_Create() or TPM2_CreatePrimary()  */
    TPMT_TK_CREATION creationTicket;

public:
    TPM2_CertifyCreation_REQUEST() {}
    TPM2_CertifyCreation_REQUEST(const TPM_HANDLE& _signHandle, const TPM_HANDLE& _objectHandle, const ByteVec& _qualifyingData, const ByteVec& _creationHash, const TPMU_SIG_SCHEME& _inScheme, const TPMT_TK_CREATION& _creationTicket)
      : signHandle(_signHandle), objectHandle(_objectHandle), qualifyingData(_qualifyingData), creationHash(_creationHash), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), creationTicket(_creationTicket)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_CertifyCreation_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_CertifyCreation_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_CertifyCreation_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_CertifyCreation_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_CertifyCreation_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_CertifyCreation_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {signHandle, objectHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CertifyCreation_REQUEST

/** This command is used to prove the association between an object and its creation data.
 *  The TPM will validate that the ticket was produced by the TPM and that the ticket
 *  validates the association between a loaded public area and the provided hash of the
 *  creation data (creationHash).
 */
class _DLLEXP_ CertifyCreationResponse : public RespStructure
{
public:
    /** The structure that was signed  */
    TPMS_ATTEST certifyInfo;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The signature over certifyInfo
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    CertifyCreationResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CertifyCreationResponse fromTpm(TpmBuffer& buf) { return buf.createObj<CertifyCreationResponse>(); }
    
    /** Static marshaling helper  */
    static CertifyCreationResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CertifyCreationResponse>(buf); }
    
    virtual const char* TypeName () const { return "CertifyCreationResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CertifyCreationResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CertifyCreationResponse

/** This command is used to quote PCR values.  */
class _DLLEXP_ TPM2_Quote_REQUEST : public ReqStructure
{
public:
    /** Handle of key that will perform signature
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** Data supplied by the caller  */
    ByteVec qualifyingData;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /** PCR set to quote  */
    vector<TPMS_PCR_SELECTION> PCRselect;

public:
    TPM2_Quote_REQUEST() {}
    TPM2_Quote_REQUEST(const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme, const vector<TPMS_PCR_SELECTION>& _PCRselect)
      : signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), PCRselect(_PCRselect)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Quote_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Quote_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Quote_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Quote_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Quote_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Quote_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Quote_REQUEST

/** This command is used to quote PCR values.  */
class _DLLEXP_ QuoteResponse : public RespStructure
{
public:
    /** The quoted information  */
    TPMS_ATTEST quoted;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The signature over quoted
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    QuoteResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static QuoteResponse fromTpm(TpmBuffer& buf) { return buf.createObj<QuoteResponse>(); }
    
    /** Static marshaling helper  */
    static QuoteResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<QuoteResponse>(buf); }
    
    virtual const char* TypeName () const { return "QuoteResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new QuoteResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class QuoteResponse

/** This command returns a digital signature of the audit session digest.  */
class _DLLEXP_ TPM2_GetSessionAuditDigest_REQUEST : public ReqStructure
{
public:
    /** Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE privacyAdminHandle;
    
    /** Handle of the signing key
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** Handle of the audit session
     *  Auth Index: None
     */
    TPM_HANDLE sessionHandle;
    
    /** User-provided qualifying data may be zero-length  */
    ByteVec qualifyingData;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_GetSessionAuditDigest_REQUEST() {}
    TPM2_GetSessionAuditDigest_REQUEST(const TPM_HANDLE& _privacyAdminHandle, const TPM_HANDLE& _signHandle, const TPM_HANDLE& _sessionHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : privacyAdminHandle(_privacyAdminHandle), signHandle(_signHandle), sessionHandle(_sessionHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_GetSessionAuditDigest_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_GetSessionAuditDigest_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_GetSessionAuditDigest_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_GetSessionAuditDigest_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_GetSessionAuditDigest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_GetSessionAuditDigest_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {privacyAdminHandle, signHandle, sessionHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_GetSessionAuditDigest_REQUEST

/** This command returns a digital signature of the audit session digest.  */
class _DLLEXP_ GetSessionAuditDigestResponse : public RespStructure
{
public:
    /** The audit information that was signed  */
    TPMS_ATTEST auditInfo;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The signature over auditInfo
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    GetSessionAuditDigestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static GetSessionAuditDigestResponse fromTpm(TpmBuffer& buf) { return buf.createObj<GetSessionAuditDigestResponse>(); }
    
    /** Static marshaling helper  */
    static GetSessionAuditDigestResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<GetSessionAuditDigestResponse>(buf); }
    
    virtual const char* TypeName () const { return "GetSessionAuditDigestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new GetSessionAuditDigestResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetSessionAuditDigestResponse

/** This command returns the current value of the command audit digest, a digest of the
 *  commands being audited, and the audit hash algorithm. These values are placed in an
 *  attestation structure and signed with the key referenced by signHandle.
 */
class _DLLEXP_ TPM2_GetCommandAuditDigest_REQUEST : public ReqStructure
{
public:
    /** Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE privacyHandle;
    
    /** The handle of the signing key
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** Other data to associate with this audit digest  */
    ByteVec qualifyingData;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_GetCommandAuditDigest_REQUEST() {}
    TPM2_GetCommandAuditDigest_REQUEST(const TPM_HANDLE& _privacyHandle, const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : privacyHandle(_privacyHandle), signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_GetCommandAuditDigest_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_GetCommandAuditDigest_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_GetCommandAuditDigest_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_GetCommandAuditDigest_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_GetCommandAuditDigest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_GetCommandAuditDigest_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {privacyHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_GetCommandAuditDigest_REQUEST

/** This command returns the current value of the command audit digest, a digest of the
 *  commands being audited, and the audit hash algorithm. These values are placed in an
 *  attestation structure and signed with the key referenced by signHandle.
 */
class _DLLEXP_ GetCommandAuditDigestResponse : public RespStructure
{
public:
    /** The auditInfo that was signed  */
    TPMS_ATTEST auditInfo;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The signature over auditInfo
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    GetCommandAuditDigestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static GetCommandAuditDigestResponse fromTpm(TpmBuffer& buf) { return buf.createObj<GetCommandAuditDigestResponse>(); }
    
    /** Static marshaling helper  */
    static GetCommandAuditDigestResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<GetCommandAuditDigestResponse>(buf); }
    
    virtual const char* TypeName () const { return "GetCommandAuditDigestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new GetCommandAuditDigestResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetCommandAuditDigestResponse

/** This command returns the current values of Time and Clock.  */
class _DLLEXP_ TPM2_GetTime_REQUEST : public ReqStructure
{
public:
    /** Handle of the privacy administrator (TPM_RH_ENDORSEMENT)
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE privacyAdminHandle;
    
    /** The keyHandle identifier of a loaded key that can perform digital signatures
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** Data to tick stamp  */
    ByteVec qualifyingData;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;

public:
    TPM2_GetTime_REQUEST() {}
    TPM2_GetTime_REQUEST(const TPM_HANDLE& _privacyAdminHandle, const TPM_HANDLE& _signHandle, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme)
      : privacyAdminHandle(_privacyAdminHandle), signHandle(_signHandle), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_GetTime_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_GetTime_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_GetTime_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_GetTime_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_GetTime_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_GetTime_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {privacyAdminHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_GetTime_REQUEST

/** This command returns the current values of Time and Clock.  */
class _DLLEXP_ GetTimeResponse : public RespStructure
{
public:
    /** Standard TPM-generated attestation block  */
    TPMS_ATTEST timeInfo;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The signature over timeInfo
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    GetTimeResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static GetTimeResponse fromTpm(TpmBuffer& buf) { return buf.createObj<GetTimeResponse>(); }
    
    /** Static marshaling helper  */
    static GetTimeResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<GetTimeResponse>(buf); }
    
    virtual const char* TypeName () const { return "GetTimeResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new GetTimeResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class GetTimeResponse

/** The purpose of this command is to generate an X.509 certificate that proves an object
 *  with a specific public key and attributes is loaded in the TPM. In contrast to
 *  TPM2_Certify, which uses a TCG-defined data structure to convey attestation
 *  information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
 *  X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
 *  Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
 */
class _DLLEXP_ TPM2_CertifyX509_REQUEST : public ReqStructure
{
public:
    /** Handle of the object to be certified
     *  Auth Index: 1
     *  Auth Role: ADMIN
     */
    TPM_HANDLE objectHandle;
    
    /** Handle of the key used to sign the attestation structure
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** Shall be an Empty Buffer  */
    ByteVec reserved;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /** A DER encoded partial certificate  */
    ByteVec partialCertificate;

public:
    TPM2_CertifyX509_REQUEST() {}
    TPM2_CertifyX509_REQUEST(const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _signHandle, const ByteVec& _reserved, const TPMU_SIG_SCHEME& _inScheme, const ByteVec& _partialCertificate)
      : objectHandle(_objectHandle), signHandle(_signHandle), reserved(_reserved), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), partialCertificate(_partialCertificate)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_CertifyX509_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_CertifyX509_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_CertifyX509_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_CertifyX509_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_CertifyX509_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_CertifyX509_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {objectHandle, signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CertifyX509_REQUEST

/** The purpose of this command is to generate an X.509 certificate that proves an object
 *  with a specific public key and attributes is loaded in the TPM. In contrast to
 *  TPM2_Certify, which uses a TCG-defined data structure to convey attestation
 *  information, TPM2_CertifyX509 encodes the attestation information in a DER-encoded
 *  X.509 certificate that is compliant with RFC5280 Internet X.509 Public Key
 *  Infrastructure Certificate and Certificate Revocation List (CRL) Profile.
 */
class _DLLEXP_ CertifyX509Response : public RespStructure
{
public:
    /** A DER encoded SEQUENCE containing the DER encoded fields added to partialCertificate
     *  to make it a complete RFC5280 TBSCertificate.
     */
    ByteVec addedToCertificate;
    
    /** The digest that was signed  */
    ByteVec tbsDigest;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The signature over tbsDigest
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    CertifyX509Response() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CertifyX509Response fromTpm(TpmBuffer& buf) { return buf.createObj<CertifyX509Response>(); }
    
    /** Static marshaling helper  */
    static CertifyX509Response fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CertifyX509Response>(buf); }
    
    virtual const char* TypeName () const { return "CertifyX509Response"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CertifyX509Response(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CertifyX509Response

/** TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
 *  will perform the point multiplications on the provided points and return intermediate
 *  signing values. The signHandle parameter shall refer to an ECC key and the signing
 *  scheme must be anonymous (TPM_RC_SCHEME).
 */
class _DLLEXP_ TPM2_Commit_REQUEST : public ReqStructure
{
public:
    /** Handle of the key that will be used in the signing operation
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** A point (M) on the curve used by signHandle  */
    TPMS_ECC_POINT P1;
    
    /** Octet array used to derive x-coordinate of a base point  */
    ByteVec s2;
    
    /** Y coordinate of the point associated with s2  */
    ByteVec y2;

public:
    TPM2_Commit_REQUEST() {}
    TPM2_Commit_REQUEST(const TPM_HANDLE& _signHandle, const TPMS_ECC_POINT& _P1, const ByteVec& _s2, const ByteVec& _y2)
      : signHandle(_signHandle), P1(_P1), s2(_s2), y2(_y2)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Commit_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Commit_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Commit_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Commit_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Commit_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Commit_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {signHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Commit_REQUEST

/** TPM2_Commit() performs the first part of an ECC anonymous signing operation. The TPM
 *  will perform the point multiplications on the provided points and return intermediate
 *  signing values. The signHandle parameter shall refer to an ECC key and the signing
 *  scheme must be anonymous (TPM_RC_SCHEME).
 */
class _DLLEXP_ CommitResponse : public RespStructure
{
public:
    /** ECC point K [ds](x2, y2)  */
    TPMS_ECC_POINT K;
    
    /** ECC point L [r](x2, y2)  */
    TPMS_ECC_POINT L;
    
    /** ECC point E [r]P1  */
    TPMS_ECC_POINT E;
    
    /** Least-significant 16 bits of commitCount  */
    UINT16 counter;

public:
    CommitResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CommitResponse fromTpm(TpmBuffer& buf) { return buf.createObj<CommitResponse>(); }
    
    /** Static marshaling helper  */
    static CommitResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CommitResponse>(buf); }
    
    virtual const char* TypeName () const { return "CommitResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CommitResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CommitResponse

/** TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.  */
class _DLLEXP_ TPM2_EC_Ephemeral_REQUEST : public ReqStructure
{
public:
    /** The curve for the computed ephemeral point  */
    TPM_ECC_CURVE curveID;

public:
    TPM2_EC_Ephemeral_REQUEST() {}
    TPM2_EC_Ephemeral_REQUEST(TPM_ECC_CURVE _curveID)
      : curveID(_curveID)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_EC_Ephemeral_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_EC_Ephemeral_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_EC_Ephemeral_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_EC_Ephemeral_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_EC_Ephemeral_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_EC_Ephemeral_REQUEST(*this); }
}; // class TPM2_EC_Ephemeral_REQUEST

/** TPM2_EC_Ephemeral() creates an ephemeral key for use in a two-phase key exchange protocol.  */
class _DLLEXP_ EC_EphemeralResponse : public RespStructure
{
public:
    /** Ephemeral public key Q [r]G  */
    TPMS_ECC_POINT Q;
    
    /** Least-significant 16 bits of commitCount  */
    UINT16 counter;

public:
    EC_EphemeralResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static EC_EphemeralResponse fromTpm(TpmBuffer& buf) { return buf.createObj<EC_EphemeralResponse>(); }
    
    /** Static marshaling helper  */
    static EC_EphemeralResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<EC_EphemeralResponse>(buf); }
    
    virtual const char* TypeName () const { return "EC_EphemeralResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new EC_EphemeralResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class EC_EphemeralResponse

/** This command uses loaded keys to validate a signature on a message with the message
 *  digest passed to the TPM.
 */
class _DLLEXP_ TPM2_VerifySignature_REQUEST : public ReqStructure
{
public:
    /** Handle of public key that will be used in the validation
     *  Auth Index: None
     */
    TPM_HANDLE keyHandle;
    
    /** Digest of the signed message  */
    ByteVec digest;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signature to be tested
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    TPM2_VerifySignature_REQUEST() {}
    TPM2_VerifySignature_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _digest, const TPMU_SIGNATURE& _signature)
      : keyHandle(_keyHandle), digest(_digest), signature(dynamic_cast<TPMU_SIGNATURE*>(_signature.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_VerifySignature_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_VerifySignature_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_VerifySignature_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_VerifySignature_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_VerifySignature_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_VerifySignature_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_VerifySignature_REQUEST

/** This command uses loaded keys to validate a signature on a message with the message
 *  digest passed to the TPM.
 */
class _DLLEXP_ VerifySignatureResponse : public RespStructure
{
public:
    TPMT_TK_VERIFIED validation;

public:
    VerifySignatureResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static VerifySignatureResponse fromTpm(TpmBuffer& buf) { return buf.createObj<VerifySignatureResponse>(); }
    
    /** Static marshaling helper  */
    static VerifySignatureResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<VerifySignatureResponse>(buf); }
    
    virtual const char* TypeName () const { return "VerifySignatureResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new VerifySignatureResponse(*this); }
}; // class VerifySignatureResponse

/** This command causes the TPM to sign an externally provided hash with the specified
 *  symmetric or asymmetric signing key.
 */
class _DLLEXP_ TPM2_Sign_REQUEST : public ReqStructure
{
public:
    /** Handle of key that will perform signing
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE keyHandle;
    
    /** Digest to be signed  */
    ByteVec digest;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for keyHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /** Proof that digest was created by the TPM
     *  If keyHandle is not a restricted signing key, then this may be a NULL Ticket with tag
     *  = TPM_ST_CHECKHASH.
     */
    TPMT_TK_HASHCHECK validation;

public:
    TPM2_Sign_REQUEST() {}
    TPM2_Sign_REQUEST(const TPM_HANDLE& _keyHandle, const ByteVec& _digest, const TPMU_SIG_SCHEME& _inScheme, const TPMT_TK_HASHCHECK& _validation)
      : keyHandle(_keyHandle), digest(_digest), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), validation(_validation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Sign_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Sign_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Sign_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Sign_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Sign_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Sign_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Sign_REQUEST

/** This command causes the TPM to sign an externally provided hash with the specified
 *  symmetric or asymmetric signing key.
 */
class _DLLEXP_ SignResponse : public RespStructure
{
public:
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The signature
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    SignResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static SignResponse fromTpm(TpmBuffer& buf) { return buf.createObj<SignResponse>(); }
    
    /** Static marshaling helper  */
    static SignResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<SignResponse>(buf); }
    
    virtual const char* TypeName () const { return "SignResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new SignResponse(*this); }
}; // class SignResponse

/** This command may be used by the Privacy Administrator or platform to change the audit
 *  status of a command or to set the hash algorithm used for the audit digest, but not
 *  both at the same time.
 */
class _DLLEXP_ TPM2_SetCommandCodeAuditStatus_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE auth;
    
    /** Hash algorithm for the audit digest; if TPM_ALG_NULL, then the hash is not changed  */
    TPM_ALG_ID auditAlg;
    
    /** List of commands that will be added to those that will be audited  */
    vector<TPM_CC> setList;
    
    /** List of commands that will no longer be audited  */
    vector<TPM_CC> clearList;

public:
    TPM2_SetCommandCodeAuditStatus_REQUEST() { auditAlg = TPM_ALG_ID::_NULL; }
    TPM2_SetCommandCodeAuditStatus_REQUEST(const TPM_HANDLE& _auth, TPM_ALG_ID _auditAlg, const vector<TPM_CC>& _setList, const vector<TPM_CC>& _clearList)
      : auth(_auth), auditAlg(_auditAlg), setList(_setList), clearList(_clearList)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_SetCommandCodeAuditStatus_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_SetCommandCodeAuditStatus_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_SetCommandCodeAuditStatus_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_SetCommandCodeAuditStatus_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_SetCommandCodeAuditStatus_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_SetCommandCodeAuditStatus_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_SetCommandCodeAuditStatus_REQUEST

/** This command is used to cause an update to the indicated PCR. The digests parameter
 *  contains one or more tagged digest values identified by an algorithm ID. For each
 *  digest, the PCR associated with pcrHandle is Extended into the bank identified by the
 *  tag (hashAlg).
 */
class _DLLEXP_ TPM2_PCR_Extend_REQUEST : public ReqStructure
{
public:
    /** Handle of the PCR
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE pcrHandle;
    
    /** List of tagged digest values to be extended  */
    vector<TPMT_HA> digests;

public:
    TPM2_PCR_Extend_REQUEST() {}
    TPM2_PCR_Extend_REQUEST(const TPM_HANDLE& _pcrHandle, const vector<TPMT_HA>& _digests)
      : pcrHandle(_pcrHandle), digests(_digests)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PCR_Extend_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PCR_Extend_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PCR_Extend_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PCR_Extend_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PCR_Extend_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PCR_Extend_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 66}; }
}; // class TPM2_PCR_Extend_REQUEST

/** This command is used to cause an update to the indicated PCR.  */
class _DLLEXP_ TPM2_PCR_Event_REQUEST : public ReqStructure
{
public:
    /** Handle of the PCR
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE pcrHandle;
    
    /** Event data in sized buffer  */
    ByteVec eventData;

public:
    TPM2_PCR_Event_REQUEST() {}
    TPM2_PCR_Event_REQUEST(const TPM_HANDLE& _pcrHandle, const ByteVec& _eventData)
      : pcrHandle(_pcrHandle), eventData(_eventData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PCR_Event_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PCR_Event_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PCR_Event_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PCR_Event_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PCR_Event_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PCR_Event_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PCR_Event_REQUEST

/** This command is used to cause an update to the indicated PCR.  */
class _DLLEXP_ PCR_EventResponse : public RespStructure
{
public:
    vector<TPMT_HA> digests;

public:
    PCR_EventResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static PCR_EventResponse fromTpm(TpmBuffer& buf) { return buf.createObj<PCR_EventResponse>(); }
    
    /** Static marshaling helper  */
    static PCR_EventResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<PCR_EventResponse>(buf); }
    
    virtual const char* TypeName () const { return "PCR_EventResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new PCR_EventResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {4, 66}; }
}; // class PCR_EventResponse

/** This command returns the values of all PCR specified in pcrSelectionIn.  */
class _DLLEXP_ TPM2_PCR_Read_REQUEST : public ReqStructure
{
public:
    /** The selection of PCR to read  */
    vector<TPMS_PCR_SELECTION> pcrSelectionIn;

public:
    TPM2_PCR_Read_REQUEST() {}
    TPM2_PCR_Read_REQUEST(const vector<TPMS_PCR_SELECTION>& _pcrSelectionIn)
      : pcrSelectionIn(_pcrSelectionIn)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PCR_Read_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PCR_Read_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PCR_Read_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PCR_Read_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PCR_Read_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PCR_Read_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {4, 3}; }
}; // class TPM2_PCR_Read_REQUEST

/** This command returns the values of all PCR specified in pcrSelectionIn.  */
class _DLLEXP_ PCR_ReadResponse : public RespStructure
{
public:
    /** The current value of the PCR update counter  */
    UINT32 pcrUpdateCounter;
    
    /** The PCR in the returned list  */
    vector<TPMS_PCR_SELECTION> pcrSelectionOut;
    
    /** The contents of the PCR indicated in pcrSelectOut-˃ pcrSelection[] as tagged digests  */
    vector<TPM2B_DIGEST> pcrValues;

public:
    PCR_ReadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static PCR_ReadResponse fromTpm(TpmBuffer& buf) { return buf.createObj<PCR_ReadResponse>(); }
    
    /** Static marshaling helper  */
    static PCR_ReadResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<PCR_ReadResponse>(buf); }
    
    virtual const char* TypeName () const { return "PCR_ReadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new PCR_ReadResponse(*this); }
}; // class PCR_ReadResponse

/** This command is used to set the desired PCR allocation of PCR and algorithms. This
 *  command requires Platform Authorization.
 */
class _DLLEXP_ TPM2_PCR_Allocate_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The requested allocation  */
    vector<TPMS_PCR_SELECTION> pcrAllocation;

public:
    TPM2_PCR_Allocate_REQUEST() {}
    TPM2_PCR_Allocate_REQUEST(const TPM_HANDLE& _authHandle, const vector<TPMS_PCR_SELECTION>& _pcrAllocation)
      : authHandle(_authHandle), pcrAllocation(_pcrAllocation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PCR_Allocate_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PCR_Allocate_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PCR_Allocate_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PCR_Allocate_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PCR_Allocate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PCR_Allocate_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 3}; }
}; // class TPM2_PCR_Allocate_REQUEST

/** This command is used to set the desired PCR allocation of PCR and algorithms. This
 *  command requires Platform Authorization.
 */
class _DLLEXP_ PCR_AllocateResponse : public RespStructure
{
public:
    /** YES if the allocation succeeded  */
    BYTE allocationSuccess;
    
    /** Maximum number of PCR that may be in a bank  */
    UINT32 maxPCR;
    
    /** Number of octets required to satisfy the request  */
    UINT32 sizeNeeded;
    
    /** Number of octets available. Computed before the allocation.  */
    UINT32 sizeAvailable;

public:
    PCR_AllocateResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static PCR_AllocateResponse fromTpm(TpmBuffer& buf) { return buf.createObj<PCR_AllocateResponse>(); }
    
    /** Static marshaling helper  */
    static PCR_AllocateResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<PCR_AllocateResponse>(buf); }
    
    virtual const char* TypeName () const { return "PCR_AllocateResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new PCR_AllocateResponse(*this); }
}; // class PCR_AllocateResponse

/** This command is used to associate a policy with a PCR or group of PCR. The policy
 *  determines the conditions under which a PCR may be extended or reset.
 */
class _DLLEXP_ TPM2_PCR_SetAuthPolicy_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The desired authPolicy  */
    ByteVec authPolicy;
    
    /** The hash algorithm of the policy  */
    TPM_ALG_ID hashAlg;
    
    /** The PCR for which the policy is to be set  */
    TPM_HANDLE pcrNum;

public:
    TPM2_PCR_SetAuthPolicy_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_PCR_SetAuthPolicy_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _authPolicy, TPM_ALG_ID _hashAlg, const TPM_HANDLE& _pcrNum)
      : authHandle(_authHandle), authPolicy(_authPolicy), hashAlg(_hashAlg), pcrNum(_pcrNum)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PCR_SetAuthPolicy_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PCR_SetAuthPolicy_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PCR_SetAuthPolicy_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PCR_SetAuthPolicy_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PCR_SetAuthPolicy_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PCR_SetAuthPolicy_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PCR_SetAuthPolicy_REQUEST

/** This command changes the authValue of a PCR or group of PCR.  */
class _DLLEXP_ TPM2_PCR_SetAuthValue_REQUEST : public ReqStructure
{
public:
    /** Handle for a PCR that may have an authorization value set
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE pcrHandle;
    
    /** The desired authorization value  */
    ByteVec auth;

public:
    TPM2_PCR_SetAuthValue_REQUEST() {}
    TPM2_PCR_SetAuthValue_REQUEST(const TPM_HANDLE& _pcrHandle, const ByteVec& _auth)
      : pcrHandle(_pcrHandle), auth(_auth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PCR_SetAuthValue_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PCR_SetAuthValue_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PCR_SetAuthValue_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PCR_SetAuthValue_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PCR_SetAuthValue_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PCR_SetAuthValue_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PCR_SetAuthValue_REQUEST

/** If the attribute of a PCR allows the PCR to be reset and proper authorization is
 *  provided, then this command may be used to set the PCR in all banks to zero. The
 *  attributes of the PCR may restrict the locality that can perform the reset operation.
 */
class _DLLEXP_ TPM2_PCR_Reset_REQUEST : public ReqStructure
{
public:
    /** The PCR to reset
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE pcrHandle;

public:
    TPM2_PCR_Reset_REQUEST() {}
    TPM2_PCR_Reset_REQUEST(const TPM_HANDLE& _pcrHandle)
      : pcrHandle(_pcrHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_PCR_Reset_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PCR_Reset_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PCR_Reset_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PCR_Reset_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PCR_Reset_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PCR_Reset_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {pcrHandle}; }
}; // class TPM2_PCR_Reset_REQUEST

/** This command includes a signed authorization in a policy. The command ties the policy
 *  to a signing key by including the Name of the signing key in the policyDigest
 */
class _DLLEXP_ TPM2_PolicySigned_REQUEST : public ReqStructure
{
public:
    /** Handle for a key that will validate the signature
     *  Auth Index: None
     */
    TPM_HANDLE authObject;
    
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The policy nonce for the session
     *  This can be the Empty Buffer.
     */
    ByteVec nonceTPM;
    
    /** Digest of the command parameters to which this authorization is limited
     *  This is not the cpHash for this command but the cpHash for the command to which this
     *  policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
     */
    ByteVec cpHashA;
    
    /** A reference to a policy relating to the authorization may be the Empty Buffer
     *  Size is limited to be no larger than the nonce size supported on the TPM.
     */
    ByteVec policyRef;
    
    /** Time when authorization will expire, measured in seconds from the time that nonceTPM
     *  was generated
     *  If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
     */
    INT32 expiration;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID authSigAlg() const { return auth ? auth->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signed authorization (not optional)
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> auth;

public:
    TPM2_PolicySigned_REQUEST() {}
    TPM2_PolicySigned_REQUEST(const TPM_HANDLE& _authObject, const TPM_HANDLE& _policySession, const ByteVec& _nonceTPM, const ByteVec& _cpHashA, const ByteVec& _policyRef, INT32 _expiration, const TPMU_SIGNATURE& _auth)
      : authObject(_authObject), policySession(_policySession), nonceTPM(_nonceTPM), cpHashA(_cpHashA), policyRef(_policyRef), expiration(_expiration), auth(dynamic_cast<TPMU_SIGNATURE*>(_auth.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicySigned_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicySigned_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicySigned_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicySigned_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicySigned_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicySigned_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authObject, policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicySigned_REQUEST

/** This command includes a signed authorization in a policy. The command ties the policy
 *  to a signing key by including the Name of the signing key in the policyDigest
 */
class _DLLEXP_ PolicySignedResponse : public RespStructure
{
public:
    /** Implementation-specific time value, used to indicate to the TPM when the ticket expires
     *  NOTE If policyTicket is a NULL Ticket, then this shall be the Empty Buffer.
     */
    ByteVec timeout;
    
    /** Produced if the command succeeds and expiration in the command was non-zero; this
     *  ticket will use the TPMT_ST_AUTH_SIGNED structure tag. See 23.2.5
     */
    TPMT_TK_AUTH policyTicket;

public:
    PolicySignedResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static PolicySignedResponse fromTpm(TpmBuffer& buf) { return buf.createObj<PolicySignedResponse>(); }
    
    /** Static marshaling helper  */
    static PolicySignedResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<PolicySignedResponse>(buf); }
    
    virtual const char* TypeName () const { return "PolicySignedResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new PolicySignedResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class PolicySignedResponse

/** This command includes a secret-based authorization to a policy. The caller proves
 *  knowledge of the secret value using an authorization session using the authValue
 *  associated with authHandle. A password session, an HMAC session, or a policy session
 *  containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
 */
class _DLLEXP_ TPM2_PolicySecret_REQUEST : public ReqStructure
{
public:
    /** Handle for an entity providing the authorization
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The policy nonce for the session
     *  This can be the Empty Buffer.
     */
    ByteVec nonceTPM;
    
    /** Digest of the command parameters to which this authorization is limited
     *  This not the cpHash for this command but the cpHash for the command to which this
     *  policy session will be applied. If it is not limited, the parameter will be the Empty Buffer.
     */
    ByteVec cpHashA;
    
    /** A reference to a policy relating to the authorization may be the Empty Buffer
     *  Size is limited to be no larger than the nonce size supported on the TPM.
     */
    ByteVec policyRef;
    
    /** Time when authorization will expire, measured in seconds from the time that nonceTPM
     *  was generated
     *  If expiration is non-negative, a NULL Ticket is returned. See 23.2.5.
     */
    INT32 expiration;

public:
    TPM2_PolicySecret_REQUEST() {}
    TPM2_PolicySecret_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _policySession, const ByteVec& _nonceTPM, const ByteVec& _cpHashA, const ByteVec& _policyRef, INT32 _expiration)
      : authHandle(_authHandle), policySession(_policySession), nonceTPM(_nonceTPM), cpHashA(_cpHashA), policyRef(_policyRef), expiration(_expiration)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicySecret_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicySecret_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicySecret_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicySecret_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicySecret_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicySecret_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicySecret_REQUEST

/** This command includes a secret-based authorization to a policy. The caller proves
 *  knowledge of the secret value using an authorization session using the authValue
 *  associated with authHandle. A password session, an HMAC session, or a policy session
 *  containing TPM2_PolicyAuthValue() or TPM2_PolicyPassword() will satisfy this requirement.
 */
class _DLLEXP_ PolicySecretResponse : public RespStructure
{
public:
    /** Implementation-specific time value used to indicate to the TPM when the ticket expires  */
    ByteVec timeout;
    
    /** Produced if the command succeeds and expiration in the command was non-zero ( See
     *  23.2.5). This ticket will use the TPMT_ST_AUTH_SECRET structure tag
     */
    TPMT_TK_AUTH policyTicket;

public:
    PolicySecretResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static PolicySecretResponse fromTpm(TpmBuffer& buf) { return buf.createObj<PolicySecretResponse>(); }
    
    /** Static marshaling helper  */
    static PolicySecretResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<PolicySecretResponse>(buf); }
    
    virtual const char* TypeName () const { return "PolicySecretResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new PolicySecretResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class PolicySecretResponse

/** This command is similar to TPM2_PolicySigned() except that it takes a ticket instead
 *  of a signed authorization. The ticket represents a validated authorization that had an
 *  expiration time associated with it.
 */
class _DLLEXP_ TPM2_PolicyTicket_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** Time when authorization will expire
     *  The contents are TPM specific. This shall be the value returned when ticket was produced.
     */
    ByteVec timeout;
    
    /** Digest of the command parameters to which this authorization is limited
     *  If it is not limited, the parameter will be the Empty Buffer.
     */
    ByteVec cpHashA;
    
    /** Reference to a qualifier for the policy may be the Empty Buffer  */
    ByteVec policyRef;
    
    /** Name of the object that provided the authorization  */
    ByteVec authName;
    
    /** An authorization ticket returned by the TPM in response to a TPM2_PolicySigned() or
     *  TPM2_PolicySecret()
     */
    TPMT_TK_AUTH ticket;

public:
    TPM2_PolicyTicket_REQUEST() {}
    TPM2_PolicyTicket_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _timeout, const ByteVec& _cpHashA, const ByteVec& _policyRef, const ByteVec& _authName, const TPMT_TK_AUTH& _ticket)
      : policySession(_policySession), timeout(_timeout), cpHashA(_cpHashA), policyRef(_policyRef), authName(_authName), ticket(_ticket)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyTicket_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyTicket_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyTicket_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyTicket_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyTicket_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyTicket_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyTicket_REQUEST

/** This command allows options in authorizations without requiring that the TPM evaluate
 *  all of the options. If a policy may be satisfied by different sets of conditions, the
 *  TPM need only evaluate one set that satisfies the policy. This command will indicate
 *  that one of the required sets of conditions has been satisfied.
 */
class _DLLEXP_ TPM2_PolicyOR_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The list of hashes to check for a match  */
    vector<TPM2B_DIGEST> pHashList;

public:
    TPM2_PolicyOR_REQUEST() {}
    TPM2_PolicyOR_REQUEST(const TPM_HANDLE& _policySession, const vector<TPM2B_DIGEST>& _pHashList)
      : policySession(_policySession), pHashList(_pHashList)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyOR_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyOR_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyOR_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyOR_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyOR_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyOR_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 2}; }
}; // class TPM2_PolicyOR_REQUEST

/** This command is used to cause conditional gating of a policy based on PCR. This
 *  command together with TPM2_PolicyOR() allows one group of authorizations to occur when
 *  PCR are in one state and a different set of authorizations when the PCR are in a
 *  different state.
 */
class _DLLEXP_ TPM2_PolicyPCR_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** Expected digest value of the selected PCR using the hash algorithm of the session; may
     *  be zero length
     */
    ByteVec pcrDigest;
    
    /** The PCR to include in the check digest  */
    vector<TPMS_PCR_SELECTION> pcrs;

public:
    TPM2_PolicyPCR_REQUEST() {}
    TPM2_PolicyPCR_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _pcrDigest, const vector<TPMS_PCR_SELECTION>& _pcrs)
      : policySession(_policySession), pcrDigest(_pcrDigest), pcrs(_pcrs)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyPCR_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyPCR_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyPCR_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyPCR_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyPCR_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyPCR_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyPCR_REQUEST

/** This command indicates that the authorization will be limited to a specific locality.  */
class _DLLEXP_ TPM2_PolicyLocality_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The allowed localities for the policy  */
    TPMA_LOCALITY locality;

public:
    TPM2_PolicyLocality_REQUEST() {}
    TPM2_PolicyLocality_REQUEST(const TPM_HANDLE& _policySession, TPMA_LOCALITY _locality)
      : policySession(_policySession), locality(_locality)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyLocality_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyLocality_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyLocality_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyLocality_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyLocality_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyLocality_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyLocality_REQUEST

/** This command is used to cause conditional gating of a policy based on the contents of
 *  an NV Index. It is an immediate assertion. The NV index is validated during the
 *  TPM2_PolicyNV() command, not when the session is used for authorization.
 */
class _DLLEXP_ TPM2_PolicyNV_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index of the area to read
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;
    
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The second operand  */
    ByteVec operandB;
    
    /** The octet offset in the NV Index for the start of operand A  */
    UINT16 offset;
    
    /** The comparison to make  */
    TPM_EO operation;

public:
    TPM2_PolicyNV_REQUEST() {}
    TPM2_PolicyNV_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const TPM_HANDLE& _policySession, const ByteVec& _operandB, UINT16 _offset, TPM_EO _operation)
      : authHandle(_authHandle), nvIndex(_nvIndex), policySession(_policySession), operandB(_operandB), offset(_offset), operation(_operation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyNV_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyNV_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyNV_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyNV_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyNV_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyNV_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex, policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyNV_REQUEST

/** This command is used to cause conditional gating of a policy based on the contents of
 *  the TPMS_TIME_INFO structure.
 */
class _DLLEXP_ TPM2_PolicyCounterTimer_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The second operand  */
    ByteVec operandB;
    
    /** The octet offset in the TPMS_TIME_INFO structure for the start of operand A  */
    UINT16 offset;
    
    /** The comparison to make  */
    TPM_EO operation;

public:
    TPM2_PolicyCounterTimer_REQUEST() {}
    TPM2_PolicyCounterTimer_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _operandB, UINT16 _offset, TPM_EO _operation)
      : policySession(_policySession), operandB(_operandB), offset(_offset), operation(_operation)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyCounterTimer_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyCounterTimer_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyCounterTimer_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyCounterTimer_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyCounterTimer_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyCounterTimer_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyCounterTimer_REQUEST

/** This command indicates that the authorization will be limited to a specific command code.  */
class _DLLEXP_ TPM2_PolicyCommandCode_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The allowed commandCode  */
    TPM_CC code;

public:
    TPM2_PolicyCommandCode_REQUEST() {}
    TPM2_PolicyCommandCode_REQUEST(const TPM_HANDLE& _policySession, TPM_CC _code)
      : policySession(_policySession), code(_code)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyCommandCode_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyCommandCode_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyCommandCode_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyCommandCode_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyCommandCode_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyCommandCode_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyCommandCode_REQUEST

/** This command indicates that physical presence will need to be asserted at the time the
 *  authorization is performed.
 */
class _DLLEXP_ TPM2_PolicyPhysicalPresence_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;

public:
    TPM2_PolicyPhysicalPresence_REQUEST() {}
    TPM2_PolicyPhysicalPresence_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    /** Static marshaling helper  */
    static TPM2_PolicyPhysicalPresence_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyPhysicalPresence_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyPhysicalPresence_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyPhysicalPresence_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyPhysicalPresence_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyPhysicalPresence_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyPhysicalPresence_REQUEST

/** This command is used to allow a policy to be bound to a specific command and command parameters.  */
class _DLLEXP_ TPM2_PolicyCpHash_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The cpHash added to the policy  */
    ByteVec cpHashA;

public:
    TPM2_PolicyCpHash_REQUEST() {}
    TPM2_PolicyCpHash_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _cpHashA)
      : policySession(_policySession), cpHashA(_cpHashA)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyCpHash_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyCpHash_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyCpHash_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyCpHash_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyCpHash_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyCpHash_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyCpHash_REQUEST

/** This command allows a policy to be bound to a specific set of TPM entities without
 *  being bound to the parameters of the command. This is most useful for commands such as
 *  TPM2_Duplicate() and for TPM2_PCR_Event() when the referenced PCR requires a policy.
 */
class _DLLEXP_ TPM2_PolicyNameHash_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The digest to be added to the policy  */
    ByteVec nameHash;

public:
    TPM2_PolicyNameHash_REQUEST() {}
    TPM2_PolicyNameHash_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _nameHash)
      : policySession(_policySession), nameHash(_nameHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyNameHash_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyNameHash_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyNameHash_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyNameHash_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyNameHash_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyNameHash_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyNameHash_REQUEST

/** This command allows qualification of duplication to allow duplication to a selected
 *  new parent.
 */
class _DLLEXP_ TPM2_PolicyDuplicationSelect_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The Name of the object to be duplicated  */
    ByteVec objectName;
    
    /** The Name of the new parent  */
    ByteVec newParentName;
    
    /** If YES, the objectName will be included in the value in policySessionpolicyDigest  */
    BYTE includeObject;

public:
    TPM2_PolicyDuplicationSelect_REQUEST() {}
    TPM2_PolicyDuplicationSelect_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _objectName, const ByteVec& _newParentName, BYTE _includeObject)
      : policySession(_policySession), objectName(_objectName), newParentName(_newParentName), includeObject(_includeObject)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyDuplicationSelect_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyDuplicationSelect_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyDuplicationSelect_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyDuplicationSelect_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyDuplicationSelect_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyDuplicationSelect_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyDuplicationSelect_REQUEST

/** This command allows policies to change. If a policy were static, then it would be
 *  difficult to add users to a policy. This command lets a policy authority sign a new
 *  policy so that it may be used in an existing policy.
 */
class _DLLEXP_ TPM2_PolicyAuthorize_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** Digest of the policy being approved  */
    ByteVec approvedPolicy;
    
    /** A policy qualifier  */
    ByteVec policyRef;
    
    /** Name of a key that can sign a policy addition  */
    ByteVec keySign;
    
    /** Ticket validating that approvedPolicy and policyRef were signed by keySign  */
    TPMT_TK_VERIFIED checkTicket;

public:
    TPM2_PolicyAuthorize_REQUEST() {}
    TPM2_PolicyAuthorize_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _approvedPolicy, const ByteVec& _policyRef, const ByteVec& _keySign, const TPMT_TK_VERIFIED& _checkTicket)
      : policySession(_policySession), approvedPolicy(_approvedPolicy), policyRef(_policyRef), keySign(_keySign), checkTicket(_checkTicket)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyAuthorize_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyAuthorize_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyAuthorize_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyAuthorize_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyAuthorize_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyAuthorize_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyAuthorize_REQUEST

/** This command allows a policy to be bound to the authorization value of the authorized entity.  */
class _DLLEXP_ TPM2_PolicyAuthValue_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;

public:
    TPM2_PolicyAuthValue_REQUEST() {}
    TPM2_PolicyAuthValue_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    /** Static marshaling helper  */
    static TPM2_PolicyAuthValue_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyAuthValue_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyAuthValue_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyAuthValue_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyAuthValue_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyAuthValue_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyAuthValue_REQUEST

/** This command allows a policy to be bound to the authorization value of the authorized object.  */
class _DLLEXP_ TPM2_PolicyPassword_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;

public:
    TPM2_PolicyPassword_REQUEST() {}
    TPM2_PolicyPassword_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    /** Static marshaling helper  */
    static TPM2_PolicyPassword_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyPassword_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyPassword_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyPassword_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyPassword_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyPassword_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyPassword_REQUEST

/** This command returns the current policyDigest of the session. This command allows the
 *  TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
 */
class _DLLEXP_ TPM2_PolicyGetDigest_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session
     *  Auth Index: None
     */
    TPM_HANDLE policySession;

public:
    TPM2_PolicyGetDigest_REQUEST() {}
    TPM2_PolicyGetDigest_REQUEST(const TPM_HANDLE& _policySession)
      : policySession(_policySession)
    {}
    
    /** Static marshaling helper  */
    static TPM2_PolicyGetDigest_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyGetDigest_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyGetDigest_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyGetDigest_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyGetDigest_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyGetDigest_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyGetDigest_REQUEST

/** This command returns the current policyDigest of the session. This command allows the
 *  TPM to be used to perform the actions required to pre-compute the authPolicy for an object.
 */
class _DLLEXP_ PolicyGetDigestResponse : public RespStructure
{
public:
    /** The current value of the policySessionpolicyDigest  */
    ByteVec policyDigest;

public:
    PolicyGetDigestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static PolicyGetDigestResponse fromTpm(TpmBuffer& buf) { return buf.createObj<PolicyGetDigestResponse>(); }
    
    /** Static marshaling helper  */
    static PolicyGetDigestResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<PolicyGetDigestResponse>(buf); }
    
    virtual const char* TypeName () const { return "PolicyGetDigestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new PolicyGetDigestResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class PolicyGetDigestResponse

/** This command allows a policy to be bound to the TPMA_NV_WRITTEN attributes. This is a
 *  deferred assertion. Values are stored in the policy session context and checked when
 *  the policy is used for authorization.
 */
class _DLLEXP_ TPM2_PolicyNvWritten_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** YES if NV Index is required to have been written
     *  NO if NV Index is required not to have been written
     */
    BYTE writtenSet;

public:
    TPM2_PolicyNvWritten_REQUEST() {}
    TPM2_PolicyNvWritten_REQUEST(const TPM_HANDLE& _policySession, BYTE _writtenSet)
      : policySession(_policySession), writtenSet(_writtenSet)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyNvWritten_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyNvWritten_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyNvWritten_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyNvWritten_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyNvWritten_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyNvWritten_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
}; // class TPM2_PolicyNvWritten_REQUEST

/** This command allows a policy to be bound to a specific creation template. This is most
 *  useful for an object creation command such as TPM2_Create(), TPM2_CreatePrimary(), or
 *  TPM2_CreateLoaded().
 */
class _DLLEXP_ TPM2_PolicyTemplate_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The digest to be added to the policy  */
    ByteVec templateHash;

public:
    TPM2_PolicyTemplate_REQUEST() {}
    TPM2_PolicyTemplate_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _templateHash)
      : policySession(_policySession), templateHash(_templateHash)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PolicyTemplate_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyTemplate_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyTemplate_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyTemplate_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyTemplate_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyTemplate_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_PolicyTemplate_REQUEST

/** This command provides a capability that is the equivalent of a revocable policy. With
 *  TPM2_PolicyAuthorize(), the authorization ticket never expires, so the authorization
 *  may not be withdrawn. With this command, the approved policy is kept in an NV Index
 *  location so that the policy may be changed as needed to render the old policy unusable.
 */
class _DLLEXP_ TPM2_PolicyAuthorizeNV_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index of the area to read
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;
    
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;

public:
    TPM2_PolicyAuthorizeNV_REQUEST() {}
    TPM2_PolicyAuthorizeNV_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const TPM_HANDLE& _policySession)
      : authHandle(_authHandle), nvIndex(_nvIndex), policySession(_policySession)
    {}
    
    /** Static marshaling helper  */
    static TPM2_PolicyAuthorizeNV_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PolicyAuthorizeNV_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PolicyAuthorizeNV_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PolicyAuthorizeNV_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PolicyAuthorizeNV_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PolicyAuthorizeNV_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex, policySession}; }
}; // class TPM2_PolicyAuthorizeNV_REQUEST

/** This command is used to create a Primary Object under one of the Primary Seeds or a
 *  Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
 *  the object to be created. The size of the unique field shall not be checked for
 *  consistency with the other object parameters. The command will create and load a
 *  Primary Object. The sensitive area is not returned.
 */
class _DLLEXP_ TPM2_CreatePrimary_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM+{PP}, or TPM_RH_NULL
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE primaryHandle;
    
    /** The sensitive data, see TPM 2.0 Part 1 Sensitive Values  */
    TPMS_SENSITIVE_CREATE inSensitive;
    
    /** The public template  */
    TPMT_PUBLIC inPublic;
    
    /** Data that will be included in the creation data for this object to provide permanent,
     *  verifiable linkage between this object and some object owner data
     */
    ByteVec outsideInfo;
    
    /** PCR that will be used in creation data  */
    vector<TPMS_PCR_SELECTION> creationPCR;

public:
    TPM2_CreatePrimary_REQUEST() {}
    TPM2_CreatePrimary_REQUEST(const TPM_HANDLE& _primaryHandle, const TPMS_SENSITIVE_CREATE& _inSensitive, const TPMT_PUBLIC& _inPublic, const ByteVec& _outsideInfo, const vector<TPMS_PCR_SELECTION>& _creationPCR)
      : primaryHandle(_primaryHandle), inSensitive(_inSensitive), inPublic(_inPublic), outsideInfo(_outsideInfo), creationPCR(_creationPCR)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_CreatePrimary_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_CreatePrimary_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_CreatePrimary_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_CreatePrimary_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_CreatePrimary_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_CreatePrimary_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {primaryHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_CreatePrimary_REQUEST

/** This command is used to create a Primary Object under one of the Primary Seeds or a
 *  Temporary Object under TPM_RH_NULL. The command uses a TPM2B_PUBLIC as a template for
 *  the object to be created. The size of the unique field shall not be checked for
 *  consistency with the other object parameters. The command will create and load a
 *  Primary Object. The sensitive area is not returned.
 */
class _DLLEXP_ CreatePrimaryResponse : public RespStructure
{
public:
    /** Handle of type TPM_HT_TRANSIENT for created Primary Object  */
    TPM_HANDLE handle;
    
    /** The public portion of the created object  */
    TPMT_PUBLIC outPublic;
    
    /** Contains a TPMT_CREATION_DATA  */
    TPMS_CREATION_DATA creationData;
    
    /** Digest of creationData using nameAlg of outPublic  */
    ByteVec creationHash;
    
    /** Ticket used by TPM2_CertifyCreation() to validate that the creation data was produced
     *  by the TPM
     */
    TPMT_TK_CREATION creationTicket;
    
    /** The name of the created object  */
    ByteVec name;

public:
    CreatePrimaryResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CreatePrimaryResponse fromTpm(TpmBuffer& buf) { return buf.createObj<CreatePrimaryResponse>(); }
    
    /** Static marshaling helper  */
    static CreatePrimaryResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CreatePrimaryResponse>(buf); }
    
    virtual const char* TypeName () const { return "CreatePrimaryResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CreatePrimaryResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class CreatePrimaryResponse

/** This command enables and disables use of a hierarchy and its associated NV storage.
 *  The command allows phEnable, phEnableNV, shEnable, and ehEnable to be changed when the
 *  proper authorization is provided.
 */
class _DLLEXP_ TPM2_HierarchyControl_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The enable being modified
     *  TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPM_RH_PLATFORM, or TPM_RH_PLATFORM_NV
     */
    TPM_HANDLE enable;
    
    /** YES if the enable should be SET, NO if the enable should be CLEAR  */
    BYTE state;

public:
    TPM2_HierarchyControl_REQUEST() {}
    TPM2_HierarchyControl_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _enable, BYTE _state)
      : authHandle(_authHandle), enable(_enable), state(_state)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_HierarchyControl_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_HierarchyControl_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_HierarchyControl_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_HierarchyControl_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_HierarchyControl_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_HierarchyControl_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_HierarchyControl_REQUEST

/** This command allows setting of the authorization policy for the lockout
 *  (lockoutPolicy), the platform hierarchy (platformPolicy), the storage hierarchy
 *  (ownerPolicy), and the endorsement hierarchy (endorsementPolicy). On TPMs implementing
 *  Authenticated Countdown Timers (ACT), this command may also be used to set the
 *  authorization policy for an ACT.
 */
class _DLLEXP_ TPM2_SetPrimaryPolicy_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER, TPMI_RH_ACT or TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** An authorization policy digest; may be the Empty Buffer
     *  If hashAlg is TPM_ALG_NULL, then this shall be an Empty Buffer.
     */
    ByteVec authPolicy;
    
    /** The hash algorithm to use for the policy
     *  If the authPolicy is an Empty Buffer, then this field shall be TPM_ALG_NULL.
     */
    TPM_ALG_ID hashAlg;

public:
    TPM2_SetPrimaryPolicy_REQUEST() { hashAlg = TPM_ALG_ID::_NULL; }
    TPM2_SetPrimaryPolicy_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _authPolicy, TPM_ALG_ID _hashAlg)
      : authHandle(_authHandle), authPolicy(_authPolicy), hashAlg(_hashAlg)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_SetPrimaryPolicy_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_SetPrimaryPolicy_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_SetPrimaryPolicy_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_SetPrimaryPolicy_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_SetPrimaryPolicy_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_SetPrimaryPolicy_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_SetPrimaryPolicy_REQUEST

/** This replaces the current platform primary seed (PPS) with a value from the RNG and
 *  sets platformPolicy to the default initialization value (the Empty Buffer).
 */
class _DLLEXP_ TPM2_ChangePPS_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;

public:
    TPM2_ChangePPS_REQUEST() {}
    TPM2_ChangePPS_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_ChangePPS_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ChangePPS_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ChangePPS_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ChangePPS_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ChangePPS_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ChangePPS_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_ChangePPS_REQUEST

/** This replaces the current endorsement primary seed (EPS) with a value from the RNG and
 *  sets the Endorsement hierarchy controls to their default initialization values:
 *  ehEnable is SET, endorsementAuth and endorsementPolicy are both set to the Empty
 *  Buffer. It will flush any resident objects (transient or persistent) in the
 *  Endorsement hierarchy and not allow objects in the hierarchy associated with the
 *  previous EPS to be loaded.
 */
class _DLLEXP_ TPM2_ChangeEPS_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_PLATFORM+{PP}
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;

public:
    TPM2_ChangeEPS_REQUEST() {}
    TPM2_ChangeEPS_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_ChangeEPS_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ChangeEPS_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ChangeEPS_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ChangeEPS_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ChangeEPS_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ChangeEPS_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_ChangeEPS_REQUEST

/** This command removes all TPM context associated with a specific Owner.  */
class _DLLEXP_ TPM2_Clear_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;

public:
    TPM2_Clear_REQUEST() {}
    TPM2_Clear_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_Clear_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Clear_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Clear_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Clear_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Clear_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Clear_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_Clear_REQUEST

/** TPM2_ClearControl() disables and enables the execution of TPM2_Clear().  */
class _DLLEXP_ TPM2_ClearControl_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_LOCKOUT or TPM_RH_PLATFORM+{PP}
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE auth;
    
    /** YES if the disableOwnerClear flag is to be SET, NO if the flag is to be CLEAR.  */
    BYTE disable;

public:
    TPM2_ClearControl_REQUEST() {}
    TPM2_ClearControl_REQUEST(const TPM_HANDLE& _auth, BYTE _disable)
      : auth(_auth), disable(_disable)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ClearControl_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ClearControl_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ClearControl_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ClearControl_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ClearControl_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ClearControl_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_ClearControl_REQUEST

/** This command allows the authorization secret for a hierarchy or lockout to be changed
 *  using the current authorization value as the command authorization.
 */
class _DLLEXP_ TPM2_HierarchyChangeAuth_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_LOCKOUT, TPM_RH_ENDORSEMENT, TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** New authorization value  */
    ByteVec newAuth;

public:
    TPM2_HierarchyChangeAuth_REQUEST() {}
    TPM2_HierarchyChangeAuth_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _newAuth)
      : authHandle(_authHandle), newAuth(_newAuth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_HierarchyChangeAuth_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_HierarchyChangeAuth_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_HierarchyChangeAuth_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_HierarchyChangeAuth_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_HierarchyChangeAuth_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_HierarchyChangeAuth_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_HierarchyChangeAuth_REQUEST

/** This command cancels the effect of a TPM lockout due to a number of successive
 *  authorization failures. If this command is properly authorized, the lockout counter is
 *  set to zero.
 */
class _DLLEXP_ TPM2_DictionaryAttackLockReset_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_LOCKOUT
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE lockHandle;

public:
    TPM2_DictionaryAttackLockReset_REQUEST() {}
    TPM2_DictionaryAttackLockReset_REQUEST(const TPM_HANDLE& _lockHandle)
      : lockHandle(_lockHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_DictionaryAttackLockReset_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_DictionaryAttackLockReset_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_DictionaryAttackLockReset_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_DictionaryAttackLockReset_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_DictionaryAttackLockReset_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_DictionaryAttackLockReset_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {lockHandle}; }
}; // class TPM2_DictionaryAttackLockReset_REQUEST

/** This command changes the lockout parameters.  */
class _DLLEXP_ TPM2_DictionaryAttackParameters_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_LOCKOUT
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE lockHandle;
    
    /** Count of authorization failures before the lockout is imposed  */
    UINT32 newMaxTries;
    
    /** Time in seconds before the authorization failure count is automatically decremented
     *  A value of zero indicates that DA protection is disabled.
     */
    UINT32 newRecoveryTime;
    
    /** Time in seconds after a lockoutAuth failure before use of lockoutAuth is allowed
     *  A value of zero indicates that a reboot is required.
     */
    UINT32 lockoutRecovery;

public:
    TPM2_DictionaryAttackParameters_REQUEST() {}
    TPM2_DictionaryAttackParameters_REQUEST(const TPM_HANDLE& _lockHandle, UINT32 _newMaxTries, UINT32 _newRecoveryTime, UINT32 _lockoutRecovery)
      : lockHandle(_lockHandle), newMaxTries(_newMaxTries), newRecoveryTime(_newRecoveryTime), lockoutRecovery(_lockoutRecovery)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_DictionaryAttackParameters_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_DictionaryAttackParameters_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_DictionaryAttackParameters_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_DictionaryAttackParameters_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_DictionaryAttackParameters_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_DictionaryAttackParameters_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {lockHandle}; }
}; // class TPM2_DictionaryAttackParameters_REQUEST

/** This command is used to determine which commands require assertion of Physical
 *  Presence (PP) in addition to platformAuth/platformPolicy.
 */
class _DLLEXP_ TPM2_PP_Commands_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_PLATFORM+PP
     *  Auth Index: 1
     *  Auth Role: USER + Physical Presence
     */
    TPM_HANDLE auth;
    
    /** List of commands to be added to those that will require that Physical Presence be asserted  */
    vector<TPM_CC> setList;
    
    /** List of commands that will no longer require that Physical Presence be asserted  */
    vector<TPM_CC> clearList;

public:
    TPM2_PP_Commands_REQUEST() {}
    TPM2_PP_Commands_REQUEST(const TPM_HANDLE& _auth, const vector<TPM_CC>& _setList, const vector<TPM_CC>& _clearList)
      : auth(_auth), setList(_setList), clearList(_clearList)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_PP_Commands_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_PP_Commands_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_PP_Commands_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_PP_Commands_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_PP_Commands_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_PP_Commands_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {auth}; }
    
    virtual SessEncInfo sessEncInfo() const { return {4, 4}; }
}; // class TPM2_PP_Commands_REQUEST

/** This command allows the platform to change the set of algorithms that are used by the
 *  TPM. The algorithmSet setting is a vendor-dependent value.
 */
class _DLLEXP_ TPM2_SetAlgorithmSet_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_PLATFORM
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** A TPM vendor-dependent value indicating the algorithm set selection  */
    UINT32 algorithmSet;

public:
    TPM2_SetAlgorithmSet_REQUEST() {}
    TPM2_SetAlgorithmSet_REQUEST(const TPM_HANDLE& _authHandle, UINT32 _algorithmSet)
      : authHandle(_authHandle), algorithmSet(_algorithmSet)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_SetAlgorithmSet_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_SetAlgorithmSet_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_SetAlgorithmSet_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_SetAlgorithmSet_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_SetAlgorithmSet_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_SetAlgorithmSet_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_SetAlgorithmSet_REQUEST

/** This command uses platformPolicy and a TPM Vendor Authorization Key to authorize a
 *  Field Upgrade Manifest.
 */
class _DLLEXP_ TPM2_FieldUpgradeStart_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_PLATFORM+{PP}
     *  Auth Index:1
     *  Auth Role: ADMIN
     */
    TPM_HANDLE authorization;
    
    /** Handle of a public area that contains the TPM Vendor Authorization Key that will be
     *  used to validate manifestSignature
     *  Auth Index: None
     */
    TPM_HANDLE keyHandle;
    
    /** Digest of the first block in the field upgrade sequence  */
    ByteVec fuDigest;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID manifestSignatureSigAlg() const { return manifestSignature ? manifestSignature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signature over fuDigest using the key associated with keyHandle (not optional)
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> manifestSignature;

public:
    TPM2_FieldUpgradeStart_REQUEST() {}
    TPM2_FieldUpgradeStart_REQUEST(const TPM_HANDLE& _authorization, const TPM_HANDLE& _keyHandle, const ByteVec& _fuDigest, const TPMU_SIGNATURE& _manifestSignature)
      : authorization(_authorization), keyHandle(_keyHandle), fuDigest(_fuDigest), manifestSignature(dynamic_cast<TPMU_SIGNATURE*>(_manifestSignature.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_FieldUpgradeStart_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_FieldUpgradeStart_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_FieldUpgradeStart_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_FieldUpgradeStart_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_FieldUpgradeStart_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_FieldUpgradeStart_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authorization, keyHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_FieldUpgradeStart_REQUEST

/** This command will take the actual field upgrade image to be installed on the TPM. The
 *  exact format of fuData is vendor-specific. This command is only possible following a
 *  successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
 *  TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
 */
class _DLLEXP_ TPM2_FieldUpgradeData_REQUEST : public ReqStructure
{
public:
    /** Field upgrade image data  */
    ByteVec fuData;

public:
    TPM2_FieldUpgradeData_REQUEST() {}
    TPM2_FieldUpgradeData_REQUEST(const ByteVec& _fuData)
      : fuData(_fuData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_FieldUpgradeData_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_FieldUpgradeData_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_FieldUpgradeData_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_FieldUpgradeData_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_FieldUpgradeData_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_FieldUpgradeData_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_FieldUpgradeData_REQUEST

/** This command will take the actual field upgrade image to be installed on the TPM. The
 *  exact format of fuData is vendor-specific. This command is only possible following a
 *  successful TPM2_FieldUpgradeStart(). If the TPM has not received a properly authorized
 *  TPM2_FieldUpgradeStart(), then the TPM shall return TPM_RC_FIELDUPGRADE.
 */
class _DLLEXP_ FieldUpgradeDataResponse : public RespStructure
{
public:
    /** Tagged digest of the next block
     *  TPM_ALG_NULL if field update is complete
     */
    TPMT_HA nextDigest;
    
    /** Tagged digest of the first block of the sequence  */
    TPMT_HA firstDigest;

public:
    FieldUpgradeDataResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static FieldUpgradeDataResponse fromTpm(TpmBuffer& buf) { return buf.createObj<FieldUpgradeDataResponse>(); }
    
    /** Static marshaling helper  */
    static FieldUpgradeDataResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<FieldUpgradeDataResponse>(buf); }
    
    virtual const char* TypeName () const { return "FieldUpgradeDataResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new FieldUpgradeDataResponse(*this); }
}; // class FieldUpgradeDataResponse

/** This command is used to read a copy of the current firmware installed in the TPM.  */
class _DLLEXP_ TPM2_FirmwareRead_REQUEST : public ReqStructure
{
public:
    /** The number of previous calls to this command in this sequence
     *  set to 0 on the first call
     */
    UINT32 sequenceNumber;

public:
    TPM2_FirmwareRead_REQUEST() {}
    TPM2_FirmwareRead_REQUEST(UINT32 _sequenceNumber)
      : sequenceNumber(_sequenceNumber)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_FirmwareRead_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_FirmwareRead_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_FirmwareRead_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_FirmwareRead_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_FirmwareRead_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_FirmwareRead_REQUEST(*this); }
}; // class TPM2_FirmwareRead_REQUEST

/** This command is used to read a copy of the current firmware installed in the TPM.  */
class _DLLEXP_ FirmwareReadResponse : public RespStructure
{
public:
    /** Field upgrade image data  */
    ByteVec fuData;

public:
    FirmwareReadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static FirmwareReadResponse fromTpm(TpmBuffer& buf) { return buf.createObj<FirmwareReadResponse>(); }
    
    /** Static marshaling helper  */
    static FirmwareReadResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<FirmwareReadResponse>(buf); }
    
    virtual const char* TypeName () const { return "FirmwareReadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new FirmwareReadResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class FirmwareReadResponse

/** This command saves a session context, object context, or sequence object context
 *  outside the TPM.
 */
class _DLLEXP_ TPM2_ContextSave_REQUEST : public ReqStructure
{
public:
    /** Handle of the resource to save
     *  Auth Index: None
     */
    TPM_HANDLE saveHandle;

public:
    TPM2_ContextSave_REQUEST() {}
    TPM2_ContextSave_REQUEST(const TPM_HANDLE& _saveHandle)
      : saveHandle(_saveHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_ContextSave_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ContextSave_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ContextSave_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ContextSave_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ContextSave_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ContextSave_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {saveHandle}; }
}; // class TPM2_ContextSave_REQUEST

/** This command saves a session context, object context, or sequence object context
 *  outside the TPM.
 */
class _DLLEXP_ ContextSaveResponse : public RespStructure
{
public:
    TPMS_CONTEXT context;

public:
    ContextSaveResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ContextSaveResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ContextSaveResponse>(); }
    
    /** Static marshaling helper  */
    static ContextSaveResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ContextSaveResponse>(buf); }
    
    virtual const char* TypeName () const { return "ContextSaveResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ContextSaveResponse(*this); }
}; // class ContextSaveResponse

/** This command is used to reload a context that has been saved by TPM2_ContextSave().  */
class _DLLEXP_ TPM2_ContextLoad_REQUEST : public ReqStructure
{
public:
    /** The context blob  */
    TPMS_CONTEXT context;

public:
    TPM2_ContextLoad_REQUEST() {}
    TPM2_ContextLoad_REQUEST(const TPMS_CONTEXT& _context)
      : context(_context)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ContextLoad_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ContextLoad_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ContextLoad_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ContextLoad_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ContextLoad_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ContextLoad_REQUEST(*this); }
}; // class TPM2_ContextLoad_REQUEST

/** This command is used to reload a context that has been saved by TPM2_ContextSave().  */
class _DLLEXP_ ContextLoadResponse : public RespStructure
{
public:
    /** The handle assigned to the resource after it has been successfully loaded  */
    TPM_HANDLE handle;

public:
    ContextLoadResponse() {}
    
    /** Static marshaling helper  */
    static ContextLoadResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ContextLoadResponse>(); }
    
    /** Static marshaling helper  */
    static ContextLoadResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ContextLoadResponse>(buf); }
    
    virtual const char* TypeName () const { return "ContextLoadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ContextLoadResponse(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual TPM_HANDLE getHandle() const { return handle; }
    virtual void setHandle(const TPM_HANDLE& h) { handle = h; }
}; // class ContextLoadResponse

/** This command causes all context associated with a loaded object, sequence object, or
 *  session to be removed from TPM memory.
 */
class _DLLEXP_ TPM2_FlushContext_REQUEST : public ReqStructure
{
public:
    /** The handle of the item to flush
     *  NOTE This is a use of a handle as a parameter.
     */
    TPM_HANDLE flushHandle;

public:
    TPM2_FlushContext_REQUEST() {}
    TPM2_FlushContext_REQUEST(const TPM_HANDLE& _flushHandle)
      : flushHandle(_flushHandle)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_FlushContext_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_FlushContext_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_FlushContext_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_FlushContext_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_FlushContext_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_FlushContext_REQUEST(*this); }
}; // class TPM2_FlushContext_REQUEST

/** This command allows certain Transient Objects to be made persistent or a persistent
 *  object to be evicted.
 */
class _DLLEXP_ TPM2_EvictControl_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE auth;
    
    /** The handle of a loaded object
     *  Auth Index: None
     */
    TPM_HANDLE objectHandle;
    
    /** If objectHandle is a transient object handle, then this is the persistent handle for
     *  the object
     *  if objectHandle is a persistent object handle, then it shall be the same value as
     *  persistentHandle
     */
    TPM_HANDLE persistentHandle;

public:
    TPM2_EvictControl_REQUEST() {}
    TPM2_EvictControl_REQUEST(const TPM_HANDLE& _auth, const TPM_HANDLE& _objectHandle, const TPM_HANDLE& _persistentHandle)
      : auth(_auth), objectHandle(_objectHandle), persistentHandle(_persistentHandle)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_EvictControl_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_EvictControl_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_EvictControl_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_EvictControl_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_EvictControl_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_EvictControl_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {auth, objectHandle}; }
}; // class TPM2_EvictControl_REQUEST

/** This command reads the current TPMS_TIME_INFO structure that contains the current
 *  setting of Time, Clock, resetCount, and restartCount.
 */
class _DLLEXP_ TPM2_ReadClock_REQUEST : public ReqStructure
{
public:
public:
    TPM2_ReadClock_REQUEST() {}
    
    /** Static marshaling helper  */
    static TPM2_ReadClock_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ReadClock_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ReadClock_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ReadClock_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ReadClock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPM2_ReadClock_REQUEST(*this); }
}; // class TPM2_ReadClock_REQUEST

/** This command reads the current TPMS_TIME_INFO structure that contains the current
 *  setting of Time, Clock, resetCount, and restartCount.
 */
class _DLLEXP_ ReadClockResponse : public RespStructure
{
public:
    TPMS_TIME_INFO currentTime;

public:
    ReadClockResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static ReadClockResponse fromTpm(TpmBuffer& buf) { return buf.createObj<ReadClockResponse>(); }
    
    /** Static marshaling helper  */
    static ReadClockResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<ReadClockResponse>(buf); }
    
    virtual const char* TypeName () const { return "ReadClockResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new ReadClockResponse(*this); }
}; // class ReadClockResponse

/** This command is used to advance the value of the TPMs Clock. The command will fail if
 *  newTime is less than the current value of Clock or if the new time is greater than
 *  FFFF00000000000016. If both of these checks succeed, Clock is set to newTime. If
 *  either of these checks fails, the TPM shall return TPM_RC_VALUE and make no change to Clock.
 */
class _DLLEXP_ TPM2_ClockSet_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE auth;
    
    /** New Clock setting in milliseconds  */
    UINT64 newTime;

public:
    TPM2_ClockSet_REQUEST() {}
    TPM2_ClockSet_REQUEST(const TPM_HANDLE& _auth, UINT64 _newTime)
      : auth(_auth), newTime(_newTime)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ClockSet_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ClockSet_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ClockSet_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ClockSet_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ClockSet_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ClockSet_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_ClockSet_REQUEST

/** This command adjusts the rate of advance of Clock and Time to provide a better
 *  approximation to real time.
 */
class _DLLEXP_ TPM2_ClockRateAdjust_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Handle: 1
     *  Auth Role: USER
     */
    TPM_HANDLE auth;
    
    /** Adjustment to current Clock update rate  */
    TPM_CLOCK_ADJUST rateAdjust;

public:
    TPM2_ClockRateAdjust_REQUEST() {}
    TPM2_ClockRateAdjust_REQUEST(const TPM_HANDLE& _auth, TPM_CLOCK_ADJUST _rateAdjust)
      : auth(_auth), rateAdjust(_rateAdjust)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ClockRateAdjust_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ClockRateAdjust_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ClockRateAdjust_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ClockRateAdjust_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ClockRateAdjust_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ClockRateAdjust_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {auth}; }
}; // class TPM2_ClockRateAdjust_REQUEST

/** This command returns various information regarding the TPM and its current state.  */
class _DLLEXP_ TPM2_GetCapability_REQUEST : public ReqStructure
{
public:
    /** Group selection; determines the format of the response  */
    TPM_CAP capability;
    
    /** Further definition of information  */
    UINT32 property;
    
    /** Number of properties of the indicated type to return  */
    UINT32 propertyCount;

public:
    TPM2_GetCapability_REQUEST() {}
    TPM2_GetCapability_REQUEST(TPM_CAP _capability, UINT32 _property, UINT32 _propertyCount)
      : capability(_capability), property(_property), propertyCount(_propertyCount)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_GetCapability_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_GetCapability_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_GetCapability_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_GetCapability_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_GetCapability_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_GetCapability_REQUEST(*this); }
}; // class TPM2_GetCapability_REQUEST

/** This command returns various information regarding the TPM and its current state.  */
class _DLLEXP_ GetCapabilityResponse : public RespStructure
{
public:
    /** Flag to indicate if there are more values of this type  */
    BYTE moreData;
    
    /** The capability  */
    public: TPM_CAP capabilityDataCapability() const { return capabilityData->GetUnionSelector(); }
    
    /** The capability data
     *  (One of [TPML_ALG_PROPERTY, TPML_HANDLE, TPML_CCA, TPML_CC, TPML_PCR_SELECTION,
     *  TPML_TAGGED_TPM_PROPERTY, TPML_TAGGED_PCR_PROPERTY, TPML_ECC_CURVE,
     *  TPML_TAGGED_POLICY, TPML_ACT_DATA])
     */
    shared_ptr<TPMU_CAPABILITIES> capabilityData;

public:
    GetCapabilityResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static GetCapabilityResponse fromTpm(TpmBuffer& buf) { return buf.createObj<GetCapabilityResponse>(); }
    
    /** Static marshaling helper  */
    static GetCapabilityResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<GetCapabilityResponse>(buf); }
    
    virtual const char* TypeName () const { return "GetCapabilityResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new GetCapabilityResponse(*this); }
}; // class GetCapabilityResponse

/** This command is used to check to see if specific combinations of algorithm parameters
 *  are supported.
 */
class _DLLEXP_ TPM2_TestParms_REQUEST : public ReqStructure
{
public:
    /** The algorithm to be tested  */
    public: TPM_ALG_ID parametersType() const { return parameters->GetUnionSelector(); }
    
    /** Algorithm parameters to be validated
     *  (One of [TPMS_KEYEDHASH_PARMS, TPMS_SYMCIPHER_PARMS, TPMS_RSA_PARMS, TPMS_ECC_PARMS,
     *  TPMS_ASYM_PARMS])
     */
    shared_ptr<TPMU_PUBLIC_PARMS> parameters;

public:
    TPM2_TestParms_REQUEST() {}
    TPM2_TestParms_REQUEST(const TPMU_PUBLIC_PARMS& _parameters)
      : parameters(dynamic_cast<TPMU_PUBLIC_PARMS*>(_parameters.Clone()))
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_TestParms_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_TestParms_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_TestParms_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_TestParms_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_TestParms_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_TestParms_REQUEST(*this); }
}; // class TPM2_TestParms_REQUEST

/** This command defines the attributes of an NV Index and causes the TPM to reserve space
 *  to hold the data associated with the NV Index. If a definition already exists at the
 *  NV Index, the TPM will return TPM_RC_NV_DEFINED.
 */
class _DLLEXP_ TPM2_NV_DefineSpace_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The authorization value  */
    ByteVec auth;
    
    /** The public parameters of the NV area  */
    TPMS_NV_PUBLIC publicInfo;

public:
    TPM2_NV_DefineSpace_REQUEST() {}
    TPM2_NV_DefineSpace_REQUEST(const TPM_HANDLE& _authHandle, const ByteVec& _auth, const TPMS_NV_PUBLIC& _publicInfo)
      : authHandle(_authHandle), auth(_auth), publicInfo(_publicInfo)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_NV_DefineSpace_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_DefineSpace_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_DefineSpace_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_DefineSpace_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_DefineSpace_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_DefineSpace_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_DefineSpace_REQUEST

/** This command removes an Index from the TPM.  */
class _DLLEXP_ TPM2_NV_UndefineSpace_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index to remove from NV space
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;

public:
    TPM2_NV_UndefineSpace_REQUEST() {}
    TPM2_NV_UndefineSpace_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    /** Static marshaling helper  */
    static TPM2_NV_UndefineSpace_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_UndefineSpace_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_UndefineSpace_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_UndefineSpace_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_UndefineSpace_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_UndefineSpace_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_UndefineSpace_REQUEST

/** This command allows removal of a platform-created NV Index that has
 *  TPMA_NV_POLICY_DELETE SET.
 */
class _DLLEXP_ TPM2_NV_UndefineSpaceSpecial_REQUEST : public ReqStructure
{
public:
    /** Index to be deleted
     *  Auth Index: 1
     *  Auth Role: ADMIN
     */
    TPM_HANDLE nvIndex;
    
    /** TPM_RH_PLATFORM + {PP}
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE platform;

public:
    TPM2_NV_UndefineSpaceSpecial_REQUEST() {}
    TPM2_NV_UndefineSpaceSpecial_REQUEST(const TPM_HANDLE& _nvIndex, const TPM_HANDLE& _platform)
      : nvIndex(_nvIndex), platform(_platform)
    {}
    
    /** Static marshaling helper  */
    static TPM2_NV_UndefineSpaceSpecial_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_UndefineSpaceSpecial_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_UndefineSpaceSpecial_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_UndefineSpaceSpecial_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_UndefineSpaceSpecial_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_UndefineSpaceSpecial_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {nvIndex, platform}; }
}; // class TPM2_NV_UndefineSpaceSpecial_REQUEST

/** This command is used to read the public area and Name of an NV Index. The public area
 *  of an Index is not privacy-sensitive and no authorization is required to read this data.
 */
class _DLLEXP_ TPM2_NV_ReadPublic_REQUEST : public ReqStructure
{
public:
    /** The NV Index
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;

public:
    TPM2_NV_ReadPublic_REQUEST() {}
    TPM2_NV_ReadPublic_REQUEST(const TPM_HANDLE& _nvIndex)
      : nvIndex(_nvIndex)
    {}
    
    /** Static marshaling helper  */
    static TPM2_NV_ReadPublic_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_ReadPublic_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_ReadPublic_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_ReadPublic_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_ReadPublic_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_ReadPublic_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {nvIndex}; }
}; // class TPM2_NV_ReadPublic_REQUEST

/** This command is used to read the public area and Name of an NV Index. The public area
 *  of an Index is not privacy-sensitive and no authorization is required to read this data.
 */
class _DLLEXP_ NV_ReadPublicResponse : public RespStructure
{
public:
    /** The public area of the NV Index  */
    TPMS_NV_PUBLIC nvPublic;
    
    /** The Name of the nvIndex  */
    ByteVec nvName;

public:
    NV_ReadPublicResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static NV_ReadPublicResponse fromTpm(TpmBuffer& buf) { return buf.createObj<NV_ReadPublicResponse>(); }
    
    /** Static marshaling helper  */
    static NV_ReadPublicResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<NV_ReadPublicResponse>(buf); }
    
    virtual const char* TypeName () const { return "NV_ReadPublicResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new NV_ReadPublicResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class NV_ReadPublicResponse

/** This command writes a value to an area in NV memory that was previously defined by
 *  TPM2_NV_DefineSpace().
 */
class _DLLEXP_ TPM2_NV_Write_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index of the area to write
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;
    
    /** The data to write  */
    ByteVec data;
    
    /** The octet offset into the NV Area  */
    UINT16 offset;

public:
    TPM2_NV_Write_REQUEST() {}
    TPM2_NV_Write_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const ByteVec& _data, UINT16 _offset)
      : authHandle(_authHandle), nvIndex(_nvIndex), data(_data), offset(_offset)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_NV_Write_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_Write_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_Write_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_Write_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_Write_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_Write_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_Write_REQUEST

/** This command is used to increment the value in an NV Index that has the TPM_NT_COUNTER
 *  attribute. The data value of the NV Index is incremented by one.
 */
class _DLLEXP_ TPM2_NV_Increment_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index to increment
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;

public:
    TPM2_NV_Increment_REQUEST() {}
    TPM2_NV_Increment_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    /** Static marshaling helper  */
    static TPM2_NV_Increment_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_Increment_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_Increment_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_Increment_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_Increment_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_Increment_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_Increment_REQUEST

/** This command extends a value to an area in NV memory that was previously defined by
 *  TPM2_NV_DefineSpace.
 */
class _DLLEXP_ TPM2_NV_Extend_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index to extend
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;
    
    /** The data to extend  */
    ByteVec data;

public:
    TPM2_NV_Extend_REQUEST() {}
    TPM2_NV_Extend_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const ByteVec& _data)
      : authHandle(_authHandle), nvIndex(_nvIndex), data(_data)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_NV_Extend_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_Extend_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_Extend_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_Extend_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_Extend_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_Extend_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_Extend_REQUEST

/** This command is used to SET bits in an NV Index that was created as a bit field. Any
 *  number of bits from 0 to 64 may be SET. The contents of bits are ORed with the current
 *  contents of the NV Index.
 */
class _DLLEXP_ TPM2_NV_SetBits_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** NV Index of the area in which the bit is to be set
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;
    
    /** The data to OR with the current contents  */
    UINT64 bits;

public:
    TPM2_NV_SetBits_REQUEST() {}
    TPM2_NV_SetBits_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, UINT64 _bits)
      : authHandle(_authHandle), nvIndex(_nvIndex), bits(_bits)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_NV_SetBits_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_SetBits_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_SetBits_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_SetBits_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_SetBits_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_SetBits_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_SetBits_REQUEST

/** If the TPMA_NV_WRITEDEFINE or TPMA_NV_WRITE_STCLEAR attributes of an NV location are
 *  SET, then this command may be used to inhibit further writes of the NV Index.
 */
class _DLLEXP_ TPM2_NV_WriteLock_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index of the area to lock
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;

public:
    TPM2_NV_WriteLock_REQUEST() {}
    TPM2_NV_WriteLock_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    /** Static marshaling helper  */
    static TPM2_NV_WriteLock_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_WriteLock_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_WriteLock_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_WriteLock_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_WriteLock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_WriteLock_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_WriteLock_REQUEST

/** The command will SET TPMA_NV_WRITELOCKED for all indexes that have their
 *  TPMA_NV_GLOBALLOCK attribute SET.
 */
class _DLLEXP_ TPM2_NV_GlobalWriteLock_REQUEST : public ReqStructure
{
public:
    /** TPM_RH_OWNER or TPM_RH_PLATFORM+{PP}
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;

public:
    TPM2_NV_GlobalWriteLock_REQUEST() {}
    TPM2_NV_GlobalWriteLock_REQUEST(const TPM_HANDLE& _authHandle)
      : authHandle(_authHandle)
    {}
    
    /** Static marshaling helper  */
    static TPM2_NV_GlobalWriteLock_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_GlobalWriteLock_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_GlobalWriteLock_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_GlobalWriteLock_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_GlobalWriteLock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_GlobalWriteLock_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle}; }
}; // class TPM2_NV_GlobalWriteLock_REQUEST

/** This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().  */
class _DLLEXP_ TPM2_NV_Read_REQUEST : public ReqStructure
{
public:
    /** The handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index to be read
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;
    
    /** Number of octets to read  */
    UINT16 size;
    
    /** Octet offset into the NV area
     *  This value shall be less than or equal to the size of the nvIndex data.
     */
    UINT16 offset;

public:
    TPM2_NV_Read_REQUEST() {}
    TPM2_NV_Read_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, UINT16 _size, UINT16 _offset)
      : authHandle(_authHandle), nvIndex(_nvIndex), size(_size), offset(_offset)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_NV_Read_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_Read_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_Read_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_Read_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_Read_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_Read_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_Read_REQUEST

/** This command reads a value from an area in NV memory previously defined by TPM2_NV_DefineSpace().  */
class _DLLEXP_ NV_ReadResponse : public RespStructure
{
public:
    /** The data read  */
    ByteVec data;

public:
    NV_ReadResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static NV_ReadResponse fromTpm(TpmBuffer& buf) { return buf.createObj<NV_ReadResponse>(); }
    
    /** Static marshaling helper  */
    static NV_ReadResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<NV_ReadResponse>(buf); }
    
    virtual const char* TypeName () const { return "NV_ReadResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new NV_ReadResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class NV_ReadResponse

/** If TPMA_NV_READ_STCLEAR is SET in an Index, then this command may be used to prevent
 *  further reads of the NV Index until the next TPM2_Startup (TPM_SU_CLEAR).
 */
class _DLLEXP_ TPM2_NV_ReadLock_REQUEST : public ReqStructure
{
public:
    /** The handle indicating the source of the authorization value
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** The NV Index to be locked
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;

public:
    TPM2_NV_ReadLock_REQUEST() {}
    TPM2_NV_ReadLock_REQUEST(const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex)
      : authHandle(_authHandle), nvIndex(_nvIndex)
    {}
    
    /** Static marshaling helper  */
    static TPM2_NV_ReadLock_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_ReadLock_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_ReadLock_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_ReadLock_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_ReadLock_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_ReadLock_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 2; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {authHandle, nvIndex}; }
}; // class TPM2_NV_ReadLock_REQUEST

/** This command allows the authorization secret for an NV Index to be changed.  */
class _DLLEXP_ TPM2_NV_ChangeAuth_REQUEST : public ReqStructure
{
public:
    /** Handle of the entity
     *  Auth Index: 1
     *  Auth Role: ADMIN
     */
    TPM_HANDLE nvIndex;
    
    /** New authorization value  */
    ByteVec newAuth;

public:
    TPM2_NV_ChangeAuth_REQUEST() {}
    TPM2_NV_ChangeAuth_REQUEST(const TPM_HANDLE& _nvIndex, const ByteVec& _newAuth)
      : nvIndex(_nvIndex), newAuth(_newAuth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_NV_ChangeAuth_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_ChangeAuth_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_ChangeAuth_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_ChangeAuth_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_ChangeAuth_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_ChangeAuth_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_ChangeAuth_REQUEST

/** The purpose of this command is to certify the contents of an NV Index or portion of an
 *  NV Index.
 */
class _DLLEXP_ TPM2_NV_Certify_REQUEST : public ReqStructure
{
public:
    /** Handle of the key used to sign the attestation structure
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE signHandle;
    
    /** Handle indicating the source of the authorization value for the NV Index
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** Index for the area to be certified
     *  Auth Index: None
     */
    TPM_HANDLE nvIndex;
    
    /** User-provided qualifying data  */
    ByteVec qualifyingData;
    
    /** Scheme selector  */
    public: TPM_ALG_ID inSchemeScheme() const { return inScheme ? inScheme->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** Signing scheme to use if the scheme for signHandle is TPM_ALG_NULL
     *  (One of [TPMS_SIG_SCHEME_RSASSA, TPMS_SIG_SCHEME_RSAPSS, TPMS_SIG_SCHEME_ECDSA,
     *  TPMS_SIG_SCHEME_ECDAA, TPMS_SIG_SCHEME_SM2, TPMS_SIG_SCHEME_ECSCHNORR,
     *  TPMS_SCHEME_HMAC, TPMS_SCHEME_HASH, TPMS_NULL_SIG_SCHEME])
     */
    shared_ptr<TPMU_SIG_SCHEME> inScheme;
    
    /** Number of octets to certify  */
    UINT16 size;
    
    /** Octet offset into the NV area
     *  This value shall be less than or equal to the size of the nvIndex data.
     */
    UINT16 offset;

public:
    TPM2_NV_Certify_REQUEST() {}
    TPM2_NV_Certify_REQUEST(const TPM_HANDLE& _signHandle, const TPM_HANDLE& _authHandle, const TPM_HANDLE& _nvIndex, const ByteVec& _qualifyingData, const TPMU_SIG_SCHEME& _inScheme, UINT16 _size, UINT16 _offset)
      : signHandle(_signHandle), authHandle(_authHandle), nvIndex(_nvIndex), qualifyingData(_qualifyingData), inScheme(dynamic_cast<TPMU_SIG_SCHEME*>(_inScheme.Clone())), size(_size), offset(_offset)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_NV_Certify_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_NV_Certify_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_NV_Certify_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_NV_Certify_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_NV_Certify_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_NV_Certify_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {signHandle, authHandle, nvIndex}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_NV_Certify_REQUEST

/** The purpose of this command is to certify the contents of an NV Index or portion of an
 *  NV Index.
 */
class _DLLEXP_ NV_CertifyResponse : public RespStructure
{
public:
    /** The structure that was signed  */
    TPMS_ATTEST certifyInfo;
    
    /** Selector of the algorithm used to construct the signature  */
    public: TPM_ALG_ID signatureSigAlg() const { return signature ? signature->GetUnionSelector() : TPM_ALG_ID::_NULL; }
    
    /** The asymmetric signature over certifyInfo using the key referenced by signHandle
     *  (One of [TPMS_SIGNATURE_RSASSA, TPMS_SIGNATURE_RSAPSS, TPMS_SIGNATURE_ECDSA,
     *  TPMS_SIGNATURE_ECDAA, TPMS_SIGNATURE_SM2, TPMS_SIGNATURE_ECSCHNORR, TPMT_HA,
     *  TPMS_SCHEME_HASH, TPMS_NULL_SIGNATURE])
     */
    shared_ptr<TPMU_SIGNATURE> signature;

public:
    NV_CertifyResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static NV_CertifyResponse fromTpm(TpmBuffer& buf) { return buf.createObj<NV_CertifyResponse>(); }
    
    /** Static marshaling helper  */
    static NV_CertifyResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<NV_CertifyResponse>(buf); }
    
    virtual const char* TypeName () const { return "NV_CertifyResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new NV_CertifyResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class NV_CertifyResponse

/** The purpose of this command is to obtain information about an Attached Component
 *  referenced by an AC handle.
 */
class _DLLEXP_ TPM2_AC_GetCapability_REQUEST : public ReqStructure
{
public:
    /** Handle indicating the Attached Component
     *  Auth Index: None
     */
    TPM_HANDLE ac;
    
    /** Starting info type  */
    TPM_AT capability;
    
    /** Maximum number of values to return  */
    UINT32 count;

public:
    TPM2_AC_GetCapability_REQUEST() {}
    TPM2_AC_GetCapability_REQUEST(const TPM_HANDLE& _ac, TPM_AT _capability, UINT32 _count)
      : ac(_ac), capability(_capability), count(_count)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_AC_GetCapability_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_AC_GetCapability_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_AC_GetCapability_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_AC_GetCapability_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_AC_GetCapability_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_AC_GetCapability_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {ac}; }
}; // class TPM2_AC_GetCapability_REQUEST

/** The purpose of this command is to obtain information about an Attached Component
 *  referenced by an AC handle.
 */
class _DLLEXP_ AC_GetCapabilityResponse : public RespStructure
{
public:
    /** Flag to indicate whether there are more values  */
    BYTE moreData;
    
    /** List of capabilities  */
    vector<TPMS_AC_OUTPUT> capabilitiesData;

public:
    AC_GetCapabilityResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static AC_GetCapabilityResponse fromTpm(TpmBuffer& buf) { return buf.createObj<AC_GetCapabilityResponse>(); }
    
    /** Static marshaling helper  */
    static AC_GetCapabilityResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<AC_GetCapabilityResponse>(buf); }
    
    virtual const char* TypeName () const { return "AC_GetCapabilityResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new AC_GetCapabilityResponse(*this); }
}; // class AC_GetCapabilityResponse

/** The purpose of this command is to send (copy) a loaded object from the TPM to an
 *  Attached Component.
 */
class _DLLEXP_ TPM2_AC_Send_REQUEST : public ReqStructure
{
public:
    /** Handle of the object being sent to ac
     *  Auth Index: 1
     *  Auth Role: DUP
     */
    TPM_HANDLE sendObject;
    
    /** The handle indicating the source of the authorization value
     *  Auth Index: 2
     *  Auth Role: USER
     */
    TPM_HANDLE authHandle;
    
    /** Handle indicating the Attached Component to which the object will be sent
     *  Auth Index: None
     */
    TPM_HANDLE ac;
    
    /** Optional non sensitive information related to the object  */
    ByteVec acDataIn;

public:
    TPM2_AC_Send_REQUEST() {}
    TPM2_AC_Send_REQUEST(const TPM_HANDLE& _sendObject, const TPM_HANDLE& _authHandle, const TPM_HANDLE& _ac, const ByteVec& _acDataIn)
      : sendObject(_sendObject), authHandle(_authHandle), ac(_ac), acDataIn(_acDataIn)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_AC_Send_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_AC_Send_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_AC_Send_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_AC_Send_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_AC_Send_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_AC_Send_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 3; }
    virtual uint16_t numAuthHandles() const { return 2; }
    virtual vector<TPM_HANDLE> getHandles() const { return {sendObject, authHandle, ac}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_AC_Send_REQUEST

/** The purpose of this command is to send (copy) a loaded object from the TPM to an
 *  Attached Component.
 */
class _DLLEXP_ AC_SendResponse : public RespStructure
{
public:
    /** May include AC specific data or information about an error.  */
    TPMS_AC_OUTPUT acDataOut;

public:
    AC_SendResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static AC_SendResponse fromTpm(TpmBuffer& buf) { return buf.createObj<AC_SendResponse>(); }
    
    /** Static marshaling helper  */
    static AC_SendResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<AC_SendResponse>(buf); }
    
    virtual const char* TypeName () const { return "AC_SendResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new AC_SendResponse(*this); }
}; // class AC_SendResponse

/** This command allows qualification of the sending (copying) of an Object to an Attached
 *  Component (AC). Qualification includes selection of the receiving AC and the method of
 *  authentication for the AC, and, in certain circumstances, the Object to be sent may be
 *  specified.
 */
class _DLLEXP_ TPM2_Policy_AC_SendSelect_REQUEST : public ReqStructure
{
public:
    /** Handle for the policy session being extended
     *  Auth Index: None
     */
    TPM_HANDLE policySession;
    
    /** The Name of the Object to be sent  */
    ByteVec objectName;
    
    /** The Name associated with authHandle used in the TPM2_AC_Send() command  */
    ByteVec authHandleName;
    
    /** The Name of the Attached Component to which the Object will be sent  */
    ByteVec acName;
    
    /** If SET, objectName will be included in the value in policySessionpolicyDigest  */
    BYTE includeObject;

public:
    TPM2_Policy_AC_SendSelect_REQUEST() {}
    TPM2_Policy_AC_SendSelect_REQUEST(const TPM_HANDLE& _policySession, const ByteVec& _objectName, const ByteVec& _authHandleName, const ByteVec& _acName, BYTE _includeObject)
      : policySession(_policySession), objectName(_objectName), authHandleName(_authHandleName), acName(_acName), includeObject(_includeObject)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Policy_AC_SendSelect_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Policy_AC_SendSelect_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Policy_AC_SendSelect_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Policy_AC_SendSelect_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Policy_AC_SendSelect_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Policy_AC_SendSelect_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 0; }
    virtual vector<TPM_HANDLE> getHandles() const { return {policySession}; }
    
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Policy_AC_SendSelect_REQUEST

/** This command is used to set the time remaining before an Authenticated Countdown Timer
 *  (ACT) expires.
 */
class _DLLEXP_ TPM2_ACT_SetTimeout_REQUEST : public ReqStructure
{
public:
    /** Handle of the selected ACT
     *  Auth Index: 1
     *  Auth Role: USER
     */
    TPM_HANDLE actHandle;
    
    /** The start timeout value for the ACT in seconds  */
    UINT32 startTimeout;

public:
    TPM2_ACT_SetTimeout_REQUEST() {}
    TPM2_ACT_SetTimeout_REQUEST(const TPM_HANDLE& _actHandle, UINT32 _startTimeout)
      : actHandle(_actHandle), startTimeout(_startTimeout)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_ACT_SetTimeout_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_ACT_SetTimeout_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_ACT_SetTimeout_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_ACT_SetTimeout_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_ACT_SetTimeout_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_ACT_SetTimeout_REQUEST(*this); }

protected:
    virtual uint16_t numHandles() const { return 1; }
    virtual uint16_t numAuthHandles() const { return 1; }
    virtual vector<TPM_HANDLE> getHandles() const { return {actHandle}; }
}; // class TPM2_ACT_SetTimeout_REQUEST

/** This is a placeholder to allow testing of the dispatch code.  */
class _DLLEXP_ TPM2_Vendor_TCG_Test_REQUEST : public ReqStructure
{
public:
    /** Dummy data  */
    ByteVec inputData;

public:
    TPM2_Vendor_TCG_Test_REQUEST() {}
    TPM2_Vendor_TCG_Test_REQUEST(const ByteVec& _inputData)
      : inputData(_inputData)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TPM2_Vendor_TCG_Test_REQUEST fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2_Vendor_TCG_Test_REQUEST>(); }
    
    /** Static marshaling helper  */
    static TPM2_Vendor_TCG_Test_REQUEST fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2_Vendor_TCG_Test_REQUEST>(buf); }
    
    virtual const char* TypeName () const { return "TPM2_Vendor_TCG_Test_REQUEST"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TPM2_Vendor_TCG_Test_REQUEST(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class TPM2_Vendor_TCG_Test_REQUEST

/** This is a placeholder to allow testing of the dispatch code.  */
class _DLLEXP_ Vendor_TCG_TestResponse : public RespStructure
{
public:
    /** Dummy data  */
    ByteVec outputData;

public:
    Vendor_TCG_TestResponse() {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static Vendor_TCG_TestResponse fromTpm(TpmBuffer& buf) { return buf.createObj<Vendor_TCG_TestResponse>(); }
    
    /** Static marshaling helper  */
    static Vendor_TCG_TestResponse fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<Vendor_TCG_TestResponse>(buf); }
    
    virtual const char* TypeName () const { return "Vendor_TCG_TestResponse"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new Vendor_TCG_TestResponse(*this); }

protected:
    virtual SessEncInfo sessEncInfo() const { return {2, 1}; }
}; // class Vendor_TCG_TestResponse

/** These are the RSA schemes that only need a hash algorithm as a scheme parameter.  */
typedef TPMS_SIG_SCHEME_RSASSA TPMS_SCHEME_RSASSA;

/** These are the RSA schemes that only need a hash algorithm as a scheme parameter.  */
typedef TPMS_SIG_SCHEME_RSAPSS TPMS_SCHEME_RSAPSS;

/** Most of the ECC signature schemes only require a hash algorithm to complete the
 *  definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
 *  count value so they are typed to be TPMS_SCHEME_ECDAA.
 */
typedef TPMS_SIG_SCHEME_ECDSA TPMS_SCHEME_ECDSA;

/** Most of the ECC signature schemes only require a hash algorithm to complete the
 *  definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
 *  count value so they are typed to be TPMS_SCHEME_ECDAA.
 */
typedef TPMS_SIG_SCHEME_SM2 TPMS_SCHEME_SM2;

/** Most of the ECC signature schemes only require a hash algorithm to complete the
 *  definition and can be typed as TPMS_SCHEME_HASH. Anonymous algorithms also require a
 *  count value so they are typed to be TPMS_SCHEME_ECDAA.
 */
typedef TPMS_SIG_SCHEME_ECSCHNORR TPMS_SCHEME_ECSCHNORR;

/** These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.  */
typedef TPMS_ENC_SCHEME_OAEP TPMS_SCHEME_OAEP;

/** These are the RSA encryption schemes that only need a hash algorithm as a controlling parameter.  */
typedef TPMS_ENC_SCHEME_RSAES TPMS_SCHEME_RSAES;

/** These are the ECC schemes that only need a hash algorithm as a controlling parameter.  */
typedef TPMS_KEY_SCHEME_ECDH TPMS_SCHEME_ECDH;

/** These are the ECC schemes that only need a hash algorithm as a controlling parameter.  */
typedef TPMS_KEY_SCHEME_ECMQV TPMS_SCHEME_ECMQV;

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
typedef TPMS_KDF_SCHEME_MGF1 TPMS_SCHEME_MGF1;

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
typedef TPMS_KDF_SCHEME_KDF1_SP800_56A TPMS_SCHEME_KDF1_SP800_56A;

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
typedef TPMS_KDF_SCHEME_KDF2 TPMS_SCHEME_KDF2;

/** These structures are used to define the key derivation for symmetric secret sharing
 *  using asymmetric methods. A secret sharing scheme is required in any asymmetric key
 *  with the decrypt attribute SET.
 */
typedef TPMS_KDF_SCHEME_KDF1_SP800_108 TPMS_SCHEME_KDF1_SP800_108;

/** Contains the public and the plaintext-sensitive and/or encrypted private part of a TPM
 *  key (or other object)
 */
class _DLLEXP_ TssObject : public TpmStructure
{
public:
    /** Public part of key  */
    TPMT_PUBLIC Public;
    
    /** Sensitive part of key  */
    TPMT_SENSITIVE Sensitive;
    
    /** Private part is the encrypted sensitive part of key  */
    TPM2B_PRIVATE Private;

public:
    TssObject() {}
    TssObject(const TPMT_PUBLIC& _Public, const TPMT_SENSITIVE& _Sensitive, const TPM2B_PRIVATE& _Private)
      : Public(_Public), Sensitive(_Sensitive), Private(_Private)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TssObject fromTpm(TpmBuffer& buf) { return buf.createObj<TssObject>(); }
    
    /** Static marshaling helper  */
    static TssObject fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TssObject>(buf); }
    
    virtual const char* TypeName () const { return "TssObject"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TssObject(*this); }
}; // class TssObject

/** Contains a PCR index and associated hash(pcr-value) [TSS]  */
class _DLLEXP_ PcrValue : public TpmStructure
{
public:
    /** PCR Index  */
    UINT32 index;
    
    /** PCR Value  */
    TPMT_HA value;

public:
    PcrValue() {}
    PcrValue(UINT32 _index, const TPMT_HA& _value)
      : index(_index), value(_value)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static PcrValue fromTpm(TpmBuffer& buf) { return buf.createObj<PcrValue>(); }
    
    /** Static marshaling helper  */
    static PcrValue fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<PcrValue>(buf); }
    
    virtual const char* TypeName () const { return "PcrValue"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new PcrValue(*this); }
}; // class PcrValue

/** Structure representing a session block in a command buffer [TSS]  */
class _DLLEXP_ SessionIn : public TpmStructure
{
public:
    /** Session handle  */
    TPM_HANDLE handle;
    
    /** Caller nonce  */
    ByteVec nonceCaller;
    
    /** Session attributes  */
    TPMA_SESSION attributes;
    
    /** AuthValue (or HMAC)  */
    ByteVec auth;

public:
    SessionIn() {}
    SessionIn(const TPM_HANDLE& _handle, const ByteVec& _nonceCaller, TPMA_SESSION _attributes, const ByteVec& _auth)
      : handle(_handle), nonceCaller(_nonceCaller), attributes(_attributes), auth(_auth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static SessionIn fromTpm(TpmBuffer& buf) { return buf.createObj<SessionIn>(); }
    
    /** Static marshaling helper  */
    static SessionIn fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<SessionIn>(buf); }
    
    virtual const char* TypeName () const { return "SessionIn"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new SessionIn(*this); }
}; // class SessionIn

/** Structure representing a session block in a response buffer [TSS]  */
class _DLLEXP_ SessionOut : public TpmStructure
{
public:
    /** TPM nonce  */
    ByteVec nonceTpm;
    
    /** Session attributes  */
    TPMA_SESSION attributes;
    
    /** HMAC value  */
    ByteVec auth;

public:
    SessionOut() {}
    SessionOut(const ByteVec& _nonceTpm, TPMA_SESSION _attributes, const ByteVec& _auth)
      : nonceTpm(_nonceTpm), attributes(_attributes), auth(_auth)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static SessionOut fromTpm(TpmBuffer& buf) { return buf.createObj<SessionOut>(); }
    
    /** Static marshaling helper  */
    static SessionOut fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<SessionOut>(buf); }
    
    virtual const char* TypeName () const { return "SessionOut"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new SessionOut(*this); }
}; // class SessionOut

/** Command header [TSS]  */
class _DLLEXP_ CommandHeader : public TpmStructure
{
public:
    /** Command tag (sessions, or no sessions)  */
    TPM_ST Tag;
    
    /** Total command buffer length  */
    UINT32 CommandSize;
    
    /** Command code  */
    TPM_CC CommandCode;

public:
    CommandHeader() {}
    CommandHeader(TPM_ST _Tag, UINT32 _CommandSize, TPM_CC _CommandCode)
      : Tag(_Tag), CommandSize(_CommandSize), CommandCode(_CommandCode)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static CommandHeader fromTpm(TpmBuffer& buf) { return buf.createObj<CommandHeader>(); }
    
    /** Static marshaling helper  */
    static CommandHeader fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<CommandHeader>(buf); }
    
    virtual const char* TypeName () const { return "CommandHeader"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new CommandHeader(*this); }
}; // class CommandHeader

/** Contains the public and private part of a TPM key  */
class _DLLEXP_ TSS_KEY : public TpmStructure
{
public:
    /** Public part of key  */
    TPMT_PUBLIC publicPart;
    
    /** Private part is the encrypted sensitive part of key  */
    ByteVec privatePart;

public:
    TSS_KEY() {}
    TSS_KEY(const TPMT_PUBLIC& _publicPart, const ByteVec& _privatePart)
      : publicPart(_publicPart), privatePart(_privatePart)
    {}
    
    void toTpm(TpmBuffer& buf) const;
    void initFromTpm(TpmBuffer& buf);
    
    /** Static marshaling helper  */
    static TSS_KEY fromTpm(TpmBuffer& buf) { return buf.createObj<TSS_KEY>(); }
    
    /** Static marshaling helper  */
    static TSS_KEY fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TSS_KEY>(buf); }
    
    virtual const char* TypeName () const { return "TSS_KEY"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    void Serialize(Serializer& buf) const;
    void Deserialize(Serializer& buf);
    
    virtual TpmStructure* Clone() const { return new TSS_KEY(*this); }
    
    operator const TPMT_PUBLIC& () const { return publicPart; }
    
    /// <summary> Create a new software key based on the parameters in the publicPart.
    /// Sets the publicPart and privatePart memebers. </summary>
    void CreateKey();
    
    /// <summary>Sign the dataToSign byte array using the given signing scheme. 
    /// If the keys does not have a scheme of its own (i.e. was configuted with a NULL scheme),
    /// sigScheme must specify the same scheme or be a NULL scheme (TPMS_NULL_SIG_SCHEME). </summary>
    SignResponse Sign(const ByteVec& dataToSign, const TPMU_SIG_SCHEME& sigScheme) const;
    
    /// <summary>Sign the dataToSign byte array using the given key. </summary>
    SignResponse Sign(const ByteVec& dataToSign) const
    {
        return Sign(dataToSign, TPMS_NULL_SIG_SCHEME());
    }
}; // class TSS_KEY

/** Auto-derived from TPM2B_DIGEST to provide unique GetUnionSelector() implementation  */
class _DLLEXP_ TPM2B_DIGEST_SYMCIPHER : public TPM2B_DIGEST
{
public:
public:
    TPM2B_DIGEST_SYMCIPHER() {}
    TPM2B_DIGEST_SYMCIPHER(const ByteVec& _buffer)
      : TPM2B_DIGEST(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::SYMCIPHER; }
    
    /** Static marshaling helper  */
    static TPM2B_DIGEST_SYMCIPHER fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_DIGEST_SYMCIPHER>(); }
    
    /** Static marshaling helper  */
    static TPM2B_DIGEST_SYMCIPHER fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_DIGEST_SYMCIPHER>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_DIGEST_SYMCIPHER"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPM2B_DIGEST_SYMCIPHER(*this); }
}; // class TPM2B_DIGEST_SYMCIPHER

/** Auto-derived from TPM2B_DIGEST  */
class _DLLEXP_ TPM2B_DIGEST_KEYEDHASH : public TPM2B_DIGEST
{
public:
public:
    TPM2B_DIGEST_KEYEDHASH() {}
    TPM2B_DIGEST_KEYEDHASH(const ByteVec& _buffer)
      : TPM2B_DIGEST(_buffer)
    {}
    
    /** TpmUnion method  */
    TPM_ALG_ID GetUnionSelector() const { return TPM_ALG_ID::KEYEDHASH; }
    
    /** Static marshaling helper  */
    static TPM2B_DIGEST_KEYEDHASH fromTpm(TpmBuffer& buf) { return buf.createObj<TPM2B_DIGEST_KEYEDHASH>(); }
    
    /** Static marshaling helper  */
    static TPM2B_DIGEST_KEYEDHASH fromBytes(const ByteVec& buf) { return TpmStructure::fromBytes<TPM2B_DIGEST_KEYEDHASH>(buf); }
    
    virtual const char* TypeName () const { return "TPM2B_DIGEST_KEYEDHASH"; }
    
    using TpmStructure::Serialize;
    using TpmStructure::Deserialize;
    
    virtual TpmStructure* Clone() const { return new TPM2B_DIGEST_KEYEDHASH(*this); }
}; // class TPM2B_DIGEST_KEYEDHASH

_TPMCPP_END
